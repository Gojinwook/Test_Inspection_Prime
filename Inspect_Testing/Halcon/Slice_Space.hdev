<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.3">
<procedure name="main">
<interface/>
<body>
<c>*******************************************************</c>
<c>*** Загрузка данных</c>
<c>*******************************************************</c>
<l>* read_image (Gi, 'G:/SAMSUNG/Test/p2112-004t3_2P0/Model/Gi.tif')</l>
<l>* read_object (Regnoproc, 'G:/SAMSUNG/Test/p2112-004t3_2P0/Model/RegNoProc.hobj')</l>
<l>* read_image (Gi, 'G:/SAMSUNG/NewData/p2309-001t1/Model_p2309-001t1_2P0/Model/Gi.tif')</l>
<l>* read_image (Im, 'G:/SAMSUNG/NewData/p2309-001t1/Model_p2309-001t1_2P0/Model/Im.tif')</l>
<l>* read_object (Regnoproc, 'G:/SAMSUNG/NewData/p2309-001t1/Model_p2309-001t1_2P0/Model/RegNoProc.hobj')</l>
<c></c>
<c></c>
<l>*path_model := 'C:/WORK_CURR/SAMSUNG/Samsung-AOI/Vision/AOI/Run/Model/Model_p2309-001t1_2P0/Model/'</l>
<l>*path_model := 'C:/WORK_CURR/SAMSUNG/Samsung-AOI/Vision/AOI/Run/Model/Model_p2312-015d1_2P0_V5/Model/'</l>
<l>* path_model := 'G:/SAMSUNG/Image/240704_2um-auto2/Model/'</l>
<l>* path_model := 'G:/SAMSUNG/Image/250213_underkill/250213_underkill/underkill/Model/p2411-004d101_LayerL1-SHORT1.0-0250/Model/'</l>
<l>path_model := 'G:/SAMSUNG/Image/250307_short/model/p2209-020t1_LayerL1-T-SHORT1.0-0200_test/Model/'</l>
<l>path_model := 'G:/SAMSUNG/Image/250324_1/Model/p2411-004d101_LayerL1-T-SHORT3.2-0200/Model/'</l>
<c></c>
<l>path_teach := path_model + 'Teach/'</l>
<c></c>
<c></c>
<l>* path_model := 'G:/SAMSUNG/Model_AOI/p2305-018t3/Model/'</l>
<l>* path_teach := 'G:/SAMSUNG/Model_AOI/p2305-018t3/Model/Teach/'</l>
<l>path_teach_tuples := path_teach + 'Tuples/'</l>
<c></c>
<c></c>
<l>* path_model := 'C:/WORK_CURR/SAMSUNG/Samsung-AOI/Vision/AOI/Run/Model/p2305-018t2_2P0/Model/'</l>
<l>* path_teach := path_model + 'Teach/'</l>
<l>*path_image := 'C:/TmpIm/'</l>
<l>path_image := 'C:/TmpIm/'</l>
<l>* path_image := 'G:/SAMSUNG/NewData/p2309-001t1/image/'</l>
<c></c>
<l>read_image (Gi_Im, path_model + 'Gi.tif')</l>
<c></c>
<l>read_object (Gi, path_model + 'Gi.hobj')</l>
<l>read_object (Skel_FWMS, path_teach + 'SkeletonsLG.hobj')</l>
<l>read_object (Skel_FWM, path_teach + 'SkeletonsFWM.hobj')</l>
<l>read_image (WidthImageS, path_teach + 'WidthImageS.tif')</l>
<c></c>
<l>read_object (Skel_FWMS1, path_teach + 'SkeletonsFWMS.hobj')</l>
<c></c>
<l>* read_image (Gi, 'G:/SAMSUNG/Model_3/AOI/p2112-004t3_2P0/Model/Gi.tif')</l>
<c></c>
<l>stop()</l>
<c></c>
<l>stop()</l>
<c></c>
<c>*******************************************************</c>
<c>*** Параметры</c>
<c>*******************************************************</c>
<l>dev_update_off()</l>
<l>Win := 20</l>
<l>WinD2 := Win/2</l>
<l>* SensLen := 50</l>
<l>SensLen := 0</l>
<c>*******************************************************</c>
<c>*** Обучение</c>
<c>*******************************************************</c>
<l>Teach_Slice (Skel_FWMS, WidthImageS, Win, SensLen, path_teach_tuples, Pointer_Skel, Pointer_Sens, Rows_Sens, Cols_Sens, Pointer_Pos, CurrentOper, TotalPRC, MaxPRC)</l>
<c></c>
<l>* Teach_Slice (Skel_FWMS, WidthImageS, Win, SensLen, path_teach_tuples, _, _, _, _, _, CurrentOper, TotalPRC, MaxPRC)</l>
<c></c>
<l>stop()</l>
<l>read_tuple(path_teach_tuples + 'Pointer_Skel.tup', Pointer_Skel)</l>
<l>read_tuple(path_teach_tuples + 'Pointer_Sens.tup', Pointer_Sens)</l>
<l>read_tuple(path_teach_tuples + 'Rows_Sens.tup', Rows_Sens)</l>
<l>read_tuple(path_teach_tuples + 'Cols_Sens.tup', Cols_Sens)</l>
<l>stop()</l>
<c></c>
<c></c>
<c>*******************************************************</c>
<c>*** Инспекция</c>
<c>*******************************************************</c>
<l>read_image (Im, path_image + 'Im3_64.tif')</l>
<l>read_image (Im, path_image + 'Im2_82.tif')</l>
<l>read_image (Im, path_image + 'Im61_272.tif')</l>
<l>read_image (Im, path_image + 'Im60_248.tif')</l>
<l>* read_image (Im, path_image + 'Im1_9.tif')</l>
<l>* read_object(RegionsLG, path_image + 'Im65_128_RegionsLG')</l>
<c>* Overkill</c>
<l>read_image (Im, path_image + 'Im49_221.tif')</l>
<c>* </c>
<l>read_image (Im, path_image + 'Im2_124.tif')</l>
<c>*</c>
<l>read_image (Im, path_image + 'Im2_67.tif')</l>
<c></c>
<l>read_image (Im, path_image + 'Im1_171.tif')</l>
<l>Threshold := 112</l>
<c></c>
<l>get_image_size(Im, Im_W, Im_H)</l>
<c></c>
<l>Avg_Gray := 15</l>
<l>szw := 9</l>
<l>Proc_Thr := 10</l>
<c></c>
<l>Type := 5</l>
<c></c>
<l>Widt_Pos := 0</l>
<l>Widt_S := []</l>
<l>Depth_S := []</l>
<l>Rows_Cent := []</l>
<l>Cols_Cent := []</l>
<l>tuple_length(Pointer_Skel, Count_Skel)</l>
<l>Pos_Skel_S := 0</l>
<c></c>
<l>for I_Skel := 0 to Count_Skel - 1 by 1</l>
<l>    Pos_Skel_E := Pointer_Skel[I_Skel]</l>
<c>    </c>
<l>    *Pos_Skel_S := Pos_Skel_E - 50</l>
<l>    *Pos_Skel_E := Pointer_Skel[I_Skel] - 12</l>
<c>    </c>
<l>    Depth_Pos := 0</l>
<l>    for Point := Pos_Skel_S to Pos_Skel_E by 1</l>
<c>        </c>
<l>*         Point := 1188</l>
<l>        *Point_E := Point_S + 50</l>
<c>        </c>
<l>        Point_S := Pointer_Sens[Point]</l>
<l>        Point_E := Pointer_Sens[Point + 1] - 1</l>
<c>        </c>
<l>        tuple_select_range(Rows_Sens, Point_S, Point_E, RowsS)</l>
<l>        tuple_select_range(Cols_Sens, Point_S, Point_E, ColsS)</l>
<c>        </c>
<l>*         gen_region_points(Region11, RowsS, ColsS)</l>
<l>*         dev_set_color('green')</l>
<l>*         dev_set_line_width(3)</l>
<l>*         dev_display(Region11)</l>
<c>        </c>
<c>        * Проверка, чтобы сенсор не выходил за пределы</c>
<l>*         Len_Sens := |RowsS|</l>
<l>*         Rows := []</l>
<l>*         Cols := []</l>
<l>*         for Is := 0 to Len_Sens - 1 by 1</l>
<l>*             if (RowsS[Is] &gt;= Im_H or RowsS[Is] &lt; 0 or ColsS[Is] &gt;= Im_W or ColsS[Is] &lt; 0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             Rows[|Rows|] := RowsS[Is]</l>
<l>*             Cols[|Cols|] := ColsS[Is]</l>
<c>            </c>
<l>*         endfor</l>
<c></c>
<l>        Rows := RowsS</l>
<l>        Cols := ColsS</l>
<c>        </c>
<l>        get_grayval (Im, Rows, Cols, Gray)</l>
<l>        tuple_length(Gray, Gray_Len)</l>
<l>        SensLenD2 := Gray_Len / 2</l>
<c></c>
<l>        *Moving_Avg(Gray, 3, Gray)</l>
<c>        </c>
<c>        </c>
<l>*         create_funct_1d_array(Gray, FGray)</l>
<l>*         smooth_funct_1d_mean(FGray, 10, 1, GraySM)</l>
<l>*         tuple_last_n(GraySM, 3, Gray)</l>
<l>*         tuple_min(Gray, Min)</l>
<l>         if (Type == 1)</l>
<c>            ** Находим минимальный ближе к центру - это дно Space</c>
<l>            SN_Loc_Min (Gray, Loc_Min, Loc_Min_Val)</l>
<c>            </c>
<c>            ***  *************************************************************************************</c>
<c>            </c>
<c>            * Найти минимальный минимум. </c>
<c>            * С допуском просматриваем все минимумы и выбираем, который ближе к центу</c>
<l>            tuple_min(Loc_Min_Val, Min_Val)</l>
<l>            Diff := 1000000</l>
<l>            tuple_length(Loc_Min, Cnt)</l>
<l>            for I := 0 to Cnt - 1 by 1</l>
<l>                if (Loc_Min_Val[I] &lt;= Min_Val + 1)</l>
<l>                    if (Diff &gt; abs(SensLenD2 - Loc_Min[I]))</l>
<l>                        Bott := Loc_Min[I]</l>
<l>                        Diff := abs(SensLenD2 - Loc_Min[I])</l>
<l>                    endif</l>
<l>                endif</l>
<l>            endfor</l>
<c>            </c>
<c>            ** Глубина ----------------------------------------------------------</c>
<l>            Depth := Gray[Bott] </l>
<l>            Depth_S[Depth_Pos] := Depth</l>
<c>            </c>
<l>            Rows_Cent[Depth_Pos] := Rows[Bott]</l>
<l>            Cols_Cent[Depth_Pos] := Cols[Bott]</l>
<c>            </c>
<l>            if (Depth_Pos == 2)</l>
<l>                Depth_S[Depth_Pos - 2] := Depth</l>
<l>                Rows_Cent[Depth_Pos - 2] := Rows[Bott]</l>
<l>                Cols_Cent[Depth_Pos - 2] := Cols[Bott]</l>
<l>            endif</l>
<c>            </c>
<l>            Test1 := 1</l>
<l>            Test1 := 1</l>
<c>         *** --------------------------------------------------------------------------------   </c>
<c>         *** --------------------------------------------------------------------------------   </c>
<c>         *** --------------------------------------------------------------------------------   </c>
<l>         elseif (Type == 5)</l>
<c>             </c>
<l>            if (Test1 == 1)</l>
<l>                Test1 := 0</l>
<l>                Point := 6650</l>
<l>                *Gray1 := Gray</l>
<l>                Depth_S := []</l>
<l>            endif</l>
<c>             </c>
<c>            * В дальнейшем нужно сделать субпиксеьную обрезку по порогу</c>
<c>            * После этого анализ ложбины по глубине впадин и высоте холмов</c>
<c>            * 1 вариант - расчет площади Garay под порогом</c>
<c>             </c>
<c>            *** Расчет площади ниже порога</c>
<l>            Threshold := 112</l>
<l>*             Thr_Min := min(Gray)</l>
<l>            Thr_Min := 0</l>
<l>            if (Thr_Min &gt;= Threshold)</l>
<l>                continue</l>
<l>            endif</l>
<l>            Thr_Span := Threshold - Thr_Min</l>
<c></c>
<l>            Itr := 10</l>
<l>            Thr_Step := []</l>
<l>            for It := 0 to Itr by 1</l>
<l>                Thr_Step[|Thr_Step|] := pow(0.85, It)</l>
<l>            endfor</l>
<c>                </c>
<l>            Thr_Arr := []</l>
<l>            for It := 0 to Itr by 1</l>
<l>                Thr := Thr_Min + (Thr_Span * Thr_Step[It])</l>
<l>                Thr_Arr[|Thr_Arr|] := Thr</l>
<l>            endfor</l>
<c>             </c>
<l>            Itr := 10</l>
<l>            Square := 0.0</l>
<l>            for It := 0 to Itr by 1</l>
<l>*                 Thr := Thr_Min + (Thr_Span * Thr_Step[It])</l>
<l>                Thr := Thr_Arr[It]</l>
<c></c>
<c>                * Идем вдоль линии порога и ищем пересечение</c>
<l>                Even := 0</l>
<l>                Intersect := []</l>
<l>                Xp := 0</l>
<l>                for I := 0 to Gray_Len - 1 by 1</l>
<c>                    * Расчет субпиксельной координаты X пересечения порога</c>
<l>                    if (Gray[I] &lt; Thr and Even == 0)</l>
<c>                        * Пересечение вниз</c>
<l>                        if (I == 0)</l>
<l>                            Xp := 0    </l>
<l>                        else</l>
<l>                            tuple_real(Gray[I], T1)</l>
<l>                            tuple_real(Gray[I - 1], T2)</l>
<l>                            Pr := (T1 - Thr) / (T1 - T2)</l>
<l>                            Xp := I - Pr </l>
<l>                        endif</l>
<l>                        Intersect[|Intersect|] := Xp        </l>
<l>                        Even := 1</l>
<l>                    elseif (Gray[I] &gt; Thr and Even == 1) </l>
<c>                        * Пересечение вверх</c>
<l>                        if (I == Gray_Len - 1)</l>
<l>                            Xp := Gray_Len - 1    </l>
<l>                        else</l>
<l>                            tuple_real(Gray[I], T1)</l>
<l>                            tuple_real(Gray[I - 1], T2)</l>
<l>                            Pr := (T1 - Thr) / (T1 - T2)</l>
<l>                            Xp := I - Pr </l>
<l>                        endif</l>
<l>                        Intersect[|Intersect|] := Xp        </l>
<l>                        Even := 0</l>
<l>                    endif</l>
<l>                endfor</l>
<c>                </c>
<l>                if (Even == 1)</l>
<l>                    Intersect[|Intersect|] := Gray_Len - 1</l>
<l>                endif</l>
<c>                </c>
<c>                </c>
<c>                * Расчет ширины</c>
<l>                Width := 0</l>
<l>                for I := 0 to |Intersect| - 1 by 2</l>
<l>                    Wd := Intersect[I + 1] - Intersect[I]</l>
<l>                    Width := Width + Wd</l>
<l>                endfor</l>
<c>                </c>
<l>                Square := Square + Width</l>
<l>            endfor</l>
<c>            </c>
<c>            </c>
<c>            *** --------------------------------------------------</c>
<l>            Depth_S[Depth_Pos] := Square</l>
<l>*             Point := 2490</l>
<c></c>
<c>            *** --------------------------------------------------</c>
<c>            * Определим положение максимума под порогом</c>
<l>            Gray_Max := 0</l>
<l>            Cent_Pos := int(Gray_Len / 2)</l>
<l>            for I := 0 to Gray_Len - 1 by 1</l>
<l>                if (Gray[I] &lt; Threshold and Gray[I] &gt; Gray_Max)</l>
<l>                    Gray_Max := Gray[I]</l>
<l>                    Cent_Pos := I</l>
<l>                endif</l>
<l>            endfor</l>
<c>            </c>
<l>            Rows_Cent[Depth_Pos] := Rows[Cent_Pos]</l>
<l>            Cols_Cent[Depth_Pos] := Cols[Cent_Pos]</l>
<c></c>
<l>            if (Depth_Pos == 263)</l>
<l>                Test111 := 0</l>
<l>            endif</l>
<c>            </c>
<c>            </c>
<c>         *** --------------------------------------------------------------------------------   </c>
<c>         *** --------------------------------------------------------------------------------   </c>
<c>         *** --------------------------------------------------------------------------------   </c>
<l>         elseif (Type == 2)</l>
<c>            * Найти края Space - Обрезать по порогу</c>
<l>*            Gray_Cut_Threshold (Gray, Threshold, Gray)</l>
<c>             </c>
<l>            Avg_Gray := SensLenD2</l>
<l>            Gray_Len := |Gray|</l>
<l>            SensLenD2 := Gray_Len / 2</l>
<c></c>
<c>            * Сильно сглаживаем. Убираем соседние патерны</c>
<c>            * Формируем признак для текущей Gray линии</c>
<c>            * Максимальное значение усредненого Gray </c>
<l>            Moving_Avg(Gray, Avg_Gray, Gray_MV)      </l>
<c>           </c>
<c>            </c>
<l>*             Depth := Gray_MV[Point_Val]</l>
<l>            Depth := min(Gray_MV)</l>
<l>            Depth_S[Depth_Pos] := Depth</l>
<c></c>
<l>            cent_pos := int(Gray_Len / 2)</l>
<l>            Rows_Cent[Depth_Pos] := Rows[cent_pos]</l>
<l>            Cols_Cent[Depth_Pos] := Cols[cent_pos]</l>
<c></c>
<l>            if (Depth_Pos == 2)</l>
<l>                Depth_S[Depth_Pos - 2] := Depth</l>
<l>                Rows_Cent[Depth_Pos - 2] := Rows[cent_pos]</l>
<l>                Cols_Cent[Depth_Pos - 2] := Cols[cent_pos]</l>
<l>            endif</l>
<c>            </c>
<c>            </c>
<l>         else</l>
<l>*             Point := 3110</l>
<l>            Avg_Gray := 27</l>
<l>            Threshold := 49 </l>
<c></c>
<l>            Gray_Cut_Threshold (Gray, Threshold, Gray_S)</l>
<c>            </c>
<c>            </c>
<l>            *Avg_Gray := |Gray_S|</l>
<l>            Moving_Avg(Gray_S, Avg_Gray, Gray_MV)      </l>
<c>             </c>
<l>            Point_Val := int(|Gray_S| / 2)</l>
<l>            Val := Gray_MV[Point_Val]</l>
<l>            Depth_S[Depth_Pos] := Val</l>
<c>            </c>
<l>            cent_pos := Point_Val</l>
<l>            Rows_Cent[Depth_Pos] := Rows[cent_pos]</l>
<l>            Cols_Cent[Depth_Pos] := Cols[cent_pos]</l>
<c>           </c>
<l>         endif</l>
<c></c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        *Корекция первого значения. Для определения граничных дефектов</c>
<c></c>
<c>        </c>
<l>        Depth_Pos := Depth_Pos + 1</l>
<c>        </c>
<c>        </c>
<l>        tuple_length(Rows, Len)</l>
<l>        gen_region_line(Line_Sens, Rows[0], Cols[0], Rows[Len-1], Cols[Len-1])</l>
<c>        </c>
<l>        dev_set_color('coral')</l>
<l>        dev_set_line_width(1)</l>
<l>        dev_display(Line_Sens)</l>
<c></c>
<c>        </c>
<l>        if (Depth_Pos == 7046)</l>
<l>            test1 := 1</l>
<c>            </c>
<l>        endif</l>
<c>        </c>
<l>    endfor</l>
<c>    </c>
<c>    ** Добавлении заднего фронта. Для определения граничных дефектов</c>
<l>    *Depth_Pos := Depth_Pos + 1</l>
<l>*     Depth_S[Depth_Pos] := Depth_S[Depth_Pos - 2]</l>
<c>    </c>
<l>*     Rows_Cent[Depth_Pos] := Rows[Bott]</l>
<l>*     Cols_Cent[Depth_Pos] := Cols[Bott]</l>
<c>    </c>
<c>    </c>
<l>*     szw := 8</l>
<l>*     FilterFloadMedn(Widt_S, szw, 50, 50, Def, Wfilt1, Wch1, Prc1)</l>
<c></c>
<l>    szw := 30</l>
<l>    Proc_Thr := 61</l>
<l>    FilterFloadMedn(Depth_S, szw, 10, 10, Def, Wfilt, Wcmnh, Prc)</l>
<l>*     write_tuple(Depth_S, 'C:/TmpIm/Defect.tup')</l>
<c>    </c>
<l>*     pp := 241</l>
<l>*     tuple_select_range (Depth_S, pp-szw/2, pp+szw/2, Sel)</l>
<l>*     tuple_median (Sel, medSel)</l>
<l>*     tuple_mean (Sel, meaSel)</l>
<c></c>
<c>    </c>
<c>    </c>
<c>    * Определение дефектов</c>
<l>*     test := Depth_S - Wfilt</l>
<c>    </c>
<l>*     tuple_length(Depth_S, Cnt)</l>
<l>*     for I := 0 to Cnt - 1 by 1</l>
<l>*         if (Prc[I] &gt; Proc_Thr)</l>
<l>*             Rows_S := Rows_Cent[I]</l>
<l>*             Cols_S := Cols_Cent[I]</l>
<c></c>
<l>*             gen_circle(Circle, Rows_S, Cols_S, 10.5)</l>
<l>*             disp_obj(Circle, 200000)</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<c>    * Объединение рядом стоящих дефектов в один</c>
<l>    PrcM_Min := []</l>
<l>    PrcM_Max := []</l>
<l>    PrcM_Median := []</l>
<l>    Def_Row := []</l>
<l>    Def_Col := []</l>
<c>    </c>
<l>    SPos := -1</l>
<l>    tuple_length(Depth_S, Cnt)</l>
<l>    PrcM :=  Prc * -1</l>
<l>    for I := 0 to Cnt - 1 by 1</l>
<l>        if (PrcM[I] &gt; Proc_Thr)</l>
<l>            if (SPos == -1)</l>
<l>                SPos := I</l>
<l>            endif</l>
<l>        elseif (SPos &gt;= 0)</l>
<l>            tuple_select_range(PrcM, SPos, I, PrcM_Sel)</l>
<l>            tuple_min(PrcM_Sel, Min)</l>
<l>            tuple_max(PrcM_Sel, Max)</l>
<l>            tuple_median(PrcM_Sel, Median)</l>
<l>            PrcM_Min[|PrcM_Min|] := Min</l>
<l>            PrcM_Max[|PrcM_Max|] := Max</l>
<l>            PrcM_Median[|PrcM_Median|] := Median</l>
<c>            </c>
<c>            </c>
<l>            SPos := SPos + (I - SPos) / 2</l>
<l>            Def_Row[|Def_Row|] := Rows_Cent[SPos]</l>
<l>            Def_Col[|Def_Col|] := Cols_Cent[SPos]</l>
<c>            </c>
<l>            SPos := -1</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<c>    * Отображение дефектов</c>
<l>    dev_display(Im)</l>
<l>    for I := 0 to |Def_Row| - 1 by 1</l>
<l>        gen_circle(Circle, Def_Row[I], Def_Col[I], 10.5)</l>
<l>        dev_display(Circle)</l>
<l>    endfor</l>
<l>    threshold(Im, Region1, Threshold, 255)</l>
<l>    threshold(Im, Region2, Threshold - 10, 255)</l>
<l>    threshold(Im, Region3, Threshold - 20, 255)</l>
<c></c>
<c>            </c>
<c>    </c>
<c>    </c>
<l>    Pos_Skel_S := Pos_Skel_E + 1</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>stop()</l>
<l>read_tuple('C:/Temp/hv_Depth_S.tup', hv_Depth_S)</l>
<l>read_tuple('C:/Temp/hv_Depth_Ppr_S.tup', hv_Depth_Ppr_S)</l>
<l>read_tuple('C:/Temp/hv_Depth_Ppr_S1.tup', hv_Depth_Ppr_S1)</l>
<c></c>
<c></c>
<c></c>
<l>read_tuple('C:/Temp/hv_Gray.tup', hv_Gray1)</l>
<l>read_tuple('C:/Temp/hv_Depth_S.tup', hv_Depth_S1)</l>
<l>szw := 8</l>
<l>FilterFloadMedn(hv_Depth_S1, szw, 10, 10, Def, Wfilt, Wcmnh, Prc)</l>
<c></c>
<l>stop()</l>
<c></c>
<c>*******************************************************</c>
<c>*** Инспекция</c>
<c>*******************************************************</c>
<l>dev_update_on()</l>
<l>dev_update_off()</l>
<c></c>
<l>thr := 230</l>
<c></c>
<l>read_image (Im, path_image + 'Im1_29.tif')</l>
<l>* read_image (Im, path_image + 'Im10_143.tif')</l>
<c></c>
<l>Auto_Threshold5 (Skel_FWMS, Im, thr, thrS, thrP)</l>
<c></c>
<c></c>
<l>Widt_Pos := 0</l>
<l>Widt_S := []</l>
<l>Depth_S := []</l>
<l>tuple_length(Pointer_Sens, Count_Sens)</l>
<l>for Point := 0 to Count_Sens - 2 by 1</l>
<c>    </c>
<l>    *Point := 850</l>
<l>    *Point := 1400</l>
<l>    Point := 2679</l>
<c>     </c>
<c>     </c>
<l>    Point_S := Pointer_Sens[Point]</l>
<l>    Point_E := Pointer_Sens[Point + 1] - 1</l>
<c>    </c>
<l>    tuple_select_range(Rows_Sens, Point_S, Point_E, Rows)</l>
<l>    tuple_select_range(Cols_Sens, Point_S, Point_E, Cols)</l>
<l>    get_grayval (Im, Rows, Cols, Gray)</l>
<c></c>
<l>*     create_funct_1d_array(Gray, FGray)</l>
<l>*     smooth_funct_1d_mean(FGray, 5, 3, Gray)</l>
<l>*     local_min_max_funct_1d(Gray, 'plateaus_center', 'true', Min21, Max21)   </l>
<c>    </c>
<c>    *** Поиск пика</c>
<c>    * Для каждого минимума найдем максимумы</c>
<c>    * Это будет ПИК</c>
<l>*     create_funct_1d_array(Gray, FGray)</l>
<l>*     local_min_max_funct_1d(FGray, 'plateaus_center', 'true', MinG, MaxG)</l>
<c>    </c>
<c>    ** Находим минимальный ближе к центру - это дно Space</c>
<l>    SN_Loc_Min (Gray, Loc_Min, Loc_Min_Val)</l>
<c>    </c>
<c>    * Найти минимальный минимум. </c>
<c>    * С допуском просматриваем все минимумы и выбираем, который ближе к центу</c>
<l>    tuple_min(Loc_Min_Val, Min_Val)</l>
<l>    Diff := 1000000</l>
<l>    tuple_length(Loc_Min, Cnt)</l>
<l>    for I := 0 to Cnt - 1 by 1</l>
<l>        if (Loc_Min_Val[I] &lt;= Min_Val + 10)</l>
<l>            if (Diff &gt; abs(SensLenD2 - Loc_Min[I]))</l>
<l>                Bott := Loc_Min[I]</l>
<l>                Diff := abs(SensLenD2 - Loc_Min[I])</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<c>    ** Глубина ----------------------------------------------------------</c>
<l>    Depth := Gray[Bott] </l>
<l>    Depth_S[Point] := Depth</l>
<c></c>
<c>   </c>
<c>    ** Найти Максимумы вокруг найденного дна  </c>
<l>    SN_Loc_Max_Center (Gray, Bott, Loc_Max, Loc_Max_Val)</l>
<c></c>
<l>    Max_Val_L := 0</l>
<l>    Max_Val_R := 0</l>
<l>    tuple_length(Loc_Max, Cnt)</l>
<l>    for I := 0 to Cnt - 1 by 1</l>
<l>        if (Loc_Max[I] &lt; Bott and Loc_Max_Val[I] &gt; Max_Val_L)</l>
<l>            Max_Val_L := Loc_Max_Val[I]</l>
<l>        elseif (Loc_Max[I] &gt; Bott and Loc_Max_Val[I] &gt; Max_Val_R)</l>
<l>            Max_Val_R := Loc_Max_Val[I]</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<c>    </c>
<c>    ** Найти порог ------------------------------------------------------</c>
<l>*     create_funct_1d_array(Gray, FGray)</l>
<l>*     smooth_funct_1d_mean(FGray, 1, 2, FGray_SM)</l>
<l>*     local_min_max_funct_1d(FGray_SM, 'plateaus_center', 'true', Min21, Max21)</l>
<c>    </c>
<c>    </c>
<l>*     tuple_max2(Max_Val_L,  Max_Val_R, Max_Val)</l>
<l>*     thr := Max_Val - (Max_Val - Gray[Bott]) * 0.5</l>
<c></c>
<l>*     tuple_min2(Max_Val_L,  Max_Val_R, Min_Val)</l>
<l>*     thr := Min_Val - (Min_Val - Gray[Bott]) * 0.3</l>
<l>    thr :=  Depth  * 1.3</l>
<c>   </c>
<c>    </c>
<c>    ** Ширина -----------------------------------------------------------</c>
<l>    Fl := 0</l>
<l>    tuple_length(Gray, Len)</l>
<l>    for I := 0 to Len-1 by 1</l>
<l>        if (Gray[I] &gt;= thr and Fl == 0)</l>
<l>            Fl := 1</l>
<l>        elseif (Gray[I] &lt;= thr and Fl == 1)</l>
<l>            P1 := I</l>
<l>            Fl := 2</l>
<l>        elseif (Gray[I] &gt; thr and Fl == 2)</l>
<l>            P2 := I</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>    tuple_real(Gray[P1], T1)</l>
<l>    tuple_real(Gray[P1 - 1], T2)</l>
<l>    Pr := (T1 - thr) / (T1 - T2)</l>
<l>    P1A := P1 - Pr </l>
<c>    </c>
<c>    </c>
<l>    tuple_real(Gray[P2], T1)</l>
<l>    tuple_real(Gray[P2 - 1], T2)</l>
<l>    Pr := (T1 - thr) / (T1 - T2)</l>
<l>    P2A := P2 - Pr </l>
<c>    </c>
<c>    </c>
<l>    Widt := P2A - P1A </l>
<l>    Widt_S[Point] := Widt</l>
<c>    </c>
<l>    tuple_length(Rows, Len)</l>
<l>    gen_region_line(Line_Sens, Rows[0], Cols[0], Rows[Len-1], Cols[Len-1])</l>
<c>    </c>
<c>    * Измеряем расстояние между пиками и глубину</c>
<c>    * Находим Порог по середине пика</c>
<c>    </c>
<c>    </c>
<l>*     Fl := 0</l>
<l>*     Max_Val := 0</l>
<l>*     tuple_length(Loc_Max, Cnt)</l>
<l>*     for I := 0 to Cnt - 1 by 1</l>
<l>*         if (Loc_Max[I] &gt;= Bott)</l>
<l>*             Fl := 1</l>
<l>*             Max_Val := 0</l>
<l>*         endif</l>
<c>        </c>
<l>*         if (Fl == 0 and Loc_Max_Val[I] &gt; Max_Val)</l>
<l>*             Boot_L := I</l>
<l>*             Max_Val := Loc_Max_Val[I]</l>
<l>*         elseif (Fl == 1 and Loc_Max_Val[I] &gt; Max_Val)</l>
<l>*             Boot_R := I</l>
<l>*             Max_Val := Loc_Max_Val[I]</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<c>    </c>
<l>*     for I := 0 to Cnt - 1 by 1</l>
<l>*         if (Loc_Max[I] &lt; Bott)</l>
<l>*             Boot_L := I</l>
<l>*         elseif (Loc_Max[I] &gt; Bott)</l>
<l>*             Boot_R := I</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    *** ---</c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<l>*     create_funct_1d_array(Gray, FGray)</l>
<l>*     smooth_funct_1d_mean(FGray, 1, 2, FGrayS)</l>
<c>    </c>
<l>*     Fl := 1</l>
<l>*     tuple_length(Gray, Len)</l>
<l>*     for I := 0 to Len - 1 by 1</l>
<c>            </c>
<l>*         if (Gray[I] &lt;= thr and Gray[I] &gt; Gray[I + 1] and Fl == 1)</l>
<l>*             P1 := I</l>
<l>*             Fl := 2</l>
<l>*         elseif (Gray[I] &gt;= thr and Fl == 2)</l>
<l>*             P2 := I</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endfor</l>
<c></c>
<l>*     tuple_real(Gray[P1], T1)</l>
<l>*     tuple_real(Gray[P1 - 1], T2)</l>
<l>*     Pr := (T1 - thr) / (T1 - T2)</l>
<l>*     P1A := P1 - Pr </l>
<c>    </c>
<c>    </c>
<l>*     tuple_real(Gray[P2], T1)</l>
<l>*     tuple_real(Gray[P2 - 1], T2)</l>
<l>*     Pr := (T1 - thr) / (T1 - T2)</l>
<l>*     P2A := P2 - Pr </l>
<c>    </c>
<c>    </c>
<l>*     Widt[Widt_Pos] := P2A - P1A </l>
<l>*     Widt_Pos := Widt_Pos + 1</l>
<c>    </c>
<c></c>
<c>    </c>
<c>    </c>
<l>endfor</l>
<c></c>
<l>szw := 50</l>
<l>FilterFloadMedn(Widt_S, szw, 50, 50, Def, Wfilt1, Wch1, Prc1)</l>
<l>FilterFloadMedn(Depth_S, szw, 50, 50, Def, Wfilt, Wch, Prc)</l>
<c></c>
<c></c>
<c></c>
<l>Gray1 := []</l>
<l>Gray2 := []</l>
<c></c>
<c></c>
<l>Tuple_In := Widt</l>
<l>Move_Avg := 10</l>
<c></c>
<c></c>
<c>* Скользящее среднее</c>
<l>tuple_length (Tuple_In, t_len)</l>
<l>move_avg_h := Move_Avg</l>
<l>sum_mov := Tuple_In[0] * move_avg_h</l>
<l>tuple_gen_const (t_len, 0, Tuple_Avg)</l>
<l>for k := 0 to t_len + move_avg_h/2 - 1 by 1</l>
<l>    if (k &gt;= move_avg_h / 2)</l>
<l>        Tuple_Avg[k - move_avg_h / 2] := sum_mov / move_avg_h</l>
<l>    endif</l>
<c>    </c>
<l>    if (k &gt;= move_avg_h)</l>
<l>        sum_mov := sum_mov - Tuple_In[k - move_avg_h]</l>
<l>    else</l>
<l>        sum_mov := sum_mov - Tuple_In[0]</l>
<l>    endif</l>
<c>    </c>
<l>    if (k &lt; t_len)</l>
<l>        sum_mov := sum_mov + Tuple_In[k]</l>
<l>    else</l>
<l>        sum_mov := sum_mov + Tuple_In[t_len - 1]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*******************************************************</c>
<c>*** End</c>
<c>*******************************************************</c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c>* </c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'off'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="dev_update_on">
<interface/>
<body>
<c>* This procedure sets different update settings to 'on'.</c>
<c>* </c>
<l>dev_update_pc ('on')</l>
<l>dev_update_var ('on')</l>
<l>dev_update_window ('on')</l>
<l>return ()</l>
</body>
<docu id="dev_update_on">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'on'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_off</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="Auto_Threshold5">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thrS" base_type="ctrl" dimension="0"/>
<par name="thrP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>union1 (SkeletonsFWMS, SkeletonFWMS)</l>
<l>dilation_circle (SkeletonFWMS, SkeletonFWMSd, 9.5)</l>
<l>reduce_domain (Im, SkeletonFWMSd, Imp)</l>
<c></c>
<l>gray_histo_abs (SkeletonFWMSd, Imp, 1, AbsoluteHisto1)</l>
<c></c>
<l>create_funct_1d_array (AbsoluteHisto1, FAbsoluteHisto1)</l>
<l>smooth_funct_1d_mean (FAbsoluteHisto1, 15, 5, FAbsoluteHistosm1)</l>
<l>local_min_max_funct_1d (FAbsoluteHistosm1, 'strict_min_max', 'true', Min21, Max21)</l>
<c></c>
<l>* Middle := 140</l>
<l>Middle := int(Min21[0])</l>
<c></c>
<l>if (Middle == 0)</l>
<l>    thr := 0</l>
<l>    thrS := 0</l>
<l>    thrP := 0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>tuple_first_n (AbsoluteHisto1, Middle, Space_T)</l>
<l>create_funct_1d_array (Space_T, FSpace_T)</l>
<l>smooth_funct_1d_mean (FSpace_T, 9, 3, FSpace_T)</l>
<l>local_min_max_funct_1d (FSpace_T, 'plateaus_center', 'true', MinS, MaxS)</l>
<c></c>
<l>Max_Index (MaxS, FSpace_T, Idx)</l>
<l>thrS := MaxS[Idx]</l>
<c></c>
<c></c>
<c></c>
<l>tuple_last_n (AbsoluteHisto1, Middle, Patern_T)</l>
<l>create_funct_1d_array (Patern_T, FPatern_T)</l>
<l>smooth_funct_1d_mean (FPatern_T, 9, 3, FPatern_T)</l>
<l>local_min_max_funct_1d (FPatern_T, 'plateaus_center', 'true', MinP, MaxP)</l>
<c></c>
<l>Max_Index (MaxP, FPatern_T, Idx)</l>
<l>thrP := MaxP[Idx] + Middle</l>
<c></c>
<l>tuple_mean ([thrS, thrP], thr)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="Auto_Threshold5">
<parameters>
<parameter id="Im"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="thr"/>
<parameter id="thrP"/>
<parameter id="thrS"/>
</parameters>
</docu>
</procedure>
<procedure name="Max_Index">
<interface>
<ic>
<par name="Max21" base_type="ctrl" dimension="0"/>
<par name="FAbsoluteHistosm1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Max_Index" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Max_Pos := 0</l>
<l>Max_Val := 0</l>
<l>Max_Index := 0</l>
<l>tuple_length (Max21, Length)</l>
<l>for Index := 0 to Length - 1 by 1</l>
<c></c>
<l>    Extr_Pos := Max21[Index]</l>
<l>    tuple_int (Extr_Pos, Extr_Pos)</l>
<l>    Extr_Val := FAbsoluteHistosm1[Extr_Pos]</l>
<l>    if (Extr_Val &gt; Max_Val)</l>
<l>        Max_Val := Extr_Val</l>
<l>        Max_Pos := Extr_Pos</l>
<l>        Max_Index := Index</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="Max_Index">
<parameters>
<parameter id="FAbsoluteHistosm1"/>
<parameter id="Max21"/>
<parameter id="Max_Index"/>
</parameters>
</docu>
</procedure>
<procedure name="SN_Loc_Min">
<interface>
<ic>
<par name="Gray" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Loc_Min" base_type="ctrl" dimension="0"/>
<par name="Loc_Min_Val" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    Loc_Min := []</l>
<l>    Loc_Min_Val := []</l>
<l>    Fl := 1</l>
<l>    tuple_length(Gray, Gray_Len)</l>
<l>    for I := 1 to Gray_Len - 1 by 1</l>
<l>        I0 := I - 1</l>
<l>        if (Gray[I0] &gt; Gray[I])</l>
<l>            Fl := 1   </l>
<l>        endif</l>
<c></c>
<l>        if ((Gray[I0] &lt; Gray[I] and Fl == 1) or (I == Gray_Len - 1 and Fl == 1))</l>
<l>            tuple_concat(Loc_Min, I0, Loc_Min)</l>
<l>            tuple_concat(Loc_Min_Val, Gray[I0], Loc_Min_Val)</l>
<l>            Fl := 0   </l>
<l>        endif</l>
<l>    endfor</l>
<l>return ()</l>
</body>
<docu id="SN_Loc_Min">
<parameters>
<parameter id="Gray"/>
<parameter id="Loc_Min"/>
<parameter id="Loc_Min_Val"/>
</parameters>
</docu>
</procedure>
<procedure name="SN_Loc_Max_Center">
<interface>
<ic>
<par name="Gray" base_type="ctrl" dimension="0"/>
<par name="Center" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Loc_Max" base_type="ctrl" dimension="0"/>
<par name="Loc_Max_Val" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    Loc_Max := []</l>
<l>    Loc_Max_Val := []</l>
<l>    Fl := 1</l>
<l>    Pos_Fl := 0</l>
<l>    tuple_length(Gray, Gray_Len)</l>
<l>    for I := 1 to Gray_Len - 1 by 1</l>
<l>        I0 := I - 1</l>
<l>        if (Gray[I0] &lt; Gray[I])</l>
<l>            Fl := 1   </l>
<l>            Pos_Fl := I</l>
<l>        endif</l>
<c></c>
<l>        if ((Gray[I0] &gt; Gray[I] and Fl == 1) or (I == Gray_Len - 1 and Fl == 1))</l>
<l>            if (Center - I0 &gt; 0)</l>
<l>                Pos_I :=  I0               </l>
<l>            else</l>
<l>                Pos_I :=  Pos_Fl               </l>
<l>            endif</l>
<l>            tuple_concat(Loc_Max, Pos_I, Loc_Max)</l>
<l>            tuple_concat(Loc_Max_Val, Gray[Pos_I], Loc_Max_Val)</l>
<l>            Fl := 0   </l>
<l>        endif</l>
<l>    endfor</l>
<l>return ()</l>
</body>
<docu id="SN_Loc_Max_Center">
<parameters>
<parameter id="Center"/>
<parameter id="Gray"/>
<parameter id="Loc_Max"/>
<parameter id="Loc_Max_Val"/>
</parameters>
</docu>
</procedure>
<procedure name="Teach_Slice">
<interface>
<io>
<par name="Skel_FWMS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Win" base_type="ctrl" dimension="0"/>
<par name="SensLen" base_type="ctrl" dimension="0"/>
<par name="path_teach_tuples" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pointer_Skel" base_type="ctrl" dimension="0"/>
<par name="Pointer_Sens" base_type="ctrl" dimension="0"/>
<par name="Rows_Sens" base_type="ctrl" dimension="0"/>
<par name="Cols_Sens" base_type="ctrl" dimension="0"/>
<par name="Pointer_Pos" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="MaxPRC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_contours_skeleton_xld(Skel_FWMS, Reg_SEL1_XLD, 1, 'filter')</l>
<l>smooth_contours_xld (Reg_SEL1_XLD, Reg_SEL1_XLD, 15)</l>
<c></c>
<l>Pointer_Skel := []</l>
<l>Pointer_Sens := []</l>
<l>Rows_Sens := []</l>
<l>Cols_Sens := []</l>
<l>Width_Sens := []</l>
<l>Pointer_Pos := 0</l>
<c></c>
<l>WinD2 := Win/2</l>
<l>SensLenD2 := SensLen / 2</l>
<c></c>
<l>get_image_size(WidthImageS, Im_W, Im_H)</l>
<c></c>
<l>*tuple_concat(Pointer_Skel, 0, Pointer_Skel)</l>
<l>count_obj(Reg_SEL1_XLD, Count)</l>
<c></c>
<l>TotalPRC := 0</l>
<l>MaxPRC := 0</l>
<l>CurrentOper:='Low Gray - Formation of sensors'</l>
<l>for Index := 1 to Count by 1</l>
<l>    select_obj (Reg_SEL1_XLD, Reg_SEL1, Index)</l>
<l>    get_contour_xld(Reg_SEL1, Rows, Cols)    </l>
<c></c>
<l>    tuple_length(Rows, Len)</l>
<l>    MaxPRC := MaxPRC + Len</l>
<l>endfor</l>
<c></c>
<l>for Index := 1 to Count by 1</l>
<c>    </c>
<l>    select_obj (Reg_SEL1_XLD, Reg_SEL1, Index)</l>
<l>    get_contour_xld(Reg_SEL1, Rows, Cols)    </l>
<c>    </c>
<l>    tuple_length(Rows, Len)</l>
<l>    if (Len &lt; Win * 2)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>*     for Ind := WinD2 to Len - WinD2 - 2 by 1</l>
<l>    for Ind := 0 to Len - 1 by 1</l>
<c></c>
<l>*         if (SensLen == 0)</l>
<l>*             get_grayval (WidthImageS, Rows[Ind], Cols[Ind], GrayW)</l>
<l>*             SensLen := GrayW * 2</l>
<l>*             SensLenD2 := SensLen / 2</l>
<l>*         endif</l>
<l>        get_grayval (WidthImageS, Rows[Ind], Cols[Ind], GrayW)</l>
<l>        SensLen := GrayW * 2</l>
<l>        SensLenD2 := SensLen / 2</l>
<c></c>
<c>            </c>
<l>        if (Ind &lt; WinD2)</l>
<l>            Ind0 := 0</l>
<l>            Ind1 := Ind + Win</l>
<l>        elseif (Ind &gt; Len - 1 - WinD2)</l>
<l>            Ind0 := Len - 1 - Win </l>
<l>            Ind1 := Len - 1</l>
<l>        else</l>
<l>            Ind0 := Ind - WinD2</l>
<l>            Ind1 := Ind + WinD2</l>
<l>        endif</l>
<c>        </c>
<c>        </c>
<l>        tuple_atan2(Rows[Ind0] - Rows[Ind1], Cols[Ind0] - Cols[Ind1], Angle) </l>
<l>        tuple_deg(Angle, Angle_Deg)</l>
<c>        </c>
<l>        tuple_cos(Angle + 1.5708, Cos)</l>
<l>        tuple_sin(Angle + 1.5708, Sin)</l>
<l>        P1X := Cols[Ind] + Cos * SensLenD2</l>
<l>        P1Y := Rows[Ind] + Sin * SensLenD2</l>
<c>    </c>
<l>        tuple_cos(Angle + 4.71239, Cos)</l>
<l>        tuple_sin(Angle + 4.71239, Sin)</l>
<l>        P2X := Cols[Ind] + Cos * SensLenD2</l>
<l>        P2Y := Rows[Ind] + Sin * SensLenD2</l>
<c>        </c>
<l>        gen_region_line(Reg_Sens, P1Y, P1X, P2Y, P2X)</l>
<l>        gen_contours_skeleton_xld(Reg_Sens, Reg_Sens_XLD, 1, 'filter')</l>
<l>        get_contour_xld(Reg_Sens_XLD, Rows_S, Cols_S)    </l>
<c>    </c>
<l>        dev_display(Reg_Sens_XLD)</l>
<c></c>
<l>        tuple_concat(Rows_Sens, Rows_S, Rows_Sens)</l>
<l>        tuple_concat(Cols_Sens, Cols_S, Cols_Sens)</l>
<l>        tuple_concat(Pointer_Sens, Pointer_Pos, Pointer_Sens)</l>
<c></c>
<l>        tuple_length(Rows_S, Length)</l>
<l>        Pointer_Pos := Pointer_Pos + Length</l>
<c>        </c>
<l>        TotalPRC := TotalPRC + 1</l>
<c></c>
<l>    endfor</l>
<c>    </c>
<l>    tuple_length(Pointer_Sens, Len_Sens)</l>
<l>    tuple_concat(Pointer_Skel, Len_Sens - 1, Pointer_Skel)</l>
<c>    </c>
<c>    </c>
<l> endfor</l>
<l>tuple_concat(Pointer_Sens, Pointer_Pos, Pointer_Sens)</l>
<c></c>
<l>CurrentOper:='Low Gray - Saving objects'</l>
<c></c>
<l>tuple_int(Rows_Sens, Rows_Sens)</l>
<l>tuple_int(Cols_Sens, Cols_Sens)</l>
<l>write_tuple(Pointer_Skel, path_teach_tuples + 'Pointer_Skel.tup')</l>
<l>write_tuple(Pointer_Sens, path_teach_tuples + 'Pointer_Sens.tup')</l>
<l>write_tuple(Rows_Sens, path_teach_tuples + 'Rows_Sens.tup')</l>
<l>write_tuple(Cols_Sens, path_teach_tuples + 'Cols_Sens.tup')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Teach_Slice">
<parameters>
<parameter id="Cols_Sens"/>
<parameter id="CurrentOper"/>
<parameter id="MaxPRC"/>
<parameter id="Pointer_Pos"/>
<parameter id="Pointer_Sens"/>
<parameter id="Pointer_Skel"/>
<parameter id="Rows_Sens"/>
<parameter id="SensLen"/>
<parameter id="Skel_FWMS"/>
<parameter id="TotalPRC"/>
<parameter id="WidthImageS"/>
<parameter id="Win"/>
<parameter id="path_teach_tuples"/>
</parameters>
</docu>
</procedure>
<procedure name="Gray_Cut_Threshold">
<interface>
<ic>
<par name="Gray" base_type="ctrl" dimension="0"/>
<par name="Threshold" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Gray_S" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Найти края Space - Обрезать по порогу</c>
<c></c>
<l>Gray_Len := |Gray|</l>
<l>SensLenD2 := Gray_Len / 2</l>
<c></c>
<l>Lp := 0</l>
<l>Rp := Gray_Len - 1</l>
<l>for I := SensLenD2 to Gray_Len - 1 by 1</l>
<l>    if (Gray[I] &gt; Threshold)</l>
<l>        Rp := I  </l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>for I := SensLenD2 to 0 by -1</l>
<l>    if (Gray[I] &gt; Threshold)</l>
<l>        Lp := I         </l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_select_range(Gray, Lp, Rp, Gray_S)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Gray_Cut_Threshold">
<parameters>
<parameter id="Gray"/>
<parameter id="Gray_S"/>
<parameter id="Threshold"/>
</parameters>
</docu>
</procedure>
</hdevelop>
