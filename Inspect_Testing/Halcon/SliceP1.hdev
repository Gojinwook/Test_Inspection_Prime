<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.3">
<procedure name="main">
<interface/>
<body>
<c>*******************************************************</c>
<c>*** Загрузка данных</c>
<c>*******************************************************</c>
<l>* read_image (Gi, 'G:/SAMSUNG/Test/p2112-004t3_2P0/Model/Gi.tif')</l>
<l>* read_object (Regnoproc, 'G:/SAMSUNG/Test/p2112-004t3_2P0/Model/RegNoProc.hobj')</l>
<l>* read_image (Gi, 'G:/SAMSUNG/NewData/p2309-001t1/Model_p2309-001t1_2P0/Model/Gi.tif')</l>
<l>* read_image (Im, 'G:/SAMSUNG/NewData/p2309-001t1/Model_p2309-001t1_2P0/Model/Im.tif')</l>
<l>* read_object (Regnoproc, 'G:/SAMSUNG/NewData/p2309-001t1/Model_p2309-001t1_2P0/Model/RegNoProc.hobj')</l>
<c></c>
<c></c>
<l>*path_model := 'C:/WORK_CURR/SAMSUNG/Samsung-AOI/Vision/AOI/Run/Model/Model_p2309-001t1_2P0/Model/'</l>
<l>*path_model := 'C:/WORK_CURR/SAMSUNG/Samsung-AOI/Vision/AOI/Run/Model/Model_p2312-015d1_2P0_V1/Model/'</l>
<l>path_model := 'G:/SAMSUNG/Image/20240719/Model/'</l>
<l>path_teach := path_model + 'Teach/'</l>
<c></c>
<c></c>
<l>* path_model := 'G:/SAMSUNG/Model_AOI/p2305-018t3/Model/'</l>
<l>* path_teach := 'G:/SAMSUNG/Model_AOI/p2305-018t3/Model/Teach/'</l>
<l>path_teach_tuples := path_teach + 'Tuples/'</l>
<c></c>
<c></c>
<l>* path_model := 'C:/WORK_CURR/SAMSUNG/Samsung-AOI/Vision/AOI/Run/Model/p2305-018t2_2P0/Model/'</l>
<l>* path_teach := path_model + 'Teach/'</l>
<l>path_image := 'C:/TmpIm/'</l>
<l>* path_image := 'G:/SAMSUNG/NewData/p2309-001t1/image/'</l>
<c></c>
<l>read_image (Gi_Im, path_model + 'Gi.tif')</l>
<c></c>
<l>read_object (Gi, path_model + 'Gi.hobj')</l>
<l>read_object (Skel_FWMS, path_teach + 'SkeletonsLG.hobj')</l>
<l>read_object (Skel_FWM, path_teach + 'SkeletonsFWM.hobj')</l>
<l>read_object (Skel_Gi, path_teach + 'SkeletonGs.hobj')</l>
<l>read_image (WidthImageS, path_teach + 'WidthImageS.tif')</l>
<l>read_image (WidthImageP, path_teach + 'WidthImageP.tif')</l>
<c></c>
<c></c>
<l>count_seconds(time1)</l>
<l>gen_empty_obj(RegionUnion)</l>
<l>for Index := 1 to 20000 by 1</l>
<l>    union2(RegionUnion, Gi, RegionUnion)</l>
<l>endfor</l>
<l>* union1(RegionUnion, RegionUnion)</l>
<l>count_seconds(time2)</l>
<l>time := time2 - time1</l>
<c></c>
<l>count_seconds(time1)</l>
<l>gen_empty_obj(RegionUnionS1)</l>
<l>gen_empty_obj(RegionUnionS2)</l>
<l>for Index := 1 to 10000 by 1</l>
<l>    union2(RegionUnionS1, Gi, RegionUnionS1)</l>
<l>endfor</l>
<c></c>
<l>for Index := 1 to 10000 by 1</l>
<l>    union2(RegionUnionS2, Gi, RegionUnionS2)</l>
<l>endfor</l>
<c></c>
<l>union2(RegionUnionS1, RegionUnionS2, RegionUnion3)</l>
<l>count_seconds(time2)</l>
<l>timeS := time2 - time1</l>
<c></c>
<c></c>
<c></c>
<l>* read_image (Gi, 'G:/SAMSUNG/Model_3/AOI/p2112-004t3_2P0/Model/Gi.tif')</l>
<c></c>
<l>stop()</l>
<c>*******************************************************</c>
<c>*** Параметры</c>
<c>*******************************************************</c>
<l>dev_update_off()</l>
<l>Percent_Height_LG := 0.20</l>
<l>Percent_Height_TH := 0.50</l>
<c></c>
<l>Win := 200</l>
<l>WinD2 := Win/2</l>
<l>SensLen := 80</l>
<c>*******************************************************</c>
<c>*** Обучение</c>
<c>*******************************************************</c>
<l>Teach_Slice_Delta (Skel_FWM, WidthImageP, Win, SensLen, path_teach_tuples, 'P', Pointer_Skel, Pointer_Sens, Rows_Sens, Cols_Sens, Pointer_Pos, CurrentOper, TotalPRC, MaxPRC)</l>
<c></c>
<l>stop()</l>
<l>read_tuple(path_teach_tuples + 'Rows_Sens_P.tup', Rows_Sens)</l>
<l>read_tuple(path_teach_tuples + 'Cols_Sens_P.tup', Cols_Sens)</l>
<l>read_tuple(path_teach_tuples + 'DeltaX_P.tup', DeltaX)</l>
<l>read_tuple(path_teach_tuples + 'DeltaY_P.tup', DeltaY)</l>
<l>stop()</l>
<c></c>
<c></c>
<c>*******************************************************</c>
<c>*** Инспекция</c>
<c>*******************************************************</c>
<c>* Краевая инспекция</c>
<c>*</c>
<c>* </c>
<c>* Обучение. Субпиксельный КАД</c>
<c>* Сенсора - имеют ортогональный угол, фронт(направление), </c>
<c>* Для сенсора определяем пару - другой сенсор совпадающий по углу ортогонали, но в другом направлении</c>
<c>* Для пары толщина - расстояние между сенсорами</c>
<c>* </c>
<c>*</c>
<c>* Опредление точки края по контрасту?</c>
<c>* Точка края имеет направление от темного к белому - передний фронт</c>
<c>* Найденная точка(кордината, субпиксель?) присваивается ближайшему ортоганальному сенсору совпадающая по фронту. </c>
<c>* Наличие у сенсора 2-х краевых точек?</c>
<c>*</c>
<c>* Если один и тот же край в двух сенсорах, то конфлик решается в пользу ближайшего по расстоянию</c>
<c>* Или с учетом предыдущих выборов</c>
<c>*</c>
<c>* Пост обработка найденных краевых точек.</c>
<c>* Сравнение краевых точек с КАД</c>
<c>* Измерение ширины</c>
<c>* Работа с аномалиями Open/Short, Island, PinHole</c>
<c></c>
<c>    </c>
<c>    </c>
<c></c>
<l>*skeleton(Gi, Skeleton)</l>
<c></c>
<l>* read_image (Im, path_image + 'Im1_44.tif')</l>
<l>read_image (Im, path_image + 'Im5_5.tif')</l>
<c></c>
<l>Contrast := 150</l>
<l>tuple_length(Rows_Sens, Count_Sens)</l>
<l>gen_image_const(Im_Gray, 'byte', Count_Sens, SensLen)</l>
<c></c>
<c></c>
<c></c>
<l>for Pos_Sens := 0 to Count_Sens - 1 by 1</l>
<c></c>
<c>    * Сформируем сенсор</c>
<l>    Rows := []</l>
<l>    Cols := []    </l>
<l>    dX := DeltaX[Pos_Sens]</l>
<l>    dY := DeltaY[Pos_Sens]</l>
<l>    Row := Rows_Sens[Pos_Sens] + dY * SensLen / 2</l>
<l>    Col := Cols_Sens[Pos_Sens] + dX * SensLen / 2</l>
<c>    </c>
<l>    Pos := 0</l>
<l>    for Idx := 0 to SensLen - 1 by 1</l>
<l>        Rows[Pos] := Row</l>
<l>        Cols[Pos] := Col</l>
<l>        Pos := Pos + 1</l>
<c>        </c>
<l>        Row := Row - dY</l>
<l>        Col := Col - dX</l>
<l>    endfor    </l>
<c>    </c>
<l>    set_color(200000, 'red')</l>
<l>    gen_region_points(Region, Rows, Cols)</l>
<l>    disp_obj(Region, 200000)</l>
<c>    </c>
<c>    </c>
<c>    * Gray</c>
<l>    get_grayval (Im, Rows, Cols, Gray)</l>
<c></c>
<c>    * Определение контраста? Находим % от (Мах - Мин)</c>
<c>    * Ищем все переходы с заданной контрастностью в обоих направлениях</c>
<c>    </c>
<c>    * Выбираем ближайшие к скелетону(центру) и расчитываем ширину?</c>
<c>    * Или находим ближайшие в пределах области поиска(предыдущие найденные)?</c>
<c>    </c>
<c>    * Для определения Open/Short формируем матрицу. Или найти другой способ поиска разрывов</c>
<c>    * В каде постороить схему проводимости(по скелетонам)? Затем "пробежка по проводам"</c>
<c>    </c>
<c>    * Определяем глубину/высоту перехода</c>
<c>    </c>
<c>    </c>
<c></c>
<c>    </c>
<c>    </c>
<c>    </c>
<l>    if (Pos_Sens &gt; 0)</l>
<l>        GrayD := abs(Gray1 - Gray)</l>
<c>        </c>
<c>        </c>
<l>        tuple_gen_const(SensLen, Pos_Sens, Tuple_Y)</l>
<l>        tuple_gen_sequence(0, SensLen - 1, 1, Tuple_X)</l>
<l>        set_grayval(Im_Gray, Tuple_X, Tuple_Y, GrayD)</l>
<c>        </c>
<l>    endif</l>
<l>    Gray1 := Gray</l>
<c>    </c>
<c>    * Найдем передний фронт слева</c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<l>endfor</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>stop()</l>
<c>*******************************************************</c>
<c>*******************************************************</c>
<c>*******************************************************</c>
<c></c>
<l>tuple_gen_const(100, 255, Gray_Short)</l>
<l>tuple_gen_const(100, 0, Gray_Max)</l>
<c></c>
<l>Mx_Size := 20 </l>
<l>create_matrix(Mx_Size, 100, 255, Matrix_Gray)</l>
<l>Mx_Pos := 0</l>
<l>Mx_Cnt := 0</l>
<c></c>
<l>Widt_Pos := 0</l>
<l>Widt_S := []</l>
<l>Widt := []</l>
<l>Depth_S := []</l>
<l>Rows_Cent := []</l>
<l>Cols_Cent := []</l>
<l>tuple_length(Pointer_Skel, Count_Skel)</l>
<l>Pos_Skel_S := 0</l>
<l>for I_Skel := 0 to Count_Skel - 1 by 1</l>
<l>    Pos_Skel_E := Pointer_Skel[I_Skel]</l>
<c>    </c>
<l>*     Pos_Skel_E := Pointer_Skel[1]</l>
<l>*     Pos_Skel_S := Pos_Skel_E - 4140</l>
<c>    </c>
<l>    Depth_Pos := 0</l>
<l>    for Point := Pos_Skel_S to Pos_Skel_E by 1</l>
<c>        </c>
<l>*           Point := 570</l>
<l>        if (Point &gt;= 60)</l>
<l>            Test1 := 0            </l>
<l>        endif</l>
<c>        </c>
<l>        Point_S := Pointer_Sens[Point]</l>
<l>        *Point_E := Point_S + 50</l>
<l>        Point_E := Pointer_Sens[Point + 1] - 1</l>
<c>        </c>
<l>        tuple_select_range(Rows_Sens, Point_S, Point_E, Rows)</l>
<l>        tuple_select_range(Cols_Sens, Point_S, Point_E, Cols)</l>
<l>        get_grayval (Im, Rows, Cols, Gray)</l>
<c></c>
<l>        tuple_length(Gray, Gray_Len)</l>
<l>        SensLenD2 := Gray_Len / 2</l>
<c></c>
<c>        * -----------------------------------------------------------------------------------------------------</c>
<c>        * Поиск минимума. Ищем 2 минимальных минимума(при условии, что мы больше не захватываем соседние Space</c>
<c>        * Если захватываются соседние Space, то ищем минимум, затем все минимумы в пределах некоторого порога, затем два ближе к центу</c>
<c>        * Обрезаем Gray по наденным минимумам</c>
<c>        * Измеряем ширину и глубину</c>
<l>        Moving_Avg(Gray, 10, Gray_MV)        </l>
<c></c>
<c>        * Ищем минимум</c>
<l>        *tuple_min(Gray_MV, Gray_MV_Min)</l>
<c>         </c>
<c>        * Ищем 2 центральных минимума</c>
<l>        create_funct_1d_array(Gray, FGray)</l>
<l>        smooth_funct_1d_mean(FGray, 5, 3, FGrayM)</l>
<l>        local_min_max_funct_1d(FGrayM, 'plateaus_center', 'true', Min_FGrayM, Max_FGrayM)  </l>
<c>        </c>
<c>        </c>
<l>        num_points_funct_1d(FGrayM, FGrayM_Length)</l>
<l>        tuple_gen_sequence(0, FGrayM_Length - 1, 1, Col_Seq)</l>
<l>        get_y_value_funct_1d(FGrayM, Col_Seq, 'constant', GrayM)</l>
<c>        </c>
<l>        tuple_length(Min_FGrayM, Min_Len)</l>
<c>        </c>
<l>        Min2_Pos := Gray_Len - 1</l>
<l>        Min1_Pos := 0</l>
<c></c>
<l>        Min1 := 1000000</l>
<l>        for Min_Pos := 0 to Min_Len - 1 by 1</l>
<l>            Pos := Min_FGrayM[Min_Pos]</l>
<l>            tuple_int(Pos, Pos)</l>
<l>            Val := GrayM[Pos]</l>
<c>           </c>
<l>            if (Val &lt; Min1)</l>
<l>                Min1 := Val</l>
<l>                Min1_Pos := Pos</l>
<l>            endif</l>
<l>        endfor</l>
<c>        </c>
<l>        GrayW := Gray_Len / 3</l>
<l>        Min2 := 1000000</l>
<l>        for Min_Pos := 0 to Min_Len - 1 by 1</l>
<l>            Pos := Min_FGrayM[Min_Pos]</l>
<l>            tuple_int(Pos, Pos)</l>
<l>            Val := GrayM[Pos]</l>
<c>           </c>
<l>            if (Val &lt; Min2 and abs(Min1_Pos - Pos) &gt; GrayW)</l>
<l>                Min2 := Val</l>
<l>                Min2_Pos := Pos</l>
<l>            endif</l>
<l>        endfor</l>
<c>        </c>
<l>        if (Min1_Pos &gt; Min2_Pos)</l>
<l>            Min_Pos := Min1_Pos</l>
<l>            Min1_Pos := Min2_Pos</l>
<l>            Min2_Pos := Min_Pos</l>
<l>        endif</l>
<c>        </c>
<c>        * Обрежем Gray  по минимумам</c>
<c>        </c>
<l>        tuple_select_range(Gray, Min1_Pos, Min2_Pos, Gray_Cut)</l>
<l>        tuple_select_range(Gray_MV, Min1_Pos, Min2_Pos, Gray_MV_Cut)</l>
<l>        tuple_length(Gray_Cut, Gray_Cut_Len)</l>
<l>        tuple_length(Gray_MV_Cut, Gray_MV_Cut_Len)</l>
<c>        * -----------------------------------------------------------------------------------------------------</c>
<c></c>
<c>        * Определить пороги</c>
<l>*         tuple_max2(Gray_MV_Cut[0], Gray_MV_Cut[Gray_MV_Cut_Len - 1], Gray_MV_Cut_Min)</l>
<l>        tuple_min(Gray_MV_Cut, Gray_MV_Cut_Min)</l>
<l>        tuple_max(Gray_MV_Cut, Gray_MV_Cut_Max)</l>
<l>        Scope := Gray_MV_Cut_Max - Gray_MV_Cut_Min</l>
<l>        thr_LG := Gray_MV_Cut_Max - Scope * Percent_Height_LG </l>
<l>        thr_TH := Gray_MV_Cut_Max - Scope * Percent_Height_TH</l>
<c>        </c>
<c>        </c>
<l>        *thr := thr_TH</l>
<l>        thr := 130</l>
<l>*         Gray_MV_Cut := Gray_Cut</l>
<l>*         Gray_MV_Cut_Len := Gray_Cut_Len</l>
<c>        </c>
<c>        * Определение ширины ----------------------------------------------------------------------------------</c>
<c></c>
<c></c>
<l>*         for I := 0 to Gray_MV_Cut_Len - 1 by 1</l>
<l>*             Val_Gray := Gray_MV_Cut[I]</l>
<l>*             if (Val_Gray &gt; thr)</l>
<l>*                 P1 := I</l>
<l>*                 break</l>
<l>*             endif</l>
<l>*         endfor</l>
<c>        </c>
<l>*         for I := Gray_MV_Cut_Len - 1 to 0 by -1</l>
<l>*             Val_Gray := Gray_MV_Cut[I]</l>
<l>*             if (Val_Gray &gt; thr)</l>
<l>*                 P2 := I</l>
<l>*                 break</l>
<l>*             endif</l>
<l>*         endfor</l>
<c>        </c>
<l>*         if (P1 &gt; 0)</l>
<l>*             tuple_real(Gray_MV_Cut[P1 + 1], T1)</l>
<l>*             tuple_real(Gray_MV_Cut[P1], T2)</l>
<l>*             Pr := (T1 - thr) / (T1 - T2)</l>
<l>*             P1A := P1 - Pr </l>
<l>*         else</l>
<l>*             P1A := 0</l>
<l>*         endif</l>
<c>        </c>
<c>        </c>
<l>*         if (P2 &lt; Gray_MV_Cut_Len - 1)</l>
<l>*             tuple_real(Gray_MV_Cut[P2 + 1], T1)</l>
<l>*             tuple_real(Gray_MV_Cut[P2], T2)</l>
<l>*             Pr := (T1 - thr) / (T1 - T2)</l>
<l>*             P2A := P2 - Pr </l>
<l>*         else</l>
<l>*             P2A := Gray_MV_Cut_Len - 1</l>
<l>*         endif</l>
<c>        </c>
<l>*         _Widt := P2A - P1A </l>
<l>*         Widt[Widt_Pos] := _Widt</l>
<l>*         Widt_Pos := Widt_Pos + 1</l>
<c>                </c>
<l>*         test1 := 0</l>
<l>*         if (test1 == 1)</l>
<l>*             Gray1 := Gray</l>
<l>*             gen_region_line(Line_Sens, Rows[I1], Cols[I1], Rows[I2], Cols[I2])</l>
<l>*             dev_display(Line_Sens)</l>
<l>            *disp_obj(Line_Sens, 200000)</l>
<l>*         endif</l>
<c>        </c>
<c>        * --- Определение Open ------------------------------------------------------------------------------- </c>
<l>*         Test_Matrix ()</l>
<c>        </c>
<l>        count_seconds(s1)</l>
<l>        tuple_gen_sequence(0, Gray_Cut_Len - 1, 1, Col_Seq)</l>
<l>        tuple_gen_const(Gray_Cut_Len, Mx_Pos, Row_Seq)</l>
<l>        set_value_matrix(Matrix_Gray, Row_Seq, Col_Seq, Gray_Cut)</l>
<l>        Mx_Pos := Mx_Pos + 1</l>
<l>        if (Mx_Pos &gt;= Mx_Size - 1)</l>
<l>            Mx_Pos := 0    </l>
<l>        endif</l>
<c></c>
<l>        if (Mx_Cnt &lt; Mx_Size - 1)</l>
<l>            Mx_Cnt := Mx_Cnt + 1</l>
<l>            Mx_Pos_Last := 0</l>
<l>        else</l>
<l>            min_matrix(Matrix_Gray, 'columns', Matrix_Gray_Min)</l>
<l>            tuple_gen_const(Gray_Cut_Len, 0, Row_Seq)</l>
<l>            get_value_matrix(Matrix_Gray_Min, Row_Seq, Col_Seq, Gray_Last)</l>
<c>            </c>
<c>            </c>
<l>            tuple_max(Gray_Last, Depth)</l>
<l>            Depth_S[Depth_Pos] := Depth</l>
<l>            Depth_Pos := Depth_Pos + 1            </l>
<c>            </c>
<l>        endif</l>
<l>        count_seconds(s2)</l>
<l>        s := s2 - s1        </l>
<c>  </c>
<c>        </c>
<c>        * -----------------------------------------------------------------------------------------------------</c>
<c>        </c>
<c>        </c>
<l>        tuple_length(Rows, Len)</l>
<l>        gen_region_line(Line_Sens, Rows[0], Cols[0], Rows[Len-1], Cols[Len-1])</l>
<l>        disp_obj(Line_Sens, 200000)</l>
<c>        </c>
<l>    endfor</l>
<c>    </c>
<l>    szw := 50</l>
<l>    FilterFloadMedn(Depth_S, szw, 10, 10, Def, Wfilt, Wcmnh, Prc)</l>
<c>    </c>
<l>    szw := 50</l>
<l>    FilterFloadMedn(Widt, szw, 10, 10, Def, Wfilt, Wcmnh, Prc)</l>
<c></c>
<l>*     read_tuple('C:/Temp/hv_Depth_S.tup', hv_Depth_S)</l>
<l>*     read_tuple('C:/Temp/hv_Depth_Ppr_S.tup', hv_Depth_Ppr_S)</l>
<c>    </c>
<c>    * Определение дефектов</c>
<c>    </c>
<l>    tuple_length(Depth_S, Cnt)</l>
<l>    for I := 0 to Cnt - 1 by 1</l>
<c>        </c>
<l>        if (Prc[I] &gt; 35)</l>
<l>            Rows_S := Rows_Cent[I]</l>
<l>            Cols_S := Cols_Cent[I]</l>
<c></c>
<l>            gen_circle(Circle, Rows_S, Cols_S, 10.5)</l>
<l>            disp_obj(Circle, 200000)</l>
<c>            </c>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>    Pos_Skel_S := Pos_Skel_E + 1</l>
<c>    </c>
<l>endfor</l>
<c></c>
<c></c>
<c></c>
<c>*******************************************************</c>
<c>*** End</c>
<c>*******************************************************</c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c>* </c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'off'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="dev_update_on">
<interface/>
<body>
<c>* This procedure sets different update settings to 'on'.</c>
<c>* </c>
<l>dev_update_pc ('on')</l>
<l>dev_update_var ('on')</l>
<l>dev_update_window ('on')</l>
<l>return ()</l>
</body>
<docu id="dev_update_on">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'on'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_off</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="Auto_Threshold5">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thrS" base_type="ctrl" dimension="0"/>
<par name="thrP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>union1 (SkeletonsFWMS, SkeletonFWMS)</l>
<l>dilation_circle (SkeletonFWMS, SkeletonFWMSd, 9.5)</l>
<l>reduce_domain (Im, SkeletonFWMSd, Imp)</l>
<c></c>
<l>gray_histo_abs (SkeletonFWMSd, Imp, 1, AbsoluteHisto1)</l>
<c></c>
<l>create_funct_1d_array (AbsoluteHisto1, FAbsoluteHisto1)</l>
<l>smooth_funct_1d_mean (FAbsoluteHisto1, 15, 5, FAbsoluteHistosm1)</l>
<l>local_min_max_funct_1d (FAbsoluteHistosm1, 'strict_min_max', 'true', Min21, Max21)</l>
<c></c>
<l>* Middle := 140</l>
<l>Middle := int(Min21[0])</l>
<c></c>
<l>if (Middle == 0)</l>
<l>    thr := 0</l>
<l>    thrS := 0</l>
<l>    thrP := 0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>tuple_first_n (AbsoluteHisto1, Middle, Space_T)</l>
<l>create_funct_1d_array (Space_T, FSpace_T)</l>
<l>smooth_funct_1d_mean (FSpace_T, 9, 3, FSpace_T)</l>
<l>local_min_max_funct_1d (FSpace_T, 'plateaus_center', 'true', MinS, MaxS)</l>
<c></c>
<l>Max_Index (MaxS, FSpace_T, Idx)</l>
<l>thrS := MaxS[Idx]</l>
<c></c>
<c></c>
<c></c>
<l>tuple_last_n (AbsoluteHisto1, Middle, Patern_T)</l>
<l>create_funct_1d_array (Patern_T, FPatern_T)</l>
<l>smooth_funct_1d_mean (FPatern_T, 9, 3, FPatern_T)</l>
<l>local_min_max_funct_1d (FPatern_T, 'plateaus_center', 'true', MinP, MaxP)</l>
<c></c>
<l>Max_Index (MaxP, FPatern_T, Idx)</l>
<l>thrP := MaxP[Idx] + Middle</l>
<c></c>
<l>tuple_mean ([thrS, thrP], thr)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="Auto_Threshold5">
<parameters>
<parameter id="Im"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="thr"/>
<parameter id="thrP"/>
<parameter id="thrS"/>
</parameters>
</docu>
</procedure>
<procedure name="Max_Index">
<interface>
<ic>
<par name="Max21" base_type="ctrl" dimension="0"/>
<par name="FAbsoluteHistosm1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Max_Index" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Max_Pos := 0</l>
<l>Max_Val := 0</l>
<l>Max_Index := 0</l>
<l>tuple_length (Max21, Length)</l>
<l>for Index := 0 to Length - 1 by 1</l>
<c></c>
<l>    Extr_Pos := Max21[Index]</l>
<l>    tuple_int (Extr_Pos, Extr_Pos)</l>
<l>    Extr_Val := FAbsoluteHistosm1[Extr_Pos]</l>
<l>    if (Extr_Val &gt; Max_Val)</l>
<l>        Max_Val := Extr_Val</l>
<l>        Max_Pos := Extr_Pos</l>
<l>        Max_Index := Index</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="Max_Index">
<parameters>
<parameter id="FAbsoluteHistosm1"/>
<parameter id="Max21"/>
<parameter id="Max_Index"/>
</parameters>
</docu>
</procedure>
<procedure name="SN_Loc_Min">
<interface>
<ic>
<par name="Gray" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Loc_Min" base_type="ctrl" dimension="0"/>
<par name="Loc_Min_Val" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    Loc_Min := []</l>
<l>    Loc_Min_Val := []</l>
<l>    Fl := 1</l>
<l>    tuple_length(Gray, Gray_Len)</l>
<l>    for I := 1 to Gray_Len - 1 by 1</l>
<l>        I0 := I - 1</l>
<l>        if (Gray[I0] &gt; Gray[I])</l>
<l>            Fl := 1   </l>
<l>        endif</l>
<c></c>
<l>        if ((Gray[I0] &lt; Gray[I] and Fl == 1) or (I == Gray_Len - 1 and Fl == 1))</l>
<l>            tuple_concat(Loc_Min, I0, Loc_Min)</l>
<l>            tuple_concat(Loc_Min_Val, Gray[I0], Loc_Min_Val)</l>
<l>            Fl := 0   </l>
<l>        endif</l>
<l>    endfor</l>
<l>return ()</l>
</body>
<docu id="SN_Loc_Min">
<parameters>
<parameter id="Gray"/>
<parameter id="Loc_Min"/>
<parameter id="Loc_Min_Val"/>
</parameters>
</docu>
</procedure>
<procedure name="SN_Loc_Max_Center">
<interface>
<ic>
<par name="Gray" base_type="ctrl" dimension="0"/>
<par name="Center" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Loc_Max" base_type="ctrl" dimension="0"/>
<par name="Loc_Max_Val" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    Loc_Max := []</l>
<l>    Loc_Max_Val := []</l>
<l>    Fl := 1</l>
<l>    Pos_Fl := 0</l>
<l>    tuple_length(Gray, Gray_Len)</l>
<l>    for I := 1 to Gray_Len - 1 by 1</l>
<l>        I0 := I - 1</l>
<l>        if (Gray[I0] &lt; Gray[I])</l>
<l>            Fl := 1   </l>
<l>            Pos_Fl := I</l>
<l>        endif</l>
<c></c>
<l>        if ((Gray[I0] &gt; Gray[I] and Fl == 1) or (I == Gray_Len - 1 and Fl == 1))</l>
<l>            if (Center - I0 &gt; 0)</l>
<l>                Pos_I :=  I0               </l>
<l>            else</l>
<l>                Pos_I :=  Pos_Fl               </l>
<l>            endif</l>
<l>            tuple_concat(Loc_Max, Pos_I, Loc_Max)</l>
<l>            tuple_concat(Loc_Max_Val, Gray[Pos_I], Loc_Max_Val)</l>
<l>            Fl := 0   </l>
<l>        endif</l>
<l>    endfor</l>
<l>return ()</l>
</body>
<docu id="SN_Loc_Max_Center">
<parameters>
<parameter id="Center"/>
<parameter id="Gray"/>
<parameter id="Loc_Max"/>
<parameter id="Loc_Max_Val"/>
</parameters>
</docu>
</procedure>
<procedure name="Teach_Slice">
<interface>
<io>
<par name="Skel_FWMS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Win" base_type="ctrl" dimension="0"/>
<par name="SensLen" base_type="ctrl" dimension="0"/>
<par name="path_teach_tuples" base_type="ctrl" dimension="0"/>
<par name="Type" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pointer_Skel" base_type="ctrl" dimension="0"/>
<par name="Pointer_Sens" base_type="ctrl" dimension="0"/>
<par name="Rows_Sens" base_type="ctrl" dimension="0"/>
<par name="Cols_Sens" base_type="ctrl" dimension="0"/>
<par name="Pointer_Pos" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="MaxPRC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_contours_skeleton_xld(Skel_FWMS, Reg_SEL1_XLD, 1, 'filter')</l>
<c></c>
<l>Pointer_Skel := []</l>
<l>Pointer_Sens := []</l>
<l>Rows_Sens := []</l>
<l>Cols_Sens := []</l>
<l>Width_Sens := []</l>
<l>Pointer_Pos := 0</l>
<c></c>
<l>WinD2 := Win/2</l>
<l>SensLenD2 := SensLen / 2</l>
<c></c>
<l>*tuple_concat(Pointer_Skel, 0, Pointer_Skel)</l>
<l>count_obj(Reg_SEL1_XLD, Count)</l>
<c></c>
<l>TotalPRC := 0</l>
<l>MaxPRC := 0</l>
<l>CurrentOper:='Low Gray - Formation of sensors'</l>
<l>for Index := 1 to Count by 1</l>
<l>    select_obj (Reg_SEL1_XLD, Reg_SEL1, Index)</l>
<l>    get_contour_xld(Reg_SEL1, Rows, Cols)    </l>
<c></c>
<l>    tuple_length(Rows, Len)</l>
<l>    MaxPRC := MaxPRC + Len</l>
<l>endfor</l>
<c></c>
<l>for Index := 1 to Count by 1</l>
<c>    </c>
<l>    select_obj (Reg_SEL1_XLD, Reg_SEL1, Index)</l>
<l>    get_contour_xld(Reg_SEL1, Rows, Cols)    </l>
<c>    </c>
<c></c>
<l>    tuple_length(Rows, Len)</l>
<l>*     for Ind := WinD2 to Len - WinD2 - 2 by 1</l>
<l>    for Ind := 0 to Len - 1 by 1</l>
<c></c>
<l>*         if (SensLen == 0)</l>
<l>*             get_grayval (WidthImageS, Rows[Ind], Cols[Ind], GrayW)</l>
<l>*             SensLen := GrayW * 2</l>
<l>*             SensLenD2 := SensLen / 2</l>
<l>*         endif</l>
<l>        get_grayval (WidthImageS, Rows[Ind], Cols[Ind], GrayW)</l>
<l>        *SensLen := GrayW * 2</l>
<l>        SensLen := GrayW * 3</l>
<l>        SensLenD2 := SensLen / 2</l>
<c></c>
<c>            </c>
<l>        if (Ind &lt; WinD2)</l>
<l>            Ind0 := 0</l>
<l>            Ind1 := Ind + Win</l>
<l>        elseif (Ind &gt; Len - 1 - WinD2)</l>
<l>            Ind0 := Len - 1 - Win </l>
<l>            Ind1 := Len - 1</l>
<l>        else</l>
<l>            Ind0 := Ind - WinD2</l>
<l>            Ind1 := Ind + WinD2</l>
<l>        endif</l>
<c>        </c>
<c>        </c>
<l>        tuple_atan2(Rows[Ind0] - Rows[Ind1], Cols[Ind0] - Cols[Ind1], Angle) </l>
<l>        tuple_deg(Angle, Angle_Deg)</l>
<c>        </c>
<l>        tuple_cos(Angle + 1.5708, Cos)</l>
<l>        tuple_sin(Angle + 1.5708, Sin)</l>
<l>        P1X := Cols[Ind] + Cos * SensLenD2</l>
<l>        P1Y := Rows[Ind] + Sin * SensLenD2</l>
<c>    </c>
<l>        tuple_cos(Angle + 4.71239, Cos)</l>
<l>        tuple_sin(Angle + 4.71239, Sin)</l>
<l>        P2X := Cols[Ind] + Cos * SensLenD2</l>
<l>        P2Y := Rows[Ind] + Sin * SensLenD2</l>
<c>        </c>
<c>        * --------------------------------------------------------</c>
<l>        dX := (P1X - P2X) / SensLen</l>
<l>        dY := (P1Y - P2Y) / SensLen</l>
<l>        Rows_S1 := []</l>
<l>        Cols_S1 := []</l>
<l>        Row1 := P1Y</l>
<l>        Col1 := P1X</l>
<l>        for Idx := 0 to SensLen - 1 by 1</l>
<c>            </c>
<l>            Rows_S1[Idx] := Row1</l>
<l>            Cols_S1[Idx] := Col1</l>
<c>            </c>
<l>            Row1 := Row1 - dY</l>
<l>            Col1 := Col1 - dX</l>
<l>        endfor</l>
<c>        </c>
<l>*         if (Ind == 20)</l>
<l>*             tuple_length(Rows_S1, Len)</l>
<l>*             gen_region_line(Line_Sens, Rows_S1[0], Cols_S1[0], Rows_S1[Len-1], Cols_S1[Len-1])</l>
<l>*             disp_obj(Line_Sens, 200000)</l>
<c>            </c>
<l>*             gen_region_points(Region, Rows_S1, Cols_S1)</l>
<l>*             disp_obj(Region, 200000)</l>
<c>            </c>
<l>*         endif</l>
<c>        * --------------------------------------------------------</c>
<c>        </c>
<l>*         gen_region_line(Reg_Sens, P1Y, P1X, P2Y, P2X)</l>
<l>*         get_region_contour(Reg_Sens, Rows_S1, Cols_S1)</l>
<c>        </c>
<l>*         disp_obj(Reg_Sens, 200000)</l>
<l>*         gen_contours_skeleton_xld(Reg_Sens, Reg_Sens_XLD, 1, 'filter')</l>
<l>*         get_contour_xld(Reg_Sens_XLD, Rows_S, Cols_S)    </l>
<c>    </c>
<l>        tuple_concat(Rows_Sens, Rows_S1, Rows_Sens)</l>
<l>        tuple_concat(Cols_Sens, Cols_S1, Cols_Sens)</l>
<l>        tuple_concat(Pointer_Sens, Pointer_Pos, Pointer_Sens)</l>
<c></c>
<l>        tuple_length(Rows_S1, Length)</l>
<l>        Pointer_Pos := Pointer_Pos + Length</l>
<c>        </c>
<l>        TotalPRC := TotalPRC + 1</l>
<c></c>
<l>    endfor</l>
<c>    </c>
<l>    tuple_length(Pointer_Sens, Len_Sens)</l>
<l>    tuple_concat(Pointer_Skel, Len_Sens - 1, Pointer_Skel)</l>
<c>    </c>
<c>    </c>
<l> endfor</l>
<l>tuple_concat(Pointer_Sens, Pointer_Pos, Pointer_Sens)</l>
<c></c>
<l>CurrentOper:='Low Gray - Saving objects'</l>
<c></c>
<l>tuple_int(Rows_Sens, Rows_Sens)</l>
<l>tuple_int(Cols_Sens, Cols_Sens)</l>
<l>if (Type == 'S')</l>
<l>    write_tuple(Pointer_Skel, path_teach_tuples + 'Pointer_Skel.tup')</l>
<l>    write_tuple(Pointer_Sens, path_teach_tuples + 'Pointer_Sens.tup')</l>
<l>    write_tuple(Rows_Sens, path_teach_tuples + 'Rows_Sens.tup')</l>
<l>    write_tuple(Cols_Sens, path_teach_tuples + 'Cols_Sens.tup')</l>
<l>else</l>
<l>    write_tuple(Pointer_Skel, path_teach_tuples + 'Pointer_Skel_P.tup')</l>
<l>    write_tuple(Pointer_Sens, path_teach_tuples + 'Pointer_Sens_P.tup')</l>
<l>    write_tuple(Rows_Sens, path_teach_tuples + 'Rows_Sens_P.tup')</l>
<l>    write_tuple(Cols_Sens, path_teach_tuples + 'Cols_Sens_P.tup')</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Teach_Slice">
<parameters>
<parameter id="Cols_Sens"/>
<parameter id="CurrentOper"/>
<parameter id="MaxPRC"/>
<parameter id="Pointer_Pos"/>
<parameter id="Pointer_Sens"/>
<parameter id="Pointer_Skel"/>
<parameter id="Rows_Sens"/>
<parameter id="SensLen"/>
<parameter id="Skel_FWMS"/>
<parameter id="TotalPRC"/>
<parameter id="Type"/>
<parameter id="WidthImageS"/>
<parameter id="Win"/>
<parameter id="path_teach_tuples"/>
</parameters>
</docu>
</procedure>
<procedure name="Test_Matrix">
<interface/>
<body>
<l>count_seconds(s1)</l>
<c></c>
<c></c>
<l>Mx_Size := 20 </l>
<l>create_matrix(Mx_Size, 100, 255, Matrix_Gray)</l>
<l>Mx_Pos := 0</l>
<l>Mx_Cnt := 0</l>
<c></c>
<l>Depth_Pos := 0</l>
<l>Gray_Len := 50</l>
<c></c>
<l>for I := 0 to 20000 - 1 by 1</l>
<c>    </c>
<l>    tuple_gen_sequence(0, Gray_Len - 1, 1, Gray)</l>
<l>    tuple_gen_sequence(0, Gray_Len - 1, 1, Col_Seq)</l>
<l>    tuple_gen_const (Gray_Len, Mx_Pos, Row_Seq)</l>
<l>    set_value_matrix(Matrix_Gray, Row_Seq, Col_Seq, Gray)</l>
<l>    Mx_Pos := Mx_Pos + 1</l>
<l>    if (Mx_Pos &gt;= Mx_Size - 1)</l>
<l>        Mx_Pos := 0</l>
<l>    endif</l>
<c></c>
<c>    </c>
<l>    if (Mx_Cnt &lt; Mx_Size - 1)</l>
<l>        Mx_Cnt := Mx_Cnt + 1</l>
<l>        Mx_Pos_Last := 0</l>
<l>    else</l>
<l>        min_matrix(Matrix_Gray, 'columns', Matrix_Gray_Min)</l>
<l>        tuple_gen_const(Gray_Len, 0, Row_Seq)</l>
<l>        get_value_matrix(Matrix_Gray_Min, Row_Seq, Col_Seq, Gray_Last)</l>
<c>        </c>
<l>        tuple_max(Gray_Last, Depth)</l>
<l>        Depth_S[Depth_Pos] := Depth</l>
<l>        Depth_Pos := Depth_Pos + 1            </l>
<c>        </c>
<l>    endif</l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>endfor</l>
<c></c>
<c></c>
<c>        </c>
<l>count_seconds(s2)</l>
<l>s := s2 - s1        </l>
<c>        </c>
<l>return ()</l>
</body>
<docu id="Test_Matrix">
<parameters/>
</docu>
</procedure>
<procedure name="Teach_Slice_Delta">
<interface>
<io>
<par name="Skel_FWMS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Win" base_type="ctrl" dimension="0"/>
<par name="SensLen" base_type="ctrl" dimension="0"/>
<par name="path_teach_tuples" base_type="ctrl" dimension="0"/>
<par name="Type" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pointer_Skel" base_type="ctrl" dimension="0"/>
<par name="Pointer_Sens" base_type="ctrl" dimension="0"/>
<par name="Rows_Sens" base_type="ctrl" dimension="0"/>
<par name="Cols_Sens" base_type="ctrl" dimension="0"/>
<par name="Pointer_Pos" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="MaxPRC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_contours_skeleton_xld(Skel_FWMS, Reg_SEL1_XLD, 1, 'filter')</l>
<c></c>
<l>Pointer_Skel := []</l>
<l>Pointer_Sens := []</l>
<l>Rows_Sens := []</l>
<l>Cols_Sens := []</l>
<l>Width_Sens := []</l>
<c></c>
<l>DeltaX := []</l>
<l>DeltaY := []</l>
<c></c>
<l>Pointer_Pos := 0</l>
<c></c>
<l>WinD2 := Win/2</l>
<l>SensLenD2 := SensLen / 2</l>
<c></c>
<l>count_obj(Reg_SEL1_XLD, Count)</l>
<c></c>
<l>TotalPRC := 0</l>
<l>MaxPRC := 0</l>
<l>CurrentOper:='Low Gray - Formation of sensors'</l>
<l>for Index := 1 to Count by 1</l>
<l>    select_obj (Reg_SEL1_XLD, Reg_SEL1, Index)</l>
<l>    get_contour_xld(Reg_SEL1, Rows, Cols)    </l>
<c></c>
<l>    tuple_length(Rows, Len)</l>
<l>    MaxPRC := MaxPRC + Len</l>
<l>endfor</l>
<c></c>
<l>for Index := 1 to Count by 1</l>
<c>    </c>
<l>    select_obj (Reg_SEL1_XLD, Reg_SEL1, Index)</l>
<l>    get_contour_xld(Reg_SEL1, Rows, Cols)    </l>
<c>    </c>
<l>    tuple_length(Rows, Len)</l>
<l>    for Ind := 0 to Len - 1 by 1</l>
<l>        get_grayval (WidthImageS, Rows[Ind], Cols[Ind], GrayW)</l>
<l>        SensLen := GrayW * 2</l>
<l>        SensLenD2 := SensLen / 2</l>
<c>            </c>
<l>        if (Ind &lt; WinD2)</l>
<l>            Ind0 := 0</l>
<l>            Ind1 := Ind + Win</l>
<l>        elseif (Ind &gt; Len - 1 - WinD2)</l>
<l>            Ind0 := Len - 1 - Win </l>
<l>            Ind1 := Len - 1</l>
<l>        else</l>
<l>            Ind0 := Ind - WinD2</l>
<l>            Ind1 := Ind + WinD2</l>
<l>        endif</l>
<c>        </c>
<c>        </c>
<l>        tuple_atan2(Rows[Ind0] - Rows[Ind1], Cols[Ind0] - Cols[Ind1], Angle) </l>
<l>        tuple_deg(Angle, Angle_Deg)</l>
<c>        </c>
<l>        tuple_cos(Angle + 1.5708, Cos)</l>
<l>        tuple_sin(Angle + 1.5708, Sin)</l>
<l>        P1X := Cols[Ind] + Cos * SensLenD2</l>
<l>        P1Y := Rows[Ind] + Sin * SensLenD2</l>
<c>    </c>
<l>        tuple_cos(Angle + 4.71239, Cos)</l>
<l>        tuple_sin(Angle + 4.71239, Sin)</l>
<l>        P2X := Cols[Ind] + Cos * SensLenD2</l>
<l>        P2Y := Rows[Ind] + Sin * SensLenD2</l>
<c>        </c>
<c>        * --------------------------------------------------------</c>
<l>        dX := (P1X - P2X) / SensLen</l>
<l>        dY := (P1Y - P2Y) / SensLen</l>
<l>        DeltaX[TotalPRC] := dX</l>
<l>        DeltaY[TotalPRC] := dY</l>
<l>        Rows_Sens[TotalPRC] := Rows[Ind]</l>
<l>        Cols_Sens[TotalPRC] := Cols[Ind]</l>
<c>        </c>
<l>        TotalPRC := TotalPRC + 1</l>
<l>    endfor</l>
<c>    </c>
<c>    </c>
<l>endfor</l>
<c></c>
<c>*--- Test ----------------------------------</c>
<l>* Sens_Pos := 20</l>
<c></c>
<l>* Rows := []</l>
<l>* Cols := []</l>
<c></c>
<l>* Row := Rows_Sens[Sens_Pos] + 0.5</l>
<l>* Col := Cols_Sens[Sens_Pos] + 0.5</l>
<c></c>
<l>* dX := DeltaX[Sens_Pos]</l>
<l>* dY := DeltaY[Sens_Pos]</l>
<c></c>
<l>* Row1 := Row - dY * 20</l>
<l>* Col1 := Col - dX * 20</l>
<l>* Row2 := Row + dY * 20</l>
<l>* Col2 := Col + dX * 20</l>
<c></c>
<c></c>
<l>* set_color(200000, 'green')</l>
<l>* gen_region_line(Line_Sens, Row1, Col1, Row2, Col2)</l>
<l>* disp_obj(Line_Sens, 200000)</l>
<c></c>
<l>* Pos := 0</l>
<l>* for Idx := 0 to 19 by 1</l>
<l>*     tuple_round(Row, Row1)</l>
<l>*     tuple_round(Col, Col1)</l>
<c></c>
<l>*     Rows[Pos] := Row1</l>
<l>*     Cols[Pos] := Col1</l>
<l>*     Pos := Pos + 1</l>
<c>    </c>
<l>*     Row := Row - dY</l>
<l>*     Col := Col - dX</l>
<l>* endfor</l>
<c></c>
<l>* Row := Rows_Sens[Sens_Pos]</l>
<l>* Col := Cols_Sens[Sens_Pos]</l>
<l>* for Idx := 0 to 20 by 1</l>
<l>*     Rows[Pos] := Row</l>
<l>*     Cols[Pos] := Col</l>
<l>*     Pos := Pos + 1</l>
<c>    </c>
<l>*     Row := Row + dY</l>
<l>*     Col := Col + dX</l>
<l>* endfor</l>
<c></c>
<c></c>
<l>* set_color(200000, 'red')</l>
<l>* gen_region_points(Region, Rows, Cols)</l>
<l>* disp_obj(Region, 200000)</l>
<c></c>
<c>*-------------------------------------------</c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>CurrentOper:='Low Gray - Saving objects'</l>
<c></c>
<l>tuple_int(Rows_Sens, Rows_Sens)</l>
<l>tuple_int(Cols_Sens, Cols_Sens)</l>
<l>if (Type == 'S')</l>
<l>    write_tuple(Rows_Sens, path_teach_tuples + 'Rows_Sens_S.tup')</l>
<l>    write_tuple(Cols_Sens, path_teach_tuples + 'Cols_Sens_S.tup')</l>
<l>    write_tuple(DeltaX, path_teach_tuples + 'DeltaX_S.tup')</l>
<l>    write_tuple(DeltaY, path_teach_tuples + 'DeltaY_S.tup')</l>
<l>else</l>
<l>    write_tuple(Rows_Sens, path_teach_tuples + 'Rows_Sens_P.tup')</l>
<l>    write_tuple(Cols_Sens, path_teach_tuples + 'Cols_Sens_P.tup')</l>
<l>    write_tuple(DeltaX, path_teach_tuples + 'DeltaX_P.tup')</l>
<l>    write_tuple(DeltaY, path_teach_tuples + 'DeltaY_P.tup')</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Teach_Slice_Delta">
<parameters>
<parameter id="Cols_Sens"/>
<parameter id="CurrentOper"/>
<parameter id="MaxPRC"/>
<parameter id="Pointer_Pos"/>
<parameter id="Pointer_Sens"/>
<parameter id="Pointer_Skel"/>
<parameter id="Rows_Sens"/>
<parameter id="SensLen"/>
<parameter id="Skel_FWMS"/>
<parameter id="TotalPRC"/>
<parameter id="Type"/>
<parameter id="WidthImageS"/>
<parameter id="Win"/>
<parameter id="path_teach_tuples"/>
</parameters>
</docu>
</procedure>
</hdevelop>
