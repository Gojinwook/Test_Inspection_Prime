///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.3
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;

// Procedure declarations 
void Union_Defects (HObject ho_ROI1, HObject ho_ROI2, HObject *ho_ROI1_Ret, HObject *ho_ROI2_Ret, 
    HTuple hv_Defect_Dist);
// Procedures 
void Union_Defects (HObject ho_ROI1, HObject ho_ROI2, HObject *ho_ROI1_Ret, HObject *ho_ROI2_Ret, 
    HTuple hv_Defect_Dist)
{

  // Local iconic variables
  HObject  ho_ROI1_C, ho_ROI2_C, ho_ROI1_Res, ho_ROI2_Res;
  HObject  ho_ObjSel1, ho_ObjSel2, ho_Skeleton1, ho_RegionDilation1;
  HObject  ho_Skeleton2, ho_RegionDilation2, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_Cnt1, hv_Cnt2, hv_I1, hv_I2, hv_Area;
  HTuple  hv_Row, hv_Col;

  Union1(ho_ROI1, &ho_ROI1);
  Union1(ho_ROI2, &ho_ROI2);

  Connection(ho_ROI1, &ho_ROI1_C);
  Connection(ho_ROI2, &ho_ROI2_C);
  CountObj(ho_ROI1_C, &hv_Cnt1);
  CountObj(ho_ROI2_C, &hv_Cnt2);

  if (0 != (HTuple(hv_Cnt1==0).TupleOr(hv_Cnt2==0)))
  {
    (*ho_ROI1_Ret) = ho_ROI1;
    (*ho_ROI2_Ret) = ho_ROI2;
    return;
  }

  ho_ROI1_Res = ho_ROI1;
  ho_ROI2_Res = ho_ROI2;
  Connection(ho_ROI1_Res, &ho_ROI1_Res);
  Connection(ho_ROI2_Res, &ho_ROI2_Res);

  {
  HTuple end_val19 = hv_Cnt1;
  HTuple step_val19 = 1;
  for (hv_I1=1; hv_I1.Continue(end_val19, step_val19); hv_I1 += step_val19)
  {
    SelectObj(ho_ROI1_C, &ho_ObjSel1, hv_I1);
    //area_center (ObjSel1, Area1, Row1, Col1)

    {
    HTuple end_val23 = hv_Cnt2;
    HTuple step_val23 = 1;
    for (hv_I2=1; hv_I2.Continue(end_val23, step_val23); hv_I2 += step_val23)
    {
      SelectObj(ho_ROI2_C, &ho_ObjSel2, hv_I2);
      //area_center (ObjSel2, Area2, Row2, Col2)

      Skeleton(ho_ObjSel1, &ho_Skeleton1);
      DilationCircle(ho_Skeleton1, &ho_RegionDilation1, hv_Defect_Dist);
      Skeleton(ho_ObjSel2, &ho_Skeleton2);
      DilationCircle(ho_Skeleton2, &ho_RegionDilation2, hv_Defect_Dist);

      Intersection(ho_RegionDilation1, ho_RegionDilation2, &ho_RegionIntersection
          );
      AreaCenter(ho_RegionIntersection, &hv_Area, &hv_Row, &hv_Col);

      if (0 != (hv_Area>0))
      {
        ObjDiff(ho_ROI1_Res, ho_ObjSel1, &ho_ROI1_Res);
        ObjDiff(ho_ROI2_Res, ho_ObjSel2, &ho_ROI2_Res);
        Union2(ho_ROI1_Res, ho_ObjSel1, &ho_ROI1_Res);
      }

      //*         DRow := abs(Row1 - Row2)
      //*         DCol := abs(Col1 - Col2)
      //*         if (DRow < Defect_Dist and DCol < Defect_Dist)
      //union2 (ROI1_Res, ObjSel2, ROI1_Res)
      //obj_diff (ROI1_Res, ObjSel1, ROI1_Res)
      //obj_diff (ROI2_Res, ObjSel2, ROI2_Res)
      //*             gen_circle(Circle, Row1, Col1, Defect_Dist / 2)
      //*             union2(ROI1_Res, Circle, ROI1_Res)
      //*         endif
    }
    }
  }
  }

  (*ho_ROI1_Ret) = ho_ROI1_Res;
  (*ho_ROI2_Ret) = ho_ROI2_Res;
  return;
}


