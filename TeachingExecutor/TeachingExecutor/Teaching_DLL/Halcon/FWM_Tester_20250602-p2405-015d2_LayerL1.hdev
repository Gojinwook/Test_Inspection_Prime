<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.4">
<procedure name="main">
<interface/>
<body>
<l>set_system('empty_region_result', 'exception')</l>
<l>set_system('no_object_result', 'exception')</l>
<c></c>
<c></c>
<c></c>
<c>**********  with Wg measured by same line sensor 2020/06/30</c>
<c>*  PARAMETERS *</c>
<c>* 202290317 fixed very big open problem</c>
<c>*********************************************************</c>
<c>  </c>
<c>*** Comp 17.5, LG 13.5</c>
<l>minWG:=4</l>
<l>minWGS:=3</l>
<l>* wpl:=11.5</l>
<l>wpl:=15.5</l>
<c>****  um/pix</c>
<l>kum := 1.0</l>
<c>**** FWM half width </c>
<l>fwmhw:=12.5</l>
<c>** opening</c>
<l>parop:=2.5</l>
<c></c>
<c>****groung regions ****</c>
<l>* GNDamin := 900000</l>
<l>GNDamin := 410000</l>
<c></c>
<c></c>
<c>**********************************</c>
<c></c>
<c>***** part of FOV selection *****</c>
<c></c>
<c>**** for skeletons *******</c>
<l>gap:=1</l>
<l>jrad:=10</l>
<c>**************  for (Non-FWM) Buiulding MSN array</c>
<l>sm_factor:=7</l>
<l>lookaround:=7</l>
<c>**** for ImageIRB prep.</c>
<l>groundpn:=1 </l>
<c> </c>
<l>groundgval:=3</l>
<c></c>
<c>* useODB:=3 for coils</c>
<l>useODB:=0</l>
<c>*________path to saving data__________________*</c>
<c>*** path for FWM</c>
<c></c>
<l>* path:='E:/250521-semco/p2405-014m1_LayerL2-SHORT3.2-0200/Model/'</l>
<l>* path:='E:/250521-semco/p2405-014m1_LayerL2-SHORT3.2-0200/Model/'</l>
<l>* path:='//192.168.0.244/d/Image/Overkill_25-05-28/Model/p2406-001m1_LayerL2-SHORT3.2-0200/Model/'</l>
<l>*path:='E:/250601-overkill/Model/p2405-015d2_LayerL1-SHORT3.2-0200/Model/'</l>
<l>path:='G:/SAMSUNG/Image/New4/20_teaching_halcorn_error/01_model/p2411-005d101_LayerL2-B-SHORT2.0-0200/Model/'</l>
<c>* p2405-015d2_LayerL1</c>
<l>pathTeach:=path+'Teach/'</l>
<l>* pathTest:=path+'Test/'</l>
<l>* read_image (Gi, path+'Gi.tif')</l>
<c></c>
<c>*** path for Non-FWM</c>
<l>pathN:=path</l>
<c>**** smoothening all CAD contours to make it similar with real pattern</c>
<c>***LG</c>
<l>* smoothCADcontours:=11</l>
<l>smoothCADcontours:=1</l>
<c>***old Compass</c>
<l>* smoothCADcontours:=51</l>
<c>***new Compass</c>
<l>* smoothCADcontours:=41</l>
<l>* read_object (Circlembscc, 'E:/PATTERN/CircleMBScc.hobj')</l>
<l>* write_object(Circlembscc, 'E:/PATTERN/CircleMBScc1.hobj')</l>
<c></c>
<c>***** Parameters ********</c>
<c>*************************</c>
<l>maxdirSP:=40</l>
<c>****  p2311-017t1 1.5um</c>
<l>* wFWM :=[ 23, 30]</l>
<l>* wFWMS:=[25]</l>
<l>* wside:=8</l>
<l>* wsideS:=5</l>
<c>*** not working</c>
<l>wFWM :=[ 70]</l>
<l>wFWMS:=[25]</l>
<l>wside:=6</l>
<l>wsideS:=6</l>
<c></c>
<l>* wside:=8</l>
<l>* wsideS:=5</l>
<c></c>
<c></c>
<c></c>
<l>eradNFWMremove:=9</l>
<l>eradMSe:=9</l>
<c>** elongation lengths for MS</c>
<l>elengthend:=-1</l>
<l>* elengthend:=-1</l>
<l>elengthnoend:=-25</l>
<c>** cutend MSS</c>
<l>cutendMSS:=25</l>
<c>** add to JP rad. for JP neibourhood removal from FWM</c>
<l>jpadd:=3</l>
<c>**</c>
<l>removeGNDfromFWM:=0</l>
<c>*______________________________________________*</c>
<c></c>
<l>* read_image (Gi, path+'ImSpiral1.tif')</l>
<l>read_image (Gi, path+'Gi.tif')</l>
<l>* read_image (Im19, 'C:/TmpIm/Im17_114.tif')</l>
<l>* read_image (Im, path+'Im.tif')</l>
<c></c>
<l>* reduce_domain(Im19, RegionG, ImageReduced)</l>
<l>* threshold(Im19, RegionIRi, 80, 255)</l>
<l>* difference(RegionIRi, RegNoProc, RegionIntersection)</l>
<l>* reduce_domain(Im19, RegionIntersection, ImageReduced)</l>
<l>* union2(RegionG, RegionIR, RegionUnion1)</l>
<c></c>
<l>get_image_size(Gi, WidthG, HeightG)</l>
<l>get_domain(Gi, DomainG)</l>
<l>* read_object(Ri, path+'R.hobj')</l>
<l>threshold(Gi, RegionG, 128, 255)</l>
<c></c>
<l>gen_empty_obj(RegDontCare)</l>
<c></c>
<l>gen_empty_obj(RegSMboundary)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*********************************</c>
<c></c>
<c>**===================== Teaching =====================</c>
<c>***** DK   ****</c>
<c></c>
<l>* read_image(Im, path+'Im.bmp')</l>
<l>* read_image (Im, 'C:/TmpIm/Im14_7.tif')</l>
<l>Im := Gi</l>
<c></c>
<c>******************</c>
<l>* if(useODB==1)</l>
<l>*     read_object(RegionFlash, path+'GiFlash.hobj')</l>
<l>*     read_object(RegionTrace, path+'GiTrace.hobj')</l>
<l>*     read_object(RegionPolygon, path+'GiPolygon.hobj')</l>
<l>* elseif(useODB==2)</l>
<l>*     read_image(GI_Flash, path+'GI_Flash.tif')</l>
<l>*     threshold(GI_Flash, RegionFlash, 128, 255)</l>
<l>*     read_image(GI_Trace, path+'GI_Trace.tif')</l>
<l>*     threshold(GI_Trace, RegionTrace, 128, 255)</l>
<l>*     gen_empty_region(RegionPolygon)</l>
<l>* else</l>
<l>    gen_empty_region(RegionFlash)</l>
<l>    gen_empty_region(RegionTrace)</l>
<l>    gen_empty_region(RegionPolygon)</l>
<l>* endif</l>
<c></c>
<c></c>
<c></c>
<l>count_seconds(t1)</l>
<l>read_object(RegNoProc, path+'RegNoProc.hobj')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*****   TEaching Main   ****</c>
<l>* useODB:=1</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>threshold(Gi, RegionGi, 128, 255)</l>
<c></c>
<c>**************************************</c>
<c>***** Teaching serialization     *****</c>
<c>**************************************</c>
<l>pathfile := path+'TeachPars.ser'</l>
<c>**************************************</c>
<l>* MakeandSavePars1(pathfile, TeachParsOut1)</l>
<c></c>
<c></c>
<l>SetDefault := 1</l>
<c>***** Teaching Parameters setting is inside of LoadPars1() ****</c>
<l>LoadPars1 (pathfile, SetDefault, GNDamin, fwmhw, parop, gap, jrad, groundpn, groundgval, sm_factor, lookaround, wpl, smoothCADcontours, maxdirSP, wFWM, wside, wFWMS, wsideS, eradMSe, eradNFWMremove, elengthend, elengthnoend, jpadd, removeGNDfromFWM, cutendMSS, minWGS, minWG, useODB, autowidth, EPexp, elongLG, minPSklen, lpnum2)</l>
<l>* stop()</l>
<l>* SavePars1 (pathfile, GNDamin, fwmhw, parop, jrad, gap, groundpn, groundgval, sm_factor, lookaround, wpl, smoothCADcontours, maxdirSP, wFWM, wside, wFWMS, wsideS, eradMSe, eradNFWMremove, elengthend, elengthnoend, jpadd, removeGNDfromFWM, cutendMSS, minWGS, minWG, useODB, autowidth, EPexp, elongLG, minPSklen, lpnum2, TeachParsOut)</l>
<l>* stop()</l>
<l>* pathfileInsp := path+'/Teach/TeachPars.ser'</l>
<l>* LoadInspectionPars1 (pathfileInsp, SetDefault, thr, fumax, aislmax, PHrmin, PHamin, Islrmin, Islamin, aphmax, dilS, dilFWM, expsize, dil, EPexp, lMB, prcMB, absMB, minMB, lSP, prcSP, absSP, minSP, sz1, lMBS, sz2, ang, prcMBS, absMBS, minMBS, minWSpace, dclcmax, LG_SensLen, LG_m_szw, LG_m_prcLG, mmat_shift, mmat_fsz, PHash)</l>
<l>* SaveInspectionPars1 (pathfileInsp, thr, fumax, aislmax, PHrmin, PHamin, Islrmin, Islamin, aphmax, dilS, dilFWM, expsize, dil, EPexp, lMB, prcMB, absMB, minMB, lSP, prcSP, absSP, minSP, sz1, lMBS, sz2, ang, prcMBS, absMBS, minMBS, minWSpace, dclcmax, LG_SensLen, LG_m_szw, LG_m_prcLG, mmat_shift, mmat_fsz, PHash)</l>
<c></c>
<c></c>
<l>pathfile:=path+'/Teach/InspectionMainPars.ser'</l>
<c>****** Coil step 1 main pars</c>
<l>autothr:=1</l>
<l>thr:=60</l>
<l>PrcMBS:=20</l>
<l>PrcSPS:=20</l>
<l>minMBS:=4.5</l>
<l>narWSpace:=18.5</l>
<l>szS:=25</l>
<l>PrcMBP:=20</l>
<l>PrcSPP:=20</l>
<l>pabs:=1.49</l>
<l>minwp:=10</l>
<l>narrowwp:=7</l>
<l>widewp:=24.0</l>
<l>szP:=45</l>
<l>LG_m_prsLG_P:=7</l>
<l>LG_m_szw_P:=50</l>
<l>LG_m_Avg_Par:=10</l>
<l>LG_m_prsLG_S:=16</l>
<l>LG_m_szw_S:=8</l>
<c></c>
<l>* SaveInspectionMainPars( pathfile, autothr, \
   thr,  PrcMBS,  PrcSPS, minMBS,  narWSpace, \
   szS,  PrcMBP,  PrcSPP,  pabs,  minwp, \
   narrowwp,  widewp,  szP,  LG_m_prsLG_P,\ 
   LG_m_szw_P,  LG_m_Avg_Par,  LG_m_prsLG_S,  LG_m_szw_S)</l>
<l>stop()</l>
<c></c>
<c></c>
<c>***** Teaching Parameters setting ****</c>
<c>**************************************</c>
<c></c>
<l>autowidth:=1</l>
<l>EPexp:=5</l>
<l>elongLG:=10</l>
<c></c>
<c>* новый параметр, минимальная допустимая длина куска скелетона</c>
<l>minPSklen:=200</l>
<l>lpnum2:=30</l>
<c>***********************************</c>
<l>TeachingMain129 (RegNoProc, Gi, Im, RegionFlash, RegionTrace, RegionG, RegionGS, SkeletonG, SkeletonGS, WidthImageP, DirImageP, WidthImageS, DirImageS, SkeletonsG, ImageIR, RegionsPNi, RegionsPNSi, RegionsNFWM, BoundariesNFWM, SkeletonFWMi, SkeletonsFWMi, SkeletonsFWMcut, SkeletonsFWMS, SkeletonsLG, SkeletonsFWMScut, RegionsGND, RegionsEMPTY, ImDisplacement, SkeletonGd, SkeletonPartsP, EPNFWMremove, SkeletonPartsPnoG, ImageIR16, ImageIRS, RegionMS, RegionsPNPi, RegionsmainSNoCut, SkelEP, RegionCut, GNDamin, path, fwmhw, parop, WidthG, HeightG, jrad, gap, groundpn, groundgval, sm_factor, lookaround, wpl, smoothCADcontours, maxdirSP, wFWM, wside, wFWMS, wsideS, eradMSe, eradNFWMremove, elengthend, elengthnoend, jpadd, removeGNDfromFWM, cutendMSS, minWGS, minWG, useODB, autowidth, EPexp, elongLG, minPSklen, lpnum2, nFWM, nFWMS, nNonFWM, WG, YC, XC, Y1, X1, Y2, X2, Pnum, Pnum2, PnumR, PregC, PcontR, PaddrR, PaddrC, PCinRnum, PuseintP, WGS, YCS, XCS, Y1S, X1S, Y2S, X2S, PnumS, Pnum2S, PnumRS, PregCS, PcontRS, PaddrRS, PaddrCS, PCinRnumS, PuseintS, SequenceIRB, SequenceIRBS, WGN1, YCN, XCN, Y1N, X1N, Y2N, X2N, PnumN, PnumRN, PregCN, PcontRN1, PaddrRN, PaddrCN, PCinRnumN, TotalPRC, CurrentOper)</l>
<l>dev_display(Gi)</l>
<l>dev_set_colored(12)</l>
<l>dev_display(SkeletonsFWMi)</l>
<c></c>
<l>kw:=0.6</l>
<l>dw:=5</l>
<l>SetWpNarrowWide (SkeletonFWMi, WidthImageP, kw, dw, narrowwp, widewp)</l>
<c></c>
<l>stop() </l>
<c></c>
<c></c>
<c>***********************************</c>
<c>*** Teach obj. OUT</c>
<c>***********************************</c>
<l>* pathTeach:=pathTeach+'H/'</l>
<l>WriteTeachData1 (Gi, WidthImageP, DirImageP, WidthImageS, DirImageS, RegionG, RegionGS, SkeletonG, SkeletonGS, RegionsGND, RegionsEMPTY, RegionFWM, RegionsPNSi, RegionsPNPi, SkeletonsFWMi, SkeletonsFWMS, SkeletonsFWMcut, SkeletonsFWMScut, SkeletonsLG, RegNoProc, RegionCut, SkelEP, SkeletonsG, ImageIR, RegionsPNi, ImDisplacement, SkeletonPartsP, ImageIR16, ImageIRS, pathTeach, WidthG, HeightG, WG, XC, YC, X1, Y1, X2, Y2, Pnum, Pnum2, PnumR, PaddrR, PaddrC, PregC, PCinRnum, PcontR, PuseintP, WGS, XCS, YCS, X1S, Y1S, X2S, Y2S, PnumS, Pnum2S, PnumRS, PaddrRS, PaddrCS, PregCS, PCinRnumS, PcontRS)</l>
<l>* read_image (HoImirbs, 'C:/Temp/ho_ImIRBS.hobj')</l>
<c></c>
<l>stop()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* PnumO:=Pnum</l>
<l>* Pnum2O:=Pnum2</l>
<c></c>
<l>RegForbidP:=SkeletonGS</l>
<c>******* INPUT DATA ****</c>
<l>step:=1</l>
<c></c>
<c>***** PARAMETERS ***</c>
<l>knwp:=0.3</l>
<l>knws:=0.3</l>
<l>kLgprsP:=2.5</l>
<l>kLgprsS:=2.5</l>
<l>kabsp:=1.</l>
<c>********</c>
<c>** narwp **</c>
<l>union1(SkeletonsFWMi, SkeletonFWM)</l>
<l>get_region_points(SkeletonFWM, RowsSk, ColumnsSk)</l>
<l>get_grayval(WidthImageP, RowsSk, ColumnsSk, GrayvalWGSk)</l>
<c>***  width dfom the Im could be used if better accuracy is needed ***</c>
<l>tuple_median(GrayvalWGSk, medWG)</l>
<l>narwp:=knwp*medWG</l>
<l>absSP:=kabsp*medWG</l>
<c></c>
<c>** narWSpace **</c>
<l>union1(SkeletonsFWMS, SkeletonFWMS)</l>
<l>get_region_points(SkeletonFWMS, RowsSSk, ColumnsSSk)</l>
<l>get_grayval(WidthImageS, RowsSSk, ColumnsSSk, GrayvalWGSSk)</l>
<l>tuple_median(GrayvalWGSSk, medWGS)</l>
<l>narWSpace:=knws*medWGS</l>
<c></c>
<c></c>
<c></c>
<c>******************</c>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMii, 'area', 'and', 150, 99999)</l>
<l>union1(SkeletonsFWMii, SkeletonsFWM)</l>
<l>set_system('neighborhood', 8)</l>
<l>connection(SkeletonsFWM, SkeletonsFWMii)</l>
<l>* expand_region (SkeletonsFWMii, RegForbidP, RegionsPNPi,  100, 'image')</l>
<l>count_obj(SkeletonsFWMii, nFWMii)</l>
<l>count_obj(RegionsPNPi, nPNPi)</l>
<c></c>
<l>union1(RegionsNFWM, RegionNFWM)</l>
<l>difference(RegionG, RegionNFWM, RegionFWM)</l>
<c></c>
<c></c>
<c>***********************************</c>
<c></c>
<c></c>
<l>stop()</l>
<c>***********************************</c>
<c></c>
<c>*** not removing GND</c>
<l>SkeletonsFWM:=SkeletonsFWMi</l>
<c>******</c>
<l>count_obj(RegionsEMPTY, nEMPTY)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* anglepoint circle radius</c>
<l>epr:=7.5</l>
<c>* max. dir change (if dir. change &lt; significantdirSP, then anglepoint is removed)</c>
<l>significantangleSP:=30</l>
<c></c>
<l>* AnglesFWMcirc2 (SkeletonsFWMi, DirImageP, SkelsAPver, CircsAPver, epr, significantangleSP)</l>
<c></c>
<c></c>
<c></c>
<l>stop()</l>
<c>******************</c>
<c>******************</c>
<c></c>
<c></c>
<c>********************************</c>
<c>*** LOADING DATA (if no teaching is performed)</c>
<c>******************************************</c>
<c>******   Loading FWM  Teaching  Data **************</c>
<c>*****************************************</c>
<c>*** Reading Objects</c>
<l>* pathTeach:='D:/240927/p2406-005t1_LayerL1-SHORT2.1-0200old/Model/Teach/'</l>
<l>* pathTeach:='D:/240909/Model/p2209-030d1_LayerL1-SHORT3.3-0200/Model//Teach/'</l>
<l>read_image (Gi, pathTeach+'Gi.tif')</l>
<c></c>
<l>get_image_size(Gi, WidthG, HeightG)</l>
<l>get_domain(Gi, DomainG)</l>
<l>* read_object(Ri, path+'R.hobj')</l>
<l>threshold(Gi, RegionG, 128, 255)</l>
<l>read_object(RegNoProc, pathTeach+'RegNoProc')</l>
<l>read_object(SkeletonG, pathTeach+'SkeletonG')</l>
<l>read_image (WidthImageP, pathTeach+'WidthImageP.tif')</l>
<l>read_image (DirImageP, pathTeach+'DirImageP.tif')</l>
<l>read_image (WidthImageS, pathTeach+'WidthImageS.tif')</l>
<l>read_image (DirImageS, pathTeach+'DirImageS.tif')</l>
<l>read_object(RegionFWM, pathTeach+'RegionFWM')</l>
<l>read_object(SkeletonGS, pathTeach+'SkeletonGS')</l>
<c></c>
<l>read_object(RegionGS, pathTeach+'RegionGS')</l>
<c></c>
<l>read_object(SkeletonsFWMcut, pathTeach+'SkeletonsFWMcut')</l>
<l>read_object(RegionsPNPi, pathTeach+'RegionsPNPi')</l>
<c></c>
<l>read_object(RegionCut, pathTeach+'RegionCut')</l>
<l>read_object(SkeletonsFWMScut, pathTeach+'SkeletonsFWMScut')</l>
<c></c>
<l>read_object(RegionsEMPTY, pathTeach+'RegionsEMPTY')</l>
<l>read_object(RegionsGND, pathTeach+'RegionsGND')</l>
<c></c>
<l>read_object(SkeletonsFWMi, pathTeach+'SkeletonsFWM')</l>
<l>read_object(SkeletonsFWMS, pathTeach+'SkeletonsFWMS')</l>
<l>read_object(RegNoProc, pathTeach+'RegNoProc')</l>
<c></c>
<l>stop()</l>
<c>*** Reading Tuples</c>
<l>pathT:=pathTeach+'Tuples/'</l>
<l>read_tuple( pathT+'WG.tup',WG)</l>
<l>read_tuple( pathT+'XC.tup', XC)</l>
<l>read_tuple( pathT+'YC.tup', YC)</l>
<l>read_tuple( pathT+'X1.tup', X1)</l>
<l>read_tuple( pathT+'Y1.tup', Y1)</l>
<l>read_tuple( pathT+'X2.tup', X2)</l>
<l>read_tuple( pathT+'Y2.tup', Y2)</l>
<l>read_tuple( pathT+'Pnum.tup', Pnum)</l>
<l>read_tuple( pathT+'Pnum2.tup', Pnum2)</l>
<c></c>
<l>read_tuple( pathT+'PnumR.tup', PnumR)</l>
<l>read_tuple( pathT+'PaddrR.tup', PaddrR)</l>
<l>read_tuple( pathT+'PaddrC.tup', PaddrC)</l>
<l>read_tuple( pathT+'PregC.tup', PregC)</l>
<l>read_tuple(pathT+'PCinRnum.tup', PCinRnum)</l>
<l>read_tuple( pathT+'PcontR.tup', PcontR)</l>
<c></c>
<c>********</c>
<c></c>
<c></c>
<l>read_tuple( pathT+'WGS.tup',WGS)</l>
<l>read_tuple( pathT+'XCS.tup', XCS)</l>
<l>read_tuple( pathT+'YCS.tup', YCS)</l>
<l>read_tuple( pathT+'X1S.tup', X1S)</l>
<l>read_tuple( pathT+'Y1S.tup', Y1S)</l>
<l>read_tuple( pathT+'X2S.tup', X2S)</l>
<l>read_tuple( pathT+'Y2S.tup', Y2S)</l>
<l>read_tuple( pathT+'PnumS.tup', PnumS)</l>
<l>read_tuple( pathT+'Pnum2S.tup', Pnum2S)</l>
<l>read_tuple( pathT+'PnumRS.tup', PnumRS)</l>
<l>read_tuple( pathT+'PaddrRS.tup', PaddrRS)</l>
<l>read_tuple( pathT+'PaddrCS.tup', PaddrCS)</l>
<l>read_tuple( pathT+'PregCS.tup', PregCS)</l>
<l>read_tuple(pathT+'PCinRnumS.tup', PCinRnumS)</l>
<l>read_tuple( pathT+'PcontRS.tup', PcontRS)</l>
<c></c>
<l>stop()</l>
<c>*************</c>
<c></c>
<c>*******************************</c>
<c>******  TESTER!!    ************</c>
<c>*******************************</c>
<l>dev_update_off()</l>
<c></c>
<l>pathIm:='C:/TmpIm/'</l>
<c></c>
<l>* read_image (Rawimage2154, 'C:/Samsung/p2309-011t1-240509/Image/RawImage_2_154.bmp')</l>
<c></c>
<c></c>
<l>read_image(Im, pathIm+'Im17_114.tif')</l>
<l>* read_image(Im, pathIm+'Im3_136.tif')</l>
<c>**** Par. ****</c>
<l>thr:=89</l>
<l>* read_image (Rawimage11, 'E:/250510/Image/PCCB250509-1-1.5-2FIXCEL_11/RawImage_1_1.bmp')</l>
<c></c>
<l>* read_image (Widthimagep, 'E:/250510/Model/p2412-022d101_LayerL1-T-SHORT1.0-0150/Model/Teach/WidthImageP.tif')</l>
<l>* read_object (Skeletonsfwm, 'E:/250510/Model/p2412-022d101_LayerL1-T-SHORT1.0-0150/Model/Teach/SkeletonsFWM.hobj')</l>
<l>* mult_image(Widthimagep, Widthimagep, ImageResult, 0.105, 0)</l>
<l>* get_image_size(ImageResult, Width1, Height1)</l>
<l>* gen_rectangle1(R1, 0, 0, Height1-1, Width1/2-1)</l>
<l>* gen_rectangle1(R2, 0, Width1/2, Height1-1, Width1-1)</l>
<l>* reduce_domain(ImageResult, R1, ImageReduced1)</l>
<l>* crop_domain(ImageReduced1, ImagePart1)</l>
<l>* intersection( R1, Skeletonsfwm,Skeletonsfwm1)</l>
<l>* area_center(Skeletonsfwm1, Area1, Row1i, Column1i)</l>
<l>* reduce_domain(ImageResult, R2, ImageReduced2)</l>
<l>* crop_domain(ImageReduced2, ImagePart2)</l>
<l>* read_object (Regnoproc, 'E:/250510/Model/p2412-022d101_LayerL1-T-SHORT1.0-0150/Model/Teach/RegNoProc.hobj')</l>
<l>* create_ncc_model(ImagePart1,'auto', -0.0, 0.0, 0, 'use_polarity', ModelID1)</l>
<l>* find_ncc_model(Rawimage11, ModelID1,-0.01, 0.01, 0.2, 1, 0.0, 'true', 0, Row1, Column1, Angle1, Score1)</l>
<l>* find_ncc_model(Widthimagep, ModelID1,-0.00, 0.00, 0.2, 1, 0.0, 'true', 0, Row1i, Column1i, Angle1i, Score1i)</l>
<l>* dev_display_ncc_matching_results(ModelID1, 'red', Row1, Column1, Angle1, 0)</l>
<l>* hom_mat2d_identity(HomMat2DIdentity)</l>
<l>* hom_mat2d_translate(HomMat2DIdentity, Row1-Row1i,Column1-Column1i,  HomMat2DTranslate1)</l>
<l>* affine_trans_region(Skeletonsfwm1, RegionAffineTrans1, HomMat2DTranslate1, 'nearest_neighbor')</l>
<c></c>
<l>* create_ncc_model(ImagePart2,'auto', -0.0, 0.0, 'auto', 'use_polarity', ModelID2)</l>
<l>* find_ncc_model(Rawimage11, ModelID2,-0.01, 0.01, 0.2, 1, 0.0, 'true', 0, Row2, Column2, Angle2, Score2)</l>
<l>* dev_display_ncc_matching_results_COPY_1(ModelID2, 'red', Row2, Column2, Angle2, 0)</l>
<c></c>
<c></c>
<c></c>
<c>*TO2</c>
<l>* thr:=140</l>
<l>* thr2:=115</l>
<l>* thr3:=115</l>
<l>* thr4:=115</l>
<l>* thr5:=115</l>
<l>thr2:=140</l>
<l>* thr3:=thr</l>
<l>* thr4:=thr</l>
<l>* thr5:=thr</l>
<c></c>
<l>fumax:=1000</l>
<c>**** Comp</c>
<l>* aislmax:=8000</l>
<c>****LG</c>
<l>aislmax:=8000</l>
<l>PHrmin:=3.0</l>
<l>PHamin:=5</l>
<c></c>
<l>Islrmin:=2</l>
<l>Islamin:=10</l>
<l>aislmax:=300</l>
<l>aphmax:=300</l>
<c></c>
<c></c>
<c>********** Short</c>
<l>dilS:=9.5</l>
<l>* Ops:=2.5</l>
<l>* ClS:=2.5</l>
<l>dilFWM:=10</l>
<c>*************</c>
<l>* nIsl:=0</l>
<l>* d1:=0</l>
<l>get_domain(Im, DomainIm)</l>
<l>set_system('parallelize_operators' , 'false')</l>
<c>*** thresholding and prep.</c>
<l>count_seconds(t1)</l>
<l>set_system('neighborhood', 4)</l>
<l>difference (DomainG, RegNoProc, RC)</l>
<c></c>
<c></c>
<c>**************************************</c>
<c>********** Preprocessing41 *******</c>
<c>************************************</c>
<c>****** Main Image Processing ****</c>
<c>****  condition thr1 &lt; thr2,thr3 &lt; thr4 ****</c>
<c>*** removed small islands and pinholes</c>
<c></c>
<l>R:=RegNoProc</l>
<l>count_seconds(s1)</l>
<l>difference(DomainG, RegNoProc, RegProc)</l>
<c></c>
<c>*********** THRESHOLDING ****************</c>
<l>* ImagePrepThr (Im, RegNoProc, RegProc, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<l>* ImagePrepThr (Im, R, RC, Domain, RegionI2, RegionIi2, thr2, Width, Height)</l>
<l>* ImagePrepThr (Im, R, RC, Domain, RegionI3, RegionIi3, thr3, Width, Height)</l>
<l>* ImagePrepThr (Im, R, RC, Domain, RegionI4, RegionIi4, thr4, Width, Height)</l>
<l>* ImagePrepThr (Im, R, RC, Domain, RegionI5, RegionIi5, thr5, Width, Height)</l>
<c>*************************************</c>
<c>* histo_to_thresh(RelativeHisto,</c>
<l>PHrmin:=3.0</l>
<l>PHamin:=5</l>
<c></c>
<l>Islrmin:=2</l>
<l>Islamin:=10</l>
<l>set_system('neighborhood', 8)</l>
<l>ThresholdPHIsp (Im, RegProc,      RegionPH, RegionIsl, RegionISnoIslnoPh, RegionInoIslnoPh, RegionI,       thr, PHrmin, PHamin, Islrmin, Islamin)</l>
<l>dev_display(Im)</l>
<l>dev_display(RegionISnoIslnoPh)</l>
<l>stop()</l>
<l>* read_object (MHoRegionph, 'C:/Temp1/m_ho_RegionPH.hobj')</l>
<l>* read_object (MHoRegionsisl, 'C:/Temp1/m_ho_RegionsIsl.hobj')</l>
<l>* read_object (MHoRegionisnoislnoph, 'C:/Temp1/m_ho_RegionInoIslnoPh.hobj')</l>
<l>* read_object (HoRegioninod, 'C:/Temp1/ho_RegionInoD.hobj')</l>
<c></c>
<l>* dev_display(RegionInoIslnoPh)</l>
<l>* stop()</l>
<c>**** Pinhole detection function</c>
<c>**** for RegionIi2:</c>
<l>* intersection(RegionIi5, R, RegionIi5)</l>
<l>* difference(RegionIi5, Ri, RegionIi5r)</l>
<c></c>
<l>* gen_empty_region(REmpty)</l>
<l>count_seconds(s1)</l>
<l>* PinholeIsland (RegionIi, R, Domain, SmallPs, SmallSs, RegionISnoIslnoPh, RegionInoIslnoPh, RegionsPH, RegionsIsl, aislmax, aphmax, PHamin, PHrmin, Islamin, Islrmin)</l>
<l>* PinholeIsland2 (RegionIi, R, Domain, RegionG, \
                SmallPs, SmallSs, RegionISnoIslnoPh, RegionInoIslnoPh, RegionsPH, RegionsIsl, \
                aislmax, aphmax, PHamin, PHrmin, Islamin, Islrmin)</l>
<l>* DetectPH3(RegionIi, Im, \
          RegionsPH, RegionIfu, \
          fumax, \
          nPHfu)</l>
<l>* difference(DomainG, RegionI, RegionIS)</l>
<l>* DetectIsl61(RegionIS, SkeletonG, RegionIfu, RegionG, Im, \
            RegionsIsl, RegionI, fumax, aislmax, nIslfu)</l>
<l>count_seconds(s2)</l>
<l>s:=s2-s1</l>
<l>dev_display(Im)</l>
<l>dev_display(RegionInoIslnoPh)</l>
<l>dev_set_color('cyan')</l>
<l>dev_set_line_width(3)</l>
<l>dev_display(RegionPH)</l>
<l>dev_set_color('orange')</l>
<l>dev_display(RegionIsl)</l>
<l>dev_disp_text('Thr/Pinhole/Islandn t='+ (s)$'5.3', 'window', 0, 0, 'black', [], [])</l>
<l>stop()</l>
<c></c>
<c></c>
<c></c>
<c>*//////// removing too small Pinholes from the list///////</c>
<l>* select_shape(RegionInoIslnoPh, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>* select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>* count_obj(RegionsPH, nPH)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<c></c>
<l>* count_obj(RegionsIsl, nIsl)</l>
<c>*///////////////   OPEN/SHORT   //////////////////////*</c>
<l>count_seconds(s1)</l>
<l>MakeSkeletonGnoR (Im, RegionI, R, SkeletonG, SkeletonGnoR)</l>
<c></c>
<c></c>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<c>** ----------------------------------------------------------</c>
<c>*** Удаление кандидатов</c>
<c>* plan (Short)</c>
<c>* 1. Find candidates as SkeletonG outside of RegionInoIslnoPhnoR (Cands)</c>
<c>* 2. Find big shift areas(BSA)</c>
<c>* 3. Inside BSA find SkeletonIBSA and EndPointsIBSA and JuncPointsIBSA</c>
<c>* 4. Find Circles(JuncPointsIBSA)</c>
<c>* 5. Candidates=intersection(Circles, Cands)</c>
<c>*</c>
<c></c>
<l>* union1(RegionsFWM, RegionFWM)</l>
<l>SkeletonsCheckPrep (RegionFWM, RegionInoIslnoPh,       RegionFWMdil, RegSkel, RegSkeld, SkeletonI, EndPointsI, JuncPointsI, SkelPointsI, RegionCheck, dilFWM, s1, dilS)</l>
<c></c>
<c></c>
<l>DetectShortN6 (SkeletonGS, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageS, DirImageS, RegionG, RegionFWMdil, RegionCheck,RegNoProc,        RegionsShi)</l>
<c></c>
<l>count_seconds(s3)</l>
<l>sprep:=s2-s1</l>
<l>ssh:=s3-s2</l>
<l>* stop()</l>
<l>* DetectOpenN6(RegionG, SkeletonGnoR, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageP, DirImageP, RegionFWMdil, RegionCheck,     RegionsOp, RegionsOpCon)</l>
<c></c>
<l>* DetectOpenN5(RegionG, SkeletonGnoR, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageP, DirImageP, RegionFWMdil, RegionCheck,     RegionsOp, RegionsOpCon)</l>
<l>DetectOpenN51(RegionG, SkeletonGnoR, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageP, DirImageP, RegionFWMdil, DomainIm,     RegionsOp, RegionsOpCon)</l>
<c>* tuple_select</c>
<l>* read_object (ho_RegionFWMdil, 'C:/Temp/ho_RegionFWMdil.hobj')</l>
<l>* test_equal_region(ho_RegionFWMdil, RegionFWMdil, IsEqual5)</l>
<l>* read_object (m_ho_RegionInoIslnoPh, 'C:/Temp/m_ho_RegionInoIslnoPh.hobj')</l>
<l>* test_equal_region(m_ho_RegionInoIslnoPh, RegionInoIslnoPh, IsEqual5)</l>
<c></c>
<c></c>
<l>* DetectOpenN3 (SkeletonGnoR, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageP, DirImageP, RegionFWMdil, RegionCheck,RegionsOp, RegionsOpCon, R2)</l>
<l>* DetectOpenN1 (SkeletonGnoR, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageP, DirImageP, RegionsOp1, RegionsOpCon1, R2)</l>
<c></c>
<l>* DetectOpenN1v1 (SkeletonGnoR, RegionInoIslnoPh, RegionISnoIslnoPh, WidthImageP, DirImageP, RegionCheck, RegionsOp1, RegionsOpCon1, R2)</l>
<l>* DetectOpenFU3_COPY_1 (SkeletonG,RegionInoIslnoPh, DirImageP, WidthImageP, RegionsOp, RegonsOpCon, 3.0, 4, d1, nOp)</l>
<c></c>
<l>count_seconds(s4)</l>
<l>sop:=s4-s3</l>
<l>s:=sprep+ssh+sop</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<c></c>
<l>count_obj(RegionsShi, nShi)</l>
<l>union1(RegionsShi, RegionsShu)</l>
<l>connection(RegionsShu, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c></c>
<l>count_obj(RegionsOp, nOp)</l>
<c></c>
<l>dev_display(Im)</l>
<l>dev_set_color('dark orchid')</l>
<l>dev_set_line_width(3)</l>
<l>dev_display(RegionPH)</l>
<l>dev_set_color('orange')</l>
<l>dev_display(RegionIsl)</l>
<l>dev_set_color('red')</l>
<l>dev_display(RegionsSh)</l>
<l>dev_disp_text('Open/Short detection', 'window', 0, 20,  'black', [], [])</l>
<l>dev_disp_text('t='+ (s)$'5.4'+'='+ (sprep)$'5.4'+'+'+ (ssh)$'5.4'+'+'+ (sop)$'5.4', 'window', 20, 20, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>dev_display(RegionsOp)</l>
<c></c>
<l>dev_disp_text('Short'+ (nSh)$'5.0'+', Open'+ (nOp)$'5.0', 'window', 40, 20, 'black', [], [])</l>
<l>stop()</l>
<l>* write_object(RegionsShi, path+'RegionsShi2')</l>
<l>* write_object(RegionsOp, path+'RegionsOp2')</l>
<c>*******stop()</c>
<l>* read_image (OutPolygonLine, 'E:/PATTERN/out_Polygon_Line.png')</l>
<l>* read_object (Reg0005, 'C:/Users/Administrator/Downloads/Telegram Desktop/Reg_0005.hobj')</l>
<c></c>
<c>*****</c>
<l>set_system('neighborhood', 4)</l>
<l>* gen_empty_obj(RegionsShi)</l>
<l>BuildRegionInoD (RegionsShi, SkeletonGS, RegionInoIslnoPh, RegionOpCon, R,      RegionInoD)</l>
<c></c>
<l>* read_object (m_ho_RegionsShi, 'C:/Temp/m_ho_RegionsShi.hobj')</l>
<l>* test_equal_region(m_ho_RegionsShi, RegionsShi, IsEqual)</l>
<l>* read_object (m_ho_SkeletonGS, 'C:/Temp/m_ho_SkeletonGS.hobj')</l>
<l>* test_equal_region(m_ho_SkeletonGS, SkeletonGS, IsEqual7)</l>
<l>* read_object (ho_RegionInoD, 'C:/Temp/ho_RegionInoD.hobj')</l>
<l>* test_equal_region(ho_RegionInoD, RegionInoD, IsEqual8)</l>
<c>***</c>
<l>connection(RegionInoD, RegionsInoDn)</l>
<l>count_seconds(s1)</l>
<l>fill_up_shape(RegionsInoDn, RegionsInoDnp,'area', 1, 30)</l>
<l>select_shape(RegionsInoDnp, RegionsInoD, 'area', 'and', 30, 99999999)</l>
<c></c>
<l>count_seconds(s2)</l>
<l>s:=s2-s1</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>* intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c>*---------------------------------------</c>
<c>********** Preprocessing41 END   *******</c>
<c>*---------------------------------------</c>
<c></c>
<l>count_seconds(t2)</l>
<l>t:=t2-t1</l>
<l>get_image_size(Im,Width, Height)</l>
<l>boundary(RegionsInoD, RegionsInoDBi, 'inner')</l>
<c></c>
<c>**************************************</c>
<c>*******  ImageChainLength+ImageIRB via Contours *****</c>
<c>****************** 2.1-1.4 sec ************</c>
<l>* skeleton(RegionG, SkeletonG2)</l>
<c>****** generate empty IRB and CLC images</c>
<c>*** selecting threshold</c>
<l>RegionInoDC:=RegionInoD</l>
<l>RegionsInoDC:=RegionsInoD</l>
<l>thrc:=thr2</l>
<l>* threshold(Gism, RegionGsm, thrc, 255)</l>
<l>* connection(RegionGsm, RegionsGsm)</l>
<l>* RegionsInoDC:=RegionsGsm</l>
<c></c>
<c>************</c>
<l>gen_image_const(ImageChainLength,'uint2', Width, Height)</l>
<l>write_image(ImageChainLength, 'tiff', 0, pathTeach+'ImCLC.tif')</l>
<l>* gen_image_const(ImageChainLength,'byte', Width, Height)</l>
<l>gen_image_const(ImagePN,'uint2', Width, Height)</l>
<l>erosion_circle(RegionInoDC, RegionInoDe,1)</l>
<l>* opening_circle(RegionInoDC, RegionInoDo,2)</l>
<l>* closing_circle(RegionsInoDC, RegionsInoDc, 1.0)</l>
<l>* union1(RegionsInoDc, RegionInoDc)</l>
<c>****** making 1 inside of RegionInoD</c>
<l>paint_region(RegionInoDe, ImagePN, ImagePN, 1, 'fill')</l>
<l>* boundary(RegionsInoD, RegionsInoDB,'inner')</l>
<l>count_obj(RegionsInoDC, nInoD)</l>
<c>**  same length size = 1,2,4,8,16</c>
<l>* lsz:=1</l>
<l>* lstep:= 1./lsz</l>
<l>count_seconds(t1)</l>
<c>*******</c>
<l>* BuildIRBandCL (RegionsInoDc, ImageChainLength, ImagePN, ImageIR, ImageCLC, ImageIRBo, lstep)</l>
<l>* BuildIRBandCLC3MT (RegionsInoD, ImageChainLength, ImagePN, ImageIR, ImageCLC, ImageIRBo, lstep)</l>
<l>* BuildIRBandCLC3MT (RegionsInoD, ImageChainLength, ImagePN, ImageIR, ImageCLC, ImageIRBo, lstep)</l>
<l>* BuildIRBandCLC4 (RegionsInoDC, ImageChainLength, ImagePN, ImageIR, ImageCLC, ImageIRBo, lstep)</l>
<l>* BuildIRBandCLC41 (RegionsInoDC, ImageChainLength, ImagePN, ImageIR, Im, ImageCLC, ImageIRBo, lstep)</l>
<l>* BuildIRB16andCLC41 (RegionsInoDC, ImageChainLength, ImagePN, ImageIR16, Im,    ImageCLC, ImageIRBo, lstep)</l>
<c></c>
<c></c>
<l>difference(DomainIm, RegionInoDC, RegionInoDSi)</l>
<l>* dilation_circle(RegNoProc, RegNoProcd, 2)</l>
<l>difference(RegionInoDSi, RegNoProc, RegionInoDS)</l>
<l>connection(RegionInoDS, RegionsInoDS)</l>
<c></c>
<c></c>
<l>* par_start&lt;ThreadID1&gt; :BuildIRBandCLC3 (RegionsInoD, ImageChainLength, ImagePN, ImageIR, ImageCLC, ImageIRBo, lstep)</l>
<l>* par_join(ThreadID1)</l>
<l>* stop()</l>
<l>* BuildIRBandCLC3 (RegionsInoD, ImageChainLength, ImagePN, ImageIR, ImageCLC, ImageIRBo, lstep)</l>
<c></c>
<l>count_seconds(t2)</l>
<l>t:=t2-t1</l>
<l>* dev_display(ImageChainLength)</l>
<l>* dev_display(ImageIRBo)</l>
<l>* dev_set_draw('margin')</l>
<l>dev_set_color('dim gray')</l>
<l>* dev_display(RegionsInoDB)</l>
<l>dev_disp_text('t='+ (t)$'5.4', 'window', 0, 0, 'black', [], [])</l>
<l>* difference(RegionsInoDB,RCo,  RegionDifference)</l>
<c></c>
<l>stop()</l>
<c></c>
<c></c>
<l>* read_image (HoImirbp, 'C:/Temp/ho_ImIRBP.hobj')</l>
<l>* read_object (MHoRegionph, 'C:/Temp/m_ho_RegionPH.hobj')</l>
<l>* read_object (MHoRegionsisl, 'C:/Temp/m_ho_RegionsIsl.hobj')</l>
<c></c>
<c></c>
<c>******** ImageIRB and ImageIRBS ************</c>
<l>* expsize:=31.5</l>
<l>* dil:=3</l>
<l>get_image_size(Im,Width, Height)</l>
<l>gen_image_const(ImIRBSi,'uint2', Width, Height)</l>
<c></c>
<l>count_seconds(s1)</l>
<l>count_obj(RegionsEMPTY, nEmpty)</l>
<l>if(nEmpty==0)</l>
<l>    nEmpty:=1</l>
<l>endif</l>
<l>* nEmpty:=0</l>
<c></c>
<l>gen_image_const(ImIRBPi,'uint2', Width, Height)</l>
<l>union1(RegionsInoD, RegionInoD)</l>
<c></c>
<l>* BuildIRBP4(SkeletonsFWM, RegionInoDS, ImIRBPi, ImIRBP, expsize, nEmpty, dil, nFWMSB)</l>
<c></c>
<c></c>
<l>* RegForbidP := SkeletonGS</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c>*** need to move to teaching</c>
<l>dil:=15</l>
<l>expsize:=351</l>
<c>** for big shift</c>
<l>BuildIRBP7B2 (SkeletonsFWMcut, RegionInoD, ImIRBPi, RegionsPNPi, RegionCut, \
            ImIRBP2, \
            expsize, nEmpty, dil, \
            nFWMSB)</l>
<c>** for small shift</c>
<l>* BuildIRBP6B2 (SkeletonsFWMcut, RegionInoD, ImIRBPi, RegionsPNPi, RegionCut, ImIRBP2, expsize, nEmpty, dil, nFWMSB)</l>
<c>**************</c>
<l>* dilation_circle(SkeletonG, SkeletonGd, 1.5)</l>
<l>* BuildIRBP6B2 (SkeletonsFWM, SkeletonGd, ImIRBPi, RegionsPNPi, RegionCut, ImIRBP2, expsize, nEmpty, dil, nFWMSB)</l>
<l>* BuildIRBP5 (SkeletonsFWM, RegionInoDS,RegionInoD, ImIRBPi, RegionsPNPi, ImIRBP2, expsize, nEmpty, dil, nFWMSB)</l>
<c></c>
<l>ImageIRBo:=ImIRBP2</l>
<l>dev_display(ImageIRBo)</l>
<l>dev_set_draw('margin')</l>
<l>* BuildIRBS3 (SkeletonsFWMS, RegionInoD, ImIRBSi, ImIRBS, expsize, nEmpty, dil, nFWMSB1)</l>
<l>* BuildIRBS3_16b (SkeletonsFWMS, RegionInoD, ImIRBSi, ImIRBS, expsize, nEmpty, dil, nFWMSB)</l>
<l>* expsize:=wFWMS[0]</l>
<c></c>
<l>junctions_skeleton(SkeletonGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>get_region_points(SkelEPu, Rows, Columns)</l>
<l>get_grayval(WidthImageS, Rows, Columns, wEPs)</l>
<l>tuple_max(wEPs, wEP)</l>
<l>* EPexp:=5</l>
<c>**** Test for BuildIRBS42B2</c>
<l>* read_object (hoRegionInoD, 'C:/Temp/ho_RegionInoD.hobj')</l>
<l>* read_object (hoSkeletonsFWMScut, 'C:/Temp/m_ho_SkeletonsFWMScut')</l>
<l>* read_object (hoSkeletonsFWMS, 'C:/Temp/m_ho_SkeletonsFWMS')</l>
<l>* read_object (hoImIRBS, 'C:/Temp/ho_ImIRBS')</l>
<l>* get_image_size(hoImIRBS, Width, Height)</l>
<l>* read_object (hoSkelSEP, 'C:/Temp/m_ho_SkelSEP')</l>
<l>* read_object (m_ho_SkeletonGS, 'C:/Temp/m_ho_SkeletonGS')</l>
<c></c>
<l>* read_object (ho_DirImageS, 'C:/Temp/ho_DirImageS')</l>
<l>* read_object (ho_WidthImageS, 'C:/Temp/ho_WidthImageS')</l>
<c></c>
<l>* junctions_skeleton(hoSkeletonsFWMS, SkelSEP, JuncPoints)</l>
<l>* union1(SkelSEP, SkelSEPu)</l>
<l>* union1(hoSkeletonsFWMS,hoSkeletonFWMS)</l>
<c></c>
<l>* count_obj(SkelSEP, nSEP)</l>
<l>* get_region_points(SkelSEPu, RowsSEP, ColumnsSEP)</l>
<l>* get_grayval(ho_DirImageS, RowsSEP, ColumnsSEP, AngS)</l>
<l>* get_grayval(ho_WidthImageS, RowsSEP, ColumnsSEP, WidthS)</l>
<l>* AngS:=[AngS, 17,232]</l>
<l>* RowsSEP:=[RowsSEP, 913,663]</l>
<l>* ColumnsSEP:=[ColumnsSEP, 257,2254]</l>
<l>* WidthS:=[WidthS, 31,31]</l>
<c></c>
<l>* Phi:=(AngS-128.)/255.*3.14-3.14/2.</l>
<l>* AngSt:=(AngS)/255.*3.14</l>
<l>* AngEnd:=(AngS)/255.*3.14+3.14</l>
<l>* tuple_length(AngS, nEPS)</l>
<l>* stopperT:=7</l>
<l>* tuple_gen_const(nEPS,stopperT, LSt)</l>
<l>* gen_rectangle2(R2, RowsSEP, ColumnsSEP, Phi, WidthS/2.+3, LSt)</l>
<l>* gen_circle_sector(CircleSector, RowsSEP, ColumnsSEP, WidthS/2.+3, AngSt, AngEnd)</l>
<l>* intersection(R2, m_ho_SkeletonGS, RegionIntersection)</l>
<l>* junctions_skeleton(RegionIntersection, EndPoints1, JuncPoints1)</l>
<l>* difference(EndPoints1, hoSkeletonFWMS, StCents)</l>
<l>* union1(StCents, StCentsu)</l>
<l>* get_region_points(StCentsu, RowsStC, ColumnsStC)</l>
<l>* gen_rectangle2(RSt, RowsStC, ColumnsStC, Phi, WidthS/2.+3, LSt)</l>
<c></c>
<l>* for j:=0 to nEPS+1 by 1</l>
<l>*     gen_rectangle2(R2, RowsSEP[j], ColumnsSEP[j], Phi[j], WidthS[j]/2.+3, 2)</l>
<l>* endfor</l>
<l>stop()</l>
<l>gen_image_const(ImIRBSi,'uint2', Width, Height)</l>
<l>* BuildIRBS42B3 (hoSkeletonsFWMS, hoRegionInoD, ImIRBSi, ho_DirImageS, ho_WidthImageS, m_ho_SkeletonGS, hoSkeletonsFWMScut, ImIRBS, expsize, nEmpty, dil, stopperT, nFWMSB)</l>
<l>dev_update_off()</l>
<l>dil:=5</l>
<l>expsize:=351</l>
<l>stopperT:=12</l>
<c></c>
<l>* BuildIRBS42B3 (SkeletonsFWMS, RegionInoD, ImIRBSi, DirImageS, WidthImageS, SkeletonGS, SkeletonsFWMScut, \
               ImIRBSi, \
               expsize, nEmpty, dil, stopperT, \
               nFWMSB)</l>
<l>dil:=11</l>
<l>BuildIRBS42B4 (SkeletonsFWMS, RegionInoD, ImIRBSi, DirImageS, WidthImageS, SkeletonGS, SkeletonsFWMScut, \
               ImIRBSi, \
               expsize, nEmpty, dil, stopperT, \
               nFWMSB)</l>
<l>* read_object (Skeletonsfwms, 'D:/250307/model/p2209-020t1_LayerL1-T-SHORT1.0-0200_test/Model/Teach/SkeletonsFWMS.hobj')</l>
<c></c>
<c></c>
<l>* BuildIRBS42B2 (SkeletonsFWMScut, RegionInoD, ImIRBSi, SkelEPu, \
               ImIRBS, \
               expsize, nEmpty, dil, nFWMSB)</l>
<c></c>
<l>dilation_circle(SkelEPu, SkelEP, wEP/2+EPexp)</l>
<l>* dil := 5</l>
<l>* BuildIRBS42B2 (SkeletonsFWMScut, RegionInoD, ImIRBSi, SkelEP, \
               ImIRBS, \
               expsize, nEmpty, dil, \
               nFWMSB)</l>
<c></c>
<c></c>
<c></c>
<c>**************</c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*******   FWM    ********</c>
<l>pathIm:='C:/TmpIm/'</l>
<l>read_image(Im, pathIm+'Im72_18.tif')</l>
<c></c>
<l>read_image (ImageIRB, 'C:/Temp1/ho_ImIRBP.hobj')</l>
<l>read_image (ImageIRBS, 'C:/Temp1/ho_ImIRBS.hobj')</l>
<l>read_object (HoRegioninod, 'C:/Temp1/ho_RegionInoD.hobj')</l>
<l>read_object (MHoRegnoproc, 'C:/Temp1/m_ho_RegNoProc.hobj')</l>
<l>read_object (MHoSkeletonsfwmcut, 'C:/Temp1/m_ho_SkeletonsFWMcut.hobj')</l>
<l>read_object (MHoSkeletonsfwmscut, 'C:/Temp1/m_ho_SkeletonsFWMScut.hobj')</l>
<c></c>
<l>* Im:=Imt</l>
<l>thr:=107</l>
<l>* ImageIRB:=ImIRBP2</l>
<c></c>
<l>* ImageIRBS:=ImIRBSi</l>
<l>* read_object (ImageIRB, 'C:/Temp/ho_ImIRBP.hobj')</l>
<l>* read_object (ImageIRBS, 'C:/Temp/ho_ImIRBS.hobj')</l>
<l>* read_object (RegionInoD, 'C:/Temp/ho_RegionInoD.hobj')</l>
<c></c>
<l>* FixThinSpace (RegionInoD, DomainG, RegionInoDr)</l>
<l>stop()</l>
<c></c>
<l>gen_image_const(ImageChainLength,'uint2', WidthG, HeightG)</l>
<l>dev_update_off()</l>
<l>* ImageIRB:=ImageIRBo</l>
<l>* ImageIRB:=ImIRBP2</l>
<l>sz:=25</l>
<l>SPregs:=[]</l>
<l>MBregs:=[]</l>
<l>prcmb:=50</l>
<l>prcsp:=50</l>
<l>prcsh:=20</l>
<c></c>
<c></c>
<c></c>
<l>nreg:=3</l>
<l>* for nreg:=1 to 10 by 1</l>
<c>    </c>
<c></c>
<l>tuple_length(PaddrC, nAddrC)</l>
<l>count_obj(SkeletonsFWMcut, nFWM)</l>
<l>nGND:=1</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* gIRB := nreg%overf+stseq</l>
<l>* threshold(ImageIRB, RegionIRB, 2, 255)</l>
<l>* for nreg:=1 to nFWM by 1</l>
<l>Wall:=[]</l>
<l>Wallmin:=[]</l>
<l>gen_empty_obj(AllRC)</l>
<l>pat0space1:=0</l>
<l>Prc:=[]</l>
<l>Def:=[]</l>
<l>    select_obj(SkeletonsFWMcut, sk, nreg)</l>
<l>*     pruning(sk, RegionPrune, 1)</l>
<l>    dev_disp_text('Region '+nreg+' from '+nFWM, 'window', 20, 20, 'black', [], [])</l>
<l>    dev_set_color('yellow')</l>
<l>    dev_display(sk)</l>
<l>    nc:=PCinRnum[nreg-1]</l>
<l>    cbeg:= PcontR[nreg-1]</l>
<c>    </c>
<c>    ***** need to find all contours ****</c>
<c>    </c>
<l>    for k:=0 to nc-1 by 1</l>
<l>*         k:=1</l>
<l>*         k:=131</l>
<c>        </c>
<l>        W:=[]</l>
<l>        WG:=[]</l>
<l>        Wd:=[]</l>
<l>        NINT:=[]</l>
<l>        PINTx1:=[]</l>
<l>        PINTy1:=[]</l>
<l>        PINTx2:=[]</l>
<l>        PINTy2:=[]</l>
<l>        gen_empty_obj(Rcont)</l>
<l>        ncont:=cbeg+k</l>
<l>        ab:=PaddrC[ncont-0]</l>
<l>*         if(ab&gt;=433)</l>
<l>*                 stop()</l>
<l>*         endif</l>
<l>        a:=ab</l>
<c>        </c>
<l>*         ab:=3838</l>
<l>        if(ncont+1&lt;nAddrC)</l>
<l>            ae:=PaddrC[ncont+1]-1</l>
<l>        else</l>
<l>            tuple_length(Pnum, nP)</l>
<l>            ae := nP-1</l>
<l>        endif</l>
<c>        </c>
<l>*         ae:=ab+200</l>
<l>        numc:= ae-ab</l>
<l>        pnum:=Pnum[a]</l>
<c>        </c>
<l>*         pnum2:=Pnum2[a]</l>
<l>        stop()</l>
<l>*         if(pnum2&lt;2)</l>
<l>*             pnum2:=2</l>
<l>*         endif</l>
<l>        W:=[]</l>
<l>        Wmin:=[]</l>
<l>        Def:=[]</l>
<l>        Wch:=[]</l>
<l>        Wchmin:=[]</l>
<l>        Prc:=[]</l>
<l>        Prcmin:=[]</l>
<l>        Wfilt:=[]</l>
<l>        Sh:=[]</l>
<l>        tuple_select_range(XC, ab, ae, Xc)</l>
<l>        tuple_select_range(YC, ab, ae, Yc)</l>
<l>        gen_region_points(Pc, Yc, Xc)</l>
<l>        dev_set_color('red')</l>
<l>        dev_display(Pc)</l>
<l>        fwm:=0</l>
<c>        </c>
<l>        for j:=0 to numc-2 by 1</l>
<l>*             if(0+j==360)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>*             ab:=0</l>
<l>*             j:=2989</l>
<l>*             pnum:=Pnum[j]</l>
<c>            **************</c>
<l>*             ab:=1960095</l>
<c>            **********  j *******</c>
<l>            j:=37</l>
<l>            a:=ab+j</l>
<l>*             ab:=3838</l>
<c>            **************</c>
<l>            x1:=X1[ab+j]</l>
<l>            y1:=Y1[ab+j]</l>
<l>            x2:=X2[ab+j]</l>
<l>            y2:=Y2[ab+j]</l>
<l>            xc:=XC[ab+j]</l>
<l>            yc:=YC[ab+j]</l>
<c>            </c>
<l>*              if(xc==6191 and yc==1115)</l>
<l>*                   stop()</l>
<l>*               endif</l>
<c>            </c>
<l>            pnum:=Pnum[ab+j]</l>
<l>            pnum2:=Pnum2[ab+j]</l>
<l>            if(pnum2==pnum)</l>
<l>                pnum2:=Pnum[ab+j-1]</l>
<l>            endif</l>
<l>            tuple_round(x1, ix1)</l>
<l>            tuple_round(y1, iy1)</l>
<l>            tuple_round(x2, ix2)</l>
<l>            tuple_round(y2, iy2)</l>
<l>            tuple_round(xc, ixc)</l>
<l>            tuple_round(yc, iyc)</l>
<l>*             if(xc==6191)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            </c>
<l>            gen_region_points(R1,iy1, ix1)</l>
<l>            gen_region_points(R2,iy2, ix2)</l>
<l>            gen_region_points(RC,iyc, ixc)</l>
<l>            dev_set_color('cyan')</l>
<l>            dev_display(R1)</l>
<l>            dev_display(R2)</l>
<l>             dev_set_color('blue violet')</l>
<l>            dev_display(RC)</l>
<l>            concat_obj(AllRC, RC, AllRC)</l>
<l>            dev_set_color('green')</l>
<l>*             disp_line(200000, iy1, ix1, iy2, ix2)</l>
<l>            gen_region_line(RegionLine, iy1, ix1, iy2, ix2)</l>
<l>*             stop()</l>
<l>            sub:=1</l>
<l>*             pnum:=93</l>
<l>            get_grayval(WidthImageP, iyc, ixc, wg) </l>
<l>            clcmax:=wg*3.5</l>
<c>            * MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>            *MSPtProc34 (Im, ImageIRB, ImageChainLength, ImIRBS, PC1, pnum, ix1, iy1, ix2, iy2, ixc, iyc, sub, thr, clcmax, pat0space1, PIntX, PIntY, w, wmin, sh, normint)</c>
<c>           </c>
<l>*             MSPtProc34 (Im, ImageIRB, ImageChainLength, ImIRBS, PC1, pnum, ix1, iy1, ix2, iy2, ixc, iyc, sub, thr, clcmax, pat0space1, PIntXS, PIntYS, w, wmin, sh, normint, merr)</l>
<c>   ***</c>
<l>*             pnum:=18</l>
<l>*             pnum2:=19</l>
<l>               MSPtProc39B2 (Im, ImageIRB, ImageChainLength, ImageIRBS, \
                          PC, \
                          pnum,pnum2, ix1, iy1, ix2, iy2, ixc, iyc, sub, thr, clcmax, pat0space1, \
                          PIntXS, PIntYS, w, wmin, sh, normint, merr)</l>
<c></c>
<c>***</c>
<l>*             MSPtProc39B2m (Im, ImageIRB, ImageChainLength, ImIRBS, \
                          PC, \
                          pnum,pnum2, ix1, iy1, ix2, iy2, ixc, iyc, sub, thr, clcmax, pat0space1, \
                          PIntXS, PIntYS, w, wmin, sh, normint, merr)</l>
<l>*             MSPtProc39B (Im, ImageIRB, ImageChainLength, ImIRBS, PC, pnum, ix1, iy1, ix2, iy2, ixc, iyc, sub, thr, clcmax, pat0space1, \
                         PIntXS, PIntYS, w, wmin, sh, normint, merr)</l>
<c></c>
<l>*             MSPtProc36 (Im, ImageIRB, ImageCLC, ImIRBS, PC1, pnum, ix1, iy1, ix2, iy2, ixc, iyc, sub, thrc, clcmax, pat0space1, PIntXS, PIntYS, w, wmin, sh, normint, merr)</l>
<c>        </c>
<c>             </c>
<l>            tuple_concat(W,w,W)</l>
<l>            tuple_concat(WG,wg,WG)</l>
<l>            tuple_concat(Wmin,wmin,Wmin)</l>
<l>            tuple_concat(Sh,sh,Sh)</l>
<l>            wd:=wg-w</l>
<l>            tuple_concat(Wd,wd,Wd)</l>
<l>*                 stop()</l>
<l>        endfor</l>
<c>        </c>
<c>        ****** building end cutters for FWM (from intersection points)</c>
<c>        *** for each FWM contour, numc == number of points in the contour</c>
<l>        gen_region_points(PINT1, PINTy1, PINTx1)</l>
<c>      </c>
<c></c>
<l>        tuple_concat(Wall, W, Wall)</l>
<l>        tuple_concat(Wallmin, Wmin, Wallmin)</l>
<c>        *********** Med.filtering &amp; defect finding</c>
<l>        sz:=11</l>
<l>        szmis:=10</l>
<l>        FindMissing(W, szmis, Defmis)</l>
<l>        FilterFloadMedn (W, sz, prcmb, prcsp, Def, Wfilt, Wch, Prc)</l>
<l>        Def:=Def*3</l>
<l>        FilterFloadMedn (Wmin, sz, prcmb, prcsp, Defmin, Wfiltmin, Wchmin, Prcmin)</l>
<l>*         FilterFloatMedSkip (W, sz, prcmb, prcsp, 1, Def, Wfilt, Wch, Prc)</l>
<l>        tuple_median(W, wmed)</l>
<l>*         FilterFloatMed (Wmin, sz, prcmb, prcsp, Def, Wfiltmin, Wchmin, Prcmin)</l>
<l>        FilterFloatMedShift (Sh, 7, prcsh, Wfilt, wmed, Defsh, Wfiltsh, Wchsh, Prcsh)</l>
<l>*         if(w&gt;20)</l>
<l>*             stop()</l>
<c>        </c>
<c>        **********</c>
<l>        create_funct_1d_array(WG, FWG)</l>
<l>        smooth_funct_1d_mean(FWG, 3, 1, FWGsm)</l>
<l>        funct_1d_to_pairs(FWGsm, XValues2, WGsm)</l>
<l>        FilterFloadMedn(WGsm, sz, prcmb, prcsp, DefG, WGfilt, WGch, PrcG)</l>
<l>        tuple_mean(Wfilt, wmean)</l>
<l>        tuple_mean(WGfilt, wgmean)</l>
<l>        dw:=wmean-wgmean</l>
<l>        WGch := WGsm-WGfilt</l>
<l>*         PrcG2 := WGch*100.0/(WGfilt+dw)</l>
<l>        PrcG := WGch*100.0/(WGfilt+0.01)</l>
<l>        RpcReal:=Prc-PrcG</l>
<c>        **********</c>
<l>*         endif</l>
<l>        tuple_max(Def, maxdef)</l>
<l>        tuple_sort_index(W,Indices1)</l>
<l>        if(maxdef &gt; 0)</l>
<c>            **  SP defect</c>
<l>*             Def:=Def*3</l>
<l>            stop()</l>
<l>            tuple_max(Prc,maxPrc)</l>
<l>            tuple_concat(SPregs, nreg, SPregs)</l>
<c>            </c>
<l>        endif</l>
<l>        tuple_min(Def, mindef)</l>
<l>        if(mindef &lt; 0)</l>
<c>            **  MB defect</c>
<l>            stop()</l>
<l>*             tuple_min(Prcmin,minPrc)</l>
<l>*             tuple_concat(MBregs, nreg, MBregs)</l>
<l>        endif</l>
<c>        ***********************************</c>
<l>        union1(Rcont, Rcontu)</l>
<l>        dilation_circle(Rcontu,Rcontd, 3.0)</l>
<c>        </c>
<l>        get_region_points(sk, Rowssk, Columnssk)</l>
<l>*         n:=7543</l>
<l>*         gen_region_points(Region, Rowssk[n], Columnssk[n])</l>
<l>*         connection(Rcontd, ConnectedRegions)</l>
<l>*         stop()</l>
<l>*         Wold:=W</l>
<l>*         tuple_min(Wmin, wmin)</l>
<l>*         if(wmin&lt;2.5)</l>
<l>*             tuple_concat(MBregs, nreg, MBregs)</l>
<l>*         endif</l>
<l>*         tuple_max(W, wmax)</l>
<l>*         if(wmin&gt;10)</l>
<l>*             tuple_concat(SPregs, nreg, SPregs)</l>
<l>*         endif</l>
<c>        *********</c>
<l>*         create_funct_1d_array(W, FW)</l>
<l>*         smooth_funct_1d_mean(FW, 9, 1, FWsm)</l>
<l>*         num_points_funct_1d(FWsm, lF)</l>
<l>*         FilterM4L(FW, 15, 50, 0, 3, 40, DefF2, PrcF2, DLen)</l>
<c>        **********</c>
<c>*         FilterM3(FW, 15, 50, 0, 3, 35, Def, Prc)</c>
<l>*        stop()</l>
<l>*       tuple_max(Def, Max)</l>
<l>*       if(Max&gt;0)</l>
<l>*            tuple_concat(SPregs, nreg, SPregs)</l>
<l>*       endif</l>
<l>*         wait_seconds(1)</l>
<l>      endfor</l>
<l>* endfor</l>
<c></c>
<l> WD:=WG-W</l>
<l> tuple_median(WD, wdmed)</l>
<l>  tuple_median(WG, wgmed)</l>
<l>  prcgr:=wdmed*100./wgmed</l>
<l>  WR:=W/Wmin</l>
<l>  WRG:=WG/Wmin</l>
<l>  stop()</l>
<l>  read_tuple('C:/Temp1/PWidthP_tuple0.tup', PWidthtuple0)</l>
<l>  read_tuple('C:/Temp1/PWidthP_tuple1.tup', PWidthtuple1)</l>
<l>  read_tuple('C:/Temp1/PWidthP_tuple2.tup', PWidthtuple2)</l>
<l>  read_tuple('C:/Temp1/PWidthP_tuple3.tup', PWidthtuple3)</l>
<c>  </c>
<l>  FilterFloadMedn (PWidthtuple1, 91, prcmb, prcsp, Def, Wfilt, Wch, Prc)</l>
<l>*   read_tuple(path+'Teach/Tuples/PWidthS_tuple.tup', PWidthtupleS)</l>
<l>  stop()</l>
<l>*     read_object (Skeletonsfwmcut, 'D:/240614/Model/Teach/SkeletonsFWMcut.hobj')</l>
<c>  </c>
<c> ********</c>
<l> FilterFloadMedn (WG, sz, prcmb, prcsp, DefG, WGfilt, WGch, PrcG)</l>
<l> create_funct_1d_array (WG, FWG)</l>
<l> smooth_funct_1d_mean(FWG, 7, 3, FWGsm)</l>
<l>  funct_1d_to_pairs(FWGsm, XValues, WGsm)</l>
<l>  tuple_mean(WGsm, WGav)</l>
<l>  tuple_length(WGsm, l)</l>
<l>  tuple_gen_const(l, WGav, WGA)</l>
<l>  WGsmC:=WGsm/WGA</l>
<l>  WD:=W/WGsmC</l>
<l>  WS:=W-WGsm</l>
<l>  WS2:=WGA+WS</l>
<c>  </c>
<l>*  create_funct_1d_array (W, FW)</l>
<c> </c>
<l>*  WD:=W/WGsm</l>
<c></c>
<l>*  WD:=WD+6</l>
<l>  FilterFloadMedn (WS2, 30, prcmb, prcsp, DefD, WDfilt, WDch, PrcD)</l>
<l>  FilterFloadMedn (W, 30, prcmb, prcsp, Def, Wfilt, Wch, Prc)</l>
<c> ********</c>
<l> read_tuple('C:/Temp/PWidthP_tuple.tup', PWidthP_tuple)</l>
<l> tuple_length(PWidthP_tuple, n)</l>
<l>    read_object (HoRint1, 'C:/Temp/ho_RInt1.hobj')</l>
<l>    read_object (HoRint2, 'C:/Temp/ho_RInt2.hobj')</l>
<l>    *read_object (Regnoproc, '//192.168.0.244/d/SEMCO_ThinLayer_PI/Model/p2408-007t1_LayerL2-SHORT0.2-0200/Model/RegNoProc.hobj')</l>
<l>    read_image (HoImirbp, 'C:/Temp/ho_ImIRBP.hobj')</l>
<c> </c>
<l>*  tuple_select_range(PWidth_tuple, 0, ae-10, Selected1)</l>
<l>*  tuple_select_range(PWidth_tuple, ab, ae, Selected1)</l>
<c> </c>
<l> tuple_select_range(PWidthP_tuple, 0, n-1, Selected1)</l>
<l> sz:=40</l>
<l> FilterFloadMedn (Selected1, sz, prcmb, prcsp, Def, Wfilt, Wch, Prc)</l>
<c> </c>
<c> </c>
<l>*     read_image (Rawimage72275, 'D:/250217-underkill/pattern/RawImage/RawImage_72_275.bmp')</l>
<l>*     read_object (MHoRegionsmb, 'C:/Temp/m_ho_RegionsMB.hobj')</l>
<l> dev_inspect_ctrl(Selected1)</l>
<l>*  write_tuple(Selected1, 'Selected1.tup')</l>
<c> </c>
<l>    read_image (HoImirbp, 'C:/Temp/ho_ImIRBP.hobj')</l>
<l>*  read_tuple('Wmed.tup',Wmed)</l>
<l>  read_tuple('WmedExt.tup',WmedExt)</l>
<l>*   tuple_select_range(WmedExt, 101, 101+numc, Selected3)</l>
<l>*     tuple_select_range(WmedExt, 0, numc-1, Selected3)</l>
<c>  </c>
<c>  </c>
<c>* Plot code generated by function inspect window</c>
<l>  Tuple:=Selected1</l>
<l>    PlotT (Tuple)</l>
<l>* Plot1 (Wfilt, Wch, W, Wmed, WmedExt)</l>
<l>stop()</l>
<l>PlotWWmed (PWidthP_tuple, Selected1)</l>
<c></c>
<l>stop()</l>
<c>********</c>
<l>read_object (Regmbcc, 'E:/PATTERN/RegMBcc.hobj')</l>
<l>stop()</l>
<c>*********</c>
<c>  </c>
<c></c>
<c>******************</c>
<c></c>
<c>************************FWM Test  *******</c>
<l>* ImageIRB:=ImagePN</l>
<c></c>
<l>* threshold(ImageIRB, RegionIRB, 3, 255)</l>
<l>* threshold(ImageChainLength, RegionCLC, 1, 65535)</l>
<c></c>
<c>****cut FWM a bit more</c>
<l>* set_system('neighborhood', 8)</l>
<l>* union1(SkeletonsFWM,SkeletonFWM)</l>
<l>* junctions_skeleton(SkeletonFWM,EndPointsF, JuncPointsF)</l>
<l>* get_region_points(EndPointsF, RowsEF, ColumnsEF)</l>
<l>* tuple_length(RowsEF, nEF)</l>
<l>* tuple_gen_const(nEF, 5, E20)</l>
<l>* gen_circle(CirclesJ, RowsEF, ColumnsEF, E20)</l>
<l>* union1(CirclesJ,CircleJ)</l>
<l>* difference(SkeletonFWM, CircleJ, SkeletonFWM1)</l>
<l>* connection(SkeletonFWM1, SkeletonsFWM1)</l>
<c>*****</c>
<c></c>
<l>* connection(RIntTupd, ConnectedRegions)</l>
<l>* select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', 100, 9999999)</l>
<l>* union1(SelectedRegions, RIntTupdu)</l>
<l>stop()</l>
<c></c>
<c></c>
<l>pathIm:='C:/TmpIm/'</l>
<l>read_image(Im, pathIm+'Im56_122.tif')</l>
<c></c>
<l>* Im:=Imt</l>
<l>thr:=56</l>
<c></c>
<l>read_object (ImageIRB, 'C:/Temp/ho_ImIRBP.hobj')</l>
<l>read_object (ImageIRBS, 'C:/Temp/ho_ImIRBS.hobj')</l>
<l>read_object (RegionInoD, 'C:/Temp/ho_RegionInoD.hobj')</l>
<l>gen_image_const(ImageChainLength,'uint2', WidthG, HeightG)</l>
<c></c>
<c></c>
<c>*************</c>
<c>**FWMS regions test</c>
<c>************</c>
<c>**narrow space</c>
<l>* ImIRBSo:= ImIRBS</l>
<l>* ImIRBS:= ImageIRBS</l>
<l>nreg:=2</l>
<l>gen_empty_obj(AllRC)</l>
<c></c>
<l>NINT:=[]</l>
<l>PINTx1:=[]</l>
<l>PINTy1:=[]</l>
<l>PINTx2:=[]</l>
<l>PINTy2:=[]</l>
<c>****</c>
<l>sz:=15</l>
<l>prcmb:=50</l>
<l>prcsp:=50</l>
<l>pat0space1:=1</l>
<l>* nreg:=1806</l>
<l>tuple_length(PaddrCS, nAddrCS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>Wall:=[]</l>
<l>Wallmin:=[]</l>
<c></c>
<l>Prc:=[]</l>
<l>Def:=[]</l>
<l>    select_obj(SkeletonsFWMS, sk, nreg)</l>
<l>    dev_disp_text('FWMS part '+nreg+' from '+nFWMS, 'window', 20, 20, 'black', [], [])</l>
<l>    dev_set_color('red')</l>
<l>    dev_display(sk)</l>
<l>    nc:=PCinRnumS[nreg-1]</l>
<l>    cbeg:= PcontRS[nreg-1]</l>
<c>    </c>
<c>    ***** need to find all contours ****</c>
<c>    </c>
<l>    for k:=0 to nc-1 by 1</l>
<l>*         k:=36</l>
<l>*         k:=131</l>
<l>        WS:=[]</l>
<l>        WGS:=[]</l>
<l>        Wd:=[]</l>
<l>        NINT:=[]</l>
<l>        PINTxS1:=[]</l>
<l>        PINTyS1:=[]</l>
<l>        PINTxS2:=[]</l>
<l>        PINTyS2:=[]</l>
<l>        gen_empty_obj(Rcont)</l>
<l>        ncont:=cbeg+k</l>
<l>        ab:=PaddrCS[ncont-0]</l>
<l>*         if(ab&gt;=433)</l>
<l>*                 stop()</l>
<l>*         endif</l>
<l>        a:=ab</l>
<l>        if(ncont+1&lt;nAddrCS)</l>
<l>            ae:=PaddrCS[ncont+1]-1</l>
<l>        else</l>
<l>            tuple_length(PnumS, nP)</l>
<l>            ae := nP-1</l>
<l>        endif</l>
<c>        </c>
<l>*         ae:=ab+200</l>
<l>        numc:= ae-ab</l>
<l>*         pnum:=PnumS[a]-2</l>
<l>        pnum:=PnumS[a]</l>
<l>        pnum2:=Pnum2S[a]</l>
<l>        WS:=[]</l>
<l>        WminS:=[]</l>
<l>        Def:=[]</l>
<l>        Wch:=[]</l>
<l>        Wchmin:=[]</l>
<l>        PrcS:=[]</l>
<l>        Prcmin:=[]</l>
<l>        Wfilt:=[]</l>
<l>        Sh:=[]</l>
<l>        tuple_select_range(XCS, ab, ae, Xc)</l>
<l>        tuple_select_range(YCS, ab, ae, Yc)</l>
<l>        gen_region_points(Pc, Yc, Xc)</l>
<l>        dev_set_color('green')</l>
<l>        dev_display(Pc)</l>
<l>        fwm:=0</l>
<c>        </c>
<l>        for j:=0 to numc-1 by 1</l>
<l>*             if(34168+j==35875)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>*             ab:=0</l>
<c>            *** for debugging at exact position</c>
<l>*             j:=10</l>
<l>            a:=ab+j</l>
<l>            pnum:=PnumS[ab+j]</l>
<l>            pnum2:=Pnum2S[ab+j]</l>
<l>            if(pnum2==pnum)</l>
<l>                pnum2:=PnumS[ab+j-1]</l>
<l>            endif</l>
<c></c>
<l>            x1:=X1S[ab+j]</l>
<l>            y1:=Y1S[ab+j]</l>
<l>            x2:=X2S[ab+j]</l>
<l>            y2:=Y2S[ab+j]</l>
<l>            xc:=XCS[ab+j]</l>
<l>            yc:=YCS[ab+j]</l>
<l>            tuple_round(x1, ix1)</l>
<l>            tuple_round(y1, iy1)</l>
<l>            tuple_round(x2, ix2)</l>
<l>            tuple_round(y2, iy2)</l>
<l>            tuple_round(xc, ixc)</l>
<l>            tuple_round(yc, iyc)</l>
<c>            </c>
<l>            gen_region_points(R1,iy1, ix1)</l>
<l>            gen_region_points(R2,iy2, ix2)</l>
<l>            gen_region_points(RC,iyc, ixc)</l>
<l>            dev_set_color('cyan')</l>
<l>            dev_display(R1)</l>
<l>            dev_display(R2)</l>
<l>            dev_display(RC)</l>
<l>            concat_obj(AllRC, RC, AllRC)</l>
<l>            dev_set_color('green')</l>
<l>*             disp_line(200000, iy1, ix1, iy2, ix2)</l>
<l>            gen_region_line(RegionLine, iy1, ix1, iy2, ix2)</l>
<l>*             stop()</l>
<l>            sub:=1</l>
<l>*             pnum:=93</l>
<l>            get_grayval(WidthImageS, iyc, ixc, wg) </l>
<l>            clcmax:=wg*4.5</l>
<l>*             clcmax:=72</l>
<c>            **** MAXMIN test ****</c>
<l>                SpMeasGray (Im, ix1, iy1, ix2, iy2, ixc, iyc, minPval)</l>
<l>                tuple_concat(WminS,minPval,WminS)</l>
<c>                ***********</c>
<l>            MSSpProc38B2 (Im, ImIRBS, ImageChainLength, ImageIRB, \
                          PCS, \
                          pnum, pnum2, ix1, iy1, ix2, iy2, ixc, iyc, sub, thr, clcmax, pat0space1, \
                          PIntXS, PIntYS, w, wmin, sh, normint, merr)</l>
<c>*             </c>
<l>        tuple_concat(PINTx1,PIntXS[0], PINTx1)</l>
<l>        tuple_concat(PINTy1,PIntYS[0], PINTy1)</l>
<l>        tuple_concat(PINTx2,PIntXS[1], PINTx2)</l>
<l>        tuple_concat(PINTy2,PIntYS[1], PINTy2)</l>
<l>        tuple_concat(NINT, normint, NINT)</l>
<l>        concat_obj(Rcont, PCS, Rcont)</l>
<c></c>
<l>            tuple_concat(WS,w,WS)</l>
<l>            tuple_concat(WGS,wg,WGS)</l>
<c></c>
<l>*             tuple_concat(Sh,sh,Sh)</l>
<l>            wd:=wg-w</l>
<l>            tuple_concat(Wd,wd,Wd)</l>
<l>*                 stop()</l>
<l>        endfor</l>
<c></c>
<c>        *********** Med.filtering &amp; defect finding</c>
<l>        szw:=25</l>
<c>        **** changing median size for short parts</c>
<l>        if(numc&lt;2*sz)</l>
<l>            szw:=numc/2</l>
<l>        endif</l>
<l>        FilterFloadMedn (WS, szw, prcmb, prcsp, Def, Wfilt, Wch, Prc)</l>
<l>       Def:=Def*2</l>
<l>*         FilterFloatMedSkip (W, sz, prcmb, prcsp, 1, Def, Wfilt, Wch, Prc)</l>
<l>        tuple_median(WS, wmed)</l>
<l>*         FilterFloatMed (Wmin, sz, prcmb, prcsp, Def, Wfiltmin, Wchmin, Prcmin)</l>
<l>*         prcsh:=20</l>
<l>*         FilterFloatMedShift (Sh, 7, prcsh, Wfilt, wmed, Defsh, Wfiltsh, Wchsh, Prcsh)</l>
<l>*         if(w&gt;20)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>        tuple_max(Def, maxdef)</l>
<l>*         if(maxdef &gt; 0)</l>
<c>            **  SP defect</c>
<l>*             stop()</l>
<l>*             tuple_max(Prc,maxPrc)</l>
<l>*             tuple_concat(SPregs, nreg, SPregs)</l>
<c>            </c>
<l>*         endif</l>
<l>        tuple_min(Def, mindef)</l>
<l>        if(mindef &lt; 0)</l>
<c>            **  MB defect</c>
<l>            stop()</l>
<l>*             tuple_min(Prcmin,minPrc)</l>
<l>*             tuple_concat(MBregs, nreg, MBregs)</l>
<l>        endif</l>
<c>        ***********************************</c>
<c></c>
<l>      endfor</l>
<l>* endfor</l>
<l> stop()</l>
<l>*  name:='D:/p2312-015d1_2P0_240523/p2312-015d1_2P0_240523/RawImage_11_1125.bmp'</l>
<l>*  nch:=3</l>
<l>*  rch:=-3</l>
<l>*  spl := '/'</l>
<c> </c>
<l>*     UpdateFileName (name, spl, nch, rch, fname)</l>
<c> </c>
<l> stop()</l>
<c> </c>
<l>  read_tuple('C:/Temp/PWidthS_tuple.tup', PWidthS_tuple)</l>
<l> tuple_select_range(PWidthS_tuple, ab, ae-1, Selected3)</l>
<l> FilterFloadMedn (Selected3, 22, prcmb, prcsp, Def3, Wfil3t, Wch3, Prc3)</l>
<c> </c>
<l> read_tuple('C:/Temp/GminS_tuple.tup', PGminS_tuple)</l>
<l> read_tuple('C:/Temp/GminS_tuple.tup', PGminS2_tuple)</l>
<l> read_tuple('C:/Temp/GminS_tuple.tup', PGminS3_tuple)</l>
<c></c>
<c></c>
<c></c>
<c>********************************************</c>
<c>*******  ImageChainLength via Contours *****</c>
<c>****************** 1.1 - 0.7 sec *****************</c>
<l>dev_update_off()</l>
<l>* dilation_circle(RegionExpanded, RegionFWMDil, 30.5)</l>
<l>* intersection(RegionsInoD, RegionFWMDil, RegionsInoDF)</l>
<l>gen_image_const(ImageChainLength,'uint2', Width, Height)</l>
<l>set_system('neighborhood', 4)</l>
<l>boundary(RegionsInoD, RegionsInoDB,'inner')</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>count_seconds(t1)</l>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c></c>
<l>VaddrC := {1}</l>
<l>VaddrC.clear()</l>
<l>addr:=0</l>
<l>VnumC := {1}</l>
<l>VnumC.clear()</l>
<c></c>
<l>VseqC := {1}</l>
<l>VseqC.clear()</l>
<c></c>
<c>* vector insertion index</c>
<l>i:=1</l>
<c>**  same length size = 1,2,4,8,16</c>
<l>lsz:=2</l>
<l>lstep:= 1./lsz</l>
<l>for j:=1 to nInoD by 1</l>
<l>    select_obj(RegionsInoD, RInod, j)</l>
<l>    get_region_contour(RInod, RowsC, ColsC)</l>
<l>*         gen_region_points(PRInoD, RowsC, ColsC)</l>
<c>    </c>
<l>    VectorCY.insert(i,RowsC)</l>
<l>    VectorCX.insert(i,ColsC)</l>
<l>    tuple_length(RowsC, n1)</l>
<c>   </c>
<l>    VnumC.insert(i, n1)</l>
<l>    VaddrC.insert(i, addr)</l>
<l>    addr:= addr+n1</l>
<l>    tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<l>    VseqC.insert(i, Seq)</l>
<l>    i:=i+1</l>
<l>    connect_and_holes(RInod, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInod, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInod, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<l>            VectorCY.insert(i,RowsC)</l>
<l>            VectorCX.insert(i,ColsC)</l>
<l>            tuple_length(RowsC, n2)</l>
<c>           </c>
<l>            VnumC.insert(i, n2)</l>
<l>            VaddrC.insert(i, addr)</l>
<l>            addr:= addr+n2</l>
<l>*             tuple_gen_sequence(0, n/2-0.5, 0.5, Seq)</l>
<l>            tuple_gen_sequence(0, n2*lstep-lstep, lstep, Seq)</l>
<l>            VseqC.insert(i, Seq)</l>
<l>            i:=i+1</l>
<l>*             gen_region_points(PHole, RowsC, ColsC)</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<c>        </c>
<l>    endif</l>
<l>*     concat_obj(AllContours, Contours, AllContours)</l>
<l>endfor</l>
<c></c>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<l>* tuple_round(Cx+0.0, Cxi)</l>
<l>* tuple_round(Cy+0.0, Cyi)</l>
<c></c>
<l>convert_vector_to_tuple(VnumC, CNum)</l>
<l>convert_vector_to_tuple(VaddrC, CAddr)</l>
<l>convert_vector_to_tuple(VseqC, CSeq)</l>
<c></c>
<c></c>
<l>* tuple_equal_elem(Rw, Rwt, Equal)</l>
<c></c>
<l>* gen_region_points(RCo, Cy, Cx)</l>
<l>tuple_length(Cy, n)</l>
<c></c>
<l>* tuple_gen_sequence(1, n/10.+n%10*0.1+0.5, 0.1, Sequence)</l>
<l>* tuple_gen_sequence(1, n, 1, Sequence)</l>
<c></c>
<l>set_grayval(ImageChainLength, Cy, Cx, CSeq)</l>
<l>count_seconds(t2)</l>
<l>t:=t2-t1</l>
<l>dev_display(ImageChainLength)</l>
<l>dev_set_draw('margin')</l>
<l>* dev_set_color('dim gray')</l>
<l>* dev_display(RCo)</l>
<l>dev_disp_text('t='+ (t)$'5.4', 'window', 0, 0, 'black', [], [])</l>
<l>* difference(RegionsInoDB,RCo,  RegionDifference)</l>
<l>set_system('neighborhood', 8)</l>
<l>stop()</l>
<c>*********</c>
<c>*********************************</c>
<c></c>
<c></c>
<c>****************************************************</c>
<c>*** Abs.and Rel. Defect detection based on Deviation Image</c>
<c>***  (with separating contours)       </c>
<c>****************************************************</c>
<c>***    t = 0.xx sec</c>
<l>set_system('parallelize_operators', 'false')</l>
<l>* set_system('parallelize_operators', 'true')</l>
<l>dev_display(Im)</l>
<l>dev_set_line_width(1)</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_color('gray')</l>
<l>dev_display(RegionG)</l>
<l>dev_set_color('dim gray')</l>
<l>dev_display(RegionInoD)</l>
<l>dmin:=-7</l>
<l>dmax:=7</l>
<l>count_seconds(t1)</l>
<l>set_system('neighborhood', 4)</l>
<l>boundary(RegionInoD, RegionInoDB, 'outer')</l>
<l>connection(RegionInoDB, RegionsInoDB)</l>
<l>count_obj(RegionsInoDB, nInoDB)</l>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<l>VaddrC := {1}</l>
<l>VaddrC.clear()</l>
<l>addr:=0</l>
<l>VnumC := {1}</l>
<l>VnumC.clear()</l>
<c></c>
<l>for j:=1 to nInoDB by 1</l>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>    get_region_contour(RInoDB, RowsInoDB, ColsInoDB)</l>
<l>    VectorCY.insert(i,RowsInoDB)</l>
<l>    VectorCX.insert(i,ColsInoDB)</l>
<l>endfor</l>
<l>count_seconds(t2)</l>
<l>t:=t2-t1</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<l>gen_region_points(Regionb, Cy, Cx)</l>
<l>get_grayval(ImDisplacement, Cy, Cx, Displacement1)</l>
<l>* set_grayval(Im, Cy, Cx, Deviation1)</l>
<l>count_seconds(t3)</l>
<l>Displacement:=Displacement1-127</l>
<c>***** Abs. processing ****</c>
<l>tuple_length(Displacement, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Displacement, LPlus, Greater)</l>
<l>tuple_select_mask(Displacement, Greater, Sel)</l>
<l>tuple_select_mask(Cy, Greater, Cys)</l>
<l>tuple_select_mask(Cx, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nMax)</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Displacement, LMin, Less)</l>
<l>tuple_select_mask(Displacement, Less, Sel)</l>
<l>tuple_select_mask(Cy, Less, Cysl)</l>
<l>tuple_select_mask(Cx, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nMin)</l>
<c></c>
<l>area_center(Pss, Area, Row, Col)</l>
<l>rc:=30.5</l>
<l>tuple_gen_const( nMax, rc, Rc)</l>
<l>gen_circle(CirclesMax, Row, Col, Rc)</l>
<l>union1(CirclesMax, RegionUnion)</l>
<l>connection(RegionUnion, CirclesSpur)</l>
<l>count_obj(CirclesSpur, nSpurda)</l>
<c></c>
<l>area_center(Psls, Area, Row, Col)</l>
<l>tuple_gen_const( nMin, rc, Rc)</l>
<l>gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>union1(CirclesMin1, RegionUnion)</l>
<l>connection(RegionUnion, CirclesMB)</l>
<l>* count_obj(CirclesMin, nMBda)</l>
<c></c>
<l>count_seconds(t2)</l>
<l>t:=t2-t1</l>
<l>dev_set_line_width(3)</l>
<l>dev_set_color('medium blue')</l>
<l>dev_display(CirclesMB)</l>
<l>dev_set_color('red')</l>
<l>dev_display(CirclesSpur)</l>
<l>dev_disp_text('t='+ (t)$'5.4', 'window', 0, 0, 'black', [], [])</l>
<l>dev_disp_text('Spurs '+ (nSpurda)$'5.0', 'window', 20, 0, 'red', [], [])</l>
<l>dev_disp_text('MBs '+ (nMBda)$'5.0', 'window', 40, 0, 'blue', [], [])</l>
<l>stop()</l>
<c></c>
<c>****************************************************</c>
<c>*** Abs.and Rel. Defect detection based on Deviation Image</c>
<c>***  (with separating contours, no boundary)   </c>
<c>*** AbsRelDefContours </c>
<c>****************************************************</c>
<c>***    t = 1.8 sec</c>
<l>set_system('parallelize_operators', 'false')</l>
<l>* set_system('parallelize_operators', 'true')</l>
<l>junctions_skeleton(SkeletonFWM, EndPointsF, JuncPointsF)</l>
<l>get_region_points(EndPointsF, RowsFE, ColsFE)</l>
<l>tuple_length(RowsFE, nFE)</l>
<l>connection(EndPointsF, EndPointsFs)</l>
<l>rfe:=15</l>
<l>tuple_gen_const(nFE, rfe, RFE)</l>
<l>gen_circle(CFE, RowsFE, ColsFE, RFE)</l>
<c>******** EndPointProc ********</c>
<l>* boundary(RegionInoD, RegionInoDB, 'inner')</l>
<l>intersection(CFE, RegionInoD,  RegionsEndFWM)</l>
<l>for j:=1 to nFE by 1</l>
<l>    select_obj(RegionsEndFWM, REndFWM, j)</l>
<l>    select_obj(EndPointsFs, EP, j)</l>
<l>    get_region_contour(REndFWM, RowsEndFWM, ColsEndFWM)</l>
<l>    gen_region_points(RCEndFWM, RowsEndFWM, ColsEndFWM)</l>
<l>    get_grayval(ImDisplacement, RowsEndFWM, ColsEndFWM, Dp1)</l>
<l>    Dp:=Dp1-127</l>
<c>    </c>
<l>    distance_pr(EP, RowsEndFWM, ColsEndFWM, DistanceMin, DistanceMax)</l>
<l>*     distance_rp(RowsFE[j-1], ColsFE[j-1], RowsEndFWM, ColsEndFWM, Distance)</l>
<l>    if(j==3698)</l>
<l>        stop()</l>
<l>    endif</l>
<l>endfor</l>
<l>stop()</l>
<c>******** EndPointProc end ***</c>
<c></c>
<c></c>
<c>**************************************</c>
<c>*******  New ImageIRB via Contours *****</c>
<c>****************** 1.7sec ************</c>
<l>skeleton(RegionG, SkeletonG2)</l>
<l>set_system('parallelize_operators', 'false')</l>
<l>gen_image_const(ImagePN,'byte', Width, Height)</l>
<l>* boundary(RegionsInoD, RegionsInoDB,'inner')</l>
<l>* count_obj(RegionsInoD, nInoD)</l>
<c></c>
<c>*******</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<c></c>
<l>count_seconds(t1)</l>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c></c>
<l>VaddrC := {1}</l>
<l>VaddrC.clear()</l>
<l>addr:=0</l>
<l>VnumC := {1}</l>
<l>VnumC.clear()</l>
<c></c>
<l>VpnC := {1}</l>
<l>VpnC.clear()</l>
<c></c>
<c>* vector insertion index</c>
<l>i:=1</l>
<c></c>
<l>for j:=1 to nInoD by 1</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<c>    </c>
<l>*     select_obj(SkeletonsG, RSkG, ig)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>*     Rsel:=RowsSk[nSk/2]</l>
<l>*     Csel:=ColsSk[nSk/2]</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<c></c>
<l>    VectorCY.insert(i,RowsC)</l>
<l>    VectorCX.insert(i,ColsC)</l>
<l>    tuple_length(RowsC, n1)</l>
<c>   </c>
<l>    VnumC.insert(i, n1)</l>
<l>    VaddrC.insert(i, addr)</l>
<l>    addr:= addr+n1</l>
<l>    tuple_gen_const(n1, pn, Pn)</l>
<l>    VpnC.insert(i, Pn)</l>
<l>    i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<l>            VectorCY.insert(i,RowsC)</l>
<l>            VectorCX.insert(i,ColsC)</l>
<l>            tuple_length(RowsC, n2)</l>
<c>           </c>
<l>            VnumC.insert(i, n2)</l>
<l>            VaddrC.insert(i, addr)</l>
<l>            addr:= addr+n2</l>
<l>            tuple_gen_const(n2, pn, Pn)</l>
<l>            VpnC.insert(i, Pn)</l>
<l>            i:=i+1</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>convert_vector_to_tuple(VnumC, CNum)</l>
<l>convert_vector_to_tuple(VaddrC, CAddr)</l>
<l>convert_vector_to_tuple(VpnC, CPN)</l>
<l>* tuple_equal_elem(Rw, Rwt, Equal)</l>
<c></c>
<l>gen_region_points(RCo, Cy, Cx)</l>
<l>tuple_length(Cy, n)</l>
<c></c>
<c></c>
<l>set_grayval(ImagePN, Cy, Cx, CPN)</l>
<c></c>
<l>count_seconds(t2)</l>
<l>t:=t2-t1</l>
<l>dev_display(ImagePN)</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_color('dim gray')</l>
<l>* dev_display(RegionsInoDB)</l>
<l>dev_disp_text('t='+ (t)$'5.4', 'window', 0, 0, 'black', [], [])</l>
<l>* difference(RegionsInoDB,RCo,  RegionDifference)</l>
<l>set_system('neighborhood', 8)</l>
<l>stop()</l>
<c>*********</c>
<c></c>
<c></c>
<c></c>
<c>*================Predicting pseudo defects (preparation part for Teaching===============</c>
<l>dev_update_off()</l>
<c></c>
<c>*** parameters for PD prediction******</c>
<c>*** Origin column</c>
<l>orc:=138</l>
<c>*** Origin row</c>
<l>orr:=58</l>
<c>*** cell size</c>
<l>n:=256</l>
<c>*** number of cells in row</c>
<l>nr:=HeightG/n</l>
<c>*** number of cells in column</c>
<l>nc:=WidthG/n</l>
<c></c>
<c></c>
<c>*** Output:</c>
<c>** nPDCV - number of candidates (vertical shift)</c>
<c>** nPDCH - number of candidates (horizontal shift)</c>
<l>union1(SkeletonFWMi, SkeletonFWM)</l>
<l>PseudoDefectsCandidates (SkeletonFWM, DirImageP, RegPDCV, RegPDCH, nr, nc, orr, n, orc, nPDCV, nPDCH)</l>
<c>*** saving candidate regions for pseudo defects ( V and H)</c>
<l>write_object(RegPDCV, path+'RegPDCV.hobj')</l>
<l>write_object(RegPDCH, path+'RegPDCH.hobj')</l>
<l>stop()</l>
<c></c>
<c>**********</c>
<l>threshold_sub_pix(Im, Border, 180)</l>
<l>select_obj(Border, B1, 1)</l>
<l>get_contour_xld(B1, RowsB, ColsB)</l>
<l>gen_circle(Circle, RowsB[0], ColsB[0], 5.5)</l>
<c></c>
<l>threshold(Im, RegionI, 180, 255)</l>
<l>boundary(RegionI, RegionIB, 'inner')</l>
<l>get_region_contour(RegionI, RowsI, ColumnsI)</l>
<l>gen_circle(Circle, RowsI[0], ColumnsI[0], 2.5)</l>
<l>tuple_length(RowsI, nI)</l>
<c></c>
<l>for j:=0 to nI-1 by 1</l>
<l>    gen_region_points(RIB, RowsI[j], ColumnsI[j])</l>
<l>*     wait_seconds(0.001)</l>
<l>    dev_display(RIB)</l>
<l>endfor</l>
<l>stop()</l>
<l>gen_region_points(RegionIB, RowsI, ColumnsI)</l>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="PatternWidthDirImages">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="AngleImageP" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** Width image for Pattern</c>
<l>distance_transform (RegionG, DistanceImageGi, 'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>* reduce_domain (DistanceImageG, SkeletonG, ImageReduced)</l>
<l>scale_image (DistanceImageGi, WidthImageP4, 2, -1)</l>
<l>mean_image (WidthImageP4, DistanceImageG, 3, 3)</l>
<c></c>
<l>convert_image_type (DistanceImageG, WidthImageP, 'byte')</l>
<l>convol_image(WidthImageP, ImageResult, 'lowpas_3_3', 'mirrored')</l>
<c>* **</c>
<c>* ------- Dir image for Pattern</c>
<l>copy_image (WidthImageP, DirImageP)</l>
<l>gen_contours_skeleton_xld (SkeletonG, SkContoursG, 10, 'filter')</l>
<l>* dev_update_off ()</l>
<l>gen_image_const(AngleImageP, 'real', WidthG, HeightG)</l>
<l>count_obj (SkContoursG, nSkCG)</l>
<l>for k := 1 to nSkCG by 1</l>
<l>*     if(k==1452)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 9</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c></c>
<l>    set_grayval (AngleImageP, RowG[0], ColG[0], AnglesG[0]-3.14159)</l>
<l>    set_grayval (AngleImageP, RowG[1], ColG[1], AnglesG[1]-3.14159)</l>
<l>    set_grayval (AngleImageP, RowG[2], ColG[2], AnglesG[2]-3.14159)</l>
<l>    set_grayval (AngleImageP, RowG[nA-1], ColG[nA-1], AnglesG[nA-1])</l>
<l>    set_grayval (AngleImageP, RowG[nA-2], ColG[nA-2], AnglesG[nA-2])</l>
<l>    set_grayval (AngleImageP, RowG[nA-3], ColG[nA-3], AnglesG[nA-3])</l>
<c>*     </c>
<c>    </c>
<l>    tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>    tuple_fmod (AnglesG1, rad(180), AnglesG2)</l>
<l>    tuple_mult (AnglesG2, 256.0/rad(180), AnglesG3)</l>
<l>    set_grayval (DirImageP, RowG, ColG, AnglesG3)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PatternWidthDirImages">
<parameters>
<parameter id="AngleImageP"/>
<parameter id="DirImageP"/>
<parameter id="HeightG"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="SpaceWidthDirImages">
<interface>
<io>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** Width image for Pattern</c>
<l>distance_transform (RegionGS, DistanceImageGSi, 'euclidean', 'true', WidthG, HeightG)</l>
<l>mean_image (DistanceImageGSi, DistanceImageGS, 3, 3)</l>
<l>* reduce_domain (DistanceImageG, SkeletonGS, ImageReduced)</l>
<l>scale_image (DistanceImageGS, WidthImageP4, 2, -1)</l>
<l>convert_image_type (WidthImageP4, WidthImageS, 'byte')</l>
<c>* **</c>
<c>* ------- Dir image for Pattern</c>
<l>copy_image (WidthImageS, DirImageS)</l>
<l>gen_contours_skeleton_xld (SkeletonGS, SkContoursGS, 10, 'filter')</l>
<l>* dev_update_off ()</l>
<c></c>
<l>count_obj (SkContoursGS, nSkCGS)</l>
<l>for k := 1 to nSkCGS by 1</l>
<l>    select_obj (SkContoursGS, SelectedContourGS, k)</l>
<l>    contour_point_num_xld (SelectedContourGS, np)</l>
<l>    get_contour_xld (SelectedContourGS, RowGS, ColGS)</l>
<l>    gen_region_points (RegionSCG, RowGS, ColGS)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourGS, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>    tuple_fmod (AnglesG1, rad(180), AnglesG2)</l>
<l>    tuple_mult (AnglesG2, 256.0/rad(180), AnglesG3)</l>
<l>set_grayval (DirImageS, RowGS, ColGS, AnglesG3)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="SpaceWidthDirImages">
<parameters>
<parameter id="DirImageS"/>
<parameter id="HeightG"/>
<parameter id="RegionGS"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="GetSkeletonBranches">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEPG, ColsEPG)</l>
<l>get_region_points(JuncPointsG, RowsJPG, ColsJPG)</l>
<l>tuple_length(RowsJPG, nJP)</l>
<l>tuple_gen_const(nJP, jrad, JP)</l>
<l>get_grayval(WidthImageP, RowsEPG, ColsEPG, WEPG)</l>
<l>get_grayval(WidthImageP, RowsJPG, ColsJPG, WJPG)</l>
<l>gen_circle(CircleEPG, RowsEPG, ColsEPG, WEPG/2+gap)</l>
<l>difference(SkeletonG, CircleEPG, SkeletonGep)</l>
<l>gen_circle(CircleJPG, RowsJPG, ColsJPG, WJPG/2+jrad)</l>
<l>difference(SkeletonGep, CircleJPG, SkeletonGejp)</l>
<l>connection(SkeletonGejp, SkeletonsGbr)</l>
<l>return ()</l>
</body>
<docu id="GetSkeletonBranches">
<parameters>
<parameter id="SkeletonG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WidthImageP"/>
<parameter id="gap"/>
<parameter id="jrad"/>
</parameters>
</docu>
</procedure>
<procedure name="FindSkeletonsFWM">
<interface>
<io>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="maxdif" base_type="ctrl" dimension="0"/>
<par name="len" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>count_obj(SkeletonsGbr, nSkbr)</l>
<l>gen_empty_region(SkeletonsFWM)</l>
<l>for j:=1 to nSkbr by 1</l>
<l>    select_obj(SkeletonsGbr, SkSel, j)</l>
<l>    gen_contours_skeleton_xld(SkSel, SkContour, 1, 'filter')</l>
<l>    dev_set_color('yellow')</l>
<l>    dev_display(SkSel)</l>
<l>    get_contour_xld(SkContour, RowsSk, ColsSk)</l>
<l>    get_grayval(WidthImageP, RowsSk, ColsSk, WSk)</l>
<l>    tuple_length(WSk, l)</l>
<c>    </c>
<l>    vc:=WSk[0]</l>
<l>    IndC:=[]</l>
<l>    IC:=[]</l>
<l>    lc:=0</l>
<l>    new:=1</l>
<l>    for jj:=1 to l-1 by 1</l>
<l>        v:=WSk[jj]</l>
<l>        if(abs(v-vc)&lt;=maxdif and v&lt;255)</l>
<l>            lc:=lc+1</l>
<l>            if(lc&gt;len)</l>
<l>                if(new==1)</l>
<l>                    tuple_concat(IndC,IC, IndC)</l>
<l>                    new:=0</l>
<l>                endif  </l>
<l>                tuple_concat(IndC,jj, IndC)</l>
<l>            else</l>
<l>                tuple_concat(IC,jj, IC)</l>
<l>            endif</l>
<l>        else</l>
<l>            vc:=v</l>
<l>            lc:=0</l>
<l>            new:=1</l>
<l>            IC:=[]</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_select(RowsSk, IndC, RowsF)</l>
<l>    tuple_select(ColsSk, IndC, ColsF)</l>
<l>    gen_region_points(RF, RowsF, ColsF)</l>
<l>    dev_set_color('red')</l>
<l>    dev_display(RF)</l>
<l>    concat_obj(SkeletonsFWM,RF,SkeletonsFWM)</l>
<l>*     stop()</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FindSkeletonsFWM">
<parameters>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WidthImageP"/>
<parameter id="len"/>
<parameter id="maxdif"/>
</parameters>
</docu>
</procedure>
<procedure name="FormBoundaryLines">
<interface>
<oo>
<par name="LinesVert" base_type="iconic" dimension="0"/>
<par name="LinesHor" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="nr" base_type="ctrl" dimension="0"/>
<par name="nc" base_type="ctrl" dimension="0"/>
<par name="orr" base_type="ctrl" dimension="0"/>
<par name="orc" base_type="ctrl" dimension="0"/>
<par name="n" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_empty_obj(LinesVert)</l>
<l>for k:=0 to nr-1 by 1</l>
<l>    for j:=0 to nc-1 by 1</l>
<l>        gen_rectangle1(Rect, orr+k*n,orc+j*n,orr+(k+1)*(n),orc+(j)*(n))</l>
<l>        concat_obj(LinesVert, Rect, LinesVert)</l>
<l>    endfor</l>
<l>    dev_display(LinesVert)</l>
<l>endfor</l>
<c></c>
<l>gen_empty_obj(LinesHor)</l>
<l>for k:=0 to nr-1 by 1</l>
<l>    for j:=0 to nc-1 by 1</l>
<l>        gen_rectangle1(Rect, orr+k*n,orc+j*n,orr+(k)*(n),orc+(j+1)*(n))</l>
<l>        concat_obj(LinesHor, Rect, LinesHor)</l>
<l>    endfor</l>
<l>    dev_display(LinesHor)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FormBoundaryLines">
<parameters>
<parameter id="LinesHor"/>
<parameter id="LinesVert"/>
<parameter id="n"/>
<parameter id="nc"/>
<parameter id="nr"/>
<parameter id="orc"/>
<parameter id="orr"/>
</parameters>
</docu>
</procedure>
<procedure name="FormPDCVert">
<interface>
<io>
<par name="LinesVert" base_type="iconic" dimension="0"/>
<par name="SkeletonGThin" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegPDCV" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="nSq" base_type="ctrl" dimension="0"/>
<par name="agtol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AngPDCV" base_type="ctrl" dimension="0"/>
<par name="AddrPDCV" base_type="ctrl" dimension="0"/>
<par name="NumPDCV" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>intersection(LinesVert, SkeletonGThin, SkThinLVs)</l>
<c>* square num for vertical PD candidates (for testing)</c>
<l>NPDCV:=[]</l>
<c>* angle for vertical PD candidates</c>
<l>gen_empty_obj(RegPDCV)</l>
<l>AngPDCV:=[]</l>
<c>* address for vertical PD candidates (nSq)</c>
<l>AddrPDCV:=[]</l>
<c>* number per address for vertical PD candidates (nSq)</c>
<l>NumPDCV:=[]</l>
<l>jc:=0</l>
<l>rp:=-1</l>
<l>cp:=-1</l>
<l>for j:=0 to nSq-1 by 1</l>
<l>   select_obj(SkThinLVs, vobj, j+1)</l>
<l>*    select_obj(LinesVert, line, j+1)</l>
<l>   area_center(vobj, a, r, c)</l>
<l>   connection(vobj, vobjs)</l>
<l>   count_obj(vobjs, no)</l>
<l>*    if(j==1352)</l>
<l>*        stop()</l>
<l>*    endif</l>
<l>   nump:=0</l>
<l>   for jj:= 1 to no by 1</l>
<l>       select_obj(vobjs, obj, jj)</l>
<l>       area_center(obj, a, r, c)</l>
<l>       gen_region_points(R, r, c)</l>
<c>       * removing duplicate points</c>
<l>       get_region_points(R, r1, c1)</l>
<l>       if(rp==r1 and cp==c1)</l>
<l>           continue</l>
<l>       endif</l>
<l>       rp:=r</l>
<l>       cp:=c</l>
<l>       get_grayval(DirImageP, r, c, d)</l>
<l>       if(d&lt;128)</l>
<l>           ang := d*3.1415926/256.0 + 3.1415926/2.</l>
<l>       else</l>
<l>           ang := (d-128)*3.1415926/256.0</l>
<l>       endif</l>
<l>       angg:=ang*180./3.1415926</l>
<l>       if( ( abs(angg-90) &lt;agtol) or (angg  &lt; agtol) or (angg &gt; 180- agtol))</l>
<l>           continue</l>
<l>       endif</l>
<l>*        if( ( d &lt; atol) or (d  &gt; 255-atol) or (abs(d-128) &lt; atol))</l>
<l>*            continue</l>
<l>*        endif</l>
<l>       concat_obj(RegPDCV, R, RegPDCV)</l>
<l>       tuple_concat(NPDCV, j, NPDCV)</l>
<l>       tuple_concat(AngPDCV, ang, AngPDCV)</l>
<l>       nump:=nump+1</l>
<l>       jc := jc+1</l>
<l>   endfor</l>
<l>   tuple_concat(NumPDCV, nump, NumPDCV)</l>
<l>   if(nump&gt;0)</l>
<l>       tuple_concat(AddrPDCV, jc-nump+0, AddrPDCV)</l>
<l>   else</l>
<l>       tuple_concat(AddrPDCV, -1, AddrPDCV)</l>
<l>   endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FormPDCVert">
<parameters>
<parameter id="AddrPDCV"/>
<parameter id="AngPDCV"/>
<parameter id="DirImageP"/>
<parameter id="LinesVert"/>
<parameter id="NumPDCV"/>
<parameter id="RegPDCV"/>
<parameter id="SkeletonGThin"/>
<parameter id="agtol"/>
<parameter id="nSq"/>
</parameters>
</docu>
</procedure>
<procedure name="FormPDCHor">
<interface>
<io>
<par name="LinesHor" base_type="iconic" dimension="0"/>
<par name="SkeletonGThin" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegPDCH" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="nSq" base_type="ctrl" dimension="0"/>
<par name="agtol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AngPDCH" base_type="ctrl" dimension="0"/>
<par name="AddrPDCH" base_type="ctrl" dimension="0"/>
<par name="NumPDCH" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>intersection(LinesHor, SkeletonGThin, SkThinLHs)</l>
<l>* union1(SkThinLHs, SkThinLH)</l>
<l>* count_obj(SkThinLHs, n)</l>
<c>* horizontal PD candidates</c>
<l>gen_empty_obj(RegPDCH)</l>
<c>* square num for vertical PD candidates</c>
<l>NPDCH:=[]</l>
<c>* angle for vertical PD candidates</c>
<l>AngPDCH:=[]</l>
<c>* address for vertical PD candidates (nSq)</c>
<l>AddrPDCH:=[]</l>
<c>* number per address for vertical PD candidates (nSq)</c>
<l>NumPDCH:=[]</l>
<l>jc:=0</l>
<l>rp:=-1</l>
<l>cp:=-1</l>
<l>for j:=0 to nSq-1 by 1</l>
<l>   select_obj(SkThinLHs, vobj, j+1)</l>
<l>   select_obj(LinesHor, line, j+1)</l>
<l>   area_center(vobj, a, r, c)</l>
<l>   connection(vobj, vobjs)</l>
<l>   count_obj(vobjs, no)</l>
<l>*    if(j==2401)</l>
<l>*        stop()</l>
<l>*    endif</l>
<l>   nump:=0</l>
<l>   for jj:= 1 to no by 1</l>
<l>       select_obj(vobjs, obj, jj)</l>
<l>       area_center(obj, a, r, c)</l>
<c>      </c>
<l>       gen_region_points(R, r, c)</l>
<c>       * removing duplicate points</c>
<l>       get_region_points(R, r1, c1)</l>
<l>       if(rp==r1 and cp==c1)</l>
<l>           continue</l>
<l>       endif</l>
<l>       rp:=r</l>
<l>       cp:=c</l>
<l>       get_grayval(DirImageP, r, c, d)</l>
<l>*        d:=247</l>
<l>       if(d&lt;128)</l>
<l>           ang := d*3.1415926/256.0 + 3.1415926/2.</l>
<l>       else</l>
<l>           ang := (d-128)*3.1415926/256.0</l>
<l>*            angg:=ang*180./3.1415926</l>
<l>       endif</l>
<l>       angg:=ang*180./3.1415926</l>
<l>       if( ( abs(angg-90) &lt;agtol) or (angg  &lt; agtol) or (angg &gt; 180- agtol))</l>
<l>           continue</l>
<l>       endif</l>
<l>*        if( ( d &lt; atol) or (d  &gt; 255-atol) or (abs(d-128) &lt; atol))</l>
<l>*            continue</l>
<l>*        endif</l>
<l>       concat_obj(RegPDCH, R, RegPDCH)</l>
<l>       tuple_concat(NPDCH, j, NPDCH)</l>
<l>       tuple_concat(AngPDCH, ang, AngPDCH)</l>
<l>       nump:=nump+1</l>
<l>       jc := jc+1</l>
<l>   endfor</l>
<l>   tuple_concat(NumPDCH, nump, NumPDCH)</l>
<l>   if(nump&gt;0)</l>
<l>       tuple_concat(AddrPDCH, jc-nump, AddrPDCH)</l>
<l>   else</l>
<l>       tuple_concat(AddrPDCH, -1, AddrPDCH)</l>
<l>   endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FormPDCHor">
<parameters>
<parameter id="AddrPDCH"/>
<parameter id="AngPDCH"/>
<parameter id="DirImageP"/>
<parameter id="LinesHor"/>
<parameter id="NumPDCH"/>
<parameter id="RegPDCH"/>
<parameter id="SkeletonGThin"/>
<parameter id="agtol"/>
<parameter id="nSq"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildFWM4">
<interface>
<io>
<par name="SkeletonsGThin" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="notusedint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>RowSkTh := []</l>
<l>ColSkTh := []</l>
<c>* * pnum corresponding to current MS</c>
<l>Pnum := []</l>
<c>* * pnum corresponding to region</c>
<l>PnumR := []</l>
<c>* * start address of a contour</c>
<l>PaddrC := []</l>
<c>* * start address for region</c>
<l>PaddrR := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregC := []</l>
<c>* * number of countours per region</c>
<l>PCinRnum := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontR := []</l>
<c>* * saving intersect. points for current MS ==1, not saving ==0</c>
<l>Puseint := []</l>
<l>paddrC := 0</l>
<l>paddrR := 0</l>
<l>pcont := 0</l>
<l>tuple_gen_const (notusedint, 0, Notused)</l>
<l>tuple_gen_sequence (0, notusedint-1, 1, Beg)</l>
<c></c>
<l>count_obj (SkeletonsGThin, nSGThin)</l>
<l>for j := 1 to nSGThin by 1</l>
<l>*     if (j==36)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c></c>
<l>    select_obj (SkeletonsGThin, ObjectSelected1, j)</l>
<l>    area_center (ObjectSelected1, a, r, c)</l>
<c>    * *** empty regions (no skeleton FWM inside of RegiondPNi[j]</c>
<l>    pnumr := -1</l>
<l>*     RowSkTh := 0</l>
<l>*     ColSkTh := 0</l>
<l>    npreg := 0</l>
<l>    if (a&gt;0)</l>
<c>        * *** non-empty regions</c>
<l>        get_region_points (ObjectSelected1, R, C)</l>
<l>        tuple_length (R, nsp)</l>
<c></c>
<l>        get_grayval (ImageIR, R, C, Val)</l>
<l>        tuple_median (Val, pnumr)</l>
<c></c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld (ObjectSelected1, Contours, 1, 'filter')</l>
<l>        count_obj (Contours, nC)</l>
<l>        tuple_concat (PCinRnum, nC, PCinRnum)</l>
<c></c>
<l>        tuple_concat (PcontR, pcont, PcontR)</l>
<l>        pcont := pcont+nC</l>
<c></c>
<l>        for jj := 1 to nC by 1</l>
<l>            select_obj (Contours, Contour, jj)</l>
<l>            get_contour_xld (Contour, R, C)</l>
<c>            </c>
<l>*             get_grayval (ImageIR, R, C, Val)</l>
<l>*             tuple_median (Val, pnum)</l>
<l>            tuple_length (R, pN)</l>
<c>            </c>
<l>             tuple_gen_const(pN, 1, Pui)</l>
<l>            if(pN &gt;=notusedint*2)</l>
<l>                tuple_gen_sequence (pN-notusedint, pN-1, 1, End)</l>
<l>                tuple_replace(Pui, Beg, Notused, Pui)</l>
<l>                tuple_replace(Pui, End, Notused, Pui)</l>
<l>            endif</l>
<c>            </c>
<c>            **** can't skip any contour, numberings don't match!!!</c>
<l>*             if(pN &lt; 100)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>            tuple_concat (PaddrC, paddrC, PaddrC)</l>
<l>*             pcont := pcont+1</l>
<l>            paddrC := paddrC + pN</l>
<l>            tuple_concat (PregC, j, PregC)</l>
<l>*             if (pN&gt;100)</l>
<l>                tuple_concat (RowSkTh, R, RowSkTh)</l>
<l>                tuple_concat (ColSkTh, C, ColSkTh)</l>
<l>            get_grayval(DirImageP, R, C, Dirs)</l>
<l>            Dirsi:=Dirs</l>
<l>            tuple_length(Dirs, nD)</l>
<l>            for jjj:=0 to nD-2 by 1</l>
<l>*                 if(jjj==641)</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<l>                d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>                if(d &gt; 128)</l>
<l>                    d:= d-255</l>
<l>                elseif(d &lt; -128)</l>
<l>                    d:= d+255</l>
<l>                endif</l>
<l>                Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>            endfor</l>
<l>*             endif</l>
<l>            npreg := npreg+pN</l>
<l>            create_funct_1d_array(Dirs, FDirs)</l>
<l>            create_funct_1d_array(Dirsi, FDirsi)</l>
<l>            derivate_funct_1d(FDirs, 'first', Derivative)</l>
<l>            y_range_funct_1d(Derivative, YMin, YMax)</l>
<l>            if(YMin &lt; -20 or YMax &gt; 20)</l>
<l>*                 stop()</l>
<l>            endif</l>
<l>            dev_display(Contour)</l>
<l>            tuple_concat (Puseint, Pui, Puseint)</l>
<l>        endfor</l>
<l>    else</l>
<l>        tuple_concat (PCinRnum, 0, PCinRnum)</l>
<l>        tuple_concat (PcontR, -1, PcontR)</l>
<l>*         tuple_concat (PaddrC, -1, PaddrC)</l>
<l>    endif</l>
<l>    tuple_gen_const (npreg, pnumr, Pn)</l>
<l>    tuple_concat (Pnum, Pn, Pnum)</l>
<l>    tuple_concat (PnumR, pnumr, PnumR)</l>
<l>    tuple_concat (PaddrR, paddrR, PaddrR)</l>
<l>*     tuple_concat (Puseint, Pui, Puseint)</l>
<l>    paddrR := paddrR + npreg</l>
<l>endfor</l>
<c>* ** test ***</c>
<l>* sj := 1100</l>
<l>* pnum := PnumR[sj-1]</l>
<l>* a := PaddrR[sj-1]</l>
<l>* pnum1 := Pnum[a]</l>
<c>* **************</c>
<l>get_grayval (WidthImageP, RowSkTh, ColSkTh, WG)</l>
<l>get_grayval (DirImageP, RowSkTh, ColSkTh, Dir)</l>
<l>Ang := Dir*1.0*3.1415926/256.0</l>
<l>Y1 := RowSkTh-sin(Ang)*(WG/2+wpl)</l>
<l>X1 := ColSkTh+cos(Ang)*(WG/2+wpl)</l>
<l>Y2 := RowSkTh+sin(Ang)*(WG/2+wpl)</l>
<l>X2 := ColSkTh-cos(Ang)*(WG/2+wpl)</l>
<l>YC := RowSkTh</l>
<l>XC := ColSkTh</l>
<c></c>
<l>* gen_region_points(P2, Y2, X2)</l>
<l>return ()</l>
</body>
<docu id="MSBuildFWM4">
<parameters>
<parameter id="DirImageP"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Pnum"/>
<parameter id="PnumR"/>
<parameter id="PregC"/>
<parameter id="Puseint"/>
<parameter id="SkeletonsGThin"/>
<parameter id="WG"/>
<parameter id="WidthImageP"/>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YC"/>
<parameter id="notusedint"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="PseudoDefectsCandidates">
<interface>
<io>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegPDCV" base_type="iconic" dimension="0"/>
<par name="RegPDCH" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="nr" base_type="ctrl" dimension="0"/>
<par name="nc" base_type="ctrl" dimension="0"/>
<par name="orr" base_type="ctrl" dimension="0"/>
<par name="n" base_type="ctrl" dimension="0"/>
<par name="orc" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nPDCV" base_type="ctrl" dimension="0"/>
<par name="nPDCH" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj(Squares)</l>
<l>for k:=0 to nr-1 by 1</l>
<l>    for j:=0 to nc-1 by 1</l>
<l>        gen_rectangle1(Rect, orr+k*n,orc+j*n,orr+(k+1)*(n),orc+(j+1)*(n))</l>
<l>        concat_obj(Squares, Rect, Squares)</l>
<l>    endfor</l>
<l>endfor</l>
<l>* stop()</l>
<c></c>
<l>gen_empty_region(Lines)</l>
<l>for j:=0 to nc by 1</l>
<l>    gen_region_line(Line, orr,orc+j*n,orr+n*(nr),orc+j*n)</l>
<l>    concat_obj(Lines, Line,Lines)</l>
<l>*     dev_display(Line)</l>
<l>endfor</l>
<l>* stop()</l>
<l>for j:=0 to nr by 1</l>
<l>    gen_region_line(Line, orr+j*n,orc,orr+j*n, orc+n*(nc))</l>
<l>    concat_obj(Lines, Line,Lines)</l>
<l>*     dev_display(LineR)</l>
<l>endfor</l>
<l>dev_display(Lines)</l>
<l>* stop()</l>
<l>union1(Lines, LineAll)</l>
<l>intersection(LineAll, SkeletonFWM, SkThinBound)</l>
<l>get_region_points(SkThinBound, RowsSTB, ColsSTB)</l>
<l>get_grayval(DirImageP, RowsSTB, ColsSTB, Angs)</l>
<c></c>
<l>atol:=20</l>
<l>RowsPD:=[]</l>
<l>ColsPD:=[]</l>
<l>DirPD:=[]</l>
<l>tuple_length(RowsSTB, nSTB)</l>
<l>for j:=0 to nSTB-1 by 1</l>
<l>    a:=Angs[j]</l>
<l>    if( ( a&lt; atol) or (a  &gt; 255-atol) or (abs(a-128) &lt; atol))</l>
<l>        continue</l>
<l>    endif</l>
<l>    r:=RowsSTB[j]</l>
<l>    c:=ColsSTB[j]</l>
<l>    gen_region_points(P, r, c)</l>
<l>    tuple_concat(RowsPD, r,RowsPD)</l>
<l>    tuple_concat(ColsPD, c,ColsPD)</l>
<l>    tuple_concat(DirPD, a,DirPD)</l>
<l>endfor</l>
<l>gen_region_points(PD, RowsPD, ColsPD)</l>
<l>* stop()</l>
<c></c>
<c>*********** Building Boundary lines arrays</c>
<c>* 1. Form tuples of horizontal and vertical square boundary lines</c>
<l>nSq:= nr*nc</l>
<l>FormBoundaryLines (LinesVert, LinesHor, nr, nc, orr, orc, n)</l>
<l>count_obj(LinesVert, nLV)</l>
<l>count_obj(LinesHor, nLH)</l>
<l>* stop()</l>
<c>*********** Finding Pseudo defect candidates</c>
<l>dev_update_off()</l>
<c>* 2.Form tuples of regions, intersecting boundary lines and thin FWM skeleton,</c>
<c>*      length=number of squares (nSq), many empty regions</c>
<c></c>
<c></c>
<c></c>
<c>* 3. Remove regions with small angles to X and Y and </c>
<c>*   convert multiple point regions to single points</c>
<c>* vertical</c>
<c></c>
<c>*** direction tolerance</c>
<l>atol:=20</l>
<l>agtol:=14</l>
<l>FormPDCVert (LinesVert, SkeletonFWM, DirImageP, RegPDCV, nSq, agtol, AngPDCV, AddrPDCV, NumPDCV)</l>
<l>count_obj(RegPDCV, nPDCV)</l>
<l>* stop()</l>
<c>* horizontal</c>
<l>FormPDCHor (LinesHor, SkeletonFWM, DirImageP, RegPDCH, nSq, agtol, AngPDCH, AddrPDCH, NumPDCH)</l>
<l>count_obj(RegPDCH, nPDCH)</l>
<l>* union1(RegPDCH, RegPDCHUnion)</l>
<l>* connection(RegPDCHUnion, RegPDCH)</l>
<l>* count_obj(RegPDCH, nPDCH)</l>
<l>return ()</l>
</body>
<docu id="PseudoDefectsCandidates">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegPDCH"/>
<parameter id="RegPDCV"/>
<parameter id="SkeletonFWM"/>
<parameter id="n"/>
<parameter id="nPDCH"/>
<parameter id="nPDCV"/>
<parameter id="nc"/>
<parameter id="nr"/>
<parameter id="orc"/>
<parameter id="orr"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBm4">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="H" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_image_const (ImageIRB, 'byte', W, H)</l>
<l>count_obj (RegionsPNi, nPNi)</l>
<l>* union2 (RegionIS, RegionsShm, RegForbid)</l>
<l>* expand_region (SkeletonsGThin, RegForbid, RegionsPNi, 'maximal', 'image')</l>
<l>intersection (RegionsPNi, RegionInoD, RegionsPN)</l>
<c></c>
<l>boundary (RegionsPN, RegionsINB, 'inner')</l>
<l>count_obj (RegionsINB, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>* union1 (RegionsShm, RegionShm)</l>
<l>* difference (RegionInoD, RegionShm, RegionIm)</l>
<l>paint_region (RegionInoD, ImageIRB, ImageIRB, 1, 'fill')</l>
<l>paint_region (RegionsINB, ImageIRB, ImageIRB, SequenceIRB, 'fill')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="BuildIRBm4">
<short lang="en_US">RegionInoD - Real Image region with defects (PH, Isl) removed</short>
<parameters>
<parameter id="H"/>
<parameter id="ImageIRB"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="W"/>
</parameters>
</docu>
</procedure>
<procedure name="AngleDist">
<interface>
<ic>
<par name="y" base_type="ctrl" dimension="0"/>
<par name="x" base_type="ctrl" dimension="0"/>
<par name="y1" base_type="ctrl" dimension="0"/>
<par name="x1" base_type="ctrl" dimension="0"/>
<par name="y2" base_type="ctrl" dimension="0"/>
<par name="x2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="d" base_type="ctrl" dimension="0"/>
<par name="tang" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>A := y1 - y2</l>
<l>B := x2 - x1</l>
<l>C := x1*y2 - x2*y1</l>
<l>d := (A*x + B*y + C) / sqrt(A*A + B*B)</l>
<l>k := A / B</l>
<c>* **ang = atan(k)</c>
<l>tang := k</l>
<l>return ()</l>
</body>
<docu id="AngleDist">
<parameters>
<parameter id="d"/>
<parameter id="tang"/>
<parameter id="x"/>
<parameter id="x1"/>
<parameter id="x2"/>
<parameter id="y"/>
<parameter id="y1"/>
<parameter id="y2"/>
</parameters>
</docu>
</procedure>
<procedure name="MeasIntBresenham15">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** V14 (MeasIntBresenham14), version with beg. end end points check, W corr., bb cor</c>
<c>* * fixed div/0 error</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c></c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>* gen_region_points (PPR, PPy, PPx)</l>
<l>* intersection (PPR, RegionIRB, RegionInt)</l>
<l>* get_region_points (RegionInt, Rows, Columns)</l>
<l>* tuple_length (Rows, l)</l>
<l>* if (l&lt;2)</l>
<l>*     wmax := 0</l>
<l>*     return ()</l>
<l>* endif</l>
<c></c>
<l>* if (pnum ==0)</l>
<l>*     get_grayval (ImageIRB, Rows, Columns, Grayval)</l>
<l>*     tuple_median (Grayval, pnum)</l>
<l>* endif</l>
<c></c>
<c>* Processing</c>
<c>* ** going forward from PS1</c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>PIntY := []</l>
<l>i0 := -1</l>
<l>i2 := -1</l>
<l>bfound := 0</l>
<c></c>
<l>for i := 1 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        if (bfound==0)</l>
<c>            * real def. beginning</c>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>            bfound := 1</l>
<l>        elseif (bfound==2)</l>
<l>            bfound := 1</l>
<l>        endif</l>
<l>    elseif (v==1)</l>
<l>        if (bfound==0)</l>
<c>            * preliminary def. beginning</c>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>            bfound := 2</l>
<l>        endif</l>
<l>    elseif (v==0)</l>
<c>        * space pixel</c>
<l>        if (bfound==1)</l>
<c>            * end of real def. beginning search</c>
<l>            PIntX[2] := PPx[i-1]</l>
<l>            PIntY[2] := PPy[i-1]</l>
<l>            i2 := i-1</l>
<c>            * end of 1st search</c>
<l>            break</l>
<l>        else</l>
<l>            bfound := 0</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* ** going backwards from PS2</c>
<l>gen_region_points (PS2, PPy[pind-1], PPx[pind-1])</l>
<l>i3 := -1</l>
<l>i1 := -1</l>
<l>bfound2 := 0</l>
<l>for i := pind-2 to 0 by -1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>*     gen_region_points (Region, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        if (bfound2==0)</l>
<c>            * real def. beginning</c>
<l>            PIntX[1] := xc</l>
<l>            PIntY[1] := yc</l>
<l>            i1 := i</l>
<l>            bfound2 := 1</l>
<l>        elseif (bfound2==2)</l>
<l>            bfound2 := 1</l>
<l>        endif</l>
<l>    elseif (v==1)</l>
<l>        if (bfound2==0)</l>
<c>            * preliminary def. beginning</c>
<l>            PIntX[1] := xc</l>
<l>            PIntY[1] := yc</l>
<l>            i1 := i</l>
<l>            bfound2 := 2</l>
<l>        endif</l>
<l>    elseif (v==0)</l>
<c>        * space pixel</c>
<l>        if (bfound2==1)</l>
<c>            * end of real def. beginning search</c>
<l>            PIntX[3] := PPx[i+1]</l>
<l>            PIntY[3] := PPy[i+1]</l>
<l>            i3 := i+1</l>
<c>            * end of 2nd search</c>
<l>            break</l>
<l>        else</l>
<l>            bfound2 := 0</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* if (i0==-1 or i1==-1 or i2==-1 or i3==-1)</l>
<l>if (i0==-1 or i1==-1)</l>
<l>    wmin := 0</l>
<l>    wmax := 0</l>
<l>    return ()</l>
<l>endif</l>
<l>ppi00x := PPx[i0]</l>
<l>ppi00y := PPy[i0]</l>
<l>ppi0p1x := PPx[i0+1]</l>
<l>ppi0p1y := PPy[i0+1]</l>
<l>ppi0m1x := PPx[i0-1]</l>
<l>ppi0m1y := PPy[i0-1]</l>
<c></c>
<l>ppi10x := PPx[i1]</l>
<l>ppi10y := PPy[i1]</l>
<l>ppi1p1x := PPx[i1+1]</l>
<l>ppi1p1y := PPy[i1+1]</l>
<l>ppi1m1x := PPx[i1-1]</l>
<l>ppi1m1y := PPy[i1-1]</l>
<c></c>
<l>* gen_region_points (P0, PPy[i0], PPx[i0])</l>
<l>* gen_region_points (P1, PPy[i1], PPx[i1])</l>
<l>* if (i2&gt;=0)</l>
<l>*     gen_region_points (P2, PPy[i2], PPx[i2])</l>
<l>* endif</l>
<l>* if (i3&gt;=0)</l>
<l>*     gen_region_points (P3, PPy[i3], PPx[i3])</l>
<l>* endif</l>
<c></c>
<c></c>
<l>get_grayval (Im, ppi00y, ppi00x, g)</l>
<l>g0[1] := g</l>
<l>get_grayval (Im, ppi0m1y, ppi0m1x, g)</l>
<l>g0[0] := g</l>
<l>get_grayval (Im, ppi0p1y, ppi0p1x, g)</l>
<l>g0[2] := g</l>
<l>* create_funct_1d_array (g0, Fg0)</l>
<l>* invert_funct_1d (Fg0, Fg0i)</l>
<l>* get_y_value_funct_1d (Fg0i, 50, 'constant', dy0)</l>
<c></c>
<c></c>
<c></c>
<l>get_grayval (Im, ppi10y, ppi10x, g)</l>
<l>g1[1] := g</l>
<l>get_grayval (Im, ppi1m1y, ppi1m1x, g)</l>
<l>g1[0] := g</l>
<l>get_grayval (Im, ppi1p1y, ppi1p1x, g)</l>
<l>g1[2] := g</l>
<l>* create_funct_1d_array (g1, Fg1)</l>
<l>* invert_funct_1d (Fg1, Fg1i)</l>
<l>* get_y_value_funct_1d (Fg1i, 50, 'constant', dy1)</l>
<c></c>
<l>SubPixCrdT (g0, i0, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[0] := pIntX</l>
<l>PIntY[0] := pIntY</l>
<l>SubPixCrdT (g1, i1, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[1] := pIntX</l>
<l>PIntY[1] := pIntY</l>
<l>gen_region_points (RR, PIntY, PIntX)</l>
<l>twolines := 0</l>
<l>tuple_length (PIntX, np)</l>
<l>if (i3 != i0 and np&gt;2)</l>
<l>    get_grayval (Im, PPy[i2], PPx[i2], g)</l>
<l>    g2[1] := g</l>
<l>    get_grayval (Im, PPy[i2-1], PPx[i2-1], g)</l>
<l>    g2[0] := g</l>
<l>    get_grayval (Im, PPy[i2+1], PPx[i2+1], g)</l>
<l>    g2[2] := g</l>
<c></c>
<l>SubPixCrdT (g2, i2, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[2] := pIntX</l>
<l>    PIntY[2] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<l>if (i2 != i1  and np&gt;2)</l>
<l>    get_grayval (Im, PPy[i3], PPx[i3], g)</l>
<l>    g3[1] := g</l>
<l>    get_grayval (Im, PPy[i3-1], PPx[i3-1], g)</l>
<l>    g3[0] := g</l>
<l>    get_grayval (Im, PPy[i3+1], PPx[i3+1], g)</l>
<l>    g3[2] := g</l>
<c></c>
<l>SubPixCrdT (g3, i3, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[3] := pIntX</l>
<l>    PIntY[3] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>wmin := 0</l>
<l>if (np&gt;1)</l>
<l>    if (PIntX[0] != 0 and PIntX[1] != 0 and (twolines==0))</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<l>        wmin := 0</l>
<l>    endif</l>
<l>    if (twolines==1)</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<c>        * selecting line which includes skeleton</c>
<l>        xc := (ix1+ix2)/2</l>
<l>        yc := (iy1+iy2)/2</l>
<l>        dX := ix2 - ix1</l>
<l>        dY := iy2 - iy1</l>
<l>        if (dX!=0)</l>
<l>            if (xc&lt;=PIntX[0] and xc&gt;=PIntX[2] or xc&gt;=PIntX[0] and xc&lt;=PIntX[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        else</l>
<l>            if (yc&lt;=PIntY[0] and yc&gt;=PIntY[2] or yc&gt;=PIntY[0] and yc&lt;=PIntY[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        endif</l>
<c></c>
<c></c>
<l>    endif</l>
<l>else</l>
<l>    wmax := 0</l>
<l>    wmin := 0</l>
<l>endif</l>
<c></c>
<c>* end p.********************************</c>
<l>return ()</l>
</body>
<docu id="MeasIntBresenham15">
<parameters>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="SubPixCrdT">
<interface>
<ic>
<par name="g0" base_type="ctrl" dimension="0"/>
<par name="i0" base_type="ctrl" dimension="0"/>
<par name="PPx" base_type="ctrl" dimension="0"/>
<par name="PPy" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_real (thr, rthr)</l>
<l>if (sub==0)</l>
<l>    PIntX[0] := PPx[i0]</l>
<l>    PIntY[0] := PPy[i0]</l>
<l>    return ()</l>
<l>endif</l>
<l>if (g0[0] &gt;thr and g0[1] &gt;thr and g0[2] &gt;thr)</l>
<l>    if (g0[0] &lt;= g0[1] and g0[0] &lt;= g0[2])</l>
<l>        PIntX[0] := PPx[i0]</l>
<l>        PIntY[0] := PPy[i0]</l>
<l>    elseif (g0[1] &lt;= g0[0] and g0[1] &lt;= g0[2])</l>
<l>        PIntX[0] := PPx[i0+1]</l>
<l>        PIntY[0] := PPy[i0+1]</l>
<l>    elseif (g0[2] &lt;= g0[1] and g0[2] &lt;= g0[0])</l>
<l>        PIntX[0] := PPx[i0-1]</l>
<l>        PIntY[0] := PPy[i0-1]</l>
<l>    endif</l>
<l>    return ()</l>
<l>endif</l>
<l>if (g0[0] &lt;thr and g0[1] &lt;thr and g0[2] &lt;thr)</l>
<l>    if (g0[0] &gt;= g0[1] and g0[0] &gt;= g0[2])</l>
<l>        PIntX[0] := PPx[i0]</l>
<l>        PIntY[0] := PPy[i0]</l>
<l>    elseif (g0[1] &gt;= g0[0] and g0[1] &gt;= g0[2])</l>
<l>        PIntX[0] := PPx[i0+1]</l>
<l>        PIntY[0] := PPy[i0+1]</l>
<l>    elseif (g0[2] &gt;= g0[1] and g0[2] &gt;= g0[0])</l>
<l>        PIntX[0] := PPx[i0-1]</l>
<l>        PIntY[0] := PPy[i0-1]</l>
<l>    endif</l>
<l>    return ()</l>
<l>endif</l>
<l>if ((g0[1] - g0[0]) &gt; (g0[1] - g0[2]))</l>
<l>    dg10 := g0[1]-g0[0]</l>
<l>    if (dg10!=0)</l>
<l>        dd0 := -(g0[1]-rthr)/dg10</l>
<l>        if(abs(dd0) &lt; 1.)</l>
<l>            PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>            PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>        else</l>
<l>            PIntX[0] := PPx[i0]</l>
<l>            PIntY[0] := PPy[i0]</l>
<l>        endif</l>
<c>        </c>
<l>    else</l>
<l>        PIntX[0] := PPx[i0]</l>
<l>        PIntY[0] := PPy[i0]</l>
<l>    endif</l>
<l>else</l>
<l>    dg20 := g0[2]-g0[1]</l>
<l>    if (dg20!=0)</l>
<l>        dd0 := (g0[1]-rthr)/dg20</l>
<l>        if(abs(dd0) &lt; 1.)</l>
<l>            PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>            PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>        else</l>
<l>            PIntX[0] := PPx[i0]</l>
<l>            PIntY[0] := PPy[i0]</l>
<l>        endif</l>
<c>        </c>
<l>    else</l>
<l>        PIntX[0] := PPx[i0]</l>
<l>        PIntY[0] := PPy[i0]</l>
<l>    endif</l>
<c></c>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="SubPixCrdT">
<parameters>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="PPx"/>
<parameter id="PPy"/>
<parameter id="g0"/>
<parameter id="i0"/>
<parameter id="sub"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterM4L">
<interface>
<ic>
<par name="Func" base_type="ctrl" dimension="0"/>
<par name="size1" base_type="ctrl" dimension="0"/>
<par name="size2" base_type="ctrl" dimension="0"/>
<par name="sm" base_type="ctrl" dimension="0"/>
<par name="ang" base_type="ctrl" dimension="0"/>
<par name="prc" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
<par name="DLen" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>num_points_funct_1d (Func, n)</l>
<l>if (sm&gt;0)</l>
<l>    smooth_funct_1d_mean (Func, sm, 1, SmoothedFunction)</l>
<l>endif</l>
<l>tang := tan(ang*3.14159/180.)</l>
<l>Y := []</l>
<l>D := []</l>
<l>Dav := []</l>
<l>Prc := []</l>
<l>Def := []</l>
<l>tuple_gen_const(n, 0, DLen)</l>
<l>l:=0</l>
<l>dpnum:=0</l>
<l>dmp:=0</l>
<l>dm:=0</l>
<l>for j := 0 to n-1 by 1</l>
<l>*     if (j==179)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    jm := j-size1</l>
<l>    if (jm&lt;0)</l>
<l>        jm := 0</l>
<l>    endif</l>
<l>    jp := j+size1</l>
<l>    if (jp&gt;n-1)</l>
<l>        jp := n-1</l>
<l>    endif</l>
<l>    jm2 := j-size2</l>
<l>    if (jm2&lt;0)</l>
<l>        jm2 := 0</l>
<l>    endif</l>
<l>    jp2 := j+size2</l>
<l>    if (jp2&gt;n-1)</l>
<l>        jp2 := n-1</l>
<l>    endif</l>
<l>    get_pair_funct_1d (Func, j, x, y)</l>
<l>    get_pair_funct_1d (Func, jp, xp, yp)</l>
<l>    get_pair_funct_1d (Func, jm, xm, ym)</l>
<l>    get_pair_funct_1d (Func, jp2, xp2, yp2)</l>
<l>    get_pair_funct_1d (Func, jm2, xm2, ym2)</l>
<l>    angle_lx (ym, xm, yp, xp, angl)</l>
<l>    angle_lx (ym2, xm2, yp2, xp2, angl2)</l>
<l>    ta := abs(tan(angl))</l>
<l>    ta2 := abs(tan(angl2))</l>
<l>    AngleDist (y, x, ym, xm, yp, xp, d, ta)</l>
<l>    AngleDist (y, x, ym2, xm2, yp2, xp2, d2, ta2)</l>
<l>*     distance_ps (y, x, ym, xm, yp, xp, d, DistanceMax)</l>
<l>*     distance_ps (y, x, ym2, xm2, yp2, xp2, d2, DistanceMax)</l>
<l>*     ang := 0.1</l>
<l>*     a := abs(angl)*180./3.1416</l>
<l>*     a2 := abs(angl2)*180./3.1416</l>
<l>    dmp:=dm</l>
<l>*     if ((ta &lt;= tang) and (ta2 &lt;= tang))</l>
<l>*         dm := d</l>
<l>*     else</l>
<l>*         dm := 0</l>
<l>*     endif</l>
<c>    </c>
<l>    if ((abs(ta) &lt;= tang) )</l>
<l>        dm := d</l>
<l>    elseif(abs(ta2) &lt;= tang)</l>
<l>        dm := d2</l>
<l>    else</l>
<l>        dm := 0</l>
<l>    endif</l>
<c>    </c>
<l>    yav := abs(ym+yp)/2</l>
<l>    yav2 := abs(ym2+yp2)/2</l>
<l>*     prc := abs(d)/abs(yav)</l>
<l>    tuple_concat (Y, y, Y)</l>
<l>    tuple_mean (Y, Ymean)</l>
<l>    tuple_median (Y, Ymed)</l>
<l>    tuple_concat (D, dm, D)</l>
<l>    tuple_min ([yav, yav2], yavm)</l>
<l>    if(yavm &gt; 0)</l>
<l>        measprc := dm*100.0/(yavm)</l>
<l>    else </l>
<l>        measprc := 0</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_concat (Prc, measprc, Prc)</l>
<l>    tuple_concat (Dav, yav*0.35, Dav)</l>
<l>*     if ((dm&lt;yav*prc/100.) and (dm&lt;yav*prc/100.))</l>
<l>    if ((dm&lt;yav*prc/100.))</l>
<l>        tuple_concat (Def, 0, Def)</l>
<l>        l:=0</l>
<l>        if(dmp&gt;0)</l>
<c>            </c>
<l>        endif</l>
<l>    else</l>
<l>        tuple_concat (Def, dm, Def)</l>
<l>        if(l&gt;0)</l>
<l>            DLen[j] := l</l>
<l>*             DLen[j+l/2] := l</l>
<l>        endif</l>
<l>        l:=l+1</l>
<l>        dpnum:=dpnum+1</l>
<l>    endif</l>
<l>*     tuple_concat (Prc, prc, Prc)</l>
<l>endfor</l>
<l>* stop()</l>
<l>return ()</l>
</body>
<docu id="FilterM4L">
<parameters>
<parameter id="DLen"/>
<parameter id="Def"/>
<parameter id="Func"/>
<parameter id="Prc"/>
<parameter id="ang"/>
<parameter id="prc"/>
<parameter id="size1"/>
<parameter id="size2"/>
<parameter id="sm"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain6">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ROut := R</l>
<c></c>
<c>**** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference(DomainG, ROut, RC)</l>
<c></c>
<l>* complement (ROut, RC)</l>
<l>intersection(Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection(RC,DomainG, RC)</l>
<l>* stop()</l>
<c></c>
<c>**************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold(Gi, RegionGii, 127, 255)</l>
<l>* difference(RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi:=RegionGii</l>
<l>closing_circle(RegionGii, RegionGi, 1)</l>
<l>connection(RegionGi, RegionsGi)</l>
<l>select_shape(RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj(RegionsGND,nGND)</l>
<c>***** nGND - number of GND-like (big size) regions to be removed from overflowing </c>
<l>intersection(RegionGi, RC, RegionG)</l>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c></c>
<l>* complement(RegionGi, RegionGComplement)</l>
<l>* intersection(RegionGComplement, DomainG, RegionGSi)</l>
<c></c>
<l>difference(DomainG, RegionGi, RegionGSi)</l>
<c></c>
<l>RegionGS:=RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<l>intersection(SkeletonGi, RC, SkeletonG)</l>
<c></c>
<l>skeleton(RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object(SkeletonGS, path+'SkeletonGS.hobj')</l>
<c></c>
<c>*  Finding thin (FWM) pattern</c>
<c>***FWM half width**</c>
<c></c>
<l>opening_circle(RegionG, RegionGOpi, fwmhw)</l>
<c></c>
<l>difference(RegionG, RegionGOpi, RegionGOpDifi)</l>
<l>difference(RegionG, RegionGOpDifi, RegionThicki)</l>
<l>opening_circle(RegionGOpDifi, RegionGthin, parop)</l>
<c></c>
<l>connection(RegionGthin, RegionsGthin)</l>
<l>intersection (RegionGthin, SkeletonG, SkeletonGThin)</l>
<l>area_center(SkeletonGThin, nSkThin, Row2, Column)</l>
<l>connection(SkeletonGThin, SkeletonsGThin)</l>
<l>count_obj(SkeletonsGThin, nSGThin)</l>
<l>* select_shape(RegionsGthini, RegionsGthin, 'contlength', 'and', clen, 99999999)</l>
<l>dev_set_color('red')</l>
<l>dev_display(RegionsGthin)</l>
<l>* stop()</l>
<c>*****</c>
<c>****</c>
<l>opening_circle(RegionGSi, RegionGSOp, fwmhw)</l>
<l>difference(RegionGSi, RegionGSOp, RegionGSOpDifi)</l>
<l>difference(RegionGSi, RegionGSOpDifi, RegionThicki)</l>
<l>opening_circle(RegionGSOpDifi, RegionGSthini, parop)</l>
<l>connection(RegionGSthini, RegionsGSthini)</l>
<l>shape:=['contlength', 'compactness']</l>
<l>select_shape(RegionsGSthini, RegionsGSthin, shape, 'and', [100, 10], [9999999, 99999])</l>
<l>* select_shape (RegionsGSthiniiOut, RegionsGSthiniiOut, 'contlength', 'and', 200, 9999999)</l>
<c></c>
<l>dev_set_color('green')</l>
<l>dev_display(RegionsGSthin)</l>
<l>* stop()</l>
<l>set_system('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<c></c>
<c>**** removing R from SkeletonGi and forming SkeletonG</c>
<l>intersection (SkeletonG, RC, SkeletonG)</l>
<l>GetSkeletonBranches (SkeletonG, WidthImageP, SkeletonsGbr, jrad, gap)</l>
<c></c>
<l>pruning (SkeletonG, SkeletonGii, 2)</l>
<l>* SkeletonG := SkeletonG</l>
<l>junctions_skeleton(SkeletonGii, EndPoints, JuncPoints)</l>
<l>connection(EndPoints,EndPointsc)</l>
<l>count_obj(EndPointsc, ne)</l>
<l>tuple_gen_const(ne, 1, Re)</l>
<l>area_center(EndPointsc, A, Row,Col)</l>
<l>get_grayval(WidthImageP, Row, Col, Erad)</l>
<c></c>
<l>dev_update_off()</l>
<c>*** processing skeleton</c>
<l>SkeletonGPr:=SkeletonG</l>
<l>for j:= 0 to ne-1 by 1</l>
<l>    select_obj(EndPointsc, ObjectSelected, j+1)</l>
<l>    dilation_circle(ObjectSelected, ObjectSelectedD, Erad[j]+7)</l>
<l>    difference(SkeletonGPr, ObjectSelectedD, SkeletonGPr)</l>
<l>endfor</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>maxdif:=5</l>
<l>len:=50</l>
<l>FindSkeletonsFWM (SkeletonsGbr, WidthImageP, SkeletonsFWMi, maxdif, len)</l>
<l>intersection (SkeletonsFWMi, RC, SkeletonsFWM)</l>
<c></c>
<l>* stop()</l>
<c></c>
<c>********* Preping IRB image  *******************</c>
<c></c>
<c>**** preparing for IRB, in teaching stage</c>
<l>num_iter:=999</l>
<l>connection(SkeletonG, SkeletonsG)</l>
<l>gen_image_const(ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const(ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region(RegForbid)</l>
<c></c>
<c></c>
<l>pniovl:=4</l>
<c>*** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>*** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle(RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid:=RegionGSer</l>
<l>RegForbid:=SkeletonGSi</l>
<l>expand_region(SkeletonsG, RegForbid, RegionsPNi, num_iter, 'image')</l>
<l>* union1(SkeletonsFWM,SkeletonFWM)</l>
<l>* intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM_v2)</l>
<l>* dilation_circle(RegionsPNii, RegionsPNi, pniovl)</l>
<l>count_obj(RegionsPNi, nINB)</l>
<l>* write_object(RegionsPNi, path+'RegionsPNi2.hobj')</l>
<l>tuple_gen_sequence(1, nINB, 1, SequenceINBi)</l>
<c>**** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1]:=groundgval</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>SequenceIRB[groundpn-1]:=groundgval</l>
<c>**** new GND</c>
<c>*** start of the sequence </c>
<l>* stseq:= nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1]:=groundgval</l>
<c>*****</c>
<c></c>
<c></c>
<l>union1(RegionsGND, RegionGND)</l>
<c></c>
<l>* complement(RegionGND, RegionGNDC)</l>
<l>difference(DomainG, RegionGND, RegionGNDC)</l>
<l>* complement(RegionG, RegionGS)</l>
<l>difference(DomainG, RegionG, RegionGS)</l>
<l>* expand_region(SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c></c>
<l>* stop()</l>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>intersection(RegionsPNi,SkeletonFWM,  SkeletonsFWM)</l>
<c></c>
<c></c>
<c></c>
<c>*** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<c></c>
<c></c>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>* stop()</l>
<c></c>
<c>************************</c>
<c>**** preparing non-FWM MSs</c>
<l>boundary(RegionG, RegionGB, 'inner')</l>
<c></c>
<l>erosion_circle(RegionG, RegionGer, fwmhw*1.3)</l>
<l>connection(RegionGer, RegionsGer)</l>
<l>dilation_circle(RegionsGer, RegionsGedi, fwmhw*2.0)</l>
<l>select_shape(RegionsGedi, RegionsGed, 'ra', 'and', 15, 999999)</l>
<c></c>
<l>intersection( RegionsGed, RegionGB,BoundariesNFWMi)</l>
<l>count_obj(BoundariesNFWMi, nCGb)</l>
<l>intersection( RegionsGed, RegionG,RegionsNFWM)</l>
<l>count_obj (RegionsNFWM, nNonWFM)</l>
<l>* BoundariesNFWM:=RegionsCGb</l>
<c></c>
<l>intersection(RegionsNFWM, SkeletonGi, SkelN)</l>
<c>*** 0-   1-</c>
<l>wgntype:=1</l>
<c>*** contl</c>
<c></c>
<l>area_center(BoundariesNFWMi,Area, Row1, Column1)</l>
<l>tuple_min(Area, amin)</l>
<c></c>
<l>select_shape(BoundariesNFWMi, BoundariesNFWM,'area', 'and', 50, 99999999)</l>
<c></c>
<l>MSBuildNonFWM5 (RegionsNFWM, BoundariesNFWM, ImageIR, WidthImageP, SkelN, nNonWFM, sm_factor, lookaround, wpl, wgntype, PnumN, PnumRN, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<c></c>
<l>ncontN:=70</l>
<c></c>
<l>nregn:=PregCN[ncontN-1]</l>
<l>ncontN2:=PcontRN[nregn-1]</l>
<l>ncontN3:=PCinRnumN[nregn-1]</l>
<l>* nNonWFM := nNonWFM</l>
<c></c>
<c></c>
<l>tuple_min(PnumN, minN)</l>
<l>* stop()</l>
<c></c>
<c>******   FWM  Teaching  **************</c>
<c>*****************************************</c>
<l>MSBuildFWM4 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint)</l>
<c>**************************************</c>
<c></c>
<l>return ()</l>
</body>
<docu id="TeachingMain6">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildNonFWM5">
<interface>
<io>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="SkelN" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="nCGc" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="wgntype" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildNonFWM5 211108 ****</c>
<l>RowN := []</l>
<l>ColN := []</l>
<l>PnumN := []</l>
<l>pnum:=[]</l>
<l>WN := []</l>
<c>*** address for each region (1 or several contours)</c>
<l>PaddrRN := 0</l>
<c>*** address for each contour</c>
<l>PaddrCN := []</l>
<c>**** number of contours per region</c>
<l>* PregN := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregCN := []</l>
<c>* * number of countours per region</c>
<l>PCinRnumN := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontRN := []</l>
<c>** current Region address</c>
<l>paddrR := 0</l>
<c>** current Contour address</c>
<l>paddrC := 0</l>
<l>pcontn := 0</l>
<l>indcn:=0</l>
<l>AngN:= []</l>
<l>PlenN:=[]</l>
<l>Y1N:=[]</l>
<l>X1N:=[]</l>
<l>Y2N:=[]</l>
<l>X2N:=[]</l>
<l>WGN:=[]</l>
<c></c>
<l>count_obj (BoundariesNFWM, nNonWFM)</l>
<c></c>
<l>gen_empty_obj(ContoursAll)</l>
<l>gen_empty_obj(RegsAll)</l>
<l>* count_obj (SkeletonsGThin, nSGThin)</l>
<l>pn:=0</l>
<l>for j := 1 to nNonWFM by 1</l>
<c>     **** non-FWM region ( full and only boundary regions)</c>
<l>    select_obj (RegionsNFWM, RCgc, j)</l>
<l>    select_obj (BoundariesNFWM, RCgb, j)</l>
<l>    concat_obj(RegsAll, RCgb, RegsAll)</l>
<l>    skeleton(RCgc,SkeletonRCgc)</l>
<l>    get_region_points(SkeletonRCgc,r, c)</l>
<l>*     tuple_length(r, ngb)</l>
<l>    get_grayval (ImageIR, r, c, gv)</l>
<l>*     tuple_sort(gv, gvs)</l>
<l>*     tuple_inverse(gvs, gvsi)</l>
<l>    tuple_median(gv, pnum)</l>
<c>    </c>
<l>    area_center(RCgc, a, r, c)</l>
<l>    inner_circle(RCgc, rmin, cmin, radmin)</l>
<c>    ** inner radius to be used as CAD half width</c>
<l>    gen_circle(Circle, rmin, cmin, radmin)</l>
<c></c>
<c>    * * contour is used to avoid points discontinuation ***</c>
<c></c>
<l>    gen_contours_skeleton_xld(RCgb, Contours1, 3, 'filter')</l>
<l>    union_adjacent_contours_xld(Contours1, Contours, 3, 1, 'attr_forget')</l>
<l>    smooth_contours_xld(Contours, ContoursSmi, sm_factor)</l>
<l>    select_contours_xld(ContoursSmi, ContoursSm, 'contour_length', 30.0, 20000000., -0.5, 0.5)</l>
<l>*     stop()</l>
<l>    count_obj(ContoursSm, nCo)</l>
<l>    tuple_concat (PCinRnumN, nCo, PCinRnumN)</l>
<c>    *** contours of each non-FWM region ( 1 or several)</c>
<l>    nnco:=0</l>
<l>    tuple_concat (PcontRN, pcontn, PcontRN)</l>
<l>    pcontn := pcontn+nCo</l>
<l>    for jj:=1 to nCo by 1</l>
<l>        select_obj(ContoursSm, Contour, jj)</l>
<l>        get_contour_xld (Contour, Row, Col)</l>
<l>        tuple_length (Row, pN)</l>
<l>*         if(pN&gt;30)</l>
<l>            nnco:=nnco+1</l>
<c>            </c>
<l>            concat_obj(ContoursAll, Contour, ContoursAll)</l>
<l>            tuple_gen_const(pN, radmin*2., W)</l>
<l>            tuple_gen_const (pN, j, J)</l>
<l>            tuple_concat (RowN, Row, RowN)</l>
<l>            tuple_concat (ColN, Col, ColN)</l>
<c>            </c>
<l>             tuple_concat (WN, W, WN)</l>
<l>            tuple_concat (PaddrCN, paddrC, PaddrCN)</l>
<l>            indcn:=indcn+1</l>
<l>            tuple_concat (PregCN, j, PregCN)</l>
<l>            paddrC := paddrC + pN</l>
<l>            get_contour_angle_xld (Contour, 'abs', 'regress', lookaround, AnglesG)</l>
<l>            tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>            Ang:=AnglesG1</l>
<l>            tuple_concat (AngN, Ang, AngN)</l>
<c></c>
<l>            Y1t := Row-sin(Ang)*(3)</l>
<l>            X1t := Col+cos(Ang)*(3)</l>
<c>            </c>
<l>            Y1n := Row-sin(Ang)*(wpl)</l>
<l>            X1n := Col+cos(Ang)*(wpl)</l>
<l>            Y2n := Row+sin(Ang)*(wpl)</l>
<l>            X2n := Col-cos(Ang)*(wpl)</l>
<c>            </c>
<l>            tuple_gen_const(pN, pnum, Pnum)</l>
<l>            tuple_concat (PnumN, Pnum, PnumN)</l>
<c>  </c>
<c>            **** swapping P1 and P2 if necessary</c>
<l>            test_region_point (RegionsNFWM, Y1t[pN/2], X1t[pN/2], IsInside)</l>
<l>            if(IsInside)</l>
<l>                Yt:= Y1n</l>
<l>                Xt:= X1n</l>
<l>                X1n:=X2n</l>
<l>                Y1n:=Y2n</l>
<l>                X2n:=Xt</l>
<l>                Y2n:=Yt</l>
<l>            endif</l>
<c>            ****          </c>
<l>            dev_set_color('green')</l>
<l>            disp_line(200000, Y1n, X1n, Y2n, X2n)</l>
<l>            distance_pp(Y1n, X1n, Y2n, X2n, D)</l>
<l>            tuple_gen_const( pN, 1, Ones)</l>
<l>            gen_rectangle2(Reg2,(Y1n+Y2n)/2., (X1n+X2n)/2., Ang, D/2.,Ones)</l>
<l>            gen_region_points(RC, (Y1n+Y2n)/2., (X1n+X2n)/2.)</l>
<l>            intersection(Reg2, SkelN, Ps)</l>
<l>            union1(SkelN, SN)</l>
<l>            distance_pr(SN,(Y1n+Y2n)/2., (X1n+X2n)/2.,  Dmin, Dmax)</l>
<c></c>
<c>            </c>
<l>            tuple_concat (Y1N, Y1n, Y1N)</l>
<l>            tuple_concat (X1N, X1n, X1N)</l>
<l>            tuple_concat (Y2N, Y2n, Y2N)</l>
<l>            tuple_concat (X2N, X2n, X2N)</l>
<l>            if(wgntype==0)</l>
<l>                tuple_concat (WGN, Dmin, WGN)</l>
<l>            else </l>
<l>                tuple_gen_const(pN, radmin, Wgn )</l>
<l>                tuple_concat (WGN, Wgn, WGN)</l>
<l>            endif</l>
<c>            </c>
<l>*         else</l>
<l>*             tuple_concat (PCinRnumN, 0, PCinRnumN)</l>
<l>*             tuple_concat (PcontRN, -1, PcontRN)</l>
<l>*         endif</l>
<l>    endfor</l>
<l>    tuple_concat (PaddrRN, paddrC, PaddrRN)</l>
<l>*     tuple_concat (PCinRnumN, indcn, PCinRnumN)</l>
<l>*     tuple_concat (PregN, nnco, PregN)</l>
<c></c>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="MSBuildNonFWM5">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrRN"/>
<parameter id="PcontRN"/>
<parameter id="PnumN"/>
<parameter id="PnumRN"/>
<parameter id="PregCN"/>
<parameter id="RegionsNFWM"/>
<parameter id="SkelN"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthImageP"/>
<parameter id="X1N"/>
<parameter id="X2N"/>
<parameter id="Y1N"/>
<parameter id="Y2N"/>
<parameter id="lookaround"/>
<parameter id="nCGc"/>
<parameter id="sm_factor"/>
<parameter id="wgntype"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain7">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** TeachingMain7 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<l>ROut := R</l>
<c></c>
<c>**** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference(DomainG, ROut, RC)</l>
<c>*** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection(Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection(RC,DomainG, RC)</l>
<l>* stop()</l>
<c></c>
<c>**************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold(Gi, RegionGii, 127, 255)</l>
<l>* difference(RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi:=RegionGii</l>
<l>closing_circle(RegionGii, RegionGi, 1)</l>
<l>connection(RegionGi, RegionsGi)</l>
<l>select_shape(RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj(RegionsGND,nGND)</l>
<c>***** nGND - number of GND-like (big size) regions to be removed from overflowing </c>
<l>intersection(RegionGi, RC, RegionG)</l>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c></c>
<l>* complement(RegionGi, RegionGComplement)</l>
<l>* intersection(RegionGComplement, DomainG, RegionGSi)</l>
<c></c>
<l>difference(DomainG, RegionGi, RegionGSi)</l>
<c></c>
<l>RegionGS:=RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<l>intersection(SkeletonGi, RC, SkeletonG)</l>
<c></c>
<l>skeleton(RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object(SkeletonGS, path+'SkeletonGS.hobj')</l>
<c></c>
<c>*  Finding thin (FWM) pattern</c>
<c>***FWM half width**</c>
<c></c>
<l>opening_circle(RegionG, RegionGOpi, fwmhw)</l>
<c></c>
<l>difference(RegionG, RegionGOpi, RegionGOpDifi)</l>
<l>difference(RegionG, RegionGOpDifi, RegionThicki)</l>
<l>opening_circle(RegionGOpDifi, RegionGthin, parop)</l>
<c></c>
<l>connection(RegionGthin, RegionsGthin)</l>
<l>intersection (RegionGthin, SkeletonG, SkeletonGThin)</l>
<l>area_center(SkeletonGThin, nSkThin, Row2, Column)</l>
<l>connection(SkeletonGThin, SkeletonsGThin)</l>
<l>count_obj(SkeletonsGThin, nSGThin)</l>
<l>* select_shape(RegionsGthini, RegionsGthin, 'contlength', 'and', clen, 99999999)</l>
<l>dev_set_color('red')</l>
<l>dev_display(RegionsGthin)</l>
<l>* stop()</l>
<c>*****</c>
<c>****</c>
<l>opening_circle(RegionGSi, RegionGSOp, fwmhw)</l>
<l>difference(RegionGSi, RegionGSOp, RegionGSOpDifi)</l>
<l>difference(RegionGSi, RegionGSOpDifi, RegionThicki)</l>
<l>opening_circle(RegionGSOpDifi, RegionGSthini, parop)</l>
<l>connection(RegionGSthini, RegionsGSthini)</l>
<l>shape:=['contlength', 'compactness']</l>
<l>select_shape(RegionsGSthini, RegionsGSthin, shape, 'and', [100, 10], [9999999, 99999])</l>
<l>* select_shape (RegionsGSthiniiOut, RegionsGSthiniiOut, 'contlength', 'and', 200, 9999999)</l>
<c></c>
<l>dev_set_color('green')</l>
<l>dev_display(RegionsGSthin)</l>
<l>* stop()</l>
<l>set_system('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<c></c>
<c>**** removing R from SkeletonGi and forming SkeletonG</c>
<l>intersection (SkeletonG, RC, SkeletonG)</l>
<l>GetSkeletonBranches (SkeletonG, WidthImageP, SkeletonsGbr, jrad, gap)</l>
<c></c>
<l>pruning (SkeletonG, SkeletonGii, 2)</l>
<l>* SkeletonG := SkeletonG</l>
<l>junctions_skeleton(SkeletonGii, EndPoints, JuncPoints)</l>
<l>connection(EndPoints,EndPointsc)</l>
<l>count_obj(EndPointsc, ne)</l>
<l>tuple_gen_const(ne, 1, Re)</l>
<l>area_center(EndPointsc, A, Row,Col)</l>
<l>get_grayval(WidthImageP, Row, Col, Erad)</l>
<c></c>
<l>dev_update_off()</l>
<c>*** processing skeleton</c>
<l>SkeletonGPr:=SkeletonG</l>
<l>for j:= 0 to ne-1 by 1</l>
<l>    select_obj(EndPointsc, ObjectSelected, j+1)</l>
<l>    dilation_circle(ObjectSelected, ObjectSelectedD, Erad[j]+7)</l>
<l>    difference(SkeletonGPr, ObjectSelectedD, SkeletonGPr)</l>
<l>endfor</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>maxdif:=5</l>
<l>len:=50</l>
<l>FindSkeletonsFWM (SkeletonsGbr, WidthImageP, SkeletonsFWMi, maxdif, len)</l>
<l>intersection (SkeletonsFWMi, RC, SkeletonsFWM)</l>
<c></c>
<l>* stop()</l>
<c></c>
<c>********* Preping IRB image  *******************</c>
<c></c>
<c>**** preparing for IRB, in teaching stage</c>
<l>num_iter:=999</l>
<l>connection(SkeletonG, SkeletonsG)</l>
<l>gen_image_const(ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const(ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region(RegForbid)</l>
<c></c>
<c></c>
<l>pniovl:=4</l>
<c>*** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>*** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle(RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid:=RegionGSer</l>
<l>RegForbid:=SkeletonGSi</l>
<l>expand_region(SkeletonsG, RegForbid, RegionsPNi, num_iter, 'image')</l>
<l>* union1(SkeletonsFWM,SkeletonFWM)</l>
<l>* intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM_v2)</l>
<l>* dilation_circle(RegionsPNii, RegionsPNi, pniovl)</l>
<l>count_obj(RegionsPNi, nINB)</l>
<l>* write_object(RegionsPNi, path+'RegionsPNi2.hobj')</l>
<l>tuple_gen_sequence(1, nINB, 1, SequenceINBi)</l>
<c>**** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1]:=groundgval</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>SequenceIRB[groundpn-1]:=groundgval</l>
<c>**** new GND</c>
<c>*** start of the sequence </c>
<l>* stseq:= nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1]:=groundgval</l>
<c>*****</c>
<c></c>
<c></c>
<l>union1(RegionsGND, RegionGND)</l>
<c></c>
<l>* complement(RegionGND, RegionGNDC)</l>
<l>difference(DomainG, RegionGND, RegionGNDC)</l>
<l>* complement(RegionG, RegionGS)</l>
<l>difference(DomainG, RegionG, RegionGS)</l>
<l>* expand_region(SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c></c>
<l>* stop()</l>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>intersection(RegionsPNi,SkeletonFWM,  SkeletonsFWM)</l>
<c></c>
<c></c>
<c></c>
<c>*** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<c></c>
<c></c>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>* stop()</l>
<c></c>
<c>************************</c>
<c>**** preparing non-FWM MSs</c>
<l>boundary(RegionG, RegionGB, 'inner')</l>
<c></c>
<l>erosion_circle(RegionG, RegionGer, fwmhw*1.3)</l>
<l>connection(RegionGer, RegionsGer)</l>
<l>dilation_circle(RegionsGer, RegionsGedi, fwmhw*2.0)</l>
<l>select_shape(RegionsGedi, RegionsGed, 'ra', 'and', 15, 999999)</l>
<c></c>
<l>intersection( RegionsGed, RegionGB,BoundariesNFWMi)</l>
<l>count_obj(BoundariesNFWMi, nCGb)</l>
<l>intersection( RegionsGed, RegionG,RegionsNFWM)</l>
<c></c>
<l>* BoundariesNFWM:=RegionsCGb</l>
<c></c>
<l>* intersection(RegionsNFWM, SkeletonGi, SkelN)</l>
<c>*** 0-   1-</c>
<l>wgntype:=1</l>
<c>*** contl</c>
<c></c>
<l>area_center(BoundariesNFWMi,Area, Row1, Column1)</l>
<l>tuple_min(Area, amin)</l>
<c></c>
<l>select_shape(BoundariesNFWMi, BoundariesNFWM,'area', 'and', 50, 99999999)</l>
<c></c>
<l>union1(BoundariesNFWM, BoundaryNFWM)</l>
<l>intersection(RegionsPNi, BoundaryNFWM, BoundariesNFWM)</l>
<c></c>
<l>union1(RegionsNFWM, RegionNFWM)</l>
<l>intersection(RegionsPNi, RegionNFWM, RegionsNFWM)</l>
<l>intersection(RegionsNFWM, SkeletonGi, SkelN)</l>
<l>count_obj (RegionsNFWM, nNonWFM)</l>
<c></c>
<l>MSBuildNonFWM7 (RegionsNFWM, BoundariesNFWM, ImageIR, WidthImageP, SkelN, nNonWFM, sm_factor, lookaround, wpl, wgntype, PnumN, PnumRN, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>gen_region_points(P1N, Y1N, X1N)</l>
<c>*** test R &lt;-&gt; C</c>
<l>rnum:=167</l>
<l>DefN:=[]</l>
<l>cnum:=PcontRN[rnum-1]</l>
<l>rnum2:=PregCN[cnum-1]</l>
<c></c>
<l>nreg:=155</l>
<c>* ncont:=</c>
<l>ncontN:=70</l>
<c></c>
<l>nregn:=PregCN[ncontN-1]</l>
<l>ncontN2:=PcontRN[nregn-1]</l>
<l>ncontN3:=PCinRnumN[nregn-1]</l>
<l>* nNonWFM := nNonWFM</l>
<c></c>
<c></c>
<l>tuple_min(PnumN, minN)</l>
<l>* stop()</l>
<c></c>
<c>******   FWM  Teaching  **************</c>
<c>*****************************************</c>
<l>MSBuildFWM4 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint)</l>
<c>**************************************</c>
<l>gen_region_points(PC, YC, XC)</l>
<l>return ()</l>
</body>
<docu id="TeachingMain7">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildNonFWM6">
<interface>
<io>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="SkelN" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="nCGc" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="wgntype" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildNonFWM6 211120 ****</c>
<l>RowN := []</l>
<l>ColN := []</l>
<l>PnumN := []</l>
<l>pnum:=[]</l>
<l>WN := []</l>
<c>*** address for each region (1 or several contours)</c>
<l>PaddrRN := 0</l>
<c>*** address for each contour</c>
<l>PaddrCN := []</l>
<c>**** number of contours per region</c>
<l>* PregN := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregCN := []</l>
<c>* * number of countours per region</c>
<l>PCinRnumN := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontRN := []</l>
<c>** current Region address</c>
<l>paddrR := 0</l>
<c>** current Contour address</c>
<l>paddrC := 0</l>
<l>pcontn := 1</l>
<l>indcn:=0</l>
<l>AngN:= []</l>
<l>PlenN:=[]</l>
<l>Y1N:=[]</l>
<l>X1N:=[]</l>
<l>Y2N:=[]</l>
<l>X2N:=[]</l>
<l>WGN:=[]</l>
<c></c>
<l>count_obj (BoundariesNFWM, nNonWFM)</l>
<c></c>
<l>gen_empty_obj(ContoursAll)</l>
<l>gen_empty_obj(RegsAll)</l>
<l>* count_obj (SkeletonsGThin, nSGThin)</l>
<l>pn:=0</l>
<l>for j := 1 to nNonWFM by 1</l>
<c>     **** non-FWM region ( full and only boundary regions)</c>
<l>    select_obj (RegionsNFWM, RCgc, j)</l>
<l>    area_center(RCgc, a, r, c)</l>
<l>*     if(j==100)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    if(a&gt;0)</l>
<l>        select_obj (BoundariesNFWM, RCgb, j)</l>
<l>        concat_obj(RegsAll, RCgb, RegsAll)</l>
<l>        skeleton(RCgc,SkeletonRCgc)</l>
<l>        get_region_points(SkeletonRCgc,r, c)</l>
<l>        get_grayval (ImageIR, r, c, gv)</l>
<l>        tuple_median(gv, pnum)</l>
<l>        inner_circle(RCgc, rmin, cmin, radmin)</l>
<c>        ** inner radius to be used as CAD half width</c>
<l>        gen_circle(Circle, rmin, cmin, radmin)</l>
<c>    </c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld(RCgb, Contours1, 3, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours1, Contours, 3, 1, 'attr_forget')</l>
<l>        smooth_contours_xld(Contours, ContoursSmi, sm_factor)</l>
<l>        select_contours_xld(ContoursSmi, ContoursSm, 'contour_length', 30.0, 20000000., -0.5, 0.5)</l>
<l>        count_obj(ContoursSm, nCo)</l>
<l>        tuple_concat (PCinRnumN, nCo, PCinRnumN)</l>
<c>        *** contours of each non-FWM region ( 1 or several)</c>
<l>        nnco:=0</l>
<l>        tuple_concat (PcontRN, pcontn, PcontRN)</l>
<l>        pcontn := pcontn+nCo</l>
<l>        for jj:=1 to nCo by 1</l>
<l>            select_obj(ContoursSm, Contour, jj)</l>
<l>            get_contour_xld (Contour, Row, Col)</l>
<l>            tuple_length (Row, pN)</l>
<l>*             if(pN&gt;30)</l>
<l>                nnco:=nnco+1</l>
<c>                </c>
<l>                concat_obj(ContoursAll, Contour, ContoursAll)</l>
<l>                tuple_gen_const(pN, radmin*2., W)</l>
<l>                tuple_gen_const (pN, j, J)</l>
<l>                tuple_concat (RowN, Row, RowN)</l>
<l>                tuple_concat (ColN, Col, ColN)</l>
<c>                </c>
<l>                 tuple_concat (WN, W, WN)</l>
<l>                tuple_concat (PaddrCN, paddrC, PaddrCN)</l>
<l>                indcn:=indcn+1</l>
<l>                tuple_concat (PregCN, j, PregCN)</l>
<l>                paddrC := paddrC + pN</l>
<l>                get_contour_angle_xld (Contour, 'abs', 'regress', lookaround, AnglesG)</l>
<l>                tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>                Ang:=AnglesG1</l>
<l>                tuple_concat (AngN, Ang, AngN)</l>
<c>    </c>
<l>                Y1t := Row-sin(Ang)*(3)</l>
<l>                X1t := Col+cos(Ang)*(3)</l>
<c>                </c>
<l>                Y1n := Row-sin(Ang)*(wpl)</l>
<l>                X1n := Col+cos(Ang)*(wpl)</l>
<l>                Y2n := Row+sin(Ang)*(wpl)</l>
<l>                X2n := Col-cos(Ang)*(wpl)</l>
<c>                </c>
<l>                tuple_gen_const(pN, pnum, Pnum)</l>
<l>                tuple_concat (PnumN, Pnum, PnumN)</l>
<c>      </c>
<c>                **** swapping P1 and P2 if necessary</c>
<l>                test_region_point (RegionsNFWM, Y1t[pN/2], X1t[pN/2], IsInside)</l>
<l>                if(IsInside)</l>
<l>                    Yt:= Y1n</l>
<l>                    Xt:= X1n</l>
<l>                    X1n:=X2n</l>
<l>                    Y1n:=Y2n</l>
<l>                    X2n:=Xt</l>
<l>                    Y2n:=Yt</l>
<l>                endif</l>
<c>                ****          </c>
<l>                dev_set_color('green')</l>
<l>                disp_line(200000, Y1n, X1n, Y2n, X2n)</l>
<l>                distance_pp(Y1n, X1n, Y2n, X2n, D)</l>
<l>                tuple_gen_const( pN, 1, Ones)</l>
<l>                gen_rectangle2(Reg2,(Y1n+Y2n)/2., (X1n+X2n)/2., Ang, D/2.,Ones)</l>
<l>                gen_region_points(RC, (Y1n+Y2n)/2., (X1n+X2n)/2.)</l>
<l>                intersection(Reg2, SkelN, Ps)</l>
<l>                union1(SkelN, SN)</l>
<l>                distance_pr(SN,(Y1n+Y2n)/2., (X1n+X2n)/2.,  Dmin, Dmax)</l>
<c>    </c>
<c>                </c>
<l>                tuple_concat (Y1N, Y1n, Y1N)</l>
<l>                tuple_concat (X1N, X1n, X1N)</l>
<l>                tuple_concat (Y2N, Y2n, Y2N)</l>
<l>                tuple_concat (X2N, X2n, X2N)</l>
<l>                if(wgntype==0)</l>
<l>                    tuple_concat (WGN, Dmin, WGN)</l>
<l>                else </l>
<l>                    tuple_gen_const(pN, radmin, Wgn )</l>
<l>                    tuple_concat (WGN, Wgn, WGN)</l>
<l>                endif</l>
<l>        endfor</l>
<l>        tuple_concat (PaddrRN, paddrC, PaddrRN)</l>
<l>    else</l>
<l>         tuple_concat (PCinRnumN, 0, PCinRnumN)</l>
<l>         tuple_concat (PcontRN, -1, PcontRN)</l>
<l>*          tuple_concat (PaddrCN, -1, PaddrCN)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="MSBuildNonFWM6">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrRN"/>
<parameter id="PcontRN"/>
<parameter id="PnumN"/>
<parameter id="PnumRN"/>
<parameter id="PregCN"/>
<parameter id="RegionsNFWM"/>
<parameter id="SkelN"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthImageP"/>
<parameter id="X1N"/>
<parameter id="X2N"/>
<parameter id="Y1N"/>
<parameter id="Y2N"/>
<parameter id="lookaround"/>
<parameter id="nCGc"/>
<parameter id="sm_factor"/>
<parameter id="wgntype"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain8">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smooth" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** TeachingMain8 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<l>ROut := R</l>
<c></c>
<c>**** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference(DomainG, ROut, RC)</l>
<c>*** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection(Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection(RC,DomainG, RC)</l>
<l>* stop()</l>
<c></c>
<c>**************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold(Gi, RegionGii, 127, 255)</l>
<l>* difference(RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi:=RegionGii</l>
<l>closing_circle(RegionGii, RegionGi, 1)</l>
<l>connection(RegionGi, RegionsGi)</l>
<l>select_shape(RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj(RegionsGND,nGND)</l>
<c>***** nGND - number of GND-like (big size) regions to be removed from overflowing </c>
<c></c>
<l>connection(RegionGi, RegionsGi)</l>
<l>* smooth:=17</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smooth)</l>
<c></c>
<l>intersection(RegionsGsm, RC, RegionG)</l>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c></c>
<l>* complement(RegionGi, RegionGComplement)</l>
<l>* intersection(RegionGComplement, DomainG, RegionGSi)</l>
<c></c>
<l>difference(DomainG, RegionGi, RegionGSi)</l>
<c></c>
<l>RegionGS:=RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<l>intersection(SkeletonGi, RC, SkeletonG)</l>
<c></c>
<l>skeleton(RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object(SkeletonGS, path+'SkeletonGS.hobj')</l>
<c></c>
<c>*  Finding thin (FWM) pattern</c>
<c>***FWM half width**</c>
<c></c>
<l>opening_circle(RegionG, RegionGOpi, fwmhw)</l>
<c></c>
<l>difference(RegionG, RegionGOpi, RegionGOpDifi)</l>
<l>difference(RegionG, RegionGOpDifi, RegionThicki)</l>
<l>opening_circle(RegionGOpDifi, RegionGthin, parop)</l>
<c></c>
<l>connection(RegionGthin, RegionsGthin)</l>
<l>intersection (RegionGthin, SkeletonG, SkeletonGThin)</l>
<l>area_center(SkeletonGThin, nSkThin, Row2, Column)</l>
<l>connection(SkeletonGThin, SkeletonsGThin)</l>
<l>count_obj(SkeletonsGThin, nSGThin)</l>
<l>* select_shape(RegionsGthini, RegionsGthin, 'contlength', 'and', clen, 99999999)</l>
<l>dev_set_color('red')</l>
<l>dev_display(RegionsGthin)</l>
<l>* stop()</l>
<c>*****</c>
<c>****</c>
<l>opening_circle(RegionGSi, RegionGSOp, fwmhw)</l>
<l>difference(RegionGSi, RegionGSOp, RegionGSOpDifi)</l>
<l>difference(RegionGSi, RegionGSOpDifi, RegionThicki)</l>
<l>opening_circle(RegionGSOpDifi, RegionGSthini, parop)</l>
<l>connection(RegionGSthini, RegionsGSthini)</l>
<l>shape:=['contlength', 'compactness']</l>
<l>select_shape(RegionsGSthini, RegionsGSthin, shape, 'and', [100, 10], [9999999, 99999])</l>
<l>* select_shape (RegionsGSthiniiOut, RegionsGSthiniiOut, 'contlength', 'and', 200, 9999999)</l>
<c></c>
<l>dev_set_color('green')</l>
<l>dev_display(RegionsGSthin)</l>
<l>* stop()</l>
<l>set_system('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<c></c>
<c>**** removing R from SkeletonGi and forming SkeletonG</c>
<l>intersection (SkeletonG, RC, SkeletonG)</l>
<l>GetSkeletonBranches (SkeletonG, WidthImageP, SkeletonsGbr, jrad, gap)</l>
<c></c>
<l>pruning (SkeletonG, SkeletonGii, 2)</l>
<l>* SkeletonG := SkeletonG</l>
<l>junctions_skeleton(SkeletonGii, EndPoints, JuncPoints)</l>
<l>connection(EndPoints,EndPointsc)</l>
<l>count_obj(EndPointsc, ne)</l>
<l>tuple_gen_const(ne, 1, Re)</l>
<l>area_center(EndPointsc, A, Row,Col)</l>
<l>get_grayval(WidthImageP, Row, Col, Erad)</l>
<c></c>
<l>dev_update_off()</l>
<c>*** processing skeleton</c>
<l>SkeletonGPr:=SkeletonG</l>
<l>for j:= 0 to ne-1 by 1</l>
<l>    select_obj(EndPointsc, ObjectSelected, j+1)</l>
<l>    dilation_circle(ObjectSelected, ObjectSelectedD, Erad[j]+7)</l>
<l>    difference(SkeletonGPr, ObjectSelectedD, SkeletonGPr)</l>
<l>endfor</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>maxdif:=5</l>
<l>len:=50</l>
<l>FindSkeletonsFWM (SkeletonsGbr, WidthImageP, SkeletonsFWMi, maxdif, len)</l>
<l>intersection (SkeletonsFWMi, RC, SkeletonsFWM)</l>
<c></c>
<l>* stop()</l>
<c></c>
<c>********* Preping IRB image  *******************</c>
<c></c>
<c>**** preparing for IRB, in teaching stage</c>
<l>num_iter:=999</l>
<l>connection(SkeletonG, SkeletonsG)</l>
<l>gen_image_const(ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const(ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region(RegForbid)</l>
<c></c>
<c></c>
<l>pniovl:=4</l>
<c>*** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>*** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle(RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid:=RegionGSer</l>
<l>RegForbid:=SkeletonGSi</l>
<l>expand_region(SkeletonsG, RegForbid, RegionsPNi, num_iter, 'image')</l>
<l>* union1(SkeletonsFWM,SkeletonFWM)</l>
<l>* intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM_v2)</l>
<l>* dilation_circle(RegionsPNii, RegionsPNi, pniovl)</l>
<l>count_obj(RegionsPNi, nINB)</l>
<l>* write_object(RegionsPNi, path+'RegionsPNi2.hobj')</l>
<l>tuple_gen_sequence(1, nINB, 1, SequenceINBi)</l>
<c>**** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1]:=groundgval</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>SequenceIRB[groundpn-1]:=groundgval</l>
<c>**** new GND</c>
<c>*** start of the sequence </c>
<l>* stseq:= nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1]:=groundgval</l>
<c>*****</c>
<c></c>
<c></c>
<l>union1(RegionsGND, RegionGND)</l>
<c></c>
<l>* complement(RegionGND, RegionGNDC)</l>
<l>difference(DomainG, RegionGND, RegionGNDC)</l>
<l>* complement(RegionG, RegionGS)</l>
<l>difference(DomainG, RegionG, RegionGS)</l>
<l>* expand_region(SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c></c>
<l>* stop()</l>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>intersection(RegionsPNi,SkeletonFWM,  SkeletonsFWM)</l>
<c></c>
<c></c>
<c></c>
<c>*** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<c></c>
<c></c>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>* stop()</l>
<c></c>
<c>************************</c>
<c>**** preparing non-FWM MSs</c>
<l>boundary(RegionG, RegionGB, 'inner')</l>
<c></c>
<l>erosion_circle(RegionG, RegionGer, fwmhw*1.3)</l>
<l>connection(RegionGer, RegionsGer)</l>
<l>dilation_circle(RegionsGer, RegionsGedi, fwmhw*2.0)</l>
<l>select_shape(RegionsGedi, RegionsGed, 'ra', 'and', 15, 999999)</l>
<c></c>
<l>intersection( RegionsGed, RegionGB,BoundariesNFWMi)</l>
<l>count_obj(BoundariesNFWMi, nCGb)</l>
<l>intersection( RegionsGed, RegionG,RegionsNFWM)</l>
<c></c>
<l>* BoundariesNFWM:=RegionsCGb</l>
<c></c>
<l>* intersection(RegionsNFWM, SkeletonGi, SkelN)</l>
<c>*** 0-   1-</c>
<l>wgntype:=1</l>
<c>*** contl</c>
<c></c>
<l>area_center(BoundariesNFWMi,Area, Row1, Column1)</l>
<l>tuple_min(Area, amin)</l>
<c></c>
<l>select_shape(BoundariesNFWMi, BoundariesNFWM,'area', 'and', 50, 99999999)</l>
<c></c>
<l>union1(BoundariesNFWM, BoundaryNFWM)</l>
<l>intersection(RegionsPNi, BoundaryNFWM, BoundariesNFWM)</l>
<c></c>
<l>union1(RegionsNFWM, RegionNFWM)</l>
<l>intersection(RegionsPNi, RegionNFWM, RegionsNFWM)</l>
<l>intersection(RegionsNFWM, SkeletonGi, SkelN)</l>
<l>count_obj (RegionsNFWM, nNonWFM)</l>
<c></c>
<l>MSBuildNonFWM7 (RegionsNFWM, BoundariesNFWM, ImageIR, WidthImageP, SkelN, nNonWFM, sm_factor, lookaround, wpl, wgntype, PnumN, PnumRN, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>gen_region_points(P1N, Y1N, X1N)</l>
<c>*** test R &lt;-&gt; C</c>
<l>rnum:=167</l>
<l>DefN:=[]</l>
<l>cnum:=PcontRN[rnum-1]</l>
<l>rnum2:=PregCN[cnum-1]</l>
<c></c>
<l>nreg:=155</l>
<c>* ncont:=</c>
<l>ncontN:=70</l>
<c></c>
<l>nregn:=PregCN[ncontN-1]</l>
<l>ncontN2:=PcontRN[nregn-1]</l>
<l>ncontN3:=PCinRnumN[nregn-1]</l>
<l>* nNonWFM := nNonWFM</l>
<c></c>
<c></c>
<l>tuple_min(PnumN, minN)</l>
<l>* stop()</l>
<c></c>
<c>******   FWM  Teaching  **************</c>
<c>*****************************************</c>
<l>MSBuildFWM4 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint)</l>
<c>**************************************</c>
<l>gen_region_points(PC, YC, XC)</l>
<l>return ()</l>
</body>
<docu id="TeachingMain8">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smooth"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildNonFWM7">
<interface>
<io>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="SkelN" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="nCGc" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="wgntype" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildNonFWM7 211212 ****</c>
<c>** corrected for -1</c>
<c>* 220111 fixed bug in inside/outside detection (lines 109-114)</c>
<l>RowN := []</l>
<l>ColN := []</l>
<l>PnumN := []</l>
<l>pnum:=[]</l>
<l>WN := []</l>
<c>*** address for each region (1 or several contours)</c>
<l>PaddrRN := 0</l>
<c>*** address for each contour</c>
<l>PaddrCN := []</l>
<c>**** number of contours per region</c>
<l>* PregN := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregCN := []</l>
<c>* * number of countours per region</c>
<l>PCinRnumN := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontRN := []</l>
<c>** current Region address</c>
<l>paddrR := 0</l>
<c>** current Contour address</c>
<l>paddrC := 0</l>
<l>pcontn := 1</l>
<l>indcn:=0</l>
<l>AngN:= []</l>
<l>PlenN:=[]</l>
<l>Y1N:=[]</l>
<l>X1N:=[]</l>
<l>Y2N:=[]</l>
<l>X2N:=[]</l>
<l>WGN:=[]</l>
<c></c>
<l>count_obj (BoundariesNFWM, nNonWFM)</l>
<c></c>
<l>gen_empty_obj(ContoursAll)</l>
<l>gen_empty_obj(RegsAll)</l>
<l>* count_obj (SkeletonsGThin, nSGThin)</l>
<l>pn:=0</l>
<l>for j := 1 to nNonWFM by 1</l>
<c>     **** non-FWM region ( full and only boundary regions)</c>
<l>    select_obj (RegionsNFWM, RCgc, j)</l>
<l>    area_center(RCgc, a, r, c)</l>
<l>*     if(j==100)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    if(a&gt;0)</l>
<l>        select_obj (BoundariesNFWM, RCgb, j)</l>
<l>        concat_obj(RegsAll, RCgb, RegsAll)</l>
<l>        skeleton(RCgc,SkeletonRCgc)</l>
<l>        get_region_points(SkeletonRCgc,r, c)</l>
<l>        get_grayval (ImageIR, r, c, gv)</l>
<l>        tuple_median(gv, pnum)</l>
<l>        inner_circle(RCgc, rmin, cmin, radmin)</l>
<c>        ** inner radius to be used as CAD half width</c>
<l>        gen_circle(Circle, rmin, cmin, radmin)</l>
<c>    </c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld(RCgb, Contours1, 3, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours1, Contours, 3, 1, 'attr_forget')</l>
<l>        smooth_contours_xld(Contours, ContoursSmi, sm_factor)</l>
<l>        select_contours_xld(ContoursSmi, ContoursSm, 'contour_length', 30.0, 20000000., -0.5, 0.5)</l>
<l>        count_obj(ContoursSm, nCo)</l>
<l>        tuple_concat (PCinRnumN, nCo, PCinRnumN)</l>
<c>        *** contours of each non-FWM region ( 1 or several)</c>
<l>        nnco:=0</l>
<l>        tuple_concat (PcontRN, pcontn, PcontRN)</l>
<l>        pcontn := pcontn+nCo</l>
<l>        for jj:=1 to nCo by 1</l>
<l>            select_obj(ContoursSm, Contour, jj)</l>
<l>            get_contour_xld (Contour, Row, Col)</l>
<l>            tuple_length (Row, pN)</l>
<l>*             if(pN&gt;30)</l>
<l>                nnco:=nnco+1</l>
<c>                </c>
<l>                concat_obj(ContoursAll, Contour, ContoursAll)</l>
<l>                tuple_gen_const(pN, radmin*2., W)</l>
<l>                tuple_gen_const (pN, j, J)</l>
<l>                tuple_concat (RowN, Row, RowN)</l>
<l>                tuple_concat (ColN, Col, ColN)</l>
<c>                </c>
<l>                 tuple_concat (WN, W, WN)</l>
<l>                tuple_concat (PaddrCN, paddrC, PaddrCN)</l>
<l>                indcn:=indcn+1</l>
<l>                tuple_concat (PregCN, j, PregCN)</l>
<l>                paddrC := paddrC + pN</l>
<l>                get_contour_angle_xld (Contour, 'abs', 'regress', lookaround, AnglesG)</l>
<l>                tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>                Ang:=AnglesG1</l>
<l>                tuple_concat (AngN, Ang, AngN)</l>
<c>    </c>
<l>                Y1t := Row-sin(Ang)*(3)</l>
<l>                X1t := Col+cos(Ang)*(3)</l>
<c>                </c>
<l>                Y1n := Row-sin(Ang)*(wpl)</l>
<l>                X1n := Col+cos(Ang)*(wpl)</l>
<l>                Y2n := Row+sin(Ang)*(wpl)</l>
<l>                X2n := Col-cos(Ang)*(wpl)</l>
<c>                </c>
<l>                tuple_gen_const(pN, pnum, Pnum)</l>
<l>                tuple_concat (PnumN, Pnum, PnumN)</l>
<c>      </c>
<c>                **** swapping P1 and P2 if necessary</c>
<l>*                 test_region_point (RegionsNFWM, Y1t[pN/2], X1t[pN/2], IsInside)</l>
<l>                n:=pN/6</l>
<l>                test_region_point (RegionsNFWM, Y1t[n], X1t[n],     IsInside1)</l>
<l>                test_region_point (RegionsNFWM, Y1t[2*n], X1t[2*n], IsInside2)</l>
<l>                test_region_point (RegionsNFWM, Y1t[3*n], X1t[3*n], IsInside3)</l>
<l>                test_region_point (RegionsNFWM, Y1t[4*n], X1t[4*n], IsInside4)</l>
<l>                test_region_point (RegionsNFWM, Y1t[5*n], X1t[5*n], IsInside5)</l>
<l>                tuple_median([IsInside1, IsInside2, IsInside3, IsInside4, IsInside5], IsInside)</l>
<l>                if(IsInside)</l>
<l>                    Yt:= Y1n</l>
<l>                    Xt:= X1n</l>
<l>                    X1n:=X2n</l>
<l>                    Y1n:=Y2n</l>
<l>                    X2n:=Xt</l>
<l>                    Y2n:=Yt</l>
<l>                endif</l>
<c>                ****          </c>
<l>                dev_set_color('green')</l>
<l>                disp_line(200000, Y1n, X1n, Y2n, X2n)</l>
<l>                distance_pp(Y1n, X1n, Y2n, X2n, D)</l>
<l>                tuple_gen_const( pN, 1, Ones)</l>
<l>                gen_rectangle2(Reg2,(Y1n+Y2n)/2., (X1n+X2n)/2., Ang, D/2.,Ones)</l>
<l>                gen_region_points(RC, (Y1n+Y2n)/2., (X1n+X2n)/2.)</l>
<l>                intersection(Reg2, SkelN, Ps)</l>
<l>                union1(SkelN, SN)</l>
<l>                distance_pr(SN,(Y1n+Y2n)/2., (X1n+X2n)/2.,  Dmin, Dmax)</l>
<c>    </c>
<c>                </c>
<l>                tuple_concat (Y1N, Y1n, Y1N)</l>
<l>                tuple_concat (X1N, X1n, X1N)</l>
<l>                tuple_concat (Y2N, Y2n, Y2N)</l>
<l>                tuple_concat (X2N, X2n, X2N)</l>
<l>                if(wgntype==0)</l>
<l>                    tuple_concat (WGN, Dmin, WGN)</l>
<l>                else </l>
<l>                    tuple_gen_const(pN, radmin, Wgn )</l>
<l>                    tuple_concat (WGN, Wgn, WGN)</l>
<l>                endif</l>
<l>        endfor</l>
<l>        tuple_concat (PaddrRN, paddrC, PaddrRN)</l>
<l>    else</l>
<l>         tuple_concat (PCinRnumN, 0, PCinRnumN)</l>
<l>         tuple_concat (PcontRN, -1, PcontRN)</l>
<l>*          tuple_concat (PaddrCN, -1, PaddrCN)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="MSBuildNonFWM7">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrRN"/>
<parameter id="PcontRN"/>
<parameter id="PnumN"/>
<parameter id="PnumRN"/>
<parameter id="PregCN"/>
<parameter id="RegionsNFWM"/>
<parameter id="SkelN"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthImageP"/>
<parameter id="X1N"/>
<parameter id="X2N"/>
<parameter id="Y1N"/>
<parameter id="Y2N"/>
<parameter id="lookaround"/>
<parameter id="nCGc"/>
<parameter id="sm_factor"/>
<parameter id="wgntype"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="SmoothingRegion">
<interface>
<io>
<par name="RegionsG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsGsm" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="smooth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* *** smoothing CAD regions ******</c>
<l>count_obj (RegionsG, nG)</l>
<c></c>
<l>* smooth := 11</l>
<l>if(smooth&gt;=3)</l>
<l>    gen_empty_obj (RegionsGsm)</l>
<l>    for j := 1 to nG by 1</l>
<l>*         if (j==1235)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>        select_obj (RegionsG, RegGsel, j)</l>
<l>        area_center(RegGsel, a, Row, Column)</l>
<l>        if(a&lt;10)</l>
<l>            continue</l>
<l>        endif</l>
<c>        </c>
<l>            gen_contour_region_xld (RegGsel, Contours, 'border_holes')</l>
<l>            smooth_contours_xld (Contours, SmoothedContours, smooth)</l>
<l>            get_contour_angle_xld(SmoothedContours, 'abs', 'range', 3, Angles)</l>
<l>            gen_region_contour_xld (SmoothedContours, Regions, 'filled')</l>
<l>            count_obj (Regions, nR)</l>
<l>            select_obj (Regions, Rs, 1)</l>
<l>            if (nR==1)</l>
<l>                Rsmoothedj := Rs</l>
<l>            else</l>
<l>                gen_empty_obj (Rinside)</l>
<l>                for k := 2 to nR by 1</l>
<l>                    select_obj (Regions, Rsn, k)</l>
<l>                    concat_obj (Rinside, Rsn, Rinside)</l>
<l>                endfor</l>
<l>                difference (Rs, Rinside, Rsmoothedj)</l>
<l>            endif</l>
<l>            concat_obj (RegionsGsm, Rsmoothedj, RegionsGsm)</l>
<l>*         else</l>
<c>            </c>
<c>        </c>
<c>     </c>
<l>    endfor</l>
<l>else</l>
<l>    RegionsGsm:=RegionsG</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="SmoothingRegion">
<parameters>
<parameter id="RegionsG"/>
<parameter id="RegionsGsm"/>
<parameter id="smooth"/>
</parameters>
</docu>
</procedure>
<procedure name="MeasIntBresenham15N">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** V14N (MeasIntBresenham14N -Non-FWM)</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c></c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<l>g2 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>* intersection (PPR, RegionIRB, RegionInt)</l>
<l>* get_region_points (RegionInt, Rows, Columns)</l>
<l>* tuple_length (Rows, l)</l>
<l>* if (l&lt;2)</l>
<l>*     wmax := 0</l>
<l>*     return ()</l>
<l>* endif</l>
<c></c>
<l>* if (pnum ==0)</l>
<l>*     get_grayval (ImageIRB, Rows, Columns, Grayval)</l>
<l>*     tuple_median (Grayval, pnum)</l>
<l>* endif</l>
<c></c>
<c>* Processing</c>
<c>* ** going forward from PS1</c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>PIntY := []</l>
<l>PIntX := []</l>
<l>i0 := -1</l>
<l>i1 := -1</l>
<l>i2 := -1</l>
<l>bfound := 0</l>
<l>np := 0</l>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        if (bfound==0)</l>
<c>            * real def. beginning</c>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>            bfound := 1</l>
<l>            np := 1</l>
<l>        elseif (bfound==2)</l>
<l>            bfound := 1</l>
<l>        elseif (bfound==3)</l>
<l>            PIntX[2] := xc</l>
<l>            PIntY[2] := yc</l>
<l>            i2 := i</l>
<c>            * end of 1st search</c>
<l>            bfound := 4</l>
<l>            np := 3</l>
<l>            break</l>
<l>        endif</l>
<l>    elseif (v==1)</l>
<l>        if (bfound==0)</l>
<c>            * preliminary def. beginning</c>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>            bfound := 2</l>
<l>            np := 1</l>
<l>        endif</l>
<l>    elseif (v==0)</l>
<c>        * space pixel</c>
<l>        if (bfound==1)</l>
<c>            * end of real def. beginning search</c>
<l>            PIntX[1] := PPx[i-1]</l>
<l>            PIntY[1] := PPy[i-1]</l>
<l>            i1 := i-1</l>
<c>            * end of 1st search</c>
<l>            bfound := 3</l>
<l>            np := 2</l>
<l>*             break</l>
<l>        elseif (bfound==2)</l>
<l>            bfound := 0</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* ** tremoving last intersection if P2 is outside of pattern</c>
<l>* if (Pval[pind-1]==0)</l>
<l>*     tuple_length (PIntX, n)</l>
<l>*     tuple_remove (PIntX, n-1, PIntX)</l>
<l>*     tuple_remove (PIntY, n-1, PIntY)</l>
<l>* endif</l>
<l>PCX := (ix1+ix2)/2.</l>
<l>PCY := (iy1+iy2)/2.</l>
<l>wc := sqrt( (PCX - ix2)*(PCX - ix2) + (PCY - iy2)*(PCY - iy2) )</l>
<l>if (np==0)</l>
<l>    wmax := -wc</l>
<l>    wmin := -wc</l>
<l>    PIntX[0] := ix2</l>
<l>    PIntY[0] := iy2</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Pval[pind-1]==0 and np&gt;1)</l>
<l>    PIntX[np-1] := 0</l>
<l>    PIntY[np-1] := 0</l>
<l>    np := np-1</l>
<l>endif</l>
<l>gen_region_points (Region, PIntY, PIntX)</l>
<l>if (i0==-1)</l>
<l>    wmin := 0</l>
<l>    wmax := 0</l>
<l>*     return ()</l>
<l>endif</l>
<l>ppi00x := PPx[i0]</l>
<l>ppi00y := PPy[i0]</l>
<l>ppi0p1x := PPx[i0+1]</l>
<l>ppi0p1y := PPy[i0+1]</l>
<l>ppi0m1x := PPx[i0-1]</l>
<l>ppi0m1y := PPy[i0-1]</l>
<l>gen_region_points (P0, PPy[i0], PPx[i0])</l>
<c></c>
<l>if (i1&gt;=0 and i1&lt;pind-1)</l>
<l>    ppi10x := PPx[i1]</l>
<l>    ppi10y := PPy[i1]</l>
<l>    ppi1p1x := PPx[i1+1]</l>
<l>    ppi1p1y := PPy[i1+1]</l>
<l>    ppi1m1x := PPx[i1-1]</l>
<l>    ppi1m1y := PPy[i1-1]</l>
<c></c>
<l>    gen_region_points (P1, PPy[i1], PPx[i1])</l>
<l>endif</l>
<c></c>
<l>if (i2&gt;=0 and i2&lt;pind-1)</l>
<l>    ppi20x := PPx[i2]</l>
<l>    ppi20y := PPy[i2]</l>
<l>    ppi2p1x := PPx[i2+1]</l>
<l>    ppi2p1y := PPy[i2+1]</l>
<l>    ppi2m1x := PPx[i2-1]</l>
<l>    ppi2m1y := PPy[i2-1]</l>
<c></c>
<l>    gen_region_points (P2, PPy[i2], PPx[i2])</l>
<l>endif</l>
<l>* if (i3&gt;=0)</l>
<l>*     gen_region_points (P3, PPy[i3], PPx[i3])</l>
<l>* endif</l>
<c></c>
<c>* ***** subpixel for 1st intersection point</c>
<l>get_grayval (Im, ppi00y, ppi00x, g)</l>
<l>g0[1] := g</l>
<l>get_grayval (Im, ppi0m1y, ppi0m1x, g)</l>
<l>g0[0] := g</l>
<l>get_grayval (Im, ppi0p1y, ppi0p1x, g)</l>
<l>g0[2] := g</l>
<l>SubPixCrdT (g0, i0, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[0] := pIntX</l>
<l>PIntY[0] := pIntY</l>
<l>* create_funct_1d_array (g0, Fg0)</l>
<l>* invert_funct_1d (Fg0, Fg0i)</l>
<l>* get_y_value_funct_1d (Fg0i, 50, 'constant', dy0)</l>
<l>* tuple_length (PIntX, np)</l>
<c>* ***** subpixel for 2nd intersection point</c>
<l>if (i1 != i0 and np&gt;1)</l>
<l>    get_grayval (Im, ppi10y, ppi10x, g)</l>
<l>    g1[1] := g</l>
<l>    get_grayval (Im, ppi1m1y, ppi1m1x, g)</l>
<l>    g1[0] := g</l>
<l>    get_grayval (Im, ppi1p1y, ppi1p1x, g)</l>
<l>    g1[2] := g</l>
<c></c>
<c></c>
<l>SubPixCrdT (g1, i1, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[1] := pIntX</l>
<l>    PIntY[1] := pIntY</l>
<l>endif</l>
<c></c>
<l>* twolines := 0</l>
<c>* ***** subpixel for 3rd intersection point</c>
<l>if (i2 != i1 and np&gt;2)</l>
<l>    get_grayval (Im, PPy[i2], PPx[i2], g)</l>
<l>    g2[1] := g</l>
<l>    get_grayval (Im, PPy[i2-1], PPx[i2-1], g)</l>
<l>    g2[0] := g</l>
<l>    get_grayval (Im, PPy[i2+1], PPx[i2+1], g)</l>
<l>    g2[2] := g</l>
<c></c>
<l>SubPixCrdT (g2, i2, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[2] := pIntX</l>
<l>    PIntY[2] := pIntY</l>
<l>*     twolines := 1</l>
<l>endif</l>
<c></c>
<c>* ****  reference point *****</c>
<c></c>
<l>gen_region_points (RC, PCY, PCX)</l>
<l>wmin := 0</l>
<l>if (np&gt;0)</l>
<l>    if (PIntX[0] != 0)</l>
<l>*         wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<l>        wmax := sqrt( (PIntX[0] - ix2)*(PIntX[0] - ix2) + (PIntY[0] - iy2)*(PIntY[0] - iy2) )</l>
<l>        wmin := wmax</l>
<l>    endif</l>
<l>    if (np&gt;1)</l>
<l>        wmin := sqrt( (PIntX[1] - ix2)*(PIntX[1] - ix2) + (PIntY[1] - iy2)*(PIntY[1] - iy2) )</l>
<l>    endif</l>
<l>    if (np&gt;2)</l>
<l>        wmin := sqrt( (PIntX[2] - ix2)*(PIntX[2] - ix2) + (PIntY[2] - iy2)*(PIntY[2] - iy2) )</l>
<l>    endif</l>
<l>    wmax := wmax-wc</l>
<l>    wmin := wmin-wc</l>
<l>else</l>
<l>    wmax := 0</l>
<l>    wmin := 0</l>
<l>endif</l>
<c></c>
<c>* end p.********************************</c>
<l>return ()</l>
</body>
<docu id="MeasIntBresenham15N">
<parameters>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterM4N2">
<interface>
<ic>
<par name="Func" base_type="ctrl" dimension="0"/>
<par name="size1" base_type="ctrl" dimension="0"/>
<par name="size2" base_type="ctrl" dimension="0"/>
<par name="sm" base_type="ctrl" dimension="0"/>
<par name="ang" base_type="ctrl" dimension="0"/>
<par name="andnoor" base_type="ctrl" dimension="0"/>
<par name="avsz" base_type="ctrl" dimension="0"/>
<par name="prcm" base_type="ctrl" dimension="0"/>
<par name="prcp" base_type="ctrl" dimension="0"/>
<par name="mabs" base_type="ctrl" dimension="0"/>
<par name="pabs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>num_points_funct_1d (Func, n)</l>
<l>if (sm&gt;0)</l>
<l>    smooth_funct_1d_mean (Func, sm, 1, SmoothedFunction)</l>
<l>endif</l>
<l>tang := tan(ang*3.14159/180.)</l>
<l>Y := []</l>
<l>D := []</l>
<l>Dav := []</l>
<l>Prc := []</l>
<l>Prc2 := []</l>
<l>Def := []</l>
<l>for j := 0 to n-1 by 1</l>
<l>*     if (j==154)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    jm := j-size1</l>
<l>    if (jm&lt;0)</l>
<l>        jm := 0</l>
<l>    endif</l>
<l>    jp := j+size1</l>
<l>    if (jp&gt;n-1)</l>
<l>        jp := n-1</l>
<l>    endif</l>
<l>    jm2 := j-size2</l>
<l>    if (jm2&lt;0)</l>
<l>        jm2 := 0</l>
<l>    endif</l>
<l>    jp2 := j+size2</l>
<l>    if (jp2&gt;n-1)</l>
<l>        jp2 := n-1</l>
<l>    endif</l>
<l>    get_pair_funct_1d (Func, j, x, y)</l>
<l>    get_pair_funct_1d (Func, jp, xp, yp)</l>
<l>    get_pair_funct_1d (Func, jm, xm, ym)</l>
<l>    get_pair_funct_1d (Func, jp2, xp2, yp2)</l>
<l>    get_pair_funct_1d (Func, jm2, xm2, ym2)</l>
<l>*     angle_lx (ym, xm, yp, xp, angl)</l>
<l>*     angle_lx (ym2, xm2, yp2, xp2, angl2)</l>
<l>*     ta := abs(tan(angl))</l>
<l>*     ta2 := abs(tan(angl2))</l>
<l>AngleDist (y, x, ym, xm, yp, xp, d, ta)</l>
<l>AngleDist (y, x, ym2, xm2, yp2, xp2, d2, ta2)</l>
<l>*     distance_ps (y, x, ym, xm, yp, xp, d, DistanceMax)</l>
<l>*     distance_ps (y, x, ym2, xm2, yp2, xp2, d2, DistanceMax)</l>
<l>*     ang := 0.1</l>
<l>*     a := abs(angl)*180./3.1416</l>
<l>*     a2 := abs(angl2)*180./3.1416</l>
<c></c>
<c></c>
<l>    if (abs(ta) &lt;= tang)</l>
<l>        dm := d</l>
<l>    else</l>
<l>        dm := 0</l>
<l>    endif</l>
<c></c>
<c></c>
<l>    if (abs(ta2) &lt;= tang)</l>
<l>        dm2 := d2</l>
<l>    else</l>
<l>        dm2 := 0</l>
<l>    endif</l>
<c></c>
<c></c>
<l>    yav := abs(ym+yp)/2</l>
<l>    yav2 := abs(ym2+yp2)/2</l>
<l>*     prcm := abs(d)/abs(yav)</l>
<l>    tuple_concat (Y, y, Y)</l>
<l>    tuple_mean (Y, Ymean)</l>
<l>    tuple_median (Y, Ymed)</l>
<l>    tuple_concat (D, dm, D)</l>
<l>    tuple_min ([yav, yav2], yavm)</l>
<c></c>
<c></c>
<l>    if (dm &lt; -mabs and dm2 &lt; -mabs)</l>
<l>        def := min2(dm, dm2)</l>
<l>    elseif (dm &gt; pabs and dm2 &gt; pabs)</l>
<l>        def := max2(dm, dm2)</l>
<l>    elseif (y &gt; prcp or y &lt; -prcm)</l>
<l>        def := y</l>
<l>    else</l>
<l>        def := 0</l>
<l>    endif</l>
<c></c>
<l>    tuple_concat (Def, def, Def)</l>
<c>    * ** 1 AND 2</c>
<c></c>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="FilterM4N2">
<parameters>
<parameter id="Def"/>
<parameter id="Func"/>
<parameter id="Prc"/>
<parameter id="andnoor"/>
<parameter id="ang"/>
<parameter id="avsz"/>
<parameter id="mabs"/>
<parameter id="pabs"/>
<parameter id="prcm"/>
<parameter id="prcp"/>
<parameter id="size1"/>
<parameter id="size2"/>
<parameter id="sm"/>
</parameters>
</docu>
</procedure>
<procedure name="ImagePrepThr">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Domain" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIi" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size (Im, Width, Height)</l>
<l>get_domain (Im, Domain)</l>
<l>boundary (Domain, DomainBorder, 'inner')</l>
<l>complement (DomainBorder, DomainBorderComplement)</l>
<l>boundary (R, RBorder, 'outer')</l>
<l>complement (RBorder, RBorderComplement)</l>
<c></c>
<c>* histo_to_thresh(RelativeHisto,</c>
<l>threshold (Im, RegionIi, thr, 255)</l>
<c></c>
<l>intersection (RegionIi, RC, RegionI)</l>
<l>intersection (RegionI, DomainBorderComplement, RegionI)</l>
<l>count_obj(RBorderComplement, nRBC)</l>
<c>** checking if not empty</c>
<l>if(nRBC!=0)</l>
<l>   intersection (RegionI, RBorderComplement, RegionI) </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ImagePrepThr">
<parameters>
<parameter id="Domain"/>
<parameter id="Height"/>
<parameter id="Im"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RegionI"/>
<parameter id="RegionIi"/>
<parameter id="Width"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBm4_COPY_1">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="H" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_image_const (ImageIRB, 'byte', W, H)</l>
<l>count_obj (RegionsPNi, nPNi)</l>
<l>* union2 (RegionIS, RegionsShm, RegForbid)</l>
<l>* expand_region (SkeletonsGThin, RegForbid, RegionsPNi, 'maximal', 'image')</l>
<l>intersection (RegionsPNi, RegionInoD, RegionsPN)</l>
<c></c>
<l>boundary (RegionsPN, RegionsINB, 'inner')</l>
<l>count_obj (RegionsINB, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* union1 (RegionsShm, RegionShm)</l>
<l>* difference (RegionInoD, RegionShm, RegionIm)</l>
<l>paint_region (RegionInoD, ImageIRB, ImageIRB, 1, 'fill')</l>
<l>paint_region (RegionsINB, ImageIRB, ImageIRB, SequenceIRB, 'fill')</l>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="BuildIRBm4_COPY_1">
<short lang="en_US">RegionInoD - Real Image region with defects (PH, Isl) removed</short>
<parameters>
<parameter id="H"/>
<parameter id="ImageIRB"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="W"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenFU2">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
<par name="d" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nOp" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** OPEN  FillUp******</c>
<l>if(d&gt;1)</l>
<l>    dilation_circle (RegionI, RegionId, d)</l>
<l>else</l>
<l>    RegionId:=RegionI</l>
<l>endif</l>
<c></c>
<l>difference (SkeletonG, RegionId, RegionSkGI)</l>
<l>connection (RegionSkGI, RegionsSkGI)</l>
<l>area_center (RegionsSkGI, Area, RowOpC, ColOpC)</l>
<l>gen_region_points (RC, RowOpC, ColOpC)</l>
<l>tuple_length (RowOpC, nOpC)</l>
<c></c>
<l>nOp := 0</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>for j := 1 to nOpC by 1</l>
<l>    select_obj (RegionsSkGI, RegionsSkGISel, j)</l>
<l>    get_region_points (RegionsSkGISel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>    if(j==239)</l>
<l>        stop()</l>
<l>    endif</l>
<l>*     gen_region_points (R, row, col)</l>
<l>*     if (row&gt;5415 and row&lt;5423)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     gen_region_points (P, Rows[np/2], Cols[np/2])</l>
<l>    get_grayval (DirImageP, row, col, dirOpC)</l>
<l>    get_grayval (WidthImageP, row, col, widthOpC)</l>
<c></c>
<l>*     angsOpC := dirOpC*3.1415926/256.0</l>
<l>    angsOpC := dirOpC*0.012271846</l>
<c></c>
<l>    region_features (RegionsSkGISel, 'rect2_len1', l1)</l>
<l>    tuple_max2 (widthOpC*coef/2, l1+wgap*2, recw)</l>
<l>    gen_rectangle2 (Rect, row, col, angsOpC, widthOpC*coef/2, recw)</l>
<l>    intersection (Rect, RegionI, RegionIR)</l>
<l>    connection (RegionIR, RegionsIRCon)</l>
<l>    count_obj (RegionsIRCon, nR)</l>
<l>    intersection (Rect, SkeletonG, SkelGR)</l>
<l>    connection (SkelGR, SkelGRCon)</l>
<l>    count_obj (SkelGRCon, nS)</l>
<c></c>
<l>*     intersection (RegionsIRCon, SkeletonG, RegionsIRConSkeli)</l>
<l>*     select_shape (RegionsIRConSkeli, RegionsIRConSkel, 'area', 'and', 1, 99999)</l>
<l>*     count_obj (RegionsIRConSkel, nIRcons)</l>
<l>    for n := 1 to nS by 1</l>
<l>        select_obj (SkelGRCon, SkelS, n)</l>
<l>        numint := 0</l>
<l>        gen_empty_obj (Reg)</l>
<l>        for nn := 1 to nR by 1</l>
<l>            select_obj (RegionsIRCon, RegR, nn)</l>
<l>            intersection (SkelS, RegR, RInt)</l>
<l>            area_center (RInt, a, r, c)</l>
<l>            if (a&gt;0)</l>
<l>                numint := numint+1</l>
<l>                concat_obj (Reg, RegR, Reg)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (numint &gt; 1)</l>
<l>            nOp := nOp+1</l>
<l>            union1 (Reg, Regu)</l>
<l>            concat_obj (RegionsOp, Regu, RegionsOp)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenFU2">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionI"/>
<parameter id="RegionsOp"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
<parameter id="coef"/>
<parameter id="d"/>
<parameter id="nOp"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectIsl4">
<interface>
<io>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nIslfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>fill_up_shape (RegionIS, RegionISfu, 'area', 1, fumax)</l>
<l>difference (RegionISfu, RegionIS, RegionIslfu)</l>
<l>* difference (RegionIslfu, RegionG, RegionIslfunG)</l>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<l>* gen_empty_obj (RegionsIslfu)</l>
<l>* nIslfu := 0</l>
<l>* for j := 1 to nIslfum by 1</l>
<l>*     select_obj (RegionsIslfu, ObjectSelected, j)</l>
<l>*     intersection (ObjectSelected, SkeletonG, RegionInt)</l>
<l>*     area_center (RegionInt, a, r, c)</l>
<l>*     if (a==0)</l>
<l>*         concat_obj (RegionsIslfu, ObjectSelected, RegionsIslfu)</l>
<l>*         nIslfu := nIslfu+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>difference (RegionIfu, RegionsIslfu, RegionIi)</l>
<l>connection (RegionIi, RegionsIi)</l>
<l>select_shape (RegionsIi, RegionsI, 'area', 'and', 10, 99999999)</l>
<l>union1 (RegionsI, RegionI)</l>
<l>return ()</l>
</body>
<docu id="DetectIsl4">
<parameters>
<parameter id="Im"/>
<parameter id="RegionG"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionIfu"/>
<parameter id="RegionsIslfu"/>
<parameter id="SkeletonG"/>
<parameter id="fumax"/>
<parameter id="nIslfu"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectPH2">
<interface>
<io>
<par name="RegionIi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsPHfu" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nPHfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>fill_up_shape (RegionIi, RegionIfu, 'area', 1, fumax)</l>
<l>* fill_up (RegionIi, RegionIfu2)</l>
<c></c>
<l>difference (RegionIfu, RegionIi, RegionPHfui)</l>
<l>fill_up (RegionPHfui, RegionsPHfu)</l>
<l>connection (RegionsPHfu, RegionsPHfu)</l>
<l>count_obj (RegionsPHfu, nPHfu)</l>
<l>* difference (RegionIi, RegionsPHfu, RegionIfu)</l>
<l>union2 (RegionIi, RegionsPHfu, RegionIfu)</l>
<l>return ()</l>
</body>
<docu id="DetectPH2">
<parameters>
<parameter id="Im"/>
<parameter id="RegionIfu"/>
<parameter id="RegionIi"/>
<parameter id="RegionsPHfu"/>
<parameter id="fumax"/>
<parameter id="nPHfu"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortFU">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nSh" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>difference (SkeletonGS, RegionIS, RegionSkGSIS)</l>
<l>connection (RegionSkGSIS, RegionsSkGSIS)</l>
<l>area_center (RegionsSkGSIS, Area, RowShC, ColShC)</l>
<l>tuple_length (RowShC, nShC)</l>
<l>nSh := 0</l>
<l>gen_empty_obj (RegionsSh)</l>
<l>for j := 1 to nShC by 1</l>
<l>*     if(j==304)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (RegionsSkGSIS, RegionSel, j)</l>
<l>    get_region_points (RegionSel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>    get_grayval (DirImageS, row, col, dirShC)</l>
<l>    get_grayval (WidthImageS, row, col, widthShC)</l>
<c></c>
<l>*     angsShC := dirShC*3.1415926/256.0</l>
<l>*     region_features (RegionSel, 'rect2_len1', l1)</l>
<l>*     region_features (RegionSel, 'rect2_len2', l2)</l>
<l>*     region_features(RegionSel, 'rect2_phi', phi)</l>
<c>    </c>
<l>    smallest_rectangle2(RegionSel, Row, Column, Phi, Length1, Length2)</l>
<c>    </c>
<l>*     tuple_max2 (widthShC*coef/2, l1+wgap*2, recw)</l>
<l>*     gen_rectangle2 (Rect, row, col, angsShC, widthShC*coef/2, recw)</l>
<l>    gen_rectangle2 (Rect, Row, Column, Phi, Length1+wgap*2, widthShC*coef/2)</l>
<l>*     gen_rectangle2 (Rect, Row, Column, Phi, Length1+wgap*2, Length2+wgap*2)</l>
<l>    intersection (Rect, RegionIS, RegionISR)</l>
<l>    connection (RegionISR, RegionsIRSCon)</l>
<l>    count_obj (RegionsIRSCon, nR)</l>
<l>    intersection (Rect, SkeletonGS, SkelGSR)</l>
<l>    connection (SkelGSR, SkelGSRCon)</l>
<l>    count_obj (SkelGSRCon, nS)</l>
<c></c>
<l>    for n := 1 to nS by 1</l>
<l>        select_obj (SkelGSRCon, SkelS, n)</l>
<l>        numint := 0</l>
<l>        gen_empty_obj (Reg)</l>
<l>        for nn := 1 to nR by 1</l>
<l>            select_obj (RegionsIRSCon, RegR, nn)</l>
<l>            intersection (SkelS, RegR, RInt)</l>
<l>            area_center (RInt, a, r, c)</l>
<l>            if (a&gt;0)</l>
<l>                numint := numint+1</l>
<l>                concat_obj (Reg, RegR, Reg)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (numint &gt; 1)</l>
<l>            nSh := nSh+1</l>
<l>            difference (Rect, Reg, Regd)</l>
<c></c>
<l>            concat_obj (RegionsSh, Regd, RegionsSh)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortFU">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegionIS"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
<parameter id="coef"/>
<parameter id="nSh"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBm5">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="H" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>** inner boundary for Pattern</c>
<l>gen_image_const (ImageIRB, 'byte', W, H)</l>
<l>count_obj (RegionsPNi, nPNi)</l>
<l>* union2 (RegionIS, RegionsShm, RegForbid)</l>
<l>* expand_region (SkeletonsGThin, RegForbid, RegionsPNi, 'maximal', 'image')</l>
<l>* union1 (RegionsPNi, RegionPNi)</l>
<l>* intersection (RegionPNi, RegionInoD, RegionPN)</l>
<l>* connection (RegionPN, RegionsPNn)</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>intersection (RegionsPNi, RegionInoD, RegionsPN)</l>
<l>* intersection (RegionInoD, RegionsPNi, RegionsPN)</l>
<c></c>
<l>boundary (RegionsPN, RegionsINB, 'inner')</l>
<l>count_obj (RegionsINB, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<l>* union1 (RegionsShm, RegionShm)</l>
<l>* difference (RegionInoD, RegionShm, RegionIm)</l>
<l>paint_region (RegionInoD, ImageIRB, ImageIRB, 1, 'fill')</l>
<l>paint_region (RegionsINB, ImageIRB, ImageIRB, SequenceIRB, 'fill')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="BuildIRBm5">
<short lang="en_US">RegionInoD - Real Image region with defects (PH, Isl) removed</short>
<parameters>
<parameter id="H"/>
<parameter id="ImageIRB"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="W"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain9">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain9 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 31</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>stop ()</l>
<c></c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>stop ()</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>get_region_points (SkeletonG, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>stop ()</l>
<l>wmain := 6</l>
<l>wside := 3</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if (w &gt;= wmain-wside and w &lt;= wmain+wside)</l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>stop ()</l>
<c></c>
<l>wmain := 25</l>
<l>wside := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    if (w &gt;= wmain-wside and w &lt;= wmain+wside)</l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNi, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNi, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSi, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSi, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageResult, 0.5, 0)</l>
<l>stop ()</l>
<c>* ****************</c>
<c></c>
<l>minlen := 50</l>
<c>*  Finding thin (FWM) pattern</c>
<c>* **FWM half width**</c>
<c></c>
<l>opening_circle (RegionG, RegionGOpi, fwmhw)</l>
<c></c>
<l>difference (RegionG, RegionGOpi, RegionGOpDifi)</l>
<l>difference (RegionG, RegionGOpDifi, RegionThicki)</l>
<l>opening_circle (RegionGOpDifi, RegionGthin, parop)</l>
<c></c>
<l>connection (RegionGthin, RegionsGthin)</l>
<l>intersection (RegionGthin, SkeletonG, SkeletonGThin)</l>
<l>area_center (SkeletonGThin, nSkThin, Row2, Column)</l>
<l>connection (SkeletonGThin, SkeletonsGThin)</l>
<l>select_shape (SkeletonsGThin, SkeletonsGThin, 'area', 'and', minlen, 9999999)</l>
<l>count_obj (SkeletonsGThin, nSGThin)</l>
<l>* select_shape (RegionsGthini, RegionsGthin, 'contlength', 'and', clen, 99999999)</l>
<l>dev_set_color ('red')</l>
<l>dev_display (RegionsGthin)</l>
<l>count_obj (RegionsGthin, nGthin)</l>
<c></c>
<l>SkeletonsFWM:=RegionsGthin</l>
<l>stop ()</l>
<c>* ****</c>
<c>*  Finding thin (SFWM) space</c>
<c>* **SFWM half width for space**</c>
<l>sfwmhw := 22</l>
<l>sfwmcompactness := 5</l>
<l>sfwmminlen := 50</l>
<c></c>
<l>opening_circle (RegionGS, RegionGSOpi, sfwmhw)</l>
<c></c>
<l>difference (RegionGS, RegionGSOpi, RegionGSOpDifi)</l>
<l>difference (RegionGS, RegionGSOpDifi, RegionSThicki)</l>
<l>parop := 2</l>
<l>opening_circle (RegionGSOpDifi, RegionGSthin, parop)</l>
<c></c>
<l>connection (RegionGSthin, RegionsGSthini)</l>
<l>skeleton (RegionsGSthini, SkeletonGSthini)</l>
<l>junctions_skeleton (SkeletonGSthini, EndPoints1, JuncPoints1)</l>
<l>union1 (EndPoints1, EndPoints1u)</l>
<l>get_region_points (EndPoints1u, Rows, Columns)</l>
<c></c>
<c></c>
<l>get_grayval (WidthImageS, Rows, Columns, Grayval)</l>
<l>gen_circle (Circles, Rows, Columns, Grayval)</l>
<l>union1 (Circles, Circlesu)</l>
<l>SkeletonGSThin:=SkeletonGSthini</l>
<l>difference (SkeletonGSThin, Circlesu, SkeletonGSThin1)</l>
<c></c>
<l>union1 (JuncPoints1, JuncPoints1u)</l>
<l>get_region_points (JuncPoints1u, Rows, Columns)</l>
<l>get_grayval (WidthImageS, Rows, Columns, Grayval)</l>
<l>gen_circle (Circles, Rows, Columns, Grayval)</l>
<l>union1 (Circles, Circlesu)</l>
<l>difference (SkeletonGSThin, Circlesu, SkeletonGSThin2)</l>
<c></c>
<l>gen_contours_skeleton_xld (SkeletonGSThin2, Contours, 30, 'filter')</l>
<c></c>
<c></c>
<l>compactness (RegionsGSthini, Comp)</l>
<l>select_shape (RegionsGSthini, RegionsGSthini, 'compactness', 'and', sfwmcompactness, 99999)</l>
<l>opening_circle (RegionsGSthini, RegionGSthin, parop)</l>
<c></c>
<l>intersection (RegionGSthin, SkeletonGS, SkeletonGSThin)</l>
<l>stop ()</l>
<c>* *****************************************************</c>
<c></c>
<l>union1 (SkeletonsFWM, SkeletonFWM)</l>
<l>intersection (RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<c></c>
<c></c>
<c></c>
<l>area_center (SkeletonGSThin, nSkThin, Row2, Column)</l>
<l>pruning (SkeletonGSThin, SkeletonGSThinPrune, minlen)</l>
<l>connection (SkeletonGSThinPrune, SkeletonsGSThin)</l>
<l>select_shape (SkeletonsGSThin, SkeletonsGSThin, 'area', 'and', minlen, 9999999)</l>
<l>count_obj (SkeletonsGSThin, nSGSThin)</l>
<l>* select_shape (RegionsGthini, RegionsGthin, 'contlength', 'and', clen, 99999999)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (RegionGSthin)</l>
<l>count_obj (SkeletonsGSThin, nGSthin)</l>
<l>stop ()</l>
<c>* ***</c>
<l>* opening_circle (RegionGSi, RegionGSOp, fwmhw)</l>
<l>* difference (RegionGSi, RegionGSOp, RegionGSOpDifi)</l>
<l>* difference (RegionGSi, RegionGSOpDifi, RegionThicki)</l>
<l>* opening_circle (RegionGSOpDifi, RegionGSthini, parop)</l>
<l>* connection (RegionGSthini, RegionsGSthini)</l>
<l>* shape := ['contlength', 'compactness']</l>
<l>* select_shape (RegionsGSthini, RegionsGSthin, shape, 'and', [100, 10], [9999999, 99999])</l>
<l>* select_shape (RegionsGSthiniiOut, RegionsGSthiniiOut, 'contlength', 'and', 200, 9999999)</l>
<c></c>
<l>* dev_set_color ('green')</l>
<l>* dev_display (RegionsGSthin)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>* *** removing R from SkeletonGi and forming SkeletonG</c>
<l>intersection (SkeletonG, RC, SkeletonG)</l>
<l>GetSkeletonBranches (SkeletonG, WidthImageP, SkeletonsGbr, jrad, gap)</l>
<c></c>
<l>pruning (SkeletonG, SkeletonGii, 2)</l>
<l>* SkeletonG := SkeletonG</l>
<l>junctions_skeleton (SkeletonGii, EndPoints, JuncPoints)</l>
<l>connection (EndPoints, EndPointsc)</l>
<l>count_obj (EndPointsc, ne)</l>
<l>tuple_gen_const (ne, 1, Re)</l>
<l>area_center (EndPointsc, A, Row, Col)</l>
<l>get_grayval (WidthImageP, Row, Col, Erad)</l>
<c></c>
<l>dev_update_off ()</l>
<c>* ** processing skeleton</c>
<l>SkeletonGPr := SkeletonG</l>
<l>for j := 0 to ne-1 by 1</l>
<l>    select_obj (EndPointsc, ObjectSelected, j+1)</l>
<l>    dilation_circle (ObjectSelected, ObjectSelectedD, Erad[j]+7)</l>
<l>    difference (SkeletonGPr, ObjectSelectedD, SkeletonGPr)</l>
<l>endfor</l>
<c></c>
<l>* stop ()</l>
<c></c>
<l>maxdif := 5</l>
<l>len := 50</l>
<l>FindSkeletonsFWM (SkeletonsGbr, WidthImageP, SkeletonsFWMi, maxdif, len)</l>
<l>intersection (SkeletonsFWMi, RC, SkeletonsFWM)</l>
<c></c>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>* stop ()</l>
<c></c>
<c>* ***********************</c>
<c>* *** preparing non-FWM MSs</c>
<l>boundary (RegionG, RegionGB, 'inner')</l>
<c></c>
<l>erosion_circle (RegionG, RegionGer, fwmhw*1.3)</l>
<l>connection (RegionGer, RegionsGer)</l>
<l>dilation_circle (RegionsGer, RegionsGedi, fwmhw*2.0)</l>
<l>select_shape (RegionsGedi, RegionsGed, 'ra', 'and', 15, 999999)</l>
<c></c>
<l>intersection (RegionsGed, RegionGB, BoundariesNFWMi)</l>
<l>count_obj (BoundariesNFWMi, nCGb)</l>
<l>intersection (RegionsGed, RegionG, RegionsNFWM)</l>
<c></c>
<l>* BoundariesNFWM := RegionsCGb</l>
<c></c>
<l>* intersection (RegionsNFWM, SkeletonGi, SkelN)</l>
<c>* ** 0-   1-</c>
<l>wgntype := 1</l>
<c>* ** contl</c>
<c></c>
<l>area_center (BoundariesNFWMi, Area, Row1, Column1)</l>
<l>tuple_min (Area, amin)</l>
<c></c>
<l>select_shape (BoundariesNFWMi, BoundariesNFWM, 'area', 'and', 50, 99999999)</l>
<c></c>
<l>union1 (BoundariesNFWM, BoundaryNFWM)</l>
<l>intersection (RegionsPNi, BoundaryNFWM, BoundariesNFWM)</l>
<c></c>
<l>union1 (RegionsNFWM, RegionNFWM)</l>
<l>intersection (RegionsPNi, RegionNFWM, RegionsNFWM)</l>
<l>intersection (RegionsNFWM, SkeletonGi, SkelN)</l>
<l>count_obj (RegionsNFWM, nNonWFM)</l>
<l>MSBuildNonFWM7_COPY_1 (RegionsNFWM, BoundariesNFWM, ImageIR, WidthImageP, SkelN, nNonWFM, sm_factor, lookaround, wpl, wgntype, PnumN, PnumRN, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>* MSBuildNonFWM6 (RegionsNFWM, BoundariesNFWM, ImageIR, WidthImageP, SkelN, nNonWFM, sm_factor, lookaround, wpl, wgntype, PnumN, PnumRN, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>gen_region_points (P1N, Y1N, X1N)</l>
<c>* ** test R &lt;-&gt; C</c>
<l>rnum := 167</l>
<l>DefN := []</l>
<l>cnum := PcontRN[rnum-1]</l>
<l>rnum2 := PregCN[cnum-1]</l>
<c></c>
<l>nreg := 155</l>
<c>* ncont:=</c>
<l>ncontN := 70</l>
<c></c>
<l>nregn := PregCN[ncontN-1]</l>
<l>ncontN2 := PcontRN[nregn-1]</l>
<l>ncontN3 := PCinRnumN[nregn-1]</l>
<l>* nNonWFM := nNonWFM</l>
<c></c>
<c></c>
<l>tuple_min (PnumN, minN)</l>
<l>* stop ()</l>
<c></c>
<c>* *****   FWM  Teaching  **************</c>
<c>* ****************************************</c>
<l>MSBuildFWM4 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<l>return ()</l>
</body>
<docu id="TeachingMain9">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildNonFWM7_COPY_1">
<interface>
<io>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="SkelN" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="nCGc" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="wgntype" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSBuildNonFWM7 211212 ****</c>
<c>* * corrected for -1</c>
<l>RowN := []</l>
<l>ColN := []</l>
<l>PnumN := []</l>
<l>pnum := []</l>
<l>WN := []</l>
<c>* ** address for each region (1 or several contours)</c>
<l>PaddrRN := 0</l>
<c>* ** address for each contour</c>
<l>PaddrCN := []</l>
<c>* *** number of contours per region</c>
<l>* PregN := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregCN := []</l>
<c>* * number of countours per region</c>
<l>PCinRnumN := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontRN := []</l>
<c>* * current Region address</c>
<l>paddrR := 0</l>
<c>* * current Contour address</c>
<l>paddrC := 0</l>
<l>pcontn := 1</l>
<l>indcn := 0</l>
<l>AngN := []</l>
<l>PlenN := []</l>
<l>Y1N := []</l>
<l>X1N := []</l>
<l>Y2N := []</l>
<l>X2N := []</l>
<l>WGN := []</l>
<c></c>
<l>count_obj (BoundariesNFWM, nNonWFM)</l>
<c></c>
<l>gen_empty_obj (ContoursAll)</l>
<l>gen_empty_obj (RegsAll)</l>
<l>* count_obj (SkeletonsGThin, nSGThin)</l>
<l>pn := 0</l>
<l>for j := 1 to nNonWFM by 1</l>
<c>    * *** non-FWM region ( full and only boundary regions)</c>
<l>    select_obj (RegionsNFWM, RCgc, j)</l>
<l>    area_center (RCgc, a, r, c)</l>
<l>*     if (j==100)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    if (a&gt;0)</l>
<l>        select_obj (BoundariesNFWM, RCgb, j)</l>
<l>        concat_obj (RegsAll, RCgb, RegsAll)</l>
<l>        skeleton (RCgc, SkeletonRCgc)</l>
<l>        get_region_points (SkeletonRCgc, r, c)</l>
<l>        get_grayval (ImageIR, r, c, gv)</l>
<l>        tuple_median (gv, pnum)</l>
<l>        inner_circle (RCgc, rmin, cmin, radmin)</l>
<c>        * * inner radius to be used as CAD half width</c>
<l>        gen_circle (Circle, rmin, cmin, radmin)</l>
<c></c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld (RCgb, Contours1, 3, 'filter')</l>
<l>        union_adjacent_contours_xld (Contours1, Contours, 3, 1, 'attr_forget')</l>
<l>        smooth_contours_xld (Contours, ContoursSmi, sm_factor)</l>
<l>        select_contours_xld (ContoursSmi, ContoursSm, 'contour_length', 30.0, 20000000., -0.5, 0.5)</l>
<l>        count_obj (ContoursSm, nCo)</l>
<l>        tuple_concat (PCinRnumN, nCo, PCinRnumN)</l>
<c>        * ** contours of each non-FWM region ( 1 or several)</c>
<l>        nnco := 0</l>
<l>        tuple_concat (PcontRN, pcontn, PcontRN)</l>
<l>        pcontn := pcontn+nCo</l>
<l>        for jj := 1 to nCo by 1</l>
<l>            select_obj (ContoursSm, Contour, jj)</l>
<l>            get_contour_xld (Contour, Row, Col)</l>
<l>            tuple_length (Row, pN)</l>
<l>*             if (pN&gt;30)</l>
<l>            nnco := nnco+1</l>
<c></c>
<l>            concat_obj (ContoursAll, Contour, ContoursAll)</l>
<l>            tuple_gen_const (pN, radmin*2., W)</l>
<l>            tuple_gen_const (pN, j, J)</l>
<l>            tuple_concat (RowN, Row, RowN)</l>
<l>            tuple_concat (ColN, Col, ColN)</l>
<c></c>
<l>            tuple_concat (WN, W, WN)</l>
<l>            tuple_concat (PaddrCN, paddrC, PaddrCN)</l>
<l>            indcn := indcn+1</l>
<l>            tuple_concat (PregCN, j, PregCN)</l>
<l>            paddrC := paddrC + pN</l>
<l>            get_contour_angle_xld (Contour, 'abs', 'regress', lookaround, AnglesG)</l>
<l>            tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>            Ang := AnglesG1</l>
<l>            tuple_concat (AngN, Ang, AngN)</l>
<c></c>
<l>            Y1t := Row-sin(Ang)*(3)</l>
<l>            X1t := Col+cos(Ang)*(3)</l>
<c></c>
<l>            Y1n := Row-sin(Ang)*(wpl)</l>
<l>            X1n := Col+cos(Ang)*(wpl)</l>
<l>            Y2n := Row+sin(Ang)*(wpl)</l>
<l>            X2n := Col-cos(Ang)*(wpl)</l>
<c></c>
<l>            tuple_gen_const (pN, pnum, Pnum)</l>
<l>            tuple_concat (PnumN, Pnum, PnumN)</l>
<c></c>
<c>            * *** swapping P1 and P2 if necessary</c>
<l>            test_region_point (RegionsNFWM, Y1t[pN/2], X1t[pN/2], IsInside)</l>
<l>            if (IsInside)</l>
<l>                Yt := Y1n</l>
<l>                Xt := X1n</l>
<l>                X1n := X2n</l>
<l>                Y1n := Y2n</l>
<l>                X2n := Xt</l>
<l>                Y2n := Yt</l>
<l>            endif</l>
<c>            * ***</c>
<l>            dev_set_color ('green')</l>
<l>            disp_line (200000, Y1n, X1n, Y2n, X2n)</l>
<l>            distance_pp (Y1n, X1n, Y2n, X2n, D)</l>
<l>            tuple_gen_const (pN, 1, Ones)</l>
<l>            gen_rectangle2 (Reg2, (Y1n+Y2n)/2., (X1n+X2n)/2., Ang, D/2., Ones)</l>
<l>            gen_region_points (RC, (Y1n+Y2n)/2., (X1n+X2n)/2.)</l>
<l>            intersection (Reg2, SkelN, Ps)</l>
<l>            union1 (SkelN, SN)</l>
<l>            distance_pr (SN, (Y1n+Y2n)/2., (X1n+X2n)/2., Dmin, Dmax)</l>
<c></c>
<c></c>
<l>            tuple_concat (Y1N, Y1n, Y1N)</l>
<l>            tuple_concat (X1N, X1n, X1N)</l>
<l>            tuple_concat (Y2N, Y2n, Y2N)</l>
<l>            tuple_concat (X2N, X2n, X2N)</l>
<l>            if (wgntype==0)</l>
<l>                tuple_concat (WGN, Dmin, WGN)</l>
<l>            else</l>
<l>                tuple_gen_const (pN, radmin, Wgn)</l>
<l>                tuple_concat (WGN, Wgn, WGN)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        tuple_concat (PaddrRN, paddrC, PaddrRN)</l>
<l>    else</l>
<l>        tuple_concat (PCinRnumN, 0, PCinRnumN)</l>
<l>        tuple_concat (PcontRN, -1, PcontRN)</l>
<l>*         tuple_concat (PaddrCN, -1, PaddrCN)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="MSBuildNonFWM7_COPY_1">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrRN"/>
<parameter id="PcontRN"/>
<parameter id="PnumN"/>
<parameter id="PnumRN"/>
<parameter id="PregCN"/>
<parameter id="RegionsNFWM"/>
<parameter id="SkelN"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthImageP"/>
<parameter id="X1N"/>
<parameter id="X2N"/>
<parameter id="Y1N"/>
<parameter id="Y2N"/>
<parameter id="lookaround"/>
<parameter id="nCGc"/>
<parameter id="sm_factor"/>
<parameter id="wgntype"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain10">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain10 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>stop ()</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>get_region_points (SkeletonG, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>stop ()</l>
<l>Wmain := [6, 14, 28]</l>
<l>wside := 3</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( (w &gt;= Wmain[0]-wside and w &lt;= Wmain[0]+wside) or (w &gt;= Wmain[1]-wside and w &lt;= Wmain[1]+wside) or (w &gt;= Wmain[2]-wside and w &lt;= Wmain[2]+wside) )</l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>stop ()</l>
<c></c>
<l>WmainS := [25, 25]</l>
<l>wsides := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>stop ()</l>
<c></c>
<c></c>
<c>* ****************</c>
<c></c>
<c></c>
<c>*  Finding thin (FWM) pattern</c>
<c>* ***</c>
<l>* opening_circle (RegionGSi, RegionGSOp, fwmhw)</l>
<l>* difference (RegionGSi, RegionGSOp, RegionGSOpDifi)</l>
<l>* difference (RegionGSi, RegionGSOpDifi, RegionThicki)</l>
<l>* opening_circle (RegionGSOpDifi, RegionGSthini, parop)</l>
<l>* connection (RegionGSthini, RegionsGSthini)</l>
<l>* shape := ['contlength', 'compactness']</l>
<l>* select_shape (RegionsGSthini, RegionsGSthin, shape, 'and', [100, 10], [9999999, 99999])</l>
<l>* select_shape (RegionsGSthiniiOut, RegionsGSthiniiOut, 'contlength', 'and', 200, 9999999)</l>
<c></c>
<l>* dev_set_color ('green')</l>
<l>* dev_display (RegionsGSthin)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>* *** removing R from SkeletonGi and forming SkeletonG</c>
<l>* intersection (SkeletonG, RC, SkeletonG)</l>
<l>* GetSkeletonBranches (SkeletonG, WidthImageP, SkeletonsGbr, jrad, gap)</l>
<c></c>
<l>* pruning (SkeletonG, SkeletonGii, 2)</l>
<l>* SkeletonG := SkeletonG</l>
<l>* junctions_skeleton (SkeletonGii, EndPoints, JuncPoints)</l>
<l>* connection (EndPoints, EndPointsc)</l>
<l>* count_obj (EndPointsc, ne)</l>
<l>* tuple_gen_const (ne, 1, Re)</l>
<l>* area_center (EndPointsc, A, Row, Col)</l>
<l>* get_grayval (WidthImageP, Row, Col, Erad)</l>
<c></c>
<l>* dev_update_off ()</l>
<c>* ** processing skeleton</c>
<l>* SkeletonGPr := SkeletonG</l>
<l>* for j := 0 to ne-1 by 1</l>
<l>*     select_obj (EndPointsc, ObjectSelected, j+1)</l>
<l>*     dilation_circle (ObjectSelected, ObjectSelectedD, Erad[j]+7)</l>
<l>*     difference (SkeletonGPr, ObjectSelectedD, SkeletonGPr)</l>
<l>* endfor</l>
<c></c>
<l>* stop ()</l>
<c></c>
<l>* maxdif := 5</l>
<l>* len := 50</l>
<l>* FindSkeletonsFWM (SkeletonsGbr, WidthImageP, SkeletonsFWMi, maxdif, len)</l>
<l>* intersection (SkeletonsFWMi, RC, SkeletonsFWM)</l>
<c></c>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>* count_obj (SkeletonsFWM, nFWM)</l>
<l>* stop ()</l>
<c></c>
<c>* ***********************</c>
<c>* *** preparing non-FWM MSs</c>
<l>* boundary (RegionG, RegionGB, 'inner')</l>
<c></c>
<l>* erosion_circle (RegionG, RegionGer, fwmhw*1.3)</l>
<l>* connection (RegionGer, RegionsGer)</l>
<l>* dilation_circle (RegionsGer, RegionsGedi, fwmhw*2.0)</l>
<l>* select_shape (RegionsGedi, RegionsGed, 'ra', 'and', 15, 999999)</l>
<c></c>
<l>* intersection (RegionsGed, RegionGB, BoundariesNFWMi)</l>
<l>* count_obj (BoundariesNFWMi, nCGb)</l>
<l>* intersection (RegionsGed, RegionG, RegionsNFWM)</l>
<c></c>
<c>* ** 0-   1-</c>
<l>* wgntype := 1</l>
<c>* ** contl</c>
<c></c>
<l>* area_center (BoundariesNFWMi, Area, Row1, Column1)</l>
<l>* tuple_min (Area, amin)</l>
<c></c>
<l>* select_shape (BoundariesNFWMi, BoundariesNFWM, 'area', 'and', 50, 99999999)</l>
<c></c>
<l>* union1 (BoundariesNFWM, BoundaryNFWM)</l>
<l>* intersection (RegionsPNi, BoundaryNFWM, BoundariesNFWM)</l>
<c></c>
<l>* union1 (RegionsNFWM, RegionNFWM)</l>
<l>* intersection (RegionsPNi, RegionNFWM, RegionsNFWM)</l>
<l>* intersection (RegionsNFWM, SkeletonGi, SkelN)</l>
<l>* count_obj (RegionsNFWM, nNonWFM)</l>
<l>* MSBuildNonFWM7_COPY_1 (RegionsNFWM, BoundariesNFWM, ImageIR, WidthImageP, SkelN, nNonWFM, sm_factor, lookaround, wpl, wgntype, PnumN, PnumRN, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>* gen_region_points (P1N, Y1N, X1N)</l>
<c>* ** test R &lt;-&gt; C</c>
<l>* rnum := 167</l>
<l>* DefN := []</l>
<l>* cnum := PcontRN[rnum-1]</l>
<l>* rnum2 := PregCN[cnum-1]</l>
<c></c>
<l>* nreg := 155</l>
<c>* ncont:=</c>
<l>* ncontN := 70</l>
<c></c>
<l>* nregn := PregCN[ncontN-1]</l>
<l>* ncontN2 := PcontRN[nregn-1]</l>
<l>* ncontN3 := PCinRnumN[nregn-1]</l>
<l>* nNonWFM := nNonWFM</l>
<c></c>
<c></c>
<l>* tuple_min (PnumN, minN)</l>
<l>* stop ()</l>
<l>* SkeletonsFWM := Regionsmain</l>
<l>jrad:=9</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP ***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>union1(JuncPoints, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>union1(EndPoints, EP)</l>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>tuple_length(RowsE, nE)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, 7, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c></c>
<c>*** FWMS (for space)</c>
<l>SkeletonsFWMSp := RegionsmainS</l>
<l>stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>stop()</l>
<c></c>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>gen_region_points (PSC, YSC, XSC)</l>
<c>* ****************************************</c>
<c>*** FWMP (for pattern)</c>
<l>MSBuildFWM4 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<l>stop()</l>
<l>return()</l>
<c></c>
<l>edpar:=20.5</l>
<l>expand:=7</l>
<l>connection(RegionG, RegionsG)</l>
<l>select_shape(RegionsG, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>erosion_circle(RegionsGnoholes, RegionEr, edpar)</l>
<l>dilation_circle(RegionEr, RegionsDil, edpar)</l>
<l>* union1(RegionsDili, RegionDil)</l>
<l>* connection(RegionDil, RegionsDil)</l>
<l>select_shape(RegionsDil, RegionsNFWMi, 'holes_num', 'and', 0, 0)</l>
<c></c>
<l>expand_region(RegionsDil, RegionGS, RegionExpanded, expand, 'image')</l>
<l>select_shape(RegionExpanded, RegionsNFWMi, 'holes_num', 'and', 0, 0)</l>
<c></c>
<l>stop()</l>
<l>* difference(RegionDil, RegionsGnoholes, RegionDifference)</l>
<l>fill_up(SkeletonsFWMS, SkeletonsNFWMfu)</l>
<l>difference(RegionsNFWMi,SkeletonsNFWMfu, RegionsNFWM)</l>
<l>count_obj(RegionsNFWM, nNFWM)</l>
<c></c>
<c>**************************************************************</c>
<c>*** removing NFWM which have FWMS ***</c>
<c>*************************************</c>
<l>dilsize:=17.5</l>
<l>coeff:=0.7</l>
<l>union1(SkeletonsFWMS, SkeletonFWMS)</l>
<l>boundary(RegionsNFWM, RegionsNFWMb, 'outer')</l>
<c>*** finding NFWMs boundary area</c>
<l>area_center(RegionsNFWMb, AreaNFWMb, RowNFWMb, ColumnNFWMb)</l>
<l>dilation_circle(RegionsNFWM, RegionDilationNFWM, dilsize)</l>
<l>intersection(RegionDilationNFWM, SkeletonFWMS, RegionIntersectionNFWM)</l>
<c>*** finding dilated FWMSs boundary area</c>
<l>area_center(RegionIntersectionNFWM, AreaInt, RowInt, ColumnInt)</l>
<l>count_obj(RegionIntersectionNFWM, n)</l>
<l>gen_empty_obj(RegionsNFWMs)</l>
<l>for j:=1 to n by 1</l>
<l>    aint:= AreaInt[j-1]*coeff</l>
<l>    aNFWMb:= AreaNFWMb[j-1]</l>
<l>    if(aint &lt; aNFWMb)</l>
<l>        select_obj(RegionsNFWM, Obj, j)</l>
<l>        concat_obj(RegionsNFWMs, Obj, RegionsNFWMs)</l>
<l>    endif</l>
<l>endfor</l>
<l>count_obj(RegionsNFWMs, nNFWMs)</l>
<l>* tuple_greater_elem(AreaInt*coeff, AreaNFWMb, Greater)</l>
<c></c>
<l>* tuple_sort_index(Greater,IndicesGr)</l>
<l>* tuple_sort(IndicesGr, IndicesGrs)</l>
<c>* obj_diff</c>
<l>stop()</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="TeachingMain10">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBSm5">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="H" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="pat" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>** pat==0 - outer boundary for Space, pat==1 - iner boundary for Pattern</c>
<l>gen_image_const (ImageIRB, 'byte', W, H)</l>
<l>count_obj (RegionsPNi, nPNi)</l>
<l>* union2 (RegionIS, RegionsShm, RegForbid)</l>
<l>* expand_region (SkeletonsGThin, RegForbid, RegionsPNi, 'maximal', 'image')</l>
<l>* union1 (RegionsPNi, RegionPNi)</l>
<l>* intersection (RegionPNi, RegionInoD, RegionPN)</l>
<l>* connection (RegionPN, RegionsPNn)</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>intersection (RegionsPNi, RegionInoD, RegionsPN)</l>
<l>* intersection (RegionInoD, RegionsPNi, RegionsPN)</l>
<l>if(pat==0)</l>
<c>    * space</c>
<l>    boundary (RegionsPN, RegionsINB, 'outer')   </l>
<l>else</l>
<c>    * pattern</c>
<l>    boundary (RegionsPN, RegionsINB, 'inner')</l>
<l>endif</l>
<c></c>
<l>count_obj (RegionsINB, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%250+3</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<l>* union1 (RegionsShm, RegionShm)</l>
<l>* difference (RegionInoD, RegionShm, RegionIm)</l>
<l>paint_region (RegionInoD, ImageIRB, ImageIRB, 1, 'fill')</l>
<l>paint_region (RegionsINB, ImageIRB, ImageIRB, SequenceIRB, 'fill')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="BuildIRBSm5">
<short lang="en_US">RegionInoD - Real Image region with defects (PH, Isl) removed</short>
<parameters>
<parameter id="H"/>
<parameter id="ImageIRB"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="W"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="pat"/>
</parameters>
</docu>
</procedure>
<procedure name="IntersectionSS">
<interface>
<ic>
<par name="A1y" base_type="ctrl" dimension="0"/>
<par name="A1x" base_type="ctrl" dimension="0"/>
<par name="B1y" base_type="ctrl" dimension="0"/>
<par name="B1x" base_type="ctrl" dimension="0"/>
<par name="A2y" base_type="ctrl" dimension="0"/>
<par name="A2x" base_type="ctrl" dimension="0"/>
<par name="B2y" base_type="ctrl" dimension="0"/>
<par name="B2x" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Iy" base_type="ctrl" dimension="0"/>
<par name="Ix" base_type="ctrl" dimension="0"/>
<par name="inter" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** finding intersectin oint of 2 line segments</c>
<l>Ix:=0</l>
<l>Iy:=0</l>
<l>dir1x:=B1x-A1x</l>
<l>dir1y:=B1y-A1y</l>
<l>dir2x:=B2x-A2x</l>
<l>dir2y:=B2y-A2y</l>
<c></c>
<l>a1:= -dir1y</l>
<l>b1:= dir1x</l>
<l>d1:= -(a1*A1x+b1*A1y)</l>
<l>a2:= -dir2y</l>
<l>b2:= dir2x</l>
<l>d2:= -(a2*A2x+b2*A2y)</l>
<c></c>
<l>seg1_line2_start := a2*A1x + b2*A1y + d2 +0.0</l>
<l>seg1_line2_end   := a2*B1x + b2*B1y + d2 +0.0</l>
<c></c>
<l>seg2_line1_start := a1*A2x + b1*A2y + d1+0.0</l>
<l>seg2_line1_end   := a1*B2x + b1*B2y + d1+0.0</l>
<c></c>
<l>if (seg1_line2_start * seg1_line2_end &gt;= 0 or seg2_line1_start * seg2_line1_end &gt;= 0)</l>
<l>    inter:=0</l>
<l>else</l>
<l>    inter:=1</l>
<l>    u := 0.0 + seg1_line2_start / (seg1_line2_start - seg1_line2_end)</l>
<l>    Ix:=A1x+u*dir1x</l>
<l>    Iy:=A1y+u*dir1y</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="IntersectionSS">
<parameters>
<parameter id="A1x"/>
<parameter id="A1y"/>
<parameter id="A2x"/>
<parameter id="A2y"/>
<parameter id="B1x"/>
<parameter id="B1y"/>
<parameter id="B2x"/>
<parameter id="B2y"/>
<parameter id="Ix"/>
<parameter id="Iy"/>
<parameter id="inter"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL1">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL1 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacement, 1, 128)</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>* stop ()</l>
<l>Wmain := [6, 14, 28]</l>
<l>wside := 3</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( (w &gt;= Wmain[0]-wside and w &lt;= Wmain[0]+wside) or (w &gt;= Wmain[1]-wside and w &lt;= Wmain[1]+wside) or (w &gt;= Wmain[2]-wside and w &lt;= Wmain[2]+wside) )</l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>* stop ()</l>
<c></c>
<l>WmainS := [25, 25]</l>
<l>wsides := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>jrad:=9</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP ***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>tuple_length(RowsE, nE)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, 7, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c></c>
<c>*** FWMS (for space)</c>
<l>SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c></c>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>gen_region_points (PSC, YSC, XSC)</l>
<c>* ****************************************</c>
<c>*** FWMP (for pattern)</c>
<l>MSBuildFWM4 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL1">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortFU2">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nSh" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>set_system('neighborhood', 8)</l>
<l>difference (SkeletonGS, RegionIS, RegionSkGSIS)</l>
<l>connection (RegionSkGSIS, RegionsSkGSIS)</l>
<l>area_center (RegionsSkGSIS, Area, RowShC, ColShC)</l>
<l>tuple_length (RowShC, nShC)</l>
<l>nSh := 0</l>
<l>gen_empty_obj (RegionsSh)</l>
<l>for j := 1 to nShC by 1</l>
<l>*     if(j==940)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (RegionsSkGSIS, RegionSel, j)</l>
<l>    get_region_points (RegionSel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>    get_grayval (DirImageS, row, col, dirShC)</l>
<l>    get_grayval (WidthImageS, row, col, widthShC)</l>
<c></c>
<l>*     angsShC := dirShC*3.1415926/256.0</l>
<l>*     region_features (RegionSel, 'rect2_len1', l1)</l>
<l>*     region_features (RegionSel, 'rect2_len2', l2)</l>
<l>*     region_features(RegionSel, 'rect2_phi', phi)</l>
<c>    </c>
<l>    smallest_rectangle2(RegionSel, Row, Column, Phi, Length1, Length2)</l>
<c>    </c>
<l>*     tuple_max2 (widthShC*coef/2, l1+wgap*2, recw)</l>
<l>*     gen_rectangle2 (Rect, row, col, angsShC, widthShC*coef/2, recw)</l>
<l>    gen_rectangle2 (Rect, Row, Column, Phi, Length1+wgap*1, widthShC*coef/2+wgap)</l>
<l>*     gen_rectangle2 (Rect, Row, Column, Phi, Length1+wgap*2, Length2+wgap*2)</l>
<l>    intersection (Rect, RegionIS, RegionISR)</l>
<l>    connection (RegionISR, RegionsIRSCon)</l>
<l>    count_obj (RegionsIRSCon, nR)</l>
<l>    intersection (Rect, SkeletonGS, SkelGSR)</l>
<l>    connection (SkelGSR, SkelGSRCon)</l>
<l>    count_obj (SkelGSRCon, nS)</l>
<c></c>
<l>    for n := 1 to nS by 1</l>
<l>        select_obj (SkelGSRCon, SkelS, n)</l>
<l>        numint := 0</l>
<l>        gen_empty_obj (Reg)</l>
<l>        for nn := 1 to nR by 1</l>
<l>            select_obj (RegionsIRSCon, RegR, nn)</l>
<l>            intersection (SkelS, RegR, RInt)</l>
<l>            area_center (RInt, a, r, c)</l>
<l>            if (a&gt;0)</l>
<l>                numint := numint+1</l>
<l>                concat_obj (Reg, RegR, Reg)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (numint &gt; 1)</l>
<c>            *** trying to verify</c>
<l>*             expand_region(RegionSel, RegionIS,RegionExpanded, widthShC*3, 'image')</l>
<l>*             dilation_circle(RegionExpanded, RegionDilation, 1.5)</l>
<l>*             difference(RegionDilation, RegionIS, RegionIntersection)</l>
<c>            *** trying to verify end</c>
<l>            nSh := nSh+1</l>
<l>*             if(nSh==23)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>            difference (Rect, Reg, Regd)</l>
<c></c>
<l>            concat_obj (RegionsSh, Regd, RegionsSh)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortFU2">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegionIS"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
<parameter id="coef"/>
<parameter id="nSh"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="BildIRBm5n">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="H" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="overf" base_type="ctrl" dimension="0"/>
<par name="stseq" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>** inner boundary for Pattern</c>
<l>gen_image_const (ImageIRB, 'byte', W, H)</l>
<l>count_obj (RegionsPNi, nPNi)</l>
<l>* union2 (RegionIS, RegionsShm, RegForbid)</l>
<l>* expand_region (SkeletonsGThin, RegForbid, RegionsPNi, 'maximal', 'image')</l>
<l>* union1 (RegionsPNi, RegionPNi)</l>
<l>* intersection (RegionPNi, RegionInoD, RegionPN)</l>
<l>* connection (RegionPN, RegionsPNn)</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>intersection (RegionsPNi, RegionInoD, RegionsPN)</l>
<l>* intersection (RegionInoD, RegionsPNi, RegionsPN)</l>
<c></c>
<l>boundary (RegionsPN, RegionsINB, 'inner')</l>
<l>count_obj (RegionsINB, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* union1 (RegionsShm, RegionShm)</l>
<l>* difference (RegionInoD, RegionShm, RegionIm)</l>
<l>paint_region (RegionInoD, ImageIRB, ImageIRB, 1, 'fill')</l>
<l>paint_region (RegionsINB, ImageIRB, ImageIRB, SequenceIRB, 'fill')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="BildIRBm5n">
<short lang="en_US">RegionInoD - Real Image region with defects (PH, Isl) removed</short>
<parameters>
<parameter id="H"/>
<parameter id="ImageIRB"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="W"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="overf"/>
<parameter id="stseq"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBm5n">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="H" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="overf" base_type="ctrl" dimension="0"/>
<par name="stseq" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>** inner boundary for Pattern</c>
<l>gen_image_const (ImageIRB, 'byte', W, H)</l>
<l>count_obj (RegionsPNi, nPNi)</l>
<l>* union2 (RegionIS, RegionsShm, RegForbid)</l>
<l>* expand_region (SkeletonsGThin, RegForbid, RegionsPNi, 'maximal', 'image')</l>
<l>* union1 (RegionsPNi, RegionPNi)</l>
<l>* intersection (RegionPNi, RegionInoD, RegionPN)</l>
<l>* connection (RegionPN, RegionsPNn)</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>intersection (RegionsPNi, RegionInoD, RegionsPN)</l>
<l>* intersection (RegionInoD, RegionsPNi, RegionsPN)</l>
<c></c>
<l>boundary (RegionsPN, RegionsINB, 'inner')</l>
<l>count_obj (RegionsINB, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<l>* union1 (RegionsShm, RegionShm)</l>
<l>* difference (RegionInoD, RegionShm, RegionIm)</l>
<l>paint_region (RegionInoD, ImageIRB, ImageIRB, 1, 'fill')</l>
<l>paint_region (RegionsINB, ImageIRB, ImageIRB, SequenceIRB, 'fill')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="BuildIRBm5n">
<short lang="en_US">RegionInoD - Real Image region with defects (PH, Isl) removed</short>
<parameters>
<parameter id="H"/>
<parameter id="ImageIRB"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="W"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="overf"/>
<parameter id="stseq"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevAbs">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CirclesMB" base_type="iconic" dimension="0"/>
<par name="CirclesSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*   ProcDevAbs</c>
<c>*** 20220429-complement shouldn't be used because of wrong outer boundaries</c>
<l>* complement(RegionInoD, RegionInoDC)</l>
<l>get_region_contour(RegionInoD, RowsCP, ColsCP)</l>
<l>tuple_max(ColsCP, MaxCPC)</l>
<l>tuple_max(RowsCP, MaxCPR)</l>
<l>gen_rectangle1(Rectangle, 0, 0, MaxCPR, MaxCPC)</l>
<l>* gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<l>difference(Rectangle, RegionInoD, RegionInoDC)</l>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<l>* tuple_max(ColsCC, MaxCC)</l>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<c></c>
<l>gen_region_points(TInoDC, RowsC, ColsC)</l>
<l>* tuple_max(ColsC, MaxC)</l>
<l>*tuple_min(ColsC, MinC)</l>
<l>* tuple_max(RowsC, MaxR)</l>
<l>*tuple_min(RowsC, MinR)</l>
<l>* get_grayval(ImDeviation, MaxR/2, MaxC/2, Deviation1)</l>
<l>* get_image_size(ImDeviation,Width, Height)</l>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>tuple_max(ColsC, Max)</l>
<c></c>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nMin)</l>
<c></c>
<l>area_center(Psls, Area, Row, Col)</l>
<l>rc:=30.5</l>
<l>tuple_gen_const( nMin, rc, Rc)</l>
<l>gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>union1(CirclesMin1, RegionUnion)</l>
<l>connection(RegionUnion, CirclesMB)</l>
<l>count_obj(CirclesMB, nMin)</l>
<c></c>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nMax)</l>
<c></c>
<l>area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>tuple_gen_const( nMax, rc, Rc)</l>
<l>gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>union1(CirclesMax1, RegionUnion)</l>
<l>connection(RegionUnion, CirclesSpur)</l>
<l>count_obj(CirclesSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevAbs">
<parameters>
<parameter id="CirclesMB"/>
<parameter id="CirclesSpur"/>
<parameter id="ImDeviation"/>
<parameter id="RegionInoD"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevCont">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CirclesMB" base_type="iconic" dimension="0"/>
<par name="CirclesSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>* complement(RegionInoD, RegionInoDC)</l>
<l>* get_region_contour(RegionInoD, RowsCP, ColsCP)</l>
<c>** </c>
<l>boundary(RegionInoD, RegionInoDB, 'outer')</l>
<l>connection(RegionInoDB, RegionsInoDB)</l>
<l>count_obj(RegionsInoDB, nInoDB)</l>
<l>for j:=1 to nInoDB by 1</l>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>    get_region_contour(RInoDB, RowInoDB, ColInoDB)</l>
<l>endfor</l>
<l>stop()</l>
<l>get_region_contour(RegionInoDB, Rows, Columns)</l>
<l>gen_region_points(Region, Rows, Columns)</l>
<l>connection(Region, ConnectedRegions)</l>
<c></c>
<l>boundary(RegionInoDC, RegionInoDCB, 'inner')</l>
<c></c>
<l>count_obj(RegionInoD, nInoD)</l>
<l>count_obj(RegionInoDC, nInoDC)</l>
<l>gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<c></c>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<c></c>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nMin)</l>
<c></c>
<l>area_center(Psls, Area, Row, Col)</l>
<l>rc:=30.5</l>
<l>tuple_gen_const( nMin, rc, Rc)</l>
<l>gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>union1(CirclesMin1, RegionUnion)</l>
<l>connection(RegionUnion, CirclesMB)</l>
<l>count_obj(CirclesMB, nMin)</l>
<c></c>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nMax)</l>
<c></c>
<l>area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>tuple_gen_const( nMax, rc, Rc)</l>
<l>gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>union1(CirclesMax1, RegionUnion)</l>
<l>connection(RegionUnion, CirclesSpur)</l>
<l>count_obj(CirclesSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevCont">
<parameters>
<parameter id="CirclesMB"/>
<parameter id="CirclesSpur"/>
<parameter id="ImDeviation"/>
<parameter id="RegionInoD"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MeasIntBresenham17">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** V17 (MeasIntBresenham17), version with beg. end end points check, W corr., bb cor</c>
<c>* * fixed div/0 error</c>
<c>* fixed wmin</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c></c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<c></c>
<c>* Processing</c>
<c>* ** going forward from PS1</c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>PIntY := []</l>
<l>i0 := -1</l>
<l>i2 := -1</l>
<l>bfound := 0</l>
<l>vp := Pval[1]</l>
<l>for i := 1 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        if (bfound==0)</l>
<c>            * real def. beginning</c>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>            bfound := 1</l>
<l>        elseif (bfound==2)</l>
<l>            bfound := 1</l>
<l>        endif</l>
<l>    elseif (v==1)</l>
<c>        * ** wire body</c>
<l>        if (bfound==0)</l>
<c>            * preliminary def. beginning</c>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>            bfound := 2</l>
<l>        endif</l>
<l>    elseif (v&gt;1)</l>
<c>        * *** possibly neighbouring wire</c>
<l>        if (bfound==0 and i&lt;pind/2+4)</l>
<l>            PIntX[0] := xc</l>
<l>            PIntY[0] := yc</l>
<l>            i0 := i</l>
<l>        endif</l>
<l>        bfound := 3</l>
<l>    elseif (v==0)</l>
<c>        * space pixel</c>
<l>*         if (i&lt;pind/2)</l>
<l>*             bfound := 0</l>
<l>*         endif</l>
<l>        if (bfound==1)</l>
<c>            * end of real def. beginning search</c>
<l>            PIntX[2] := PPx[i-1]</l>
<l>            PIntY[2] := PPy[i-1]</l>
<l>            i2 := i-1</l>
<c>            * end of 1st search</c>
<l>            break</l>
<l>*             elseif (bfound==3)</l>
<c></c>
<l>        else</l>
<l>            if (vp==0)</l>
<l>                bfound := 0</l>
<l>            endif</l>
<c></c>
<l>        endif</l>
<l>    endif</l>
<l>    vp := v</l>
<l>endfor</l>
<c>* ** going backwards from PS2</c>
<l>gen_region_points (PS2, PPy[pind-1], PPx[pind-1])</l>
<l>i3 := -1</l>
<l>i1 := -1</l>
<l>bfound2 := 0</l>
<l>vp := Pval[pind-1]</l>
<l>for i := pind-2 to 0 by -1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    gen_region_points (Region, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        if (bfound2==0)</l>
<c>            * real def. beginning</c>
<l>            PIntX[1] := xc</l>
<l>            PIntY[1] := yc</l>
<l>            i1 := i</l>
<l>            bfound2 := 1</l>
<l>        elseif (bfound2==2)</l>
<l>            bfound2 := 1</l>
<l>        elseif (bfound2==3)</l>
<l>            bfound2 := 1</l>
<l>        endif</l>
<l>    elseif (v==1)</l>
<c>        * ** wire body</c>
<l>        if (bfound2==0)</l>
<c>            * preliminary def. beginning</c>
<l>            PIntX[1] := xc</l>
<l>            PIntY[1] := yc</l>
<l>            i1 := i</l>
<l>            bfound2 := 2</l>
<l>        endif</l>
<l>    elseif (v&gt;1)</l>
<c>        * *** possibly neighbouring wire</c>
<l>        if (bfound2==0 and i&gt;pind/2-4)</l>
<l>            PIntX[1] := xc</l>
<l>            PIntY[1] := yc</l>
<l>            i1 := i</l>
<l>        endif</l>
<l>        bfound2 := 3</l>
<l>    elseif (v==0)</l>
<c>        * space pixel</c>
<l>*         if (i&lt;pind/2)</l>
<l>*             bfound := 0</l>
<l>*         endif</l>
<l>        if (bfound2==1)</l>
<c>            * end of real def. beginning search</c>
<l>            PIntX[3] := PPx[i+1]</l>
<l>            PIntY[3] := PPy[i+1]</l>
<l>            i3 := i+1</l>
<c>            * end of 2nd search</c>
<l>            break</l>
<l>        else</l>
<l>            if (vp==0)</l>
<l>                bfound2 := 0</l>
<l>            endif</l>
<l>        endif</l>
<c></c>
<l>    endif</l>
<l>    vp := v</l>
<l>endfor</l>
<l>* if (i0==-1 or i1==-1 or i2==-1 or i3==-1)</l>
<l>if (i0==-1 or i1==-1)</l>
<l>    wmin := 0</l>
<l>    wmax := 0</l>
<l>    return ()</l>
<l>endif</l>
<l>ppi00x := PPx[i0]</l>
<l>ppi00y := PPy[i0]</l>
<l>ppi0p1x := PPx[i0+1]</l>
<l>ppi0p1y := PPy[i0+1]</l>
<l>ppi0m1x := PPx[i0-1]</l>
<l>ppi0m1y := PPy[i0-1]</l>
<c></c>
<l>ppi10x := PPx[i1]</l>
<l>ppi10y := PPy[i1]</l>
<l>ppi1p1x := PPx[i1+1]</l>
<l>ppi1p1y := PPy[i1+1]</l>
<l>ppi1m1x := PPx[i1-1]</l>
<l>ppi1m1y := PPy[i1-1]</l>
<l>gen_region_points (P0, PPy[i0], PPx[i0])</l>
<l>gen_region_points (P1, PPy[i1], PPx[i1])</l>
<l>if (i2&gt;=0)</l>
<l>    gen_region_points (P2, PPy[i2], PPx[i2])</l>
<l>endif</l>
<l>if (i3&gt;=0)</l>
<l>    gen_region_points (P3, PPy[i3], PPx[i3])</l>
<l>endif</l>
<c></c>
<c></c>
<l>get_grayval (Im, ppi00y, ppi00x, g)</l>
<l>g0[1] := g</l>
<l>get_grayval (Im, ppi0m1y, ppi0m1x, g)</l>
<l>g0[0] := g</l>
<l>get_grayval (Im, ppi0p1y, ppi0p1x, g)</l>
<l>g0[2] := g</l>
<l>* create_funct_1d_array (g0, Fg0)</l>
<l>* invert_funct_1d (Fg0, Fg0i)</l>
<l>* get_y_value_funct_1d (Fg0i, 50, 'constant', dy0)</l>
<c></c>
<c></c>
<c></c>
<l>get_grayval (Im, ppi10y, ppi10x, g)</l>
<l>g1[1] := g</l>
<l>get_grayval (Im, ppi1m1y, ppi1m1x, g)</l>
<l>g1[0] := g</l>
<l>get_grayval (Im, ppi1p1y, ppi1p1x, g)</l>
<l>g1[2] := g</l>
<l>* create_funct_1d_array (g1, Fg1)</l>
<l>* invert_funct_1d (Fg1, Fg1i)</l>
<l>* get_y_value_funct_1d (Fg1i, 50, 'constant', dy1)</l>
<c></c>
<l>SubPixCrdT (g0, i0, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[0] := pIntX</l>
<l>PIntY[0] := pIntY</l>
<l>SubPixCrdT (g1, i1, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[1] := pIntX</l>
<l>PIntY[1] := pIntY</l>
<l>gen_region_points (RR, PIntY, PIntX)</l>
<l>twolines := 0</l>
<l>tuple_length (PIntX, np)</l>
<l>if (i3 != i0 and np&gt;2 and i2&gt;0)</l>
<l>    get_grayval (Im, PPy[i2], PPx[i2], g)</l>
<l>    g2[1] := g</l>
<l>    get_grayval (Im, PPy[i2-1], PPx[i2-1], g)</l>
<l>    g2[0] := g</l>
<l>    get_grayval (Im, PPy[i2+1], PPx[i2+1], g)</l>
<l>    g2[2] := g</l>
<c></c>
<l>SubPixCrdT (g2, i2, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[2] := pIntX</l>
<l>    PIntY[2] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<l>if (i2 != i1  and np&gt;2 and i3&gt;0)</l>
<l>    get_grayval (Im, PPy[i3], PPx[i3], g)</l>
<l>    g3[1] := g</l>
<l>    get_grayval (Im, PPy[i3-1], PPx[i3-1], g)</l>
<l>    g3[0] := g</l>
<l>    get_grayval (Im, PPy[i3+1], PPx[i3+1], g)</l>
<l>    g3[2] := g</l>
<c></c>
<l>SubPixCrdT (g3, i3, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[3] := pIntX</l>
<l>    PIntY[3] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>wmin := 0</l>
<l>if (np&gt;1)</l>
<l>    if (PIntX[0] != 0 and PIntX[1] != 0 and (twolines==0))</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<l>        wmin := wmax</l>
<l>    endif</l>
<l>    if (twolines==1)</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<c>        * selecting line which includes skeleton</c>
<l>        xc := (ix1+ix2)/2</l>
<l>        yc := (iy1+iy2)/2</l>
<l>        dX := ix2 - ix1</l>
<l>        dY := iy2 - iy1</l>
<l>        if (PIntX[2] != 0 and PIntX[3] != 0)</l>
<l>            if (dX!=0)</l>
<l>                if (xc&lt;=PIntX[0] and xc&gt;=PIntX[2] or xc&gt;=PIntX[0] and xc&lt;=PIntX[2])</l>
<l>                    wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>                elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                    wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>                else</l>
<l>                    wmin := -1</l>
<l>                endif</l>
<l>            else</l>
<l>                if (yc&lt;=PIntY[0] and yc&gt;=PIntY[2] or yc&gt;=PIntY[0] and yc&lt;=PIntY[2])</l>
<l>                    wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>                elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                    wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>                else</l>
<l>                    wmin := -1</l>
<l>                endif</l>
<l>            endif</l>
<l>        else</l>
<l>            wmin := wmax</l>
<l>        endif</l>
<c></c>
<c></c>
<c></c>
<l>    endif</l>
<l>else</l>
<l>    wmax := 0</l>
<l>    wmin := 0</l>
<l>endif</l>
<c></c>
<c>* end p.********************************</c>
<l>return ()</l>
</body>
<docu id="MeasIntBresenham17">
<parameters>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterM4">
<interface>
<ic>
<par name="Func" base_type="ctrl" dimension="0"/>
<par name="size1" base_type="ctrl" dimension="0"/>
<par name="size2" base_type="ctrl" dimension="0"/>
<par name="sm" base_type="ctrl" dimension="0"/>
<par name="ang" base_type="ctrl" dimension="0"/>
<par name="prc" base_type="ctrl" dimension="0"/>
<par name="andnoor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>num_points_funct_1d (Func, n)</l>
<l>if (sm&gt;0)</l>
<l>    smooth_funct_1d_mean (Func, sm, 1, SmoothedFunction)</l>
<l>endif</l>
<l>tang := tan(ang*3.14159/180.)</l>
<l>Y := []</l>
<l>D := []</l>
<l>Dav := []</l>
<l>Prc := []</l>
<l>Prc2 := []</l>
<l>Def := []</l>
<l>for j := 0 to n-1 by 1</l>
<l>*     if (j==11543)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    jm := j-size1</l>
<l>    if (jm&lt;0)</l>
<l>        jm := 0</l>
<l>    endif</l>
<l>    jp := j+size1</l>
<l>    if (jp&gt;n-1)</l>
<l>        jp := n-1</l>
<l>    endif</l>
<l>    jm2 := j-size2</l>
<l>    if (jm2&lt;0)</l>
<l>        jm2 := 0</l>
<l>    endif</l>
<l>    jp2 := j+size2</l>
<l>    if (jp2&gt;n-1)</l>
<l>        jp2 := n-1</l>
<l>    endif</l>
<l>    get_pair_funct_1d (Func, j, x, y)</l>
<l>    get_pair_funct_1d (Func, jp, xp, yp)</l>
<l>    get_pair_funct_1d (Func, jm, xm, ym)</l>
<l>    get_pair_funct_1d (Func, jp2, xp2, yp2)</l>
<l>    get_pair_funct_1d (Func, jm2, xm2, ym2)</l>
<l>*     angle_lx (ym, xm, yp, xp, angl)</l>
<l>*     angle_lx (ym2, xm2, yp2, xp2, angl2)</l>
<l>*     ta := abs(tan(angl))</l>
<l>*     ta2 := abs(tan(angl2))</l>
<l>AngleDist (y, x, ym, xm, yp, xp, d, ta)</l>
<l>AngleDist (y, x, ym2, xm2, yp2, xp2, d2, ta2)</l>
<l>*     distance_ps (y, x, ym, xm, yp, xp, d, DistanceMax)</l>
<l>*     distance_ps (y, x, ym2, xm2, yp2, xp2, d2, DistanceMax)</l>
<l>*     ang := 0.1</l>
<l>*     a := abs(angl)*180./3.1416</l>
<l>*     a2 := abs(angl2)*180./3.1416</l>
<c></c>
<l>    if (abs(ta) &lt;= tang)</l>
<l>        dm := d</l>
<l>    else</l>
<l>        dm := 0</l>
<l>    endif</l>
<c></c>
<l>    if (abs(ta2) &lt;= tang)</l>
<l>        dm2 := d2</l>
<l>    else</l>
<l>        dm2 := 0</l>
<l>    endif</l>
<l>    yav := abs(ym+yp)/2</l>
<l>    yav2 := abs(ym2+yp2)/2</l>
<l>*     prc := abs(d)/abs(yav)</l>
<l>    tuple_concat (Y, y, Y)</l>
<l>    tuple_mean (Y, Ymean)</l>
<l>    tuple_median (Y, Ymed)</l>
<l>    tuple_concat (D, dm, D)</l>
<l>    tuple_min ([yav, yav2], yavm)</l>
<l>    if (yavm &gt; 0)</l>
<l>        measprc := dm*100.0/(yavm)</l>
<l>    else</l>
<l>        measprc := 0</l>
<l>    endif</l>
<l>    if (yavm &gt; 0)</l>
<l>        measprc2 := dm2*100.0/(yavm)</l>
<l>    else</l>
<l>        measprc2 := 0</l>
<l>    endif</l>
<c>    * ** defect finding</c>
<l>    tuple_concat (Prc, measprc, Prc)</l>
<l>    tuple_concat (Dav, yav*0.35, Dav)</l>
<c>    * ** 1 OR 2</c>
<l>    if (andnoor==0)</l>
<l>        if ((abs(dm)&gt;=yav*prc/100.) and ( y &lt;= ym and y &gt;= yp) and ( y &gt;= ym and y &lt;= yp))</l>
<l>            tuple_concat (Def, dm, Def)</l>
<l>        elseif (abs(dm2)&gt;=yav2*prc/100.)</l>
<l>            tuple_concat (Def, dm2, Def)</l>
<l>        else</l>
<l>            tuple_concat (Def, 0, Def)</l>
<l>        endif</l>
<l>    else</l>
<l>        if ((abs(dm)&gt;=yav*prc/100.) and (abs(dm2)&gt;=yav2*prc/100.))</l>
<l>            if (abs(dm)&gt;abs(dm2))</l>
<l>                tuple_concat (Def, dm, Def)</l>
<l>            else</l>
<l>                tuple_concat (Def, dm2, Def)</l>
<l>            endif</l>
<l>        else</l>
<l>            tuple_concat (Def, 0, Def)</l>
<l>        endif</l>
<l>    endif</l>
<c></c>
<c>    * ** 1 AND 2</c>
<c></c>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="FilterM4">
<parameters>
<parameter id="Def"/>
<parameter id="Func"/>
<parameter id="Prc"/>
<parameter id="andnoor"/>
<parameter id="ang"/>
<parameter id="prc"/>
<parameter id="size1"/>
<parameter id="size2"/>
<parameter id="sm"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloatMed">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="prcmb" base_type="ctrl" dimension="0"/>
<par name="prcsp" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<l>tuple_gen_const (nW, -prcmb, ThrMB)</l>
<l>tuple_gen_const (nW, prcsp, ThrSp)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<l>Prc := Wch*100.0/(Wfilt+0.001)</l>
<l>tuple_greater_equal_elem (Prc, ThrSp, DefSp)</l>
<l>tuple_less_equal_elem (Prc, ThrMB, DefMB)</l>
<l>Def := -DefMB+DefSp</l>
<l>return ()</l>
</body>
<docu id="FilterFloatMed">
<parameters>
<parameter id="Def"/>
<parameter id="Prc"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="prcmb"/>
<parameter id="prcsp"/>
<parameter id="sz"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloatMed_COPY_1">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="prcmb" base_type="ctrl" dimension="0"/>
<par name="prcsp" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<c></c>
<l>tuple_gen_const (nW, -prcmb, ThrMB)</l>
<l>tuple_gen_const (nW, prcsp, ThrSp)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<l>Prc := Wch*100.0/Wfilt</l>
<l>tuple_greater_equal_elem (Prc, ThrSp, DefSp)</l>
<l>tuple_less_equal_elem (Prc, ThrMB, DefMB)</l>
<l>Def := (DefMB+DefSp)*Prc</l>
<l>return ()</l>
<c></c>
</body>
<docu id="FilterFloatMed_COPY_1">
<parameters>
<parameter id="Def"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="prcmb"/>
<parameter id="prcsp"/>
<parameter id="sz"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloatMedNFWM">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="pixmb" base_type="ctrl" dimension="0"/>
<par name="pixsp" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<l>tuple_gen_const (nW, -pixmb, ThrMB)</l>
<l>tuple_gen_const (nW, pixsp, ThrSp)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<c></c>
<l>tuple_greater_equal_elem (Wch, ThrSp, DefSp)</l>
<l>tuple_less_equal_elem (Wch, ThrMB, DefMB)</l>
<l>Def := DefMB+DefSp</l>
<l>return ()</l>
</body>
<docu id="FilterFloatMedNFWM">
<parameters>
<parameter id="Def"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="pixmb"/>
<parameter id="pixsp"/>
<parameter id="sz"/>
</parameters>
</docu>
</procedure>
<procedure name="MSProc2">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc2 V1 (MeasIntBresenham14), version with beg. end end points check, W corr., bb cor</c>
<c>* * fixed div/0 error</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for PC---&gt;P1</c>
<l>deltaX1 := abs(ix1 - ixc)</l>
<l>deltaY1 := abs(iy1 - iyc)</l>
<l>if (ixc &lt; ix1)</l>
<l>    signX1 := 1</l>
<l>else</l>
<l>    signX1 := -1</l>
<l>endif</l>
<l>if (iyc &lt; iy1)</l>
<l>    signY1 := 1</l>
<l>else</l>
<l>    signY1 := -1</l>
<l>endif</l>
<c></c>
<l>error1 := deltaX1 - deltaY1</l>
<c></c>
<l>* signX2 := -signX</l>
<l>* signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ixc</l>
<l>yintc := iyc</l>
<l>xintn := ixc</l>
<l>yintn := iyc</l>
<c></c>
<l>xpb := ixc</l>
<l>ypb := iyc</l>
<l>xc := ixc</l>
<l>yc := iyc</l>
<l>xn := ixc</l>
<l>yn := iyc</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PP1x := []</l>
<l>PP1y := []</l>
<l>Pval1 := []</l>
<l>* Pclc1 := []</l>
<l>g0 := [0,0,0]</l>
<l>g2 := [0,0,0]</l>
<c>* *******Bres. cycle 1 ***********************</c>
<l>ix := ixc</l>
<l>iy := iyc</l>
<l>cnt := 0</l>
<l>error := deltaX1 - deltaY1</l>
<l>pind := 0</l>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix1 or iy != iy1)</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>*     get_grayval (ImageCLC, iy, ix, clc)</l>
<l>    PP1x := [PP1x,ix]</l>
<l>    PP1y := [PP1y,iy]</l>
<l>    Pval1 := [Pval1,v]</l>
<l>*     Pclc1 := [Pval1,clc]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY1)</l>
<l>        error := error-deltaY1</l>
<l>        ix := ix+signX1</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX1)</l>
<l>        error := error+deltaX1</l>
<l>        iy := iy+signY1</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR1, PP1y, PP1x)</l>
<l>* intersection (PPR, RegionIRB, RegionInt)</l>
<l>* get_region_points (RegionInt, Rows, Columns)</l>
<l>* tuple_length (Rows, l)</l>
<l>* if (l&lt;2)</l>
<l>*     wmax := 0</l>
<l>*     return ()</l>
<l>* endif</l>
<c></c>
<l>* if (pnum ==0)</l>
<l>*     get_grayval (ImageIRB, Rows, Columns, Grayval)</l>
<l>*     tuple_median (Grayval, pnum)</l>
<l>* endif</l>
<c></c>
<c>* Processing</c>
<c>* ** going forward to PS1</c>
<c></c>
<l>* gen_region_points (PS1, PP1y[0], PP1x[0])</l>
<l>* stop()</l>
<c></c>
<l>PInt1Y := []</l>
<l>PInt1X := []</l>
<l>i0 := -1</l>
<l>i2 := -1</l>
<l>bfound := 0</l>
<c></c>
<l>for i := 1 to pind-1 by 1</l>
<l>    xc := PP1x[i]</l>
<l>    yc := PP1y[i]</l>
<c>    </c>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval1[i]</l>
<l>    if (v==pnum)</l>
<c>        *** boundary point found</c>
<c>        * finding CLC</c>
<l>        get_grayval(ImageCLC, yc, xc, clc)</l>
<l>        if (bfound==0)</l>
<l>            clc0:=clc</l>
<l>            dclc:=0</l>
<l>        else</l>
<l>            dclc:=min2(abs(clc-clc0), abs(clc-255-clc0)) </l>
<l>        endif</l>
<c>        * verifying CLC</c>
<l>        if(dclc &lt; clcmax)</l>
<l>            if (bfound==0)</l>
<l>                PInt1X[0] := xc</l>
<l>                PInt1Y[0] := yc</l>
<l>                i0 := i</l>
<l>                bfound := 1 </l>
<l>                clc0:=clc</l>
<l>            else</l>
<l>                if(i&gt;i0+1)</l>
<l>                     PInt1X[2] := PInt1X[0]</l>
<l>                     PInt1Y[2] := PInt1Y[0]</l>
<l>                     i2 := i</l>
<l>                     clc2:=clc</l>
<l>                else</l>
<l>                     i2 := i0</l>
<l>                     i0 := i</l>
<l>                     clc2:=clc0</l>
<l>                endif</l>
<l>                PInt1X[0] := xc</l>
<l>                PInt1Y[0] := yc</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* t:=thr</l>
<c></c>
<l>ppi00x := PP1x[i0]</l>
<l>ppi00y := PP1y[i0]</l>
<l>ppi0p1x := PP1x[i0+1]</l>
<l>ppi0p1y := PP1y[i0+1]</l>
<l>ppi0m1x := PP1x[i0-1]</l>
<l>ppi0m1y := PP1y[i0-1]</l>
<c></c>
<l>get_grayval (Im, ppi00y, ppi00x, g)</l>
<l>g0[1] := g</l>
<l>get_grayval (Im, ppi0m1y, ppi0m1x, g)</l>
<l>g0[0] := g</l>
<l>get_grayval (Im, ppi0p1y, ppi0p1x, g)</l>
<l>g0[2] := g</l>
<c></c>
<l>SubPixCrdT (g0, i0, PP1x, PP1y, sub, thr, pIntX, pIntY)</l>
<l>PIntX[0] := pIntX</l>
<l>PIntY[0] := pIntY</l>
<c></c>
<l>tuple_length (PInt1X, np)</l>
<l>if (np&gt;1)</l>
<l>    get_grayval (Im, PP1y[i2], PP1x[i2], g)</l>
<l>    g2[1] := g</l>
<l>    get_grayval (Im, PP1y[i2-1], PP1x[i2-1], g)</l>
<l>    g2[0] := g</l>
<l>    get_grayval (Im, PP1y[i2+1], PP1x[i2+1], g)</l>
<l>    g2[2] := g</l>
<c></c>
<l>    SubPixCrdT (g2, i2, PP1x, PP1y, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[2] := pIntX</l>
<l>    PIntY[2] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<l>* gen_region_points (PInt1, PInt1Y, PInt1X)</l>
<l>* stop()</l>
<l>* gen_region_points (PS1, PP1y[0], PP1x[0])</l>
<c></c>
<c>* ** going to PS2</c>
<c>**** for PC---&gt;P2</c>
<l>deltaX2 := abs(ix2 - ixc)</l>
<l>deltaY2 := abs(iy2 - iyc)</l>
<l>if (ixc &lt; ix2)</l>
<l>    signX2 := 1</l>
<l>else</l>
<l>    signX2 := -1</l>
<l>endif</l>
<l>if (iyc &lt; iy2)</l>
<l>    signY2 := 1</l>
<l>else</l>
<l>    signY2 := -1</l>
<l>endif</l>
<c></c>
<l>error := deltaX2 - deltaY2</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ixc</l>
<l>yintc := iyc</l>
<l>xintn := ixc</l>
<l>yintn := iyc</l>
<c></c>
<l>xpb := ixc</l>
<l>ypb := iyc</l>
<l>xc := ixc</l>
<l>yc := iyc</l>
<l>xn := ixc</l>
<l>yn := iyc</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PP2x := []</l>
<l>PP2y := []</l>
<l>Pval2 := []</l>
<l>* Pclc1 := []</l>
<l>g1 := [0,0,0]</l>
<l>g3 := [0,0,0]</l>
<c>* *******Bres. cycle 2 ***********************</c>
<l>ix := ixc</l>
<l>iy := iyc</l>
<l>cnt := 0</l>
<l>error := deltaX2 - deltaY2</l>
<l>pind := 0</l>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>*     get_grayval (ImageCLC, iy, ix, clc)</l>
<l>    PP2x := [PP2x,ix]</l>
<l>    PP2y := [PP2y,iy]</l>
<l>    Pval2 := [Pval2,v]</l>
<l>*     Pclc1 := [Pval1,clc]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY2)</l>
<l>        error := error-deltaY1</l>
<l>        ix := ix+signX2</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX2)</l>
<l>        error := error+deltaX2</l>
<l>        iy := iy+signY2</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR2, PP2y, PP2x)</l>
<c></c>
<c>* Processing</c>
<c>* ** going forward to PS2</c>
<c></c>
<l>* gen_region_points (PS2, PP2y[0], PP2x[0])</l>
<l>* stop()</l>
<c></c>
<l>i1 := -1</l>
<l>i3 := -1</l>
<l>bfound := 0</l>
<c></c>
<l>for i := 0 to pind-1 by 1</l>
<l>    xc := PP2x[i]</l>
<l>    yc := PP2y[i]</l>
<c>    </c>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval2[i]</l>
<l>    if (v==pnum)</l>
<c>        *** boundary point found</c>
<c>        * finding CLC</c>
<l>        get_grayval(ImageCLC, yc, xc, clc)</l>
<l>        if (bfound==0)</l>
<l>            clc0:=clc</l>
<l>            dclc:=0</l>
<l>        else</l>
<l>            dclc:=min2(abs(clc-clc0), abs(clc-255-clc0)) </l>
<l>        endif</l>
<c>        * verifying CLC</c>
<l>        if(dclc &lt; clcmax)</l>
<l>            if (bfound==0)</l>
<l>                PInt2X[0] := xc</l>
<l>                PInt2Y[0] := yc</l>
<l>                i1 := i</l>
<l>                bfound := 1 </l>
<l>                clc1:=clc</l>
<l>            else</l>
<l>                if(i&gt;i1+1)</l>
<l>                     PInt2X[2] := PInt2X[0]</l>
<l>                     PInt2Y[2] := PInt2Y[0]</l>
<l>                     i3 := i</l>
<l>                     clc2:=clc</l>
<l>                else</l>
<l>                     i3 := i1</l>
<l>                     i1 := i</l>
<l>                     clc3:=clc1</l>
<l>                endif</l>
<l>                PInt2X[0] := xc</l>
<l>                PInt2Y[0] := yc</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* t:=thr</l>
<c></c>
<l>ppi10x := PP2x[i1]</l>
<l>ppi10y := PP2y[i1]</l>
<l>ppi1p1x := PP2x[i1+1]</l>
<l>ppi1p1y := PP2y[i1+1]</l>
<l>ppi1m1x := PP2x[i1-1]</l>
<l>ppi1m1y := PP2y[i1-1]</l>
<c></c>
<l>get_grayval (Im, ppi10y, ppi10x, g)</l>
<l>g1[1] := g</l>
<l>get_grayval (Im, ppi1m1y, ppi1m1x, g)</l>
<l>g1[0] := g</l>
<l>get_grayval (Im, ppi1p1y, ppi1p1x, g)</l>
<l>g1[2] := g</l>
<c></c>
<l>SubPixCrdT (g1, i1, PP2x, PP2y, sub, thr, pIntX, pIntY)</l>
<l>PIntX[1] := pIntX</l>
<l>PIntY[1] := pIntY</l>
<c></c>
<l>tuple_length (PInt2X, np)</l>
<l>if (np&gt;1)</l>
<l>    get_grayval (Im, PP1y[i3], PP1x[i3], g)</l>
<l>    g3[1] := g</l>
<l>    get_grayval (Im, PP1y[i3-1], PP1x[i3-1], g)</l>
<l>    g3[0] := g</l>
<l>    get_grayval (Im, PP1y[i3+1], PP1x[i3+1], g)</l>
<l>    g3[2] := g</l>
<c></c>
<l>    SubPixCrdT (g3, i3, PP2x, PP2y, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[3] := pIntX</l>
<l>    PIntY[3] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c>********</c>
<l>gen_region_points(PInt, PIntY, PIntX)</l>
<l>* stop()</l>
<l>* if (i0==-1 or i1==-1 or i2==-1 or i3==-1)</l>
<l>if (i0==-1 or i1==-1)</l>
<l>    wmin := 0</l>
<l>    wmax := 0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>tuple_length (PIntX, np)</l>
<l>wmin := 0</l>
<l>if (np==2)</l>
<l>    if (PIntX[0] != 0 and PIntX[1] != 0 )</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<l>        wmin := 0</l>
<l>    endif</l>
<c>       </c>
<l>elseif (np==4)</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<c>        * selecting line which includes skeleton</c>
<l>*         xc := (ix1+ix2)/2</l>
<l>*         yc := (iy1+iy2)/2</l>
<l>        dX := ix2 - ix1</l>
<l>        dY := iy2 - iy1</l>
<l>        if (dX!=0)</l>
<l>            if (xc&lt;=PIntX[0] and xc&gt;=PIntX[2] or xc&gt;=PIntX[0] and xc&lt;=PIntX[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        else</l>
<l>            if (yc&lt;=PIntY[0] and yc&gt;=PIntY[2] or yc&gt;=PIntY[0] and yc&lt;=PIntY[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        endif</l>
<c></c>
<c></c>
<l>    *endif</l>
<l>else</l>
<l>    wmax := 0</l>
<l>    wmin := 0</l>
<l>endif</l>
<l>* stop()</l>
<c>* end p.********************************</c>
<l>return ()</l>
</body>
<docu id="MSProc2">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSProc21">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc21 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c></c>
<l>PInt1Y := []</l>
<l>PInt1X := []</l>
<l>i0 := -1</l>
<l>i2 := -1</l>
<l>bfound := 0</l>
<c></c>
<l>for i := 1 to ic+1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<c>    </c>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<c>        *** boundary point found</c>
<c>        * finding CLC</c>
<l>        get_grayval(ImageCLC, yc, xc, clc)</l>
<l>        if (bfound==0)</l>
<l>            clc0:=clc</l>
<l>            dclc:=0</l>
<l>        else</l>
<l>            dclc:=min2(abs(clc-clc0), abs(clc-255-clc0)) </l>
<l>        endif</l>
<c>        * verifying CLC</c>
<l>        if(dclc &lt; clcmax)</l>
<l>            if (bfound==0)</l>
<l>                PIntX[0] := xc</l>
<l>                PIntY[0] := yc</l>
<l>                i0 := i</l>
<l>                bfound := 1 </l>
<l>                clc0:=clc</l>
<l>            else</l>
<l>                if(i&gt;i0+1)</l>
<l>                     PIntX[2] := PIntX[0]</l>
<l>                     PIntY[2] := PIntY[0]</l>
<l>                     i2 := i</l>
<l>                     clc2:=clc</l>
<l>                else</l>
<l>                     i2 := i0</l>
<l>                     i0 := i</l>
<l>                     clc2:=clc0</l>
<l>                endif</l>
<l>                PIntX[0] := xc</l>
<l>                PIntY[0] := yc</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* t:=thr</l>
<c></c>
<l>ppi00x := PPx[i0]</l>
<l>ppi00y := PPy[i0]</l>
<l>ppi0p1x := PPx[i0+1]</l>
<l>ppi0p1y := PPy[i0+1]</l>
<l>ppi0m1x := PPx[i0-1]</l>
<l>ppi0m1y := PPy[i0-1]</l>
<c></c>
<l>get_grayval (Im, ppi00y, ppi00x, g)</l>
<l>g0[1] := g</l>
<l>get_grayval (Im, ppi0m1y, ppi0m1x, g)</l>
<l>g0[0] := g</l>
<l>get_grayval (Im, ppi0p1y, ppi0p1x, g)</l>
<l>g0[2] := g</l>
<c></c>
<l>SubPixCrdT (g0, i0, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[0] := pIntX</l>
<l>PIntY[0] := pIntY</l>
<c></c>
<l>* tuple_length (PIntX, np)</l>
<l>if (i2!=-1)</l>
<l>    get_grayval (Im, PPy[i2], PPx[i2], g)</l>
<l>    g2[1] := g</l>
<l>    get_grayval (Im, PPy[i2-1], PPx[i2-1], g)</l>
<l>    g2[0] := g</l>
<l>    get_grayval (Im, PPy[i2+1], PPx[i2+1], g)</l>
<l>    g2[2] := g</l>
<c></c>
<l>    SubPixCrdT (g2, i2, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[2] := pIntX</l>
<l>    PIntY[2] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>* stop()</l>
<l>* gen_region_points (PS1, PP1y[0], PP1x[0])</l>
<c></c>
<c>* ** going to PS2</c>
<c>**** for PC---&gt;P2</c>
<c></c>
<c>* Processing</c>
<l>gen_region_points (PS2, PPy[pind-1], PPx[pind-1])</l>
<l>* stop()</l>
<c></c>
<l>i1 := -1</l>
<l>i3 := -1</l>
<l>bfound := 0</l>
<c></c>
<l>for i := ic-1 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<c>    </c>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<c>        *** boundary point found</c>
<c>        * finding CLC</c>
<l>        get_grayval(ImageCLC, yc, xc, clc)</l>
<l>        if (bfound==0)</l>
<l>            clc0:=clc</l>
<l>            dclc:=0</l>
<l>        else</l>
<l>            dclc:=min2(abs(clc-clc0), abs(clc-255-clc0)) </l>
<l>        endif</l>
<c>        * verifying CLC</c>
<l>        if(dclc &lt; clcmax)</l>
<l>            if (bfound==0)</l>
<l>                PIntX[1] := xc</l>
<l>                PIntY[1] := yc</l>
<l>                i1 := i</l>
<l>                bfound := 1 </l>
<l>                clc1:=clc</l>
<l>            else</l>
<l>                if(i&gt;i1+1)</l>
<l>                     PIntX[3] := PIntX[1]</l>
<l>                     PIntY[3] := PIntY[1]</l>
<l>                     i3 := i</l>
<l>                     clc2:=clc</l>
<l>                else</l>
<l>                     i3 := i1</l>
<l>                     i1 := i</l>
<l>                     clc3:=clc1</l>
<l>                endif</l>
<l>                PIntX[1] := xc</l>
<l>                PIntY[1] := yc</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* t:=thr</l>
<c></c>
<l>ppi10x := PPx[i1]</l>
<l>ppi10y := PPy[i1]</l>
<l>ppi1p1x := PPx[i1+1]</l>
<l>ppi1p1y := PPy[i1+1]</l>
<l>ppi1m1x := PPx[i1-1]</l>
<l>ppi1m1y := PPy[i1-1]</l>
<c></c>
<l>get_grayval (Im, ppi10y, ppi10x, g)</l>
<l>g1[1] := g</l>
<l>get_grayval (Im, ppi1m1y, ppi1m1x, g)</l>
<l>g1[0] := g</l>
<l>get_grayval (Im, ppi1p1y, ppi1p1x, g)</l>
<l>g1[2] := g</l>
<c></c>
<l>SubPixCrdT (g1, i1, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[1] := pIntX</l>
<l>PIntY[1] := pIntY</l>
<c></c>
<l>tuple_length (PIntX, np)</l>
<l>if (i3!=-1)</l>
<l>    get_grayval (Im, PPy[i3], PPx[i3], g)</l>
<l>    g3[1] := g</l>
<l>    get_grayval (Im, PPy[i3-1], PPx[i3-1], g)</l>
<l>    g3[0] := g</l>
<l>    get_grayval (Im, PPy[i3+1], PPx[i3+1], g)</l>
<l>    g3[2] := g</l>
<c></c>
<l>    SubPixCrdT (g3, i3, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[3] := pIntX</l>
<l>    PIntY[3] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c>********</c>
<l>gen_region_points(PInt, PIntY, PIntX)</l>
<l>* stop()</l>
<l>* if (i0==-1 or i1==-1 or i2==-1 or i3==-1)</l>
<l>if (i0==-1 or i1==-1)</l>
<l>    wmin := 0</l>
<l>    wmax := 0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>tuple_length (PIntX, np)</l>
<l>wmin := 0</l>
<l>if (np==2)</l>
<l>    if (PIntX[0] != 0 and PIntX[1] != 0 )</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<l>        wmin := 0</l>
<l>    endif</l>
<c>       </c>
<l>elseif (np==4)</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<c>        * selecting line which includes skeleton</c>
<l>        dX := ix2 - ix1</l>
<l>        dY := iy2 - iy1</l>
<l>        if (dX!=0)</l>
<l>            if (xc&lt;=PIntX[0] and xc&gt;=PIntX[2] or xc&gt;=PIntX[0] and xc&lt;=PIntX[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        else</l>
<l>            if (yc&lt;=PIntY[0] and yc&gt;=PIntY[2] or yc&gt;=PIntY[0] and yc&lt;=PIntY[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        endif</l>
<l>else</l>
<l>    wmax := 0</l>
<l>    wmin := 0</l>
<l>endif</l>
<l>* stop()</l>
<c>* end p.********************************</c>
<l>return ()</l>
</body>
<docu id="MSProc21">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSProc30">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc30 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<c></c>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;pPat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('red')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        if((vp==0 or (vp&gt;1 and vp!= pnum)) or vn==0 )    </l>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-255-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                ii:=ii+1</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==1 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>    endif</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        ii:=ii+1</l>
<l>        if(Pval[pind-2]==0)</l>
<l>            PIntY[ii]:=PPy[pind-1]</l>
<l>            PIntX[ii]:=PPx[pind-1]</l>
<l>            PInti[ii]:=pind-1</l>
<l>            PCLC[ii]:=clc</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>        get_grayval (Im, PPy[PInti[j]], PPx[PInti[j]],  g)</l>
<l>        g0[1] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>        g0[2] := g</l>
<l>        SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW segment</c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* stop()</l>
<c>*** finding SP points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>        if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>            continue</l>
<l>        else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSProc30">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSProc30o1">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc30 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>    gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>dev_display(PPR)</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;pPat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    dev_display(Pc)</l>
<l>    get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        PIntY[ii]:=yc</l>
<l>        PIntX[ii]:=xc</l>
<l>        noaddii:=0</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('blue')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<c>        </c>
<l>        dev_display(Pc)</l>
<c>        * checking previous sensor point</c>
<c>        </c>
<l>        if(vp==0)</l>
<l>            ptype:=1</l>
<l>        elseif(vp==1)</l>
<l>            ptype:=0</l>
<l>        elseif(vp==pnum)</l>
<c>            * previous point also belongs to boundary, </c>
<c>            * need to select 1 from 2 points</c>
<c>            </c>
<l>*             get_grayval(Im, PPy[i-1], PPx[i-1], gp)</l>
<l>            if(g&gt;gp)</l>
<l>*                 ii:=ii-1</l>
<l>                PIntY[ii-1]:=PPy[i-1]</l>
<l>                PIntX[ii-1]:=PPx[i-1]</l>
<l>                PIntY[ii]:=-1</l>
<l>                PIntX[ii]:=-1</l>
<l>                noaddii:=1</l>
<l>            endif</l>
<l>        endif</l>
<c>        *** boundary point found</c>
<c>        * finding CLC</c>
<l>        get_grayval(ImageCLC, yc, xc, clc)</l>
<l>        Ptype[ii]:=ptype</l>
<l>        PCLC[ii]:=clc</l>
<l>        if(noaddii==0)</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>     endif</l>
<l>    vp:=v</l>
<l>    gp:=g</l>
<l>endfor</l>
<l>* t:=thr</l>
<c>*********************************************************</c>
<l>stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c>***********************************************************</c>
<l>ppi00x := PPx[i0]</l>
<l>ppi00y := PPy[i0]</l>
<l>ppi0p1x := PPx[i0+1]</l>
<l>ppi0p1y := PPy[i0+1]</l>
<l>ppi0m1x := PPx[i0-1]</l>
<l>ppi0m1y := PPy[i0-1]</l>
<c></c>
<l>get_grayval (Im, ppi00y, ppi00x, g)</l>
<l>g0[1] := g</l>
<l>get_grayval (Im, ppi0m1y, ppi0m1x, g)</l>
<l>g0[0] := g</l>
<l>get_grayval (Im, ppi0p1y, ppi0p1x, g)</l>
<l>g0[2] := g</l>
<c></c>
<l>SubPixCrdT (g0, i0, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[0] := pIntX</l>
<l>PIntY[0] := pIntY</l>
<c></c>
<l>* tuple_length (PIntX, np)</l>
<l>if (i2!=-1)</l>
<l>    get_grayval (Im, PPy[i2], PPx[i2], g)</l>
<l>    g2[1] := g</l>
<l>    get_grayval (Im, PPy[i2-1], PPx[i2-1], g)</l>
<l>    g2[0] := g</l>
<l>    get_grayval (Im, PPy[i2+1], PPx[i2+1], g)</l>
<l>    g2[2] := g</l>
<c></c>
<l>    SubPixCrdT (g2, i2, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[2] := pIntX</l>
<l>    PIntY[2] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>* stop()</l>
<l>* gen_region_points (PS1, PP1y[0], PP1x[0])</l>
<c></c>
<c></c>
<l>ppi10x := PPx[i1]</l>
<l>ppi10y := PPy[i1]</l>
<l>ppi1p1x := PPx[i1+1]</l>
<l>ppi1p1y := PPy[i1+1]</l>
<l>ppi1m1x := PPx[i1-1]</l>
<l>ppi1m1y := PPy[i1-1]</l>
<c></c>
<l>get_grayval (Im, ppi10y, ppi10x, g)</l>
<l>g1[1] := g</l>
<l>get_grayval (Im, ppi1m1y, ppi1m1x, g)</l>
<l>g1[0] := g</l>
<l>get_grayval (Im, ppi1p1y, ppi1p1x, g)</l>
<l>g1[2] := g</l>
<c></c>
<l>SubPixCrdT (g1, i1, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>PIntX[1] := pIntX</l>
<l>PIntY[1] := pIntY</l>
<c></c>
<l>tuple_length (PIntX, np)</l>
<l>if (i3!=-1)</l>
<l>    get_grayval (Im, PPy[i3], PPx[i3], g)</l>
<l>    g3[1] := g</l>
<l>    get_grayval (Im, PPy[i3-1], PPx[i3-1], g)</l>
<l>    g3[0] := g</l>
<l>    get_grayval (Im, PPy[i3+1], PPx[i3+1], g)</l>
<l>    g3[2] := g</l>
<c></c>
<l>    SubPixCrdT (g3, i3, PPx, PPy, sub, thr, pIntX, pIntY)</l>
<l>    PIntX[3] := pIntX</l>
<l>    PIntY[3] := pIntY</l>
<l>    twolines := 1</l>
<l>endif</l>
<c>********</c>
<l>gen_region_points(PInt, PIntY, PIntX)</l>
<l>* stop()</l>
<l>* if (i0==-1 or i1==-1 or i2==-1 or i3==-1)</l>
<l>if (i0==-1 or i1==-1)</l>
<l>    wmin := 0</l>
<l>    wmax := 0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>tuple_length (PIntX, np)</l>
<l>wmin := 0</l>
<l>if (np==2)</l>
<l>    if (PIntX[0] != 0 and PIntX[1] != 0 )</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<l>        wmin := 0</l>
<l>    endif</l>
<c>       </c>
<l>elseif (np==4)</l>
<l>        wmax := sqrt( (PIntX[0] - PIntX[1])*(PIntX[0] - PIntX[1]) + (PIntY[0] - PIntY[1])*(PIntY[0] - PIntY[1]) )</l>
<c>        * selecting line which includes skeleton</c>
<l>        dX := ix2 - ix1</l>
<l>        dY := iy2 - iy1</l>
<l>        if (dX!=0)</l>
<l>            if (xc&lt;=PIntX[0] and xc&gt;=PIntX[2] or xc&gt;=PIntX[0] and xc&lt;=PIntX[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        else</l>
<l>            if (yc&lt;=PIntY[0] and yc&gt;=PIntY[2] or yc&gt;=PIntY[0] and yc&lt;=PIntY[2])</l>
<l>                wmin := sqrt( (PIntX[0] - PIntX[2])*(PIntX[0] - PIntX[2]) + (PIntY[0] - PIntY[2])*(PIntY[0] - PIntY[2]) )</l>
<l>            elseif (xc&lt;=PIntX[1] and xc&gt;=PIntX[3] or xc&gt;=PIntX[1] and xc&lt;=PIntX[3])</l>
<l>                wmin := sqrt( (PIntX[1] - PIntX[3])*(PIntX[1] - PIntX[3]) + (PIntY[1] - PIntY[3])*(PIntY[1] - PIntY[3]) )</l>
<l>            else</l>
<l>                wmin := -1</l>
<l>            endif</l>
<l>        endif</l>
<l>else</l>
<l>    wmax := 0</l>
<l>    wmin := 0</l>
<l>endif</l>
<l>* stop()</l>
<c>* end p.********************************</c>
<l>return ()</l>
</body>
<docu id="MSProc30o1">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="pnum"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL101">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL1 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>SkeletonG:=SkeletonGi</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>rcep:=5</l>
<l>tuple_length(RowsEP, nEP)</l>
<l>tuple_gen_const(nEP, rcep, Rcep)</l>
<l>gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacement, 1, 128)</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>Wmain := [6, 6, 6]</l>
<l>wside := 3</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( (w &gt;= Wmain[0]-wside and w &lt;= Wmain[0]+wside) or (w &gt;= Wmain[1]-wside and w &lt;= Wmain[1]+wside) or (w &gt;= Wmain[2]-wside and w &lt;= Wmain[2]+wside) )</l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>* stop ()</l>
<c></c>
<l>WmainS := [25, 25]</l>
<l>wsides := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>jrad:=9</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP ***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>tuple_length(RowsE, nE)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, 7, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c></c>
<c>*** FWMS (for space)</c>
<l>SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c></c>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ****************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<l>MSBuildFWM4 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL101">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenFU3">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
<par name="d" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nOp" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** OPEN  FillUp******</c>
<c>* 202290317 fixed very big open problem</c>
<c>* 202290317 added RegionsOpCon - connection line for 2 parts of Open defect</c>
<l>if(d&gt;1)</l>
<l>    dilation_circle (RegionI, RegionId, d)</l>
<l>else</l>
<l>    RegionId:=RegionI</l>
<l>endif</l>
<c></c>
<l>difference (SkeletonG, RegionId, RegionSkGI)</l>
<l>connection (RegionSkGI, RegionsSkGI)</l>
<l>area_center (RegionsSkGI, Area, RowOpC, ColOpC)</l>
<l>* gen_region_points (RC, RowOpC, ColOpC)</l>
<l>* connection(RC, RCs)</l>
<l>* gen_rectangle1(RCRs, RowOpC-1, ColOpC-1, RowOpC+1, ColOpC+1)</l>
<l>tuple_length (RowOpC, nOpC)</l>
<c></c>
<l>nOp := 0</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j := 1 to nOpC by 1</l>
<l>*     select_obj(RCRs,ObjectSelected, j)</l>
<l>*     intersection(ObjectSelected, RegionId,Ri)</l>
<l>*     connection(Ri, RiC)</l>
<l>*     count_obj(RiC, nRiC)</l>
<l>*     if(nRiC==1)</l>
<l>*         continue</l>
<l>*     endif</l>
<l>    select_obj (RegionsSkGI, RegionsSkGISel, j)</l>
<l>    get_region_points (RegionsSkGISel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    if(np==0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>*     if(j==225)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     gen_region_points (R, row, col)</l>
<l>*     if (row&gt;5415 and row&lt;5423)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     gen_region_points (P, Rows[np/2], Cols[np/2])</l>
<l>*     get_grayval (DirImageP, row, col, dirOpC)</l>
<l>    get_grayval (WidthImageP, row, col, widthOpC)</l>
<l>    if(widthOpC==0)</l>
<l>        continue</l>
<l>    endif</l>
<c></c>
<l>*     angsOpC := dirOpC*3.1415926/256.0</l>
<l>*     angsOpC := dirOpC*0.012271846</l>
<c></c>
<l>*     region_features (RegionsSkGISel, 'rect2_len1', l1)</l>
<l>*     tuple_max2 (widthOpC*coef/2, l1+wgap*2, recw)</l>
<l>*     gen_rectangle2 (Rect, row, col, angsOpC, widthOpC*coef/2, recw)</l>
<c>    </c>
<l>    dilation_circle(RegionsSkGISel, RegA, widthOpC*coef/2)</l>
<c>    </c>
<l>*     intersection (Rect, RegionI, RegionIR)</l>
<l>    intersection (RegA, RegionI, RegionIR)</l>
<c>    </c>
<l>    connection (RegionIR, RegionsIRCon)</l>
<l>    count_obj (RegionsIRCon, nR)</l>
<l>    intersection (RegA, SkeletonG, SkelGR)</l>
<l>    connection (SkelGR, SkelGRCon)</l>
<l>    count_obj (SkelGRCon, nS)</l>
<c></c>
<l>*     intersection (RegionsIRCon, SkeletonG, RegionsIRConSkeli)</l>
<l>*     select_shape (RegionsIRConSkeli, RegionsIRConSkel, 'area', 'and', 1, 99999)</l>
<l>*     count_obj (RegionsIRConSkel, nIRcons)</l>
<l>    for n := 1 to nS by 1</l>
<l>        select_obj (SkelGRCon, SkelS, n)</l>
<l>        numint := 0</l>
<l>        gen_empty_obj (Reg)</l>
<l>        for nn := 1 to nR by 1</l>
<l>            select_obj (RegionsIRCon, RegR, nn)</l>
<l>            intersection (SkelS, RegR, RInt)</l>
<l>            area_center (RInt, a, r, c)</l>
<l>            if (a&gt;0)</l>
<l>                numint := numint+1</l>
<l>                concat_obj (Reg, RegR, Reg)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (numint &gt; 1)</l>
<l>            nOp := nOp+1</l>
<l>            if(nOp==26)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            union1 (Reg, Regu)</l>
<l>            concat_obj (RegionsOp, Regu, RegionsOp)</l>
<l>*             union1(RegionsOp, RegionOp)</l>
<l>*             complement(RegA, RegAC)</l>
<l>*             expand_region(SkelS, RegAC, RegOpCon, 'maximal', 'image')</l>
<l>            dilation_circle(SkelS, SkelSd, 1)</l>
<l>            concat_obj (RegionsOpCon, SkelSd, RegionsOpCon)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenFU3">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionI"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
<parameter id="coef"/>
<parameter id="d"/>
<parameter id="nOp"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCL">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c></c>
<l>VaddrC := {1}</l>
<l>VaddrC.clear()</l>
<l>addr:=0</l>
<l>VnumC := {1}</l>
<l>VnumC.clear()</l>
<c></c>
<l>VseqC := {1}</l>
<l>VseqC.clear()</l>
<c></c>
<l>VpnC := {1}</l>
<l>VpnC.clear()</l>
<c></c>
<c></c>
<c>* vector insertion index</c>
<l>i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=44</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    VectorCY.insert(i,RowsC)</l>
<l>    VectorCX.insert(i,ColsC)</l>
<l>    tuple_length(RowsC, n1)</l>
<c>   </c>
<c></c>
<l>    VnumC.insert(i, n1)</l>
<l>    VaddrC.insert(i, addr)</l>
<l>    addr:= addr+n1</l>
<l>    tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<c></c>
<l>    VseqC.insert(i, Seq)</l>
<l>    tuple_gen_const(n1, pn, Pn)</l>
<c></c>
<l>    VpnC.insert(i, Pn)</l>
<l>    i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<c>            ****</c>
<l>*             gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>            VectorCY.insert(i,RowsC)</l>
<l>            VectorCX.insert(i,ColsC)</l>
<l>            tuple_length(RowsC, n)</l>
<c></c>
<l>            VnumC.insert(i, n)</l>
<l>            VaddrC.insert(i, addr)</l>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n/2-0.5, 0.5, Seq)</l>
<l>            tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>            VseqC.insert(i, Seq)</l>
<l>            tuple_gen_const(n, pn, Pn)</l>
<c></c>
<l>            VpnC.insert(i, Pn)</l>
<l>            i:=i+1</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>convert_vector_to_tuple(VnumC, CNum)</l>
<l>convert_vector_to_tuple(VaddrC, CAddr)</l>
<l>convert_vector_to_tuple(VseqC, CSeq)</l>
<l>convert_vector_to_tuple(VpnC, CPN)</l>
<c></c>
<l>tuple_length(Cy, n)</l>
<c></c>
<l>set_grayval(ImageCLC, Cy, Cx, CSeq)</l>
<l>set_grayval(ImageIRB, Cy, Cx, CPN)</l>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCL">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="ChaintoRegion">
<interface>
<oo>
<par name="Reg" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Chain" base_type="ctrl" dimension="0"/>
<par name="ColumnChb" base_type="ctrl" dimension="0"/>
<par name="RowChb" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l> tuple_length(Chain, nch)</l>
<l> c:=ColumnChb</l>
<l> r:=RowChb</l>
<l> Col:=c</l>
<l> Row:=r</l>
<l> for j:=0 to nch-1 by 1</l>
<l>     chd:=Chain[j]</l>
<l>     switch(chd)</l>
<l>     case 0:</l>
<l>         c:=c+1</l>
<l>         break</l>
<l>     case 1:</l>
<l>         c:=c+1    </l>
<l>         r:=r-1</l>
<l>         break</l>
<l>     case 2:</l>
<l>         r:=r-1</l>
<l>         break</l>
<l>     case 3:</l>
<l>         c:=c-1    </l>
<l>         r:=r-1</l>
<l>         break</l>
<l>     case 4:</l>
<l>         c:=c-1 </l>
<l>         break</l>
<l>     case 5:</l>
<l>         c:=c-1    </l>
<l>         r:=r+1</l>
<l>         break</l>
<l>     case 6:</l>
<l>         r:=r+1</l>
<l>         break</l>
<l>     case 7:</l>
<l>         c:=c+1    </l>
<l>         r:=r+1</l>
<l>         break</l>
<l>     endswitch</l>
<l>     tuple_concat(Row,r,Row)</l>
<l>     tuple_concat(Col,c,Col)</l>
<l> endfor</l>
<l> gen_region_points(Reg,Row,Col)</l>
<l>return ()</l>
</body>
<docu id="ChaintoRegion">
<parameters>
<parameter id="Chain"/>
<parameter id="ColumnChb"/>
<parameter id="Reg"/>
<parameter id="RowChb"/>
</parameters>
</docu>
</procedure>
<procedure name="BiuldIRBN">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBin" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBout" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c></c>
<l>count_obj(RegionsInoD, n)</l>
<l>ImIRBout:=ImIRBin</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* tuple_gen_sequence (1, n, 1, SequenceINBi)</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary(RegionsInoD, RegionsInoDB, 'inner')</l>
<l>union1(RegionsInoD, RegionInoD)</l>
<l>paint_region (RegionInoD, ImIRBin, ImIRBout, 1, 'fill')</l>
<c></c>
<l>for j:=1 to n by 1</l>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>    get_region_points(RInoDB, Rows, Columns)</l>
<l>    tuple_length(Rows, nPts)</l>
<l>    Rsel:=[Rows[nPts/2], Rows[nPts/4], Rows[nPts*3/4]] </l>
<l>    Csel:=[Columns[nPts/2], Columns[nPts/4], Columns[nPts*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>*     pn:= SequenceIRB[j-1]</l>
<l>    tuple_gen_const(nPts, pn, Npn)</l>
<l>    set_grayval(ImIRBout, Rows, Columns, Npn)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BiuldIRBN">
<parameters>
<parameter id="ImIRBin"/>
<parameter id="ImIRBout"/>
<parameter id="ImageIR"/>
<parameter id="RegionsInoD"/>
</parameters>
</docu>
</procedure>
<procedure name="AbsRelDefContours">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*AbsRelDefContoursT - test version</c>
<l>set_system('neighborhood', 4)</l>
<l>* boundary(RegionInoD, RegionInoDB, 'outer')</l>
<c>*** pattern regions</c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>complement(RegionInoD, RegionInoDC)</l>
<l>dilation_circle(RegionInoDC, RegionInoDCd, 1)</l>
<c>*** space regions</c>
<l>connection(RegionInoDCd, RegionsInoDC)</l>
<l>count_obj(RegionsInoDC, nInoDC)</l>
<c>*** combined pattern and space</c>
<l>concat_obj(RegionsInoD, RegionsInoDC, RegionsInoDA)</l>
<l>count_obj(RegionsInoDA, nInoDA)</l>
<c>*** removed for C++ **</c>
<c></c>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c>*****</c>
<l>sz:=41</l>
<c></c>
<l>for j:=1 to nInoD by 1</l>
<l>    stop()</l>
<l>    j:=45</l>
<l>    select_obj(RegionsInoDA, RInoDB, j)</l>
<l>    move_region(RInoDB, RInoDB, -7, -7)</l>
<l>    get_region_contour(RInoDB, RowsInoDB, ColsInoDB)</l>
<l>    gen_contour_region_xld(RInoDB, Contour, 'center')</l>
<l>    smooth_contours_xld(Contour, SmoothedoContur, 15)</l>
<l>    segment_contours_xld(SmoothedoContur, ContoursSplit, 'lines_circles', 1, 1, 5)</l>
<l>    fit_circle_contour_xld(ContoursSplit, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>    gen_region_points(Regions, Row, Column)</l>
<l>    get_contour_angle_xld(Contour, 'rel', 'range', 11, Angles)</l>
<l>    tuple_sum(Angles, Sum)</l>
<l>    create_funct_1d_array(Angles, FAngles)</l>
<l>    derivate_funct_1d(FAngles, 'first', FAnglesDerivative1)</l>
<l>    derivate_funct_1d(FAngles, 'second', FAnglesDerivative2)</l>
<l>*     get_grayval_contour_xld(ImDisplacement, Contour,'bilinear', Grayval1)</l>
<l>*      Grayval:=Grayval1-127</l>
<l>    gen_region_points(RR, RowsInoDB, ColsInoDB)</l>
<c>    *** proving that RowsInoDB index = CLC+1</c>
<l>*     tuple_length(ColsInoDB, nP)</l>
<l>*     gen_empty_obj(RP)</l>
<l>*     for k:=0 to nP-1 by 1</l>
<l>*         gen_region_points(Pk, RowsInoDB[k], ColsInoDB[k])</l>
<l>*         concat_obj(RP, Pk, RP)</l>
<l>*     endfor</l>
<l>*     stop()</l>
<l>*     gen_region_points(Region, RowsInoDB, ColsInoDB)</l>
<l>    get_grayval(ImDisplacement, RowsInoDB, ColsInoDB, Displacement1)</l>
<l>    Displacement:=Displacement1-127</l>
<c>    </c>
<l>*     for k:=0 to 162516 by 1</l>
<l>*         if( RowsInoDB[k] &gt;11492 and RowsInoDB[k] &lt;11503 and ColsInoDB[k] &gt; 1475 and ColsInoDB[k] &lt; 1485) </l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         if( RowsInoDB[k] ==11498 and ColsInoDB[k] == 1481 ) </l>
<l>*             dev:=Displacement[k]</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop()</l>
<l>    Def:=[0,0,0,0,0]</l>
<l>*     FilterFloatMedNFWM(Displacement, sz, 4, 4, Def, Wfilt, Wch)</l>
<l>    tuple_max(Def, dmax)</l>
<l>    tuple_min(Def, dmin)</l>
<l>*     tuple_length(RowsInoDB, n)</l>
<l>*     gen_empty_obj(PR)</l>
<l>*     for jj:=0 to n-1 by 1</l>
<l>*         gen_region_points(P, RowsInoDB[jj], ColsInoDB[jj])</l>
<l>*         concat_obj(PR, P, PR)</l>
<l>*     endfor</l>
<l>*     gen_region_points(Region, RowsInoDB, ColsInoDB)</l>
<l>    if(dmax &gt; 0)</l>
<l>*         tuple_sort_index(Def, Indices)</l>
<l>*         tuple_inverse(Indices, Inverted)</l>
<l>*         tuple_length(Def, len)</l>
<l>*         tuple_gen_const(len, 0, T0)</l>
<l>         tuple_select_mask(Def,Def, Selected)</l>
<l>         tuple_select_mask(RowsInoDB,Def, SelectedR)</l>
<l>         tuple_select_mask(ColsInoDB,Def, SelectedC)</l>
<l>         tuple_length(SelectedC, n)</l>
<l>         tuple_gen_const(n, 10.5, RadC)</l>
<l>         gen_circle(Circle, SelectedR, SelectedC, RadC)</l>
<l>        stop()</l>
<l>    endif</l>
<c>     </c>
<l>    if(dmin &lt; 0)</l>
<l>        stop()</l>
<l>    endif</l>
<c>***** removed for C++ **</c>
<l>    VectorCY.insert(j,RowsInoDB)</l>
<l>    VectorCX.insert(j,ColsInoDB)</l>
<c>******</c>
<l>endfor</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<l>gen_region_points(RegionnoB, Cy, Cx)</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AbsRelDefContours">
<parameters>
<parameter id="Cx"/>
<parameter id="Cy"/>
<parameter id="Def"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageCLC"/>
<parameter id="RegionInoD"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing1">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionsPHfu" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l> * DomainImOut := DomainIm</l>
<l>* ImOut := Im</l>
<l>* RegionsShmOut := RegionsShm</l>
<l>* ArOut := Ar</l>
<l>* arOut := ar</l>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>*     complement(R, RC)</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<c></c>
<l>* gauss_filter (ImOut, ImageGauss, 3)</l>
<l>* binomial_filter (ImOut, ImageBinomial, 5, 5)</l>
<l>* write_image(ImageBinomial, 'tiff', 0, path+'ImBinomial')</l>
<l>* ImOut := ImageBinomial</l>
<l>* stop()</l>
<c>************** threshold adjustment ********</c>
<l>* union1(RegionG, RegionGu)</l>
<l>* threshold(ImageBinomial, RegionI, thr, 255)</l>
<l>* threshold(Gi, RegionGu, thr, 255)</l>
<l>* difference(RegionI, RegionG,RegionDifference1)</l>
<l>* area_center(RegionDifference1, Area1, Row1, Column)</l>
<l>* threshold(ImageBinomial, RegionIp1, thr+1, 255)</l>
<l>* difference(RegionIp1, RegionG,RegionDifferencep1)</l>
<l>* area_center(RegionDifferencep1, Areap1, Row1, Column)</l>
<l>* ArOut := []</l>
<l>* if(Areap1&lt;Area1)</l>
<l>* arOut := Areap1</l>
<l>*     i:=2</l>
<l>* while (arOut&lt;Area1)</l>
<l>* Areap1 := arOut</l>
<l>*         threshold(ImageBinomial, RegionIp1, thr+i, 255)</l>
<l>*         difference(RegionGu,RegionIp1, RegionDifferencep1)</l>
<l>* area_center (RegionDifferencep1, arOut, Row1, Column)</l>
<l>* tuple_concat (ArOut, arOut, ArOut)</l>
<l>*         i:=i+1</l>
<l>*     endwhile</l>
<c>    </c>
<l>* else</l>
<l>*     threshold(ImageBinomial, RegionIm1, thr-1, 255)</l>
<l>*     difference(RegionIm1, RegionG,RegionDifferencem1)</l>
<l>*     area_center(RegionDifferencem1, Areapm1, Row1, Column)</l>
<l>* endif</l>
<l>* stop()</l>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<c></c>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<l>DetectPH2 (RegionI, Im, RegionsPHfuAll, RegionInoPh, fumax, nPHfu)</l>
<c></c>
<c>***** removing too small Pinholes from the list</c>
<l>select_shape(RegionsPHfuAll, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPHfu, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPHfu, nPH)</l>
<l>complement(RegionInoPh, RegionIS1)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS1, RC, RegionIS)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<l>* DetectIsl2n (RegionIS, Im, RegionsIslfuAll, RegionInoIsl, fumax, nIslfu)</l>
<l>* aislmax:=8000</l>
<l>* fumax:=1000</l>
<l>DetectIsl5 (RegionIS1, SkeletonG, RegionInoPh, RegionG, Im, RegionsIslfuAll, RegionInoPHnoIsl, fumax, aislmax, nIslfu)</l>
<l>difference(RegionI, RegionInoPHnoIsl,RegionDifference)</l>
<c>***** removing too small Islandss from the list</c>
<l>select_shape(RegionsIslfuAll, RegionsIslfu1, 'area', 'and', Islamin, 999999)</l>
<l>select_shape(RegionsIslfu1, RegionsIslfu, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIslfu, nIsl)</l>
<l>union1(RegionsIslfu, RegionIslfu)</l>
<l>difference(RegionI, RegionIslfu, RegionI)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH and Isl)</c>
<c></c>
<l>RegionInoD:=RegionInoPHnoIsl</l>
<c></c>
<c>************</c>
<l>* complement(RegionI, RegionIS)</l>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<c>*** zachem SkGR vmesto SkG?</c>
<l>* DetectOpenFU3 (SkeletonGnoR, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegionsOpCon, 3.0, 4, d1, nOp)</l>
<l>difference(DomainI, RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>DetectOpenN1 (SkeletonGnoR, RegionInoPHnoIsl, RegionISnoPHnoIsl, WidthImageP, DirImageP, RegionsOp, RegionsOpCon, R2)</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<l>union2(RegionInoPHnoIsl, RegionsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>* complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<c></c>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c>********** new Short</c>
<c></c>
<l>DetectShortN1 (SkeletonGS, RegionInoPHnoIsl, RegionISnoPHnoIsl, WidthImageS, DirImageS, RegionsShi, R2)</l>
<l>dev_display(RegionsShi)</l>
<l>* stop()</l>
<l>* DetectShortFU3 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>* DetectShortFU (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShio, 3.0, 4, nSh)</l>
<l>set_system('neighborhood', 4)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<l>difference(RegionInoPHnoIsl,RegionRemoveSh, RegionInoPHnoIslnoSh)</l>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<l>union2(RegionInoPHnoIslnoSh, RegionOpCon, RegionInoD)</l>
<c></c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsIslfu"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPHfu"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aislmax"/>
<parameter id="d1"/>
<parameter id="fumax"/>
<parameter id="path"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing1o">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainIm" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Domain" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="ImOut" base_type="iconic" dimension="0"/>
<par name="RegionGu" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIi" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsPHfu1" base_type="iconic" dimension="0"/>
<par name="RegionsPHfu" base_type="iconic" dimension="0"/>
<par name="RegionIS1" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionDifference" base_type="iconic" dimension="0"/>
<par name="RegionsIslfu1" base_type="iconic" dimension="0"/>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionIslfu" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegonOpCon" base_type="iconic" dimension="0"/>
<par name="R1" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsShi" base_type="iconic" dimension="0"/>
<par name="RegionShUnion" base_type="iconic" dimension="0"/>
<par name="RegionSkIntersection" base_type="iconic" dimension="0"/>
<par name="RegionRemoveSh" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="RegionsShmOut" base_type="iconic" dimension="0"/>
<par name="RegionsInoDm" base_type="iconic" dimension="0"/>
<par name="RegionInoDm" base_type="iconic" dimension="0"/>
<par name="RegionsInoDmm" base_type="iconic" dimension="0"/>
<par name="DomainImOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="aR" base_type="ctrl" dimension="0"/>
<par name="r" base_type="ctrl" dimension="0"/>
<par name="c" base_type="ctrl" dimension="0"/>
<par name="l" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="nPHfu" base_type="ctrl" dimension="0"/>
<par name="nPH" base_type="ctrl" dimension="0"/>
<par name="nIslfu" base_type="ctrl" dimension="0"/>
<par name="nIsl" base_type="ctrl" dimension="0"/>
<par name="ovl" base_type="ctrl" dimension="0"/>
<par name="nEP" base_type="ctrl" dimension="0"/>
<par name="nOp" base_type="ctrl" dimension="0"/>
<par name="j" base_type="ctrl" dimension="0"/>
<par name="jj" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
<par name="nSh" base_type="ctrl" dimension="0"/>
<par name="nShi" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>* DomainImOut := DomainIm</l>
<l>* ImOut := Im</l>
<l>* RegionsShmOut := RegionsShm</l>
<l>* ArOut := Ar</l>
<l>* arOut := ar</l>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>    complement(R, RC)</l>
<l>endif</l>
<c></c>
<l>* gauss_filter (ImOut, ImageGauss, 3)</l>
<l>* binomial_filter (ImOut, ImageBinomial, 5, 5)</l>
<l>* write_image(ImageBinomial, 'tiff', 0, path+'ImBinomial')</l>
<l>* ImOut := ImageBinomial</l>
<l>* stop()</l>
<c>************** threshold adjustment ********</c>
<l>* union1(RegionG, RegionGu)</l>
<l>* threshold(ImageBinomial, RegionI, thr, 255)</l>
<l>* threshold(Gi, RegionGu, thr, 255)</l>
<l>* difference(RegionI, RegionG,RegionDifference1)</l>
<l>* area_center(RegionDifference1, Area1, Row1, Column)</l>
<l>* threshold(ImageBinomial, RegionIp1, thr+1, 255)</l>
<l>* difference(RegionIp1, RegionG,RegionDifferencep1)</l>
<l>* area_center(RegionDifferencep1, Areap1, Row1, Column)</l>
<l>* ArOut := []</l>
<l>* if(Areap1&lt;Area1)</l>
<l>* arOut := Areap1</l>
<l>*     i:=2</l>
<l>* while (arOut&lt;Area1)</l>
<l>* Areap1 := arOut</l>
<l>*         threshold(ImageBinomial, RegionIp1, thr+i, 255)</l>
<l>*         difference(RegionGu,RegionIp1, RegionDifferencep1)</l>
<l>* area_center (RegionDifferencep1, arOut, Row1, Column)</l>
<l>* tuple_concat (ArOut, arOut, ArOut)</l>
<l>*         i:=i+1</l>
<l>*     endwhile</l>
<c>    </c>
<l>* else</l>
<l>*     threshold(ImageBinomial, RegionIm1, thr-1, 255)</l>
<l>*     difference(RegionIm1, RegionG,RegionDifferencem1)</l>
<l>*     area_center(RegionDifferencem1, Areapm1, Row1, Column)</l>
<l>* endif</l>
<l>* stop()</l>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<c></c>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<l>DetectPH2 (RegionI, Im, RegionsPHfuAll, RegionInoPh, fumax, nPHfu)</l>
<c></c>
<c>***** removing too small Pinholes from the list</c>
<l>select_shape(RegionsPHfuAll, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPHfu, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPHfu, nPH)</l>
<l>complement(RegionInoPh, RegionIS1)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS1, RC, RegionIS)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<c></c>
<l>DetectIsl4 (RegionIS, SkeletonG, RegionInoPh, RegionG, Im, RegionsIslfuAll, RegionInoPHnoIsl, fumax, nIslfu)</l>
<l>difference(RegionI, RegionInoPHnoIsl,RegionDifference)</l>
<c>***** removing too small Islandss from the list</c>
<l>select_shape(RegionsIslfuAll, RegionsIslfu1, 'area', 'and', Islamin, 999999)</l>
<l>select_shape(RegionsIslfu1, RegionsIslfu, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIslfu, nIsl)</l>
<l>union1(RegionsIslfu, RegionIslfu)</l>
<l>difference(RegionI, RegionIslfu, RegionI)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH and Isl)</c>
<c></c>
<l>RegionInoD:=RegionInoPHnoIsl</l>
<c></c>
<c>************</c>
<l>complement(RegionI, RegionIS)</l>
<c></c>
<l>DetectOpenFU3 (SkeletonG, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegonsOpCon, 3.0, 4, d1, nOp)</l>
<l>union1(RegonsOpCon, RegonOpCon)</l>
<l>union2(RegionInoPHnoIsl, RegonsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>DetectShortFU2 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<l>difference(RegionInoPHnoIsl,RegionRemoveSh, RegionInoPHnoIslnoSh)</l>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<l>union2(RegionInoPHnoIslnoSh, RegonOpCon, RegionInoD)</l>
<c></c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing1o">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Domain"/>
<parameter id="DomainIm"/>
<parameter id="DomainImOut"/>
<parameter id="Gi"/>
<parameter id="Height"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImOut"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="R1"/>
<parameter id="R2"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionDifference"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionGu"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionIS1"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionIi"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoDm"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionIslfu"/>
<parameter id="RegionRemoveSh"/>
<parameter id="RegionShUnion"/>
<parameter id="RegionSkIntersection"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsInoDm"/>
<parameter id="RegionsInoDmm"/>
<parameter id="RegionsIslfu"/>
<parameter id="RegionsIslfu1"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPHfu"/>
<parameter id="RegionsPHfu1"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegionsShi"/>
<parameter id="RegionsShmOut"/>
<parameter id="RegonOpCon"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonsGbr"/>
<parameter id="Width"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aR"/>
<parameter id="c"/>
<parameter id="d1"/>
<parameter id="dmin"/>
<parameter id="fumax"/>
<parameter id="i"/>
<parameter id="j"/>
<parameter id="jj"/>
<parameter id="l"/>
<parameter id="nEP"/>
<parameter id="nIsl"/>
<parameter id="nIslfu"/>
<parameter id="nOp"/>
<parameter id="nPH"/>
<parameter id="nPHfu"/>
<parameter id="nSh"/>
<parameter id="nShi"/>
<parameter id="ovl"/>
<parameter id="path"/>
<parameter id="r"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="VerifyNFWsMB">
<interface>
<io>
<par name="RegsMB" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MBreal" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expandMB" base_type="ctrl" dimension="0"/>
<par name="grayspacemax" base_type="ctrl" dimension="0"/>
<par name="grayspaceav" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>count_obj(RegsMB, nMBp)</l>
<l>gen_empty_obj(MBreal)</l>
<l>area_center(RegsMB, A, Row, Col)</l>
<l>gen_rectangle1(Ros, Row-10, Col-10, Row+10, Col+10)</l>
<l>intersection(RegionInoD, Ros,  Rfs)</l>
<l>expand_region(RegsMB, Rfs, Res, expandMB, 'image')</l>
<l>    for j:=1 to nMBp by 1</l>
<l>        select_obj(Res, Re, j)</l>
<l>        get_region_points(Re, Rows1, Columns1)</l>
<l>        get_grayval(Im, Rows1, Columns1, Ge)</l>
<l>        tuple_min(Ge, gemin)</l>
<l>        tuple_median(Ge, gemed)</l>
<l>*         tuple_mean(Ge, gemean)</l>
<l>        if( gemed &lt; grayspacemax or gemin &lt; grayspaceav)</l>
<l>            concat_obj(MBreal, Re, MBreal)</l>
<l>        endif</l>
<l>    endfor</l>
<l>return ()</l>
</body>
<docu id="VerifyNFWsMB">
<parameters>
<parameter id="Im"/>
<parameter id="MBreal"/>
<parameter id="RegionInoD"/>
<parameter id="RegsMB"/>
<parameter id="expandMB"/>
<parameter id="grayspaceav"/>
<parameter id="grayspacemax"/>
</parameters>
</docu>
</procedure>
<procedure name="VerifyNFWsSP">
<interface>
<io>
<par name="RegsSP" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SPreal" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expandSP" base_type="ctrl" dimension="0"/>
<par name="graypatmin" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>count_obj(RegsSP, nSPp)</l>
<l>gen_empty_obj(SPreal)</l>
<l>complement(RegionInoD, RegionInoDC)</l>
<c></c>
<l>area_center(RegsSP, A, Row, Col)</l>
<l>gen_rectangle1(Ros, Row-10, Col-10, Row+10, Col+10)</l>
<l>intersection(RegionInoDC, Ros,  Rfs)</l>
<l>expand_region(RegsSP, Rfs, Res, expandSP, 'image')</l>
<l>    for j:=1 to nSPp by 1</l>
<l>        select_obj(Res, Re, j)</l>
<l>        get_region_points(Re, Rows1, Columns1)</l>
<l>        get_grayval(Im, Rows1, Columns1, Ge)</l>
<l>        tuple_min(Ge, gemin)</l>
<l>        tuple_median(Ge, gemed)</l>
<l>*         tuple_mean(Ge, gemean)</l>
<l>        if( gemed &gt; graypatmin)</l>
<l>            concat_obj(SPreal, Re, SPreal)</l>
<l>        endif</l>
<l>    endfor</l>
<l>return ()</l>
</body>
<docu id="VerifyNFWsSP">
<parameters>
<parameter id="Im"/>
<parameter id="RegionInoD"/>
<parameter id="RegsSP"/>
<parameter id="SPreal"/>
<parameter id="expandSP"/>
<parameter id="graypatmin"/>
</parameters>
</docu>
</procedure>
<procedure name="DifGandIprc">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionDifference" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="marg" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="prcA" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size(Im, Width, Height)</l>
<l>gen_rectangle1(RAl,marg, marg, Height-marg, Width-marg)</l>
<l>union1(RegionG, RegionGu)</l>
<l>intersection(RegionGu, RAl, RAG)</l>
<l>intersection(RegionInoD, RAl, RAI)</l>
<l>symm_difference(RAG, RAI, RegionDifference)</l>
<l>area_center(RegionDifference, AreaD, Row1, Column)</l>
<l>area_center(RAG, AreaG, Row1, Column)</l>
<l>prcA:=AreaD*100./AreaG</l>
<l>return ()</l>
</body>
<docu id="DifGandIprc">
<parameters>
<parameter id="Im"/>
<parameter id="RegionDifference"/>
<parameter id="RegionG"/>
<parameter id="RegionInoD"/>
<parameter id="marg"/>
<parameter id="prcA"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL102n">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL1 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>SkeletonG:=SkeletonGi</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>rcep:=5</l>
<l>tuple_length(RowsEP, nEP)</l>
<l>tuple_gen_const(nEP, rcep, Rcep)</l>
<l>gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacement, 1, 128)</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>Wmain := [6, 6, 6]</l>
<l>wside := 3</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( (w &gt;= Wmain[0]-wside and w &lt;= Wmain[0]+wside) or (w &gt;= Wmain[1]-wside and w &lt;= Wmain[1]+wside) or (w &gt;= Wmain[2]-wside and w &lt;= Wmain[2]+wside) )</l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>* stop ()</l>
<c></c>
<l>WmainS := [25, 25]</l>
<l>wsides := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1,2}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1,2}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>jrad:=9</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP ***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>tuple_length(RowsE, nE)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, 7, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c></c>
<c>*** FWMS (for space)</c>
<l>SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c></c>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<l>MSBuildFWM4 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL102n">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="YC"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="AnglesFWM">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkelsEPU" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="epr" base_type="ctrl" dimension="0"/>
<par name="significantdirSP" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>split_skeleton_lines(SkeletonsFWM, 2, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>gen_region_line(RegionLines, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>junctions_skeleton(RegionLines, EndPointsL, JuncPointsL)</l>
<l>union1(EndPointsL, EndPointsLU)</l>
<l>area_center(EndPointsLU, nEP, R1, C1)</l>
<l>get_region_points(EndPointsLU, RowsEPU, ColsEPU)</l>
<l>count_obj(EndPointsL, nEPL)</l>
<c></c>
<l>tuple_gen_const(nEP, epr, Erad)</l>
<l>gen_circle(CircsEP, RowsEPU, ColsEPU, Erad)</l>
<c></c>
<c></c>
<c>**region CircsEPU - angle region of FWM, SP should be removed for that region</c>
<l>union1 (CircsEP, SkelsEPUver)</l>
<l>intersection (SkelsEPUver, SkeletonsFWM, SkelEPU)</l>
<l>set_system('neighborhood', 8)</l>
<l>connection(SkelEPU, SkelsEPU)</l>
<l>count_obj(SkelsEPU, nSkelsEPU)</l>
<l>gen_empty_obj(SkelsEPUver)</l>
<l>for j:=1 to nSkelsEPU by 1</l>
<l>    select_obj(SkelsEPU, ObjectSelected, j)</l>
<l>    get_region_points(ObjectSelected,Rows, Columns)</l>
<l>    get_grayval(DirImageP, Rows, Columns, Dirs)</l>
<c>    ***** compensating for 255 jump ***</c>
<l>    Dirsi:=Dirs</l>
<l>    tuple_length(Dirs, nD)</l>
<l>    for jjj:=0 to nD-2 by 1</l>
<l>        d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>        if(d &gt; 128)</l>
<l>            d:= d-255</l>
<l>        elseif(d &lt; -128)</l>
<l>            d:= d+255</l>
<l>        endif</l>
<l>        Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>    endfor</l>
<c>    ************************************</c>
<l>    tuple_max(Dirs, dmax)</l>
<l>    tuple_min(Dirs, dmin)</l>
<l>    d:=dmax-dmin</l>
<l>    if(d&gt;significantdirSP)</l>
<c>     ****** significant dir change</c>
<l>     concat_obj(SkelsEPUver, ObjectSelected,SkelsEPUver)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="AnglesFWM">
<parameters>
<parameter id="DirImageP"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkelsEPU"/>
<parameter id="epr"/>
<parameter id="significantdirSP"/>
</parameters>
</docu>
</procedure>
<procedure name="AnglesFWMcirc">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkelsEPver" base_type="iconic" dimension="0"/>
<par name="CircsEPver" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="epr" base_type="ctrl" dimension="0"/>
<par name="significantangleSP" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Procedure AnglesFWMcirc - finding circles at significant FWM wire angle</c>
<c>* 2022/04/23</c>
<l>split_skeleton_lines(SkeletonsFWM, 2, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>gen_region_line(RegionLines, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>junctions_skeleton(RegionLines, EndPointsL, JuncPointsL)</l>
<l>union1(EndPointsL, EndPointsLU)</l>
<l>area_center(EndPointsLU, nEP, R1, C1)</l>
<l>get_region_points(EndPointsLU, RowsEPU, ColsEPU)</l>
<l>count_obj(EndPointsL, nEPL)</l>
<c></c>
<l>tuple_gen_const(nEP, epr, Erad)</l>
<l>gen_circle(CircsEP, RowsEPU, ColsEPU, Erad)</l>
<l>count_obj(CircsEP, nCircsEP)</l>
<c></c>
<c>**region CircsEPU - angle region of FWM, SP should be removed for that region</c>
<l>* union1 (CircsEP, SkelsEPUver)</l>
<l>intersection (CircsEP, SkeletonsFWM, SkelsEP)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* connection (SkelsEPver, SkelsEPver)</l>
<l>count_obj(SkelsEP, nSkelsEP)</l>
<l>gen_empty_obj(SkelsEPver)</l>
<l>gen_empty_obj(CircsEPver)</l>
<l>for j:=1 to nSkelsEP by 1</l>
<l>    select_obj(SkelsEP, ObjectSelected, j)</l>
<l>    select_obj(CircsEP, ObjectSelectedC, j)</l>
<l>    get_region_points(ObjectSelected,Rows, Columns)</l>
<l>    get_grayval(DirImageP, Rows, Columns, Dirs)</l>
<c>    ***** compensating for 255 jump ***</c>
<l>    Dirsi:=Dirs</l>
<l>    tuple_length(Dirs, nD)</l>
<l>    for jjj:=0 to nD-2 by 1</l>
<l>        d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>        if(d &gt; 128)</l>
<l>            d:= d-255</l>
<l>        elseif(d &lt; -128)</l>
<l>            d:= d+255</l>
<l>        endif</l>
<l>        Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>    endfor</l>
<c>    ************************************</c>
<l>    tuple_max(Dirs, dmax)</l>
<l>    tuple_min(Dirs, dmin)</l>
<l>    d:=dmax-dmin</l>
<l>    if(d&gt;significantangleSP*180/256)</l>
<c>     ****** significant dir change</c>
<l>     concat_obj(SkelsEPver, ObjectSelected,SkelsEPver)</l>
<l>     concat_obj(CircsEPver, ObjectSelectedC,CircsEPver)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="AnglesFWMcirc">
<parameters>
<parameter id="CircsEPver"/>
<parameter id="DirImageP"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkelsEPver"/>
<parameter id="epr"/>
<parameter id="significantangleSP"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL103">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL103 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>SkeletonG:=SkeletonGi</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>rcep:=5</l>
<l>tuple_length(RowsEP, nEP)</l>
<l>tuple_gen_const(nEP, rcep, Rcep)</l>
<l>gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacement, 1, 128)</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>WminP := 13</l>
<l>wside := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( w &gt;= WminP-wside and w &lt;= WminP+wside) </l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>* stop ()</l>
<c></c>
<l>WminS := 15</l>
<l>wsides := 2</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    *if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>     if (( w &lt;= WminS+wsides))   </l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>jrad:=9</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>tuple_length(RowsE, nE)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, 7, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c></c>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c></c>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>stop()</l>
<c>*********</c>
<l>MSBuildFWM4 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM4 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint2, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, Puseint2)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL103">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumR"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCS"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCS"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="BuilsIRBS">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ImIRBSOut := ImIRBS</l>
<l>expand_region(SkeletonsFWMS, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := 0</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceIRBS, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuilsIRBS">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="expsize"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBSN">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBin" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBout" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>***** BuildIRBSN - building IRBS same way as IRBN *** 2022/05/04</c>
<l>count_obj(RegionsInoD, n)</l>
<l>ImIRBout:=ImIRBin</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* tuple_gen_sequence (1, n, 1, SequenceINBi)</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary(RegionsInoD, RegionsInoDB, 'inner')</l>
<l>union1(RegionsInoD, RegionInoD)</l>
<l>paint_region (RegionInoD, ImIRBin, ImIRBout, 1, 'fill')</l>
<c></c>
<l>for j:=1 to n by 1</l>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>    get_region_points(RInoDB, Rows, Columns)</l>
<l>    tuple_length(Rows, nPts)</l>
<l>    Rsel:=[Rows[nPts/2], Rows[nPts/4], Rows[nPts*3/4]] </l>
<l>    Csel:=[Columns[nPts/2], Columns[nPts/4], Columns[nPts*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>*     pn:= SequenceIRB[j-1]</l>
<l>    tuple_gen_const(nPts, pn, Npn)</l>
<l>    set_grayval(ImIRBout, Rows, Columns, Npn)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BuildIRBSN">
<parameters>
<parameter id="ImIRBin"/>
<parameter id="ImIRBout"/>
<parameter id="ImageIR"/>
<parameter id="RegionsInoD"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortFU3N">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nSh" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_domain(WidthImageS, Domain)</l>
<l>difference(Domain, RegionIS, RegionI)</l>
<l>difference (SkeletonGS, RegionIS, RegionSkGSIS)</l>
<l>connection (RegionSkGSIS, RegionsSkGSIS)</l>
<l>area_center (RegionsSkGSIS, Area, RowShC, ColShC)</l>
<l>tuple_length (RowShC, nShC)</l>
<l>nSh := 0</l>
<l>gen_empty_obj (RegionsSh)</l>
<l>for j := 1 to nShC by 1</l>
<l>*     if(j==304)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (RegionsSkGSIS, RegionSel, j)</l>
<l>    get_region_points (RegionSel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>    get_grayval (DirImageS, row, col, dirShC)</l>
<l>    get_grayval (WidthImageS, row, col, widthShC)</l>
<l>    Ang:=dirShC*3.14159/256</l>
<l>    gen_rectangle2(R2, row, col ,Ang, widthShC, 40)</l>
<l>    intersection(RegionIS, R2, RegionISR2)</l>
<l>    expand_region(RegionSel, RegionISR2, RegionExpanded, widthShC, 'image')</l>
<l>    dilation_circle(RegionExpanded, RegionDilation, widthShC/2.)</l>
<l>    intersection(RegionDilation, RegionI, RegionIntersection)</l>
<l>    connection(RegionIntersection, ConnectedRegions)</l>
<l>    count_obj(ConnectedRegions, nCon)</l>
<c>    </c>
<c>    </c>
<l>        if (nCon == 1)</l>
<l>            nSh := nSh+1</l>
<l>*             if(nSh==21)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>            *difference (Rect, Reg, Regd)</l>
<c></c>
<l>            concat_obj (RegionsSh, RegionIntersection, RegionsSh)</l>
<l>        endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortFU3N">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegionIS"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
<parameter id="coef"/>
<parameter id="nSh"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="AlignmentPairsGenerator">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="len" base_type="ctrl" dimension="0"/>
<par name="rsz" base_type="ctrl" dimension="0"/>
<par name="bsz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowsG" base_type="ctrl" dimension="0"/>
<par name="ColsG" base_type="ctrl" dimension="0"/>
<par name="RowsR" base_type="ctrl" dimension="0"/>
<par name="ColsR" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_rand(len, RandR)</l>
<l>tuple_rand(len, RandC)</l>
<l>dev_display(Im)</l>
<l>cnum:=0</l>
<l>RowsG:=[]</l>
<l>ColsG:=[]</l>
<l>RowsR:=[]</l>
<l>ColsR:=[]</l>
<c>***  teaching 1*****</c>
<l>for j:=1 to len by 1</l>
<l>    rra:=int(RandR[j-1]*HeightG)</l>
<l>    cra:=int(RandC[j-1]*WidthG)</l>
<l>*     tuple_int(rra, rra)</l>
<l>*     tuple_int(cra, cra)</l>
<l>    gen_rectangle1(RA, rra-rsz, cra-rsz, rra+rsz-1, cra+rsz-1)</l>
<l>    gen_rectangle1(RAB, rra-rsz-bsz, cra-rsz-bsz, rra+rsz-1+bsz, cra+rsz-1+bsz)</l>
<l>    reduce_domain(Gi, RA, ImageTeach)</l>
<c>    *** OpenCL ***</c>
<l>*     invert_image(ImageTeach, ImageTeach)</l>
<l>    intersection(RA, RegionG, RegionGS)</l>
<l>*     skeleton(RegionGS, SkeletonG1)</l>
<l>*     dilation_circle(SkeletonG1, SkeletonG, 3.5)</l>
<l>*     region_to_bin(SkeletonG, BinImageSR, 255, 0, 5120, 5120)</l>
<l>*     reduce_domain(BinImageSR, RA, ImageTeachS)</l>
<l>    create_ncc_model(ImageTeach, 'auto', -0.00, 0.00, 'auto', 'use_polarity', ModelID_ncc1)</l>
<c>    </c>
<l>    reduce_domain(Im, RAB, ImageSearch1)</l>
<l>    find_ncc_model (ImageSearch1, ModelID_ncc1, 0, 0, 0.7, 1, 0.0, 'true', 0, Row_ncc1, Column_ncc1, Angle_ncc1, Score_ncc1)</l>
<l>    if(Score_ncc1 &gt; 0.9 and abs(Row_ncc1-rra) &lt; 1 and abs(Column_ncc1-cra) &lt; 7)</l>
<l>        dev_set_color('blue')</l>
<l>        dev_display(RA)</l>
<l>        dev_set_color('red')</l>
<l>        dev_display_ncc_matching_results(ModelID_ncc1, 'red', Row_ncc1, Column_ncc1, Angle_ncc1, 0)</l>
<l>        cnum:=cnum+1</l>
<l>        tuple_concat(RowsR,Row_ncc1,RowsR)</l>
<l>        tuple_concat(ColsR,Column_ncc1,ColsR)</l>
<l>        tuple_concat(RowsG,rra,RowsG)</l>
<l>        tuple_concat(ColsG,cra,ColsG)</l>
<c>        </c>
<l>*         stop()</l>
<c></c>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="AlignmentPairsGenerator">
<parameters>
<parameter id="ColsG"/>
<parameter id="ColsR"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="RegionG"/>
<parameter id="RowsG"/>
<parameter id="RowsR"/>
<parameter id="WidthG"/>
<parameter id="bsz"/>
<parameter id="len"/>
<parameter id="rsz"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL104">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL104 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := 14</l>
<l>wside := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( w &gt;= (WminP-wside) and w &lt;= (WminP+wside)) </l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<l>PatternAngleImage (RegionG, RegionDifference1, SkeletonPartsPi, WidthG, HeightG)</l>
<l>difference(SkeletonPartsPi, R, SkeletonPartsP)</l>
<c></c>
<l>stop ()</l>
<c></c>
<l>s:=sin(5.6)</l>
<l>c:=cos(5.6)</l>
<c></c>
<l>WminS := 15</l>
<l>wsides := 2</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    *if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>     if (( w &lt;= WminS+wsides))   </l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c></c>
<l>jrad:=9</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>tuple_length(RowsE, nE)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, 7, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c></c>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c></c>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>*********</c>
<l>MSBuildFWM4 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM4 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint2, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, Puseint2)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL104">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumR"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCS"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCS"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="PatternAngleImage">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** Extended Pattern v1.0, 05.06.2022</c>
<c></c>
<l>gen_contours_skeleton_xld (SkeletonG, SkContoursG, 10, 'filter')</l>
<l>* dev_update_off ()</l>
<l>gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>count_obj (SkContoursG, nSkCG)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>for k := 1 to nSkCG by 1</l>
<l>*     if(k==1452)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    select_obj (SkeletonG, SelectedSkeletonG, k)</l>
<l>    area_center(SelectedSkeletonG, a, r, c)</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c>    </c>
<l>* get_grayval (SkeletonParts, Rows2, Cols2, Angle2)</l>
<l>*     tuple_length(Rows2, n2)</l>
<l>*     tuple_gen_const(n2, 10, L1)</l>
<l>*     tuple_gen_const(n2, 0.25, L2)</l>
<l>*     gen_rectangle2(Rectangles2i, Rows2-10*sin(Angle2), Cols2+10*cos(Angle2), Angle2, L1, L2)</l>
<c></c>
<c></c>
<l>* set_grayval (SkeletonParts, RowG[0], ColG[0], AnglesG[0]-3.14159)</l>
<l>* set_grayval (SkeletonParts, RowG[1], ColG[1], AnglesG[1]-3.14159)</l>
<l>* set_grayval (SkeletonParts, RowG[2], ColG[2], AnglesG[2]-3.14159)</l>
<l>* set_grayval (SkeletonParts, RowG[nA-1], ColG[nA-1], AnglesG[nA-1])</l>
<l>* set_grayval (SkeletonParts, RowG[nA-2], ColG[nA-2], AnglesG[nA-2])</l>
<l>* set_grayval (SkeletonParts, RowG[nA-3], ColG[nA-3], AnglesG[nA-3])</l>
<c>    </c>
<l>    gen_rectangle2(Rectangle21, RowG[1]-10*sin(AnglesG[1]-3.14159), ColG[1]+10*cos(AnglesG[1]-3.14159), AnglesG[1]-3.14159, 10, 0.25)</l>
<l>    gen_rectangle2(Rectangle22, RowG[nA-2]-10*sin(AnglesG[nA-2]), ColG[nA-2]+10*cos(AnglesG[nA-2]), AnglesG[nA-2], 10, 0.25)</l>
<l>    if(a&gt;0)</l>
<l>        union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>        union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>    endif</l>
<l>    concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<c>*     </c>
<c>    </c>
<l>*     tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>*     tuple_fmod (AnglesG1, rad(180), AnglesG2)</l>
<l>*     tuple_mult (AnglesG2, 256.0/rad(180), AnglesG3)</l>
<l>*     set_grayval (DirImageP, RowG, ColG, AnglesG3)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PatternAngleImage">
<parameters>
<parameter id="HeightG"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="WidthG"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL105">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elength" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL106 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>intersection (RegionsGsm, RC, RegionG)</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>wside := 4</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    if ( w &gt;= (WminP-wside) and w &lt;= (WminP+wside)) </l>
<l>        VectorRM.insert(j, RowsGi[j])</l>
<l>        VectorCM.insert(j, ColsGi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation length</c>
<l>* enlength:=10</l>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonG, WidthImageP, DirImageP1, SkeletonPartsPi, WidthImagePout, DirImagePout, elength, enlengthnoend, jpadd)</l>
<l>difference(SkeletonPartsPi, R, SkeletonPartsP)</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<c></c>
<c></c>
<l>* stop ()</l>
<c></c>
<l>* s:=sin(5.6)</l>
<l>* c:=cos(5.6)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>wsides := 2</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    *if ((w &gt;= WmainS[0]-wsides and w &lt;= WmainS[0]+wsides) or (w &gt;= WmainS[1]-wsides and w &lt;= WmainS[1]+wsides))</l>
<l>     if (( w &lt;= WminS+wsides))   </l>
<l>        VectorRM.insert(j, RowsGSi[j])</l>
<l>        VectorCM.insert(j, ColsGSi[j])</l>
<l>    endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainS, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbidS := SkeletonGi</l>
<l>expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<l>SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nE, eradMSe, Erad)</l>
<l>gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMi, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>*********</c>
<l>MSBuildFWM4 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint1, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, Puseint1)</l>
<c>* *************************************</c>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM4 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint2, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, Puseint2)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL105">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumR"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCS"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCS"/>
<parameter id="elength"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSProc31">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc31 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;pPat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<c>    </c>
<l>*     dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('yellow')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        concat_obj(PC, Pc, PC)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        if((vp==0 or (vp&gt;1 and vp!= pnum)) or (vn==0 or (vn&gt;1 and vn!= pnum)) )    </l>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-65535-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                ii:=ii+1</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==1 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>    endif</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        ii:=ii+1</l>
<l>        if(Pval[pind-2]==0)</l>
<l>            PIntY[ii]:=PPy[pind-1]</l>
<l>            PIntX[ii]:=PPx[pind-1]</l>
<l>            PInti[ii]:=pind-1</l>
<l>            PCLC[ii]:=clc</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    shift:=0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>        get_grayval (Im, PPy[PInti[j]], PPx[PInti[j]],  g)</l>
<l>        g0[1] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>        g0[2] := g</l>
<l>        SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW segment</c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* stop()</l>
<c>*** finding SP points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>        if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>            continue</l>
<l>        else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<c></c>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSProc31">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloatMedShift">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="prcshift" base_type="ctrl" dimension="0"/>
<par name="Wr" base_type="ctrl" dimension="0"/>
<par name="wav" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<l>* tuple_gen_const (nW, -prcmb, ThrMB)</l>
<l>tuple_gen_const (nW, prcshift, ThrSp)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<l>Prc := Wch*100.0/(wav+0.001)</l>
<l>* Prc[0]:=0</l>
<l>* Prc[nW-1]:=0</l>
<l>tuple_greater_equal_elem (Prc, ThrSp, DefSp)</l>
<l>* tuple_less_equal_elem (Prc, ThrMB, DefMB)</l>
<l>Def := DefSp</l>
<l>return ()</l>
</body>
<docu id="FilterFloatMedShift">
<parameters>
<parameter id="Def"/>
<parameter id="Prc"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="Wr"/>
<parameter id="prcshift"/>
<parameter id="sz"/>
<parameter id="wav"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedPattern">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* ** Extended Pattern v1.0, 05.06.2022</c>
<c></c>
<l>gen_contours_skeleton_xld (SkeletonG, SkContoursG, 10, 'filter')</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>count_obj (SkContoursG, nSkCG)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>for k := 1 to nSkCG by 1</l>
<l>*     if(k==1452)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    select_obj (SkeletonG, SelectedSkeletonG, k)</l>
<l>    area_center(SelectedSkeletonG, a, r, c)</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c>    </c>
<l>* get_grayval (SkeletonParts, Rows2, Cols2, Angle2)</l>
<l>*     tuple_length(Rows2, n2)</l>
<l>*     tuple_gen_const(n2, 10, L1)</l>
<l>*     tuple_gen_const(n2, 0.25, L2)</l>
<l>*     gen_rectangle2(Rectangles2i, Rows2-10*sin(Angle2), Cols2+10*cos(Angle2), Angle2, L1, L2)</l>
<c></c>
<c></c>
<l>* set_grayval (SkeletonParts, RowG[0], ColG[0], AnglesG[0]-3.14159)</l>
<l>* set_grayval (SkeletonParts, RowG[1], ColG[1], AnglesG[1]-3.14159)</l>
<l>* set_grayval (SkeletonParts, RowG[2], ColG[2], AnglesG[2]-3.14159)</l>
<l>* set_grayval (SkeletonParts, RowG[nA-1], ColG[nA-1], AnglesG[nA-1])</l>
<l>* set_grayval (SkeletonParts, RowG[nA-2], ColG[nA-2], AnglesG[nA-2])</l>
<l>* set_grayval (SkeletonParts, RowG[nA-3], ColG[nA-3], AnglesG[nA-3])</l>
<c>    </c>
<l>    gen_rectangle2(Rectangle21, RowG[1]-10*sin(AnglesG[1]-3.14159), ColG[1]+10*cos(AnglesG[1]-3.14159), AnglesG[1]-3.14159, 10, 0.25)</l>
<l>    gen_rectangle2(Rectangle22, RowG[nA-2]-10*sin(AnglesG[nA-2]), ColG[nA-2]+10*cos(AnglesG[nA-2]), AnglesG[nA-2], 10, 0.25)</l>
<l>    if(a&gt;0)</l>
<l>        union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>        union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>    endif</l>
<l>    concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<c>*     </c>
<c>    </c>
<l>*     tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>*     tuple_fmod (AnglesG1, rad(180), AnglesG2)</l>
<l>*     tuple_mult (AnglesG2, 256.0/rad(180), AnglesG3)</l>
<l>*     set_grayval (DirImageP, RowG, ColG, AnglesG3)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ExtendedPattern">
<parameters>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP v1.0, 05.06.2022</c>
<l>junctions_skeleton(SkeletonG, EndPoints, JuncPoints)</l>
<l>gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 10, 'filter')</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>count_obj (SkContoursG, nSkCG)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nSkCG by 1</l>
<l>*     if(k==120)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>    area_center(SelectedSkeletonG, a, r, c)</l>
<l>*     if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c></c>
<l>    gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>    gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>    if(a&gt;0)</l>
<l>        test_subset_region(ER1, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>            col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>            gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>            intersection(Rectangle21, Domain, Rectangle21)</l>
<l>            union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle21, R21, C21)</l>
<l>            tuple_length(R21, n21)</l>
<l>            ang:=AnglesG[1]</l>
<l>            dir21:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n21, dir21, Dir21)</l>
<l>            tuple_max(R21, rm)</l>
<l>            tuple_max(C21, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<c>        </c>
<l>        test_subset_region(ER2, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<c>            </c>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>            col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>            gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.25)</l>
<l>*             gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>            intersection(Rectangle22, Domain, Rectangle22)</l>
<l>            union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle22, R22, C22)</l>
<l>            tuple_length(R22, n22)</l>
<l>            ang:=AnglesG[nA-2]</l>
<l>            dir22:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n22, dir22, Dir22)</l>
<l>            tuple_max(R22, rm)</l>
<l>            tuple_max(C22, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<l>    endif</l>
<l>    concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<c></c>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL106">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL106 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            VectorRM.insert(j, RowsGi[j])</l>
<l>            VectorCM.insert(j, ColsGi[j])</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>*     if ( w &gt;= (WminP[0]-wside) and w &lt;= (WminP[0]+wside)) </l>
<l>*         VectorRM.insert(j, RowsGi[j])</l>
<l>*         VectorCM.insert(j, ColsGi[j])</l>
<l>*     endif</l>
<l>*     if ( w &gt;= (WminP[1]-wside) and w &lt;= (WminP[1]+wside)) </l>
<l>*         VectorRM.insert(j, RowsGi[j])</l>
<l>*         VectorCM.insert(j, ColsGi[j])</l>
<l>*     endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonG, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<l>* wsides := 2</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>            VectorRM.insert(j, RowsGSi[j])</l>
<l>            VectorCM.insert(j, ColsGSi[j])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<c></c>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, cutendMSS, RadendMSS)</l>
<l>gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>union1(CMSSE, CMSSEu)</l>
<l>difference(RegionsmainSs, CMSSEu, RegionsmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c>* *************************************</c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL106">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumR"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ImIRBSOut := ImIRBS</l>
<c>** dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<l>dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, 3.0)</l>
<l>difference(SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<l>* intersection(SkeletonsFWMS, RegionInoD,RegionIntersection)</l>
<l>* union2(SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region(RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region(SkeletonsFWMSm, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceIRBS, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBP">
<interface>
<io>
<par name="SkeletonsFWMP" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBPOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ImIRBPOut := ImIRBP</l>
<l>expand_region (SkeletonsFWMP, RegionInoD, RegionsFWMP, expsize, 'image')</l>
<l>count_obj(RegionsFWMP, nRFWMP)</l>
<l>stseq := 0</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMP, 1, SequenceINBPi)</l>
<l>SequenceIRBP := SequenceINBPi%overf+stseq</l>
<l>boundary (RegionsFWMP, RegionsFWMPB, 'inner')</l>
<l>count_obj (RegionsFWMPB, nFWMSB)</l>
<l>paint_region (RegionsFWMP, ImIRBPOut, ImIRBPOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMPB, ImIRBPOut, ImIRBPOut, SequenceIRBP, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBP">
<parameters>
<parameter id="ImIRBP"/>
<parameter id="ImIRBPOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMP"/>
<parameter id="expsize"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloatMedSkip">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="prcmb" base_type="ctrl" dimension="0"/>
<par name="prcsp" base_type="ctrl" dimension="0"/>
<par name="skip" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<l>* js:=0</l>
<l>* for j:=0 to nW-1 by 1+skip</l>
<l>*     Wskip[js]:=W[j]</l>
<l>*     js:=js+1</l>
<l>* endfor</l>
<l>* nWs:=js</l>
<c></c>
<l>tuple_gen_const (nW, -prcmb, ThrMB)</l>
<l>tuple_gen_const (nW, prcsp, ThrSp)</l>
<c></c>
<l>tuple_gen_sequence(0, nW-1, 1+skip, Wsk)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<l>Prc := Wch*100.0/(Wfilt+0.001)</l>
<l>tuple_greater_equal_elem (Prc, ThrSp, DefSp)</l>
<l>tuple_less_equal_elem (Prc, ThrMB, DefMB)</l>
<l>Def := -DefMB+DefSp</l>
<l>return ()</l>
</body>
<docu id="FilterFloatMedSkip">
<parameters>
<parameter id="Def"/>
<parameter id="Prc"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="prcmb"/>
<parameter id="prcsp"/>
<parameter id="skip"/>
<parameter id="sz"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildFWM5">
<interface>
<io>
<par name="SkeletonsGThin" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="notusedint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildFWM5 </c>
<c>**** 2022.06.17 - added Puseint - used intersection points tuple</c>
<c>****</c>
<l>RowSkTh := []</l>
<l>ColSkTh := []</l>
<c>* * pnum corresponding to current MS</c>
<l>Pnum := []</l>
<c>* * pnum corresponding to region</c>
<l>PnumR := []</l>
<c>* * start address of a contour</c>
<l>PaddrC := []</l>
<c>* * start address for region</c>
<l>PaddrR := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregC := []</l>
<c>* * number of countours per region</c>
<l>PCinRnum := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontR := []</l>
<c>* * saving intersect. points for current MS ==1, not saving ==0</c>
<l>Puseint := []</l>
<l>paddrC := 0</l>
<l>paddrR := 0</l>
<l>pcont := 0</l>
<l>tuple_gen_const (notusedint, 0, Notused)</l>
<l>tuple_gen_sequence (0, notusedint-1, 1, Beg)</l>
<c></c>
<l>count_obj (SkeletonsGThin, nSGThin)</l>
<l>for j := 1 to nSGThin by 1</l>
<l>*     if (j==871)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c></c>
<l>*     j:=871</l>
<l>    select_obj (SkeletonsGThin, ObjectSelected1, j)</l>
<l>    area_center (ObjectSelected1, a, r, c)</l>
<c>    * *** empty regions (no skeleton FWM inside of RegiondPNi[j]</c>
<l>    pnumr := -1</l>
<l>*     RowSkTh := 0</l>
<l>*     ColSkTh := 0</l>
<l>    npreg := 0</l>
<l>    if (a&gt;0)</l>
<c>        * *** non-empty regions</c>
<l>        get_region_points (ObjectSelected1, R, C)</l>
<l>        tuple_length (R, nsp)</l>
<c></c>
<l>        get_grayval (ImageIR, R, C, PnValr)</l>
<l>        tuple_median (PnValr, pnumr)</l>
<l>*         tuple_max(Val,vmax)</l>
<l>*         if(vmax!=j)</l>
<l>*             stop()</l>
<l>*         endif</l>
<c></c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld (ObjectSelected1, Contours, 1, 'filter')</l>
<l>        count_obj (Contours, nC)</l>
<l>        tuple_concat (PCinRnum, nC, PCinRnum)</l>
<c></c>
<l>        tuple_concat (PcontR, pcont, PcontR)</l>
<l>        pcont := pcont+nC</l>
<c></c>
<l>        for jj := 1 to nC by 1</l>
<l>            select_obj (Contours, Contour, jj)</l>
<l>            get_contour_xld (Contour, R, C)</l>
<l>            get_grayval (ImageIR, R, C, PnVal)</l>
<c>            </c>
<l>*             get_grayval (ImageIR, R, C, Val)</l>
<l>*             tuple_median (Val, pnum)</l>
<l>            tuple_length (R, pN)</l>
<c>            </c>
<l>             tuple_gen_const(pN, 1, Pui)</l>
<l>            if(pN &gt;=notusedint*2)</l>
<l>                tuple_gen_sequence (pN-notusedint, pN-1, 1, End)</l>
<l>                tuple_replace(Pui, Beg, Notused, Pui)</l>
<l>                tuple_replace(Pui, End, Notused, Pui)</l>
<l>            endif</l>
<c>            </c>
<c>            **** can't skip any contour, numberings don't match!!!</c>
<l>*             if(pN &lt; 100)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>            tuple_concat (PaddrC, paddrC, PaddrC)</l>
<l>*             pcont := pcont+1</l>
<l>            paddrC := paddrC + pN</l>
<l>            tuple_concat (PregC, j, PregC)</l>
<l>*             if (pN&gt;100)</l>
<l>                tuple_concat (RowSkTh, R, RowSkTh)</l>
<l>                tuple_concat (ColSkTh, C, ColSkTh)</l>
<l>            get_grayval(DirImageP, R, C, Dirs)</l>
<l>            Dirsi:=Dirs</l>
<l>            tuple_length(Dirs, nD)</l>
<l>            for jjj:=0 to nD-2 by 1</l>
<l>*                 if(jjj==641)</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<l>                d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>                if(d &gt; 128)</l>
<l>                    d:= d-255</l>
<l>                elseif(d &lt; -128)</l>
<l>                    d:= d+255</l>
<l>                endif</l>
<l>                Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>            endfor</l>
<l>*             endif</l>
<l>            npreg := npreg+pN</l>
<l>            create_funct_1d_array(Dirs, FDirs)</l>
<l>            create_funct_1d_array(Dirsi, FDirsi)</l>
<l>            derivate_funct_1d(FDirs, 'first', Derivative)</l>
<l>            y_range_funct_1d(Derivative, YMin, YMax)</l>
<l>            if(YMin &lt; -20 or YMax &gt; 20)</l>
<l>*                 stop()</l>
<l>            endif</l>
<l>            dev_display(Contour)</l>
<l>            tuple_concat (Puseint, Pui, Puseint)</l>
<l>            tuple_concat (Pnum, PnVal, Pnum)</l>
<l>        endfor</l>
<l>    else</l>
<l>        tuple_concat (PCinRnum, 0, PCinRnum)</l>
<l>        tuple_concat (PcontR, -1, PcontR)</l>
<l>*         tuple_concat (PaddrC, -1, PaddrC)</l>
<l>    endif</l>
<l>    tuple_gen_const (npreg, pnumr, Pn)</l>
<l>*     tuple_concat (Pnum, Pn, Pnum)</l>
<l>    tuple_concat (PnumR, pnumr, PnumR)</l>
<l>    tuple_concat (PaddrR, paddrR, PaddrR)</l>
<c>    </c>
<l>    paddrR := paddrR + npreg</l>
<l>endfor</l>
<c>* ** test ***</c>
<l>* sj := 1100</l>
<l>* pnum := PnumR[sj-1]</l>
<l>* a := PaddrR[sj-1]</l>
<l>* pnum1 := Pnum[a]</l>
<c>* **************</c>
<l>get_grayval (WidthImageP, RowSkTh, ColSkTh, WG)</l>
<l>get_grayval (DirImageP, RowSkTh, ColSkTh, Dir)</l>
<l>Ang := Dir*1.0*3.1415926/256.0</l>
<l>K:=1.</l>
<l>Y1 := RowSkTh-sin(Ang)*(WG/K+wpl)</l>
<l>X1 := ColSkTh+cos(Ang)*(WG/K+wpl)</l>
<l>Y2 := RowSkTh+sin(Ang)*(WG/K+wpl)</l>
<l>X2 := ColSkTh-cos(Ang)*(WG/K+wpl)</l>
<l>YC := RowSkTh</l>
<l>XC := ColSkTh</l>
<c></c>
<l>* gen_region_points(P2, Y2, X2)</l>
<l>return ()</l>
</body>
<docu id="MSBuildFWM5">
<parameters>
<parameter id="DirImageP"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Pnum"/>
<parameter id="PnumR"/>
<parameter id="PregC"/>
<parameter id="Puseint"/>
<parameter id="SkeletonsGThin"/>
<parameter id="WG"/>
<parameter id="WidthImageP"/>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YC"/>
<parameter id="notusedint"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSProc32">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc32 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c></c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;pPat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    if(i==20)</l>
<l>        stop()</l>
<l>    endif</l>
<l>*     dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('yellow')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        concat_obj(PC, Pc, PC)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        if((vp==0 or (vp&gt;1 and vp!= pnum)) or (vn==0 or (vn&gt;1 and vn!= pnum)) )    </l>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-65535-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                ii:=ii+1</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==1 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>    endif</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        ii:=ii+1</l>
<l>        if(Pval[pind-2]==0)</l>
<l>            PIntY[ii]:=PPy[pind-1]</l>
<l>            PIntX[ii]:=PPx[pind-1]</l>
<l>            PInti[ii]:=pind-1</l>
<l>            PCLC[ii]:=clc</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    shift:=0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>        get_grayval (Im, PPy[PInti[j]], PPx[PInti[j]],  g)</l>
<l>        g0[1] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>        g0[2] := g</l>
<l>        SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW segment</c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* stop()</l>
<c>*** finding SP points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>        if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>            continue</l>
<l>        else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>if(intnum==2)</l>
<l>    normint:=1</l>
<l>else</l>
<l>    normint:=0</l>
<l>endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSProc32">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="normint"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandReal">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBin" base_type="iconic" dimension="0"/>
<par name="ImIRealBin" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBout" base_type="iconic" dimension="0"/>
<par name="ImIRealBout" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="TInoDtoIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** BuildIRBandReal *** builds ImageIRB and ImageRealB</c>
<l>count_obj(RegionsInoD, n)</l>
<l>ImIRBout:=ImIRBin</l>
<l>ImIRealBout:=ImIRealBin</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* tuple_gen_sequence (1, n, 1, SequenceINBi)</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary(RegionsInoD, RegionsInoDB, 'inner')</l>
<l>union1(RegionsInoD, RegionInoD)</l>
<l>paint_region (RegionInoD, ImIRBin, ImIRBout, 1, 'fill')</l>
<l>TInoDtoIRB:=[]</l>
<l>for j:=1 to n by 1</l>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>    get_region_points(RInoDB, Rows, Columns)</l>
<l>    tuple_length(Rows, nPts)</l>
<l>    Rsel:=[Rows[nPts/2], Rows[nPts/4], Rows[nPts*3/4]] </l>
<l>    Csel:=[Columns[nPts/2], Columns[nPts/4], Columns[nPts*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>*     pn:= SequenceIRB[j-1]</l>
<l>    tuple_gen_const(nPts, pn, Npn)</l>
<l>    set_grayval(ImIRBout, Rows, Columns, Npn)</l>
<l>    tuple_gen_const(nPts, j, Nj)</l>
<l>    set_grayval(ImIRealBout, Rows, Columns, Nj)</l>
<l>    tuple_concat(TInoDtoIRB,pn,TInoDtoIRB)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandReal">
<parameters>
<parameter id="ImIRBin"/>
<parameter id="ImIRBout"/>
<parameter id="ImIRealBin"/>
<parameter id="ImIRealBout"/>
<parameter id="ImageIR"/>
<parameter id="RegionsInoD"/>
<parameter id="TInoDtoIRB"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloadMedn">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="prcmb" base_type="ctrl" dimension="0"/>
<par name="prcsp" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<l>tuple_gen_const (nW, -prcmb, ThrMB)</l>
<l>tuple_gen_const (nW, prcsp, ThrSp)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<l>Prc := Wch*100.0/(Wfilt+0.001)</l>
<l>tuple_greater_equal_elem (Prc, ThrSp, DefSp)</l>
<l>tuple_less_equal_elem (Prc, ThrMB, DefMB)</l>
<l>Def := -DefMB+DefSp</l>
<l>return ()</l>
</body>
<docu id="FilterFloadMedn">
<parameters>
<parameter id="Def"/>
<parameter id="Prc"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="prcmb"/>
<parameter id="prcsp"/>
<parameter id="sz"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildEndCutters">
<interface>
<oo>
<par name="Rbeg" base_type="iconic" dimension="0"/>
<par name="Rend" base_type="iconic" dimension="0"/>
<par name="Pbeg" base_type="iconic" dimension="0"/>
<par name="Pend" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="numc" base_type="ctrl" dimension="0"/>
<par name="NINT" base_type="ctrl" dimension="0"/>
<par name="PINTx1" base_type="ctrl" dimension="0"/>
<par name="PINTy1" base_type="ctrl" dimension="0"/>
<par name="PINTx2" base_type="ctrl" dimension="0"/>
<par name="PINTy2" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>        ****** BuildEndCutters - building end cutters for FWM (from intersection points)</c>
<c>        *** for each FWM contour, numc == number of points in the contour</c>
<l>          fwmbeg:=-1</l>
<l>          fwmend:=-1</l>
<l>          for i:=0 to numc-1 by 1</l>
<l>              if(NINT[i]==2 and fwmbeg == -1)</l>
<l>                  fwmbeg:= i</l>
<l>              endif</l>
<l>              if(NINT[numc-1-i]==2 and fwmend == -1)</l>
<l>                  fwmend:= numc-1-i</l>
<l>              endif</l>
<l>              if( fwmbeg != -1 and fwmend == -1)</l>
<l>                  break</l>
<l>              endif</l>
<l>          endfor</l>
<l>          x1b:=PINTx1[fwmbeg]</l>
<l>          y1b:=PINTy1[fwmbeg]</l>
<l>          x2b:=PINTx2[fwmbeg]</l>
<l>          y2b:=PINTy2[fwmbeg]</l>
<c>          </c>
<l>          x1e:=PINTx1[fwmend]</l>
<l>          y1e:=PINTy1[fwmend]</l>
<l>          x2e:=PINTx2[fwmend]</l>
<l>          y2e:=PINTy2[fwmend]</l>
<c></c>
<l>          gen_region_points(Pbeg, [y1b,y2b],[x1b,x2b])</l>
<l>          smallest_rectangle2(Pbeg, row, col, Phi, Length1, Length2)</l>
<l>          gen_rectangle2(Rbeg, row, col, Phi, Length1+1, Length2+1)</l>
<l>          gen_region_points(Pend, [y1e,y2e],[x1e,x2e])</l>
<l>          smallest_rectangle2(Pend, row, col, Phi, Length1, Length2)</l>
<l>          gen_rectangle2(Rend, row, col, Phi, Length1+1, Length2+1)</l>
<l>return ()</l>
</body>
<docu id="BuildEndCutters">
<parameters>
<parameter id="NINT"/>
<parameter id="PINTx1"/>
<parameter id="PINTx2"/>
<parameter id="PINTy1"/>
<parameter id="PINTy2"/>
<parameter id="Pbeg"/>
<parameter id="Pend"/>
<parameter id="Rbeg"/>
<parameter id="Rend"/>
<parameter id="numc"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandRealT">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBin" base_type="iconic" dimension="0"/>
<par name="ImIRealBin" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBout" base_type="iconic" dimension="0"/>
<par name="ImIRealBout" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="TInoDtoIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** BuildIRBandReal *** builds ImageIRB and ImageRealB</c>
<c>*** 220628 - TInoDtoIRB - connection InoD&lt;-&gt;CAD</c>
<l>count_obj(RegionsInoD, n)</l>
<l>ImIRBout:=ImIRBin</l>
<l>ImIRealBout:=ImIRealBin</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* tuple_gen_sequence (1, n, 1, SequenceINBi)</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary(RegionsInoD, RegionsInoDB, 'inner')</l>
<l>union1(RegionsInoD, RegionInoD)</l>
<l>paint_region (RegionInoD, ImIRBin, ImIRBout, 1, 'fill')</l>
<l>TInoDtoIRB:=[]</l>
<l>for j:=1 to n by 1</l>
<l>*     if(j==57)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>    get_region_points(RInoDB, Rows, Columns)</l>
<l>    tuple_length(Rows, nPts)</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    inner_circle(RInoD, r, c, radius)</l>
<l>    if(radius &gt; 2.0)</l>
<l>        erosion_circle(RInoD, RInoDd, 1.5)</l>
<l>    else</l>
<l>        RInoDd:=RInoD</l>
<l>    endif</l>
<c>    </c>
<l>    get_region_points(RInoDd, Rowsd, Columnsd)</l>
<l>    tuple_length(Rowsd, nPtsd)</l>
<l>    Rsel:=[Rowsd[nPtsd/2], Rowsd[nPtsd/4], Rowsd[nPtsd*3/4]] </l>
<l>    Csel:=[Columnsd[nPtsd/2], Columnsd[nPtsd/4], Columnsd[nPtsd*3/4]]</l>
<c></c>
<l>*     Rsel:=[Rows[nPts/2], Rows[nPts/4], Rows[nPts*3/4], Rows[nPts*3/8], Rows[nPts*5/8]] </l>
<l>*     Csel:=[Columns[nPts/2], Columns[nPts/4], Columns[nPts*3/4], Columns[nPts*3/8], Columns[nPts*5/8]]</l>
<l>*     gen_region_points(PP, Rsel, Csel)</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_grayval(ImageIR16, Rsel,Csel, Grayval16)</l>
<l>    tuple_median(Grayval16, pn16)</l>
<l>*     get_grayval(ImageIR16, Rsel[1],Csel[1], pn16)</l>
<l>    *     pn:= SequenceIRB[j-1]</l>
<l>    tuple_gen_const(nPts, pn, Npn)</l>
<l>    set_grayval(ImIRBout, Rows, Columns, Npn)</l>
<l>    tuple_gen_const(nPts, j, Nj)</l>
<l>    set_grayval(ImIRealBout, Rows, Columns, Nj)</l>
<l>    tuple_concat(TInoDtoIRB,pn16,TInoDtoIRB)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandRealT">
<parameters>
<parameter id="ImIRBin"/>
<parameter id="ImIRBout"/>
<parameter id="ImIRealBin"/>
<parameter id="ImIRealBout"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="RegionsInoD"/>
<parameter id="TInoDtoIRB"/>
</parameters>
</docu>
</procedure>
<procedure name="AbsRelDefContoursPT">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="ImNRealB" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="TInoDtoIRB" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PINTx1" base_type="ctrl" dimension="0"/>
<par name="PINTy1" base_type="ctrl" dimension="0"/>
<par name="PINTx2" base_type="ctrl" dimension="0"/>
<par name="PINTy2" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*AbsRelDefContoursPT - 220628 for Pattern and with FWM removal</c>
<l>set_system('neighborhood', 4)</l>
<l>* boundary(RegionInoD, RegionInoDB, 'outer')</l>
<c>*** pattern regions</c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>boundary(RegionsInoD, RegionsInoDB, 'inner')</l>
<c>*** removed for C++ **</c>
<c></c>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c>*****</c>
<l>sz:=41</l>
<l>tuple_length(PaddrC, nAddrC)</l>
<l>tuple_length(PaddrR, nAddrR)</l>
<l>cnt:=0</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=1201</l>
<c>    </c>
<c>        *** FMW reg. number</c>
<l>    nreg:= TInoDtoIRB[j-1]</l>
<c>    *** number of contours in reg</c>
<l>    nc:=PCinRnum[nreg-1]</l>
<l>    ncontb:= PcontR[nreg-1]</l>
<c>    ***** need to find all contours ****</c>
<l>    gen_empty_obj(AllRegCont)</l>
<l>    gen_empty_obj(AllRegdif)</l>
<l>    for k:=0 to nc-1 by 1</l>
<l>        ncont:=ncontb+k</l>
<l>        ab:=PaddrC[ncont]</l>
<l>*         if(ab&gt;=433)</l>
<l>*                 stop()</l>
<l>*         endif</l>
<l>        a:=ab</l>
<l>        if(ncont+1&lt;nAddrC)</l>
<l>            ae:=PaddrC[ncont+1]-1</l>
<l>        else</l>
<l>            tuple_length(PINTx1, nP)</l>
<l>            ae := nP-1</l>
<l>        endif</l>
<c>        </c>
<l>*         ae:=ab+200</l>
<l>        numc:= ae-ab</l>
<l>        tuple_select_range(PINTy1, ab, ae, SelectedY1)</l>
<l>        tuple_select_range(PINTx1, ab, ae, SelectedX1)</l>
<l>        gen_region_points(PI, SelectedY1, SelectedX1)</l>
<l>        tuple_select_range(PINTy2, ab, ae, SelectedY2)</l>
<l>        tuple_select_range(PINTx2, ab, ae, SelectedX2)</l>
<l>        gen_region_points(PI2, SelectedY2, SelectedX2)</l>
<l>        amid:=(ab+ae)/2</l>
<l>        gen_region_points(Pmid, PINTy1[amid], PINTx1[amid])</l>
<l>*         endfor</l>
<l>        select_obj(RegionsInoD, RInoDB, j)</l>
<c>        ****** building end cutters for FWM (from intersection points)</c>
<c>        *** for each FWM contour, numc == number of points in the contour</c>
<l>          BuildEndCutters (Rbeg, Rend, Pbeg, Pend, numc, Puseint, SelectedX1, SelectedY1, SelectedX2, SelectedY2)</l>
<l>           cnt:=cnt+1         </l>
<l>          get_region_points(Pbeg,  Rb, Cb)</l>
<l>          get_grayval(ImNRealB, Rb, Cb, ninod)</l>
<l>          union2(Rbeg, Rend, Rbe)</l>
<l>*           concat_obj(Rbeg, Rend, Rbes)</l>
<l>          nd:=max2(ninod[0], ninod[1])</l>
<l>          select_obj(RegionsInoD, ObjectSelected, nd)</l>
<l>          select_obj(RegionsInoDB, ObjectSelectedBi, nd)</l>
<l>          difference(ObjectSelected, Rbe, RegionDifference)</l>
<l>          connection(RegionDifference, RegionsDifference)</l>
<l>          count_obj(RegionsDifference, ndif)</l>
<c></c>
<l>          for kk:=1 to ndif by 1</l>
<l>              select_obj(RegionsDifference, Rdif, kk)</l>
<l>              test_region_point(Rdif, PINTy1[amid], PINTx1[amid], isInside)</l>
<l>              if(isInside==1)</l>
<l>                  break</l>
<l>              endif</l>
<l>          endfor</l>
<c>          </c>
<l>*           count_obj(RegionsDifference, ndif)</l>
<l>*           dilation_circle(Rbe, Rbed, 1.5)</l>
<l>*           dilation_circle(Rbes, Rbeds, 1.5)</l>
<l>*           for kk:=1 to ndif by 1</l>
<l>*               select_obj(RegionsDifference, Rdif, kk)</l>
<l>*               intersection(Rbed, Rdif, RegionIntersection)</l>
<l>*               connection(RegionIntersection, RegionsIntersection)</l>
<l>*               count_obj(RegionsIntersection, nint)</l>
<l>*               if(nint&gt;1)</l>
<l>*                   break</l>
<l>*               endif</l>
<l>*           endfor</l>
<l>          difference(ObjectSelectedBi, Rdif, RegNFWM)</l>
<l>          ObjectSelectedBi:=RegNFWM</l>
<l>*           dev_display(Im)</l>
<l>*           dev_set_color('magenta')</l>
<l>*           dev_display(Rdif)</l>
<l>*           stop()</l>
<l>          union2(AllRegdif, Rdif, AllRegdif)</l>
<l>*           connection(RegNFWM, RegsNFWM)</l>
<l>*           count_obj(RegsNFWM, nr)</l>
<l>*           for kk:=1 to nr by 1</l>
<l>*               select_obj(RegsNFWM, Reg, kk)</l>
<l>*               gen_contours_skeleton_xld(Reg, Cont, 1, 'generalize1')</l>
<l>*               union_adjacent_contours_xld(Cont, UnionContour, 1, 1, 'attr_forget')</l>
<l>*               select_contours_xld(UnionContour, SelectedContour, 'contour_length', 2, 2000000, -0.5, 0.5)</l>
<l>*               smooth_contours_xld(SelectedContour, SmoothedContour, 3)</l>
<c>***               get_contour_xld(SmoothedContour, RowsC, ColsC)</c>
<l>*           endfor</l>
<l>*           concat_obj(AllRegCont, SmoothedContour, AllRegCont)</l>
<l>      endfor </l>
<l>      difference(RInoDB, AllRegdif, RegionDifference1)</l>
<l>*       stop()</l>
<l>    get_region_contour(RInoDB, RowsInoDB, ColsInoDB)</l>
<l>    gen_region_points(RR, RowsInoDB, ColsInoDB)</l>
<c>    *** proving that RowsInoDB index = CLC+1</c>
<l>*     tuple_length(ColsInoDB, nP)</l>
<l>*     gen_empty_obj(RP)</l>
<l>*     for k:=0 to nP-1 by 1</l>
<l>*         gen_region_points(Pk, RowsInoDB[k], ColsInoDB[k])</l>
<l>*         concat_obj(RP, Pk, RP)</l>
<l>*     endfor</l>
<l>*     stop()</l>
<l>*     gen_region_points(Region, RowsInoDB, ColsInoDB)</l>
<l>        get_grayval(ImDisplacement, RowsInoDB, ColsInoDB, Displacement1)</l>
<l>        Displacement:=Displacement1-127</l>
<c></c>
<l>        Def:=[0,0,0,0,0]</l>
<l>*         FilterFloatMedNFWM(Displacement, sz, 4, 4, Def, Wfilt, Wch)</l>
<l>*         tuple_max(Def, dmax)</l>
<l>*         tuple_min(Def, dmin)</l>
<c>*     </c>
<l>*         if(dmax &gt; 0)</l>
<l>*             tuple_sort_index(Def, Indices)</l>
<l>*             tuple_inverse(Indices, Inverted)</l>
<l>*             tuple_length(Def, len)</l>
<l>*             tuple_gen_const(len, 0, T0)</l>
<l>*              tuple_select_mask(Def,Def, Selected)</l>
<l>*              tuple_select_mask(RowsInoDB,Def, SelectedR)</l>
<l>*              tuple_select_mask(ColsInoDB,Def, SelectedC)</l>
<l>*              tuple_length(SelectedC, n)</l>
<l>*              tuple_gen_const(n, 10.5, RadC)</l>
<l>*              gen_circle(Circle, SelectedR, SelectedC, RadC)</l>
<l>*             stop()</l>
<l>*         endif</l>
<c>    </c>
<l>*     if(dmin &lt; 0)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>***** removed for C++ **</c>
<l>    VectorCY.insert(j,RowsInoDB)</l>
<l>    VectorCX.insert(j,ColsInoDB)</l>
<c>******</c>
<l>endfor</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<l>gen_region_points(RegionnoB, Cy, Cx)</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AbsRelDefContoursPT">
<parameters>
<parameter id="Cx"/>
<parameter id="Cy"/>
<parameter id="Def"/>
<parameter id="ImDisplacement"/>
<parameter id="ImNRealB"/>
<parameter id="PCinRnum"/>
<parameter id="PINTx1"/>
<parameter id="PINTx2"/>
<parameter id="PINTy1"/>
<parameter id="PINTy2"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Puseint"/>
<parameter id="RegionInoD"/>
<parameter id="TInoDtoIRB"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandReal_COPY_1">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBin" base_type="iconic" dimension="0"/>
<par name="ImIRealBin" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBout" base_type="iconic" dimension="0"/>
<par name="ImIRealBout" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* *** BuildIRBandReal *** builds ImageIRB and ImageRealB</c>
<l>count_obj (RegionsInoD, n)</l>
<l>ImIRBout := ImIRBin</l>
<l>ImIRealBout := ImIRealBin</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* tuple_gen_sequence (1, n, 1, SequenceINBi)</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary (RegionsInoD, RegionsInoDB, 'inner')</l>
<l>union1 (RegionsInoD, RegionInoD)</l>
<l>paint_region (RegionInoD, ImIRBin, ImIRBout, 1, 'fill')</l>
<c></c>
<l>for j := 1 to n by 1</l>
<l>    select_obj (RegionsInoDB, RInoDB, j)</l>
<l>    get_region_points (RInoDB, Rows, Columns)</l>
<l>    tuple_length (Rows, nPts)</l>
<l>    Rsel := [Rows[nPts/2], Rows[nPts/4], Rows[nPts*3/4]]</l>
<l>    Csel := [Columns[nPts/2], Columns[nPts/4], Columns[nPts*3/4]]</l>
<l>    get_grayval (ImageIR, Rsel, Csel, Grayval)</l>
<l>    tuple_median (Grayval, pn)</l>
<l>*     pn := SequenceIRB[j-1]</l>
<l>    tuple_gen_const (nPts, pn, Npn)</l>
<l>    set_grayval (ImIRBout, Rows, Columns, Npn)</l>
<l>    tuple_gen_const (nPts, j, Nj)</l>
<l>    set_grayval (ImIRealBout, Rows, Columns, Nj)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandReal_COPY_1">
<parameters>
<parameter id="ImIRBin"/>
<parameter id="ImIRBout"/>
<parameter id="ImIRealBin"/>
<parameter id="ImIRealBout"/>
<parameter id="ImageIR"/>
<parameter id="RegionsInoD"/>
</parameters>
</docu>
</procedure>
<procedure name="AbsRelDefContoursPT_COPY_1">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="ImNRealB" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="TInoDtoIRB" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PINTx1" base_type="ctrl" dimension="0"/>
<par name="PINTy1" base_type="ctrl" dimension="0"/>
<par name="PINTx2" base_type="ctrl" dimension="0"/>
<par name="PINTy2" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* AbsRelDefContoursPT - 220628 for Pattern and with FWM removal</c>
<l>set_system ('neighborhood', 4)</l>
<l>* boundary (RegionInoD, RegionInoDB, 'outer')</l>
<c>* ** pattern regions</c>
<l>connection (RegionInoD, RegionsInoD)</l>
<l>count_obj (RegionsInoD, nInoD)</l>
<l>boundary (RegionsInoD, RegionsInoDB, 'inner')</l>
<c>* ** removed for C++ **</c>
<c></c>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c>* ****</c>
<l>sz := 41</l>
<l>tuple_length (PaddrC, nAddrC)</l>
<l>tuple_length (PaddrR, nAddrR)</l>
<l>cnt := 0</l>
<l>for j := 1 to nInoD by 1</l>
<l>*     j := 1201</l>
<l>    select_obj (RegionsInoD, RInoDB, j)</l>
<c>    * ***** building end cutters for FWM (from intersection points)</c>
<c>    * ** for each FWM contour, numc == number of points in the contour</c>
<c>    * ** FMW reg. number</c>
<l>    nreg := TInoDtoIRB[j-1]</l>
<c>    * ** number of contours in reg</c>
<l>    nc := PCinRnum[nreg-1]</l>
<l>    ncontb := PcontR[nreg-1]</l>
<c>    * **** need to find all contours ****</c>
<l>    gen_empty_obj (AllRegCont)</l>
<l>    gen_empty_obj (AllRegdif)</l>
<l>    for k := 0 to nc-1 by 1</l>
<l>        ncont := ncontb+k</l>
<l>        ab := PaddrC[ncont]</l>
<l>*         if (ab&gt;=433)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>        a := ab</l>
<l>        if (ncont+1&lt;nAddrC)</l>
<l>            ae := PaddrC[ncont+1]-1</l>
<l>        else</l>
<l>            tuple_length (PINTx1, nP)</l>
<l>            ae := nP-1</l>
<l>        endif</l>
<c></c>
<l>*         ae := ab+200</l>
<l>        numc := ae-ab</l>
<l>        tuple_select_range (PINTy1, ab, ae, SelectedY1)</l>
<l>        tuple_select_range (PINTx1, ab, ae, SelectedX1)</l>
<l>        gen_region_points (PI, SelectedY1, SelectedX1)</l>
<l>        tuple_select_range (PINTy2, ab, ae, SelectedY2)</l>
<l>        tuple_select_range (PINTx2, ab, ae, SelectedX2)</l>
<l>        gen_region_points (PI2, SelectedY2, SelectedX2)</l>
<l>        amid := (ab+ae)/2</l>
<l>        gen_region_points (Pmid, PINTy1[amid], PINTx1[amid])</l>
<l>*         endfor</l>
<l>BuildEndCutters (Rbeg, Rend, Pbeg, Pend, numc, Puseint, SelectedX1, SelectedY1, SelectedX2, SelectedY2)</l>
<l>        cnt := cnt+1</l>
<c></c>
<l>        get_region_points (Pbeg, Rb, Cb)</l>
<l>        get_grayval (ImNRealB, Rb, Cb, ninod)</l>
<l>        union2 (Rbeg, Rend, Rbe)</l>
<l>*         concat_obj (Rbeg, Rend, Rbes)</l>
<l>        nd := max2(ninod[0], ninod[1])</l>
<l>        select_obj (RegionsInoD, ObjectSelected, nd)</l>
<l>        select_obj (RegionsInoDB, ObjectSelectedBi, nd)</l>
<l>        difference (ObjectSelected, Rbe, RegionDifference)</l>
<l>        connection (RegionDifference, RegionsDifference)</l>
<l>        count_obj (RegionsDifference, ndif)</l>
<l>*         dilation_circle (Rbe, Rbed, 1.5)</l>
<l>*         dilation_circle (Rbes, Rbeds, 1.5)</l>
<l>        for kk := 1 to ndif by 1</l>
<l>            select_obj (RegionsDifference, Rdif, kk)</l>
<l>            test_region_point (Rdif, PINTy1[amid], PINTx1[amid], isInside)</l>
<l>*             intersection (Rbed, Rdif, RegionIntersection)</l>
<l>*             connection (RegionIntersection, RegionsIntersection)</l>
<l>*             count_obj (RegionsIntersection, nint)</l>
<l>            if (isInside==1)</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<c></c>
<l>*         count_obj (RegionsDifference, ndif)</l>
<l>*         dilation_circle (Rbe, Rbed, 1.5)</l>
<l>*         dilation_circle (Rbes, Rbeds, 1.5)</l>
<l>*           for kk:=1 to ndif by 1</l>
<l>*             select_obj (RegionsDifference, Rdif, kk)</l>
<l>*               intersection(Rbed, Rdif, RegionIntersection)</l>
<l>*               connection(RegionIntersection, RegionsIntersection)</l>
<l>*               count_obj(RegionsIntersection, nint)</l>
<l>*               if(nint&gt;1)</l>
<l>*                   break</l>
<l>*               endif</l>
<l>*           endfor</l>
<l>        difference (ObjectSelectedBi, Rdif, RegNFWM)</l>
<l>        ObjectSelectedBi := RegNFWM</l>
<l>*         dev_display (Im)</l>
<l>*         dev_set_color ('magenta')</l>
<l>*         dev_display (Rdif)</l>
<l>*         stop ()</l>
<l>        union2 (AllRegdif, Rdif, AllRegdif)</l>
<l>*         connection (RegNFWM, RegsNFWM)</l>
<l>*           count_obj(RegsNFWM, nr)</l>
<l>*           for kk:=1 to nr by 1</l>
<l>*               select_obj(RegsNFWM, Reg, kk)</l>
<l>*               gen_contours_skeleton_xld(Reg, Cont, 1, 'generalize1')</l>
<l>*               union_adjacent_contours_xld(Cont, UnionContour, 1, 1, 'attr_forget')</l>
<l>*               select_contours_xld(UnionContour, SelectedContour, 'contour_length', 2, 2000000, -0.5, 0.5)</l>
<l>*               smooth_contours_xld(SelectedContour, SmoothedContour, 3)</l>
<c>            * **               get_contour_xld(SmoothedContour, RowsC, ColsC)</c>
<l>*           endfor</l>
<l>*           concat_obj(AllRegCont, SmoothedContour, AllRegCont)</l>
<l>    endfor</l>
<l>    difference (RInoDB, AllRegdif, RegionDifference1)</l>
<l>*     stop ()</l>
<l>    get_region_contour (RInoDB, RowsInoDB, ColsInoDB)</l>
<l>    gen_region_points (RR, RowsInoDB, ColsInoDB)</l>
<c>    * ** proving that RowsInoDB index = CLC+1</c>
<l>*     tuple_length (ColsInoDB, nP)</l>
<l>*     gen_empty_obj (RP)</l>
<l>*     for k := 0 to nP-1 by 1</l>
<l>*         gen_region_points (Pk, RowsInoDB[k], ColsInoDB[k])</l>
<l>*         concat_obj (RP, Pk, RP)</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<l>*     gen_region_points (Region, RowsInoDB, ColsInoDB)</l>
<l>    get_grayval (ImDisplacement, RowsInoDB, ColsInoDB, Displacement1)</l>
<l>    Displacement := Displacement1-127</l>
<c></c>
<l>    Def := [0,0,0,0,0]</l>
<l>* FilterFloatMedNFWM (Displacement, sz, 4, 4, Def, Wfilt, Wch)</l>
<l>*     tuple_max (Def, dmax)</l>
<l>*     tuple_min (Def, dmin)</l>
<c></c>
<l>*         if(dmax &gt; 0)</l>
<l>*         tuple_sort_index (Def, Indices)</l>
<l>*         tuple_inverse (Indices, Inverted)</l>
<l>*         tuple_length (Def, len)</l>
<l>*         tuple_gen_const (len, 0, T0)</l>
<l>*         tuple_select_mask (Def, Def, Selected)</l>
<l>*         tuple_select_mask (RowsInoDB, Def, SelectedR)</l>
<l>*         tuple_select_mask (ColsInoDB, Def, SelectedC)</l>
<l>*              tuple_length(SelectedC, n)</l>
<l>*              tuple_gen_const(n, 10.5, RadC)</l>
<l>*              gen_circle(Circle, SelectedR, SelectedC, RadC)</l>
<l>*         stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     if(dmin &lt; 0)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * **** removed for C++ **</c>
<l>    VectorCY.insert(j,RowsInoDB)</l>
<l>    VectorCX.insert(j,ColsInoDB)</l>
<c>    * *****</c>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorCX, Cx)</l>
<l>convert_vector_to_tuple (VectorCY, Cy)</l>
<l>gen_region_points (RegionnoB, Cy, Cx)</l>
<l>convert_vector_to_tuple (VectorCX, Cx)</l>
<l>convert_vector_to_tuple (VectorCY, Cy)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AbsRelDefContoursPT_COPY_1">
<parameters>
<parameter id="Cx"/>
<parameter id="Cy"/>
<parameter id="Def"/>
<parameter id="ImDisplacement"/>
<parameter id="ImNRealB"/>
<parameter id="PCinRnum"/>
<parameter id="PINTx1"/>
<parameter id="PINTx2"/>
<parameter id="PINTy1"/>
<parameter id="PINTy2"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Puseint"/>
<parameter id="RegionInoD"/>
<parameter id="TInoDtoIRB"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSProc32">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc32 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;pPat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('yellow')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        concat_obj(PC, Pc, PC)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        *if((vp==pat0space1 or (vp&gt;1 and vp!= pnum)) or (vn==pat0space1 or (vn&gt;1 and vn!= pnum)) )    </l>
<l>        if((vp==pat0space1 ) or (vn==pat0space1 ) )    </l>
<c>    </c>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>            get_grayval(ImageIRBS, yc, xc, clc)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-65535-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                ii:=ii+1</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<l>* tuple_select_range(PIntY, 0, intnum-1, PIntYs) </l>
<l>* tuple_select_range(PIntX, 0, intnum-1, PIntXs) </l>
<l>* get_grayval(ImageCLC, PIntYs, PIntXs, Grayval)</l>
<l>* Ind</l>
<l>* tuple_replace(PCLC, PIntXs, PIntXs, Replaced)</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==1 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>    endif</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        ii:=ii+1</l>
<l>        if(Pval[pind-2]==0)</l>
<l>            PIntY[ii]:=PPy[pind-1]</l>
<l>            PIntX[ii]:=PPx[pind-1]</l>
<l>            PInti[ii]:=pind-1</l>
<l>            PCLC[ii]:=clc</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    shift:=0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>        get_grayval (Im, PPy[PInti[j]], PPx[PInti[j]],  g)</l>
<l>        g0[1] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>        g0[2] := g</l>
<l>        SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW segment</c>
<c>*** fixing PCLC</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>    PCLC[j]:=vclc</l>
<l>endfor</l>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* stop()</l>
<c>*** finding SP points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>        if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>            continue</l>
<l>        else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>if(wmax&gt;35)</l>
<l>    stop()</l>
<l>endif</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSProc32">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="AbsRelDefContours2">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*AbsRelDefContoursT - test version</c>
<l>set_system('neighborhood', 4)</l>
<l>* boundary(RegionInoD, RegionInoDB, 'outer')</l>
<c>*** pattern regions</c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>* get_image_size(ImDisplacement, W, H)</l>
<l>get_domain(ImDisplacement, Domain)</l>
<l>difference(Domain, RegionInoD, RegionInoDC)</l>
<l>* complement(RegionInoD, RegionInoDC)</l>
<c></c>
<l>dilation_circle(RegionInoDC, RegionInoDCd, 1)</l>
<c>*** space regions</c>
<l>connection(RegionInoDCd, RegionsInoDC)</l>
<l>count_obj(RegionsInoDC, nInoDC)</l>
<c>*** combined pattern and space</c>
<l>concat_obj(RegionsInoD, RegionsInoDC, RegionsInoDA)</l>
<l>count_obj(RegionsInoDA, nInoDA)</l>
<c>*** removed for C++ **</c>
<c></c>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c>*****</c>
<l>sz:=121</l>
<l>* read_object (HoSpp, 'E:/PATTERN/ho_SPP.hobj')</l>
<l>* read_object (RegsSPNall, 'E:/PATTERN/RegsSPNall.hobj')</l>
<l>* read_object (ho_RconnectedNFWMmb, 'E:/PATTERN/ho_RconnectedNFWMmb.hobj')</l>
<l>* read_object (ho_RSPnfwm, 'E:/PATTERN/ho_RSPnfwm.hobj')</l>
<c></c>
<l>for j:=1 to nInoDA by 1</l>
<l>*     j:=7</l>
<l>*     j:=nInoD+6</l>
<l>    j:=4238</l>
<l>    select_obj(RegionsInoDA, RInoDB, j)</l>
<l>    get_region_contour(RInoDB, RowsInoDB, ColsInoDB)</l>
<l>*     connect_and_holes(RInoDB, NumConnected, NumHoles)</l>
<l>*     fill_up(RInoDB, RegionFillUp)</l>
<l>*     difference(RegionFillUp, RInoDB, RegionDifference)</l>
<l>*     connection(RegionDifference, RHoles)</l>
<c>    </c>
<l>*     gen_region_points(PPP, RowsInoDB, ColsInoDB)</l>
<c>    **** checking contour points  ***</c>
<l>*     tuple_length(RowsInoDB, n)</l>
<l>*     gen_empty_obj(PP)</l>
<l>*     gen_empty_obj(PPt)</l>
<l>*     for k:=0 to n-1 by 1</l>
<l>*         gen_region_points(P, RowsInoDB[k], ColsInoDB[k])</l>
<l>*         concat_obj(PPt,P,PPt)</l>
<l>*         if(k%10000==0)</l>
<l>*             concat_obj(PP,PPt,PP)</l>
<l>*             gen_empty_obj(PPt)</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop()</l>
<c>    ************************</c>
<l>*     gen_contour_region_xld(RInoDB, Contour, 'center')</l>
<l>*     smooth_contours_xld(Contour, SmoothedoContur, 15)</l>
<l>*     segment_contours_xld(SmoothedoContur, ContoursSplit, 'lines_circles', 1, 1, 5)</l>
<l>*     fit_circle_contour_xld(ContoursSplit, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>*     gen_region_points(Regions, Row, Column)</l>
<l>*     get_contour_angle_xld(Contour, 'rel', 'range', 11, Angles)</l>
<l>*     tuple_sum(Angles, Sum)</l>
<l>*     create_funct_1d_array(Angles, FAngles)</l>
<l>*     derivate_funct_1d(FAngles, 'first', FAnglesDerivative1)</l>
<l>*     derivate_funct_1d(FAngles, 'second', FAnglesDerivative2)</l>
<c></c>
<l>*     gen_region_points(RR, RowsInoDB, ColsInoDB)</l>
<c></c>
<l>    get_grayval(ImDisplacement, RowsInoDB, ColsInoDB, Displacement1)</l>
<c>    </c>
<l>    Displacement:=Displacement1-127</l>
<c></c>
<l>    tuple_length(Displacement, n)</l>
<c>        ********</c>
<l>*     gen_empty_obj(PP)</l>
<l>*     gen_empty_obj(Pt)</l>
<l>*     t:=0</l>
<l>*     for k:=0 to n-1 by 1</l>
<l>*         t:=t+1</l>
<l>*         gen_region_points(P, RowsInoDB[k], ColsInoDB[k])</l>
<l>*         concat_obj(Pt, P, Pt) </l>
<l>*         if(t&gt;=10000)</l>
<l>*            concat_obj(PP, Pt, PP) </l>
<l>*            gen_empty_obj(Pt)</l>
<l>*            t:=0</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop()</l>
<c>    *********</c>
<l>    tuple_select_range(Displacement, n-50, n-1, DisplacementEnd)</l>
<l>    tuple_insert(Displacement, 0, DisplacementEnd, DisplacementExt)</l>
<c>    </c>
<l>    Def:=[0,0,0,0,0]</l>
<l>*     FilterFloatMedNFWM(DisplacementExt, sz, 5, 5, Defext, Wfilt, Wch)</l>
<l>    FilterFloatMedNFWM(DisplacementExt, sz, 5, 5, Defext, Wfilt, Wch)</l>
<l>    tuple_max(DisplacementExt, dimax)</l>
<l>    tuple_min(DisplacementExt, dimin)</l>
<l>    tuple_max(Defext, dmax)</l>
<l>*     tuple_sort_index(Defext, Indices)</l>
<l>*     tuple_inverse(Indices, Inverted)</l>
<l>*     gen_circle(CC, RowsInoDB[Inverted[0]], ColsInoDB[Inverted[0]], 20)</l>
<l>*     tuple_min(Defext, dmin)</l>
<l>*     read_tuple('hv_Displacement.tup', hv_Displacement2)</l>
<l>*     Dif:=Displacement-hv_Displacement2</l>
<l>    read_tuple('hv_Displacement.tup', hv_Displacement)</l>
<l>    FilterFloatMedNFWM(hv_Displacement, sz, 5, 5, Defexth, Wfilth, Wchh)</l>
<l>    tuple_length(Defext, next)</l>
<l>    tuple_select_range(Defext, 50,  next-1, Def)  </l>
<l>    if(dmax &gt; 0)</l>
<l>         tuple_select_mask(Def,Def, Selected)</l>
<l>         tuple_select_mask(RowsInoDB,Def, SelectedR)</l>
<l>         tuple_select_mask(ColsInoDB,Def, SelectedC)</l>
<l>         gen_region_points(RP, SelectedR, SelectedC)</l>
<l>         tuple_length(SelectedC, n)</l>
<l>         tuple_gen_const(n, 10.5, RadC)</l>
<l>         gen_circle(Circle, SelectedR, SelectedC, RadC)</l>
<l>         dev_display(RInoDB)</l>
<l>         dev_display(Circle)</l>
<l>        stop()</l>
<l>    endif</l>
<l>     stop()</l>
<l>*     if(dmin &lt; 0)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>***** removed for C++ **</c>
<l>    VectorCY.insert(j,RowsInoDB)</l>
<l>    VectorCX.insert(j,ColsInoDB)</l>
<c>******</c>
<l>endfor</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<l>gen_region_points(RegionnoB, Cy, Cx)</l>
<l>convert_vector_to_tuple(VectorCX, Cx)</l>
<l>convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AbsRelDefContours2">
<parameters>
<parameter id="Cx"/>
<parameter id="Cy"/>
<parameter id="Def"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageCLC"/>
<parameter id="RegionInoD"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
</parameters>
</docu>
</procedure>
<procedure name="AbsRelDefContours2_COPY_1">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* AbsRelDefContoursT - test version</c>
<l>set_system ('neighborhood', 4)</l>
<l>* boundary (RegionInoD, RegionInoDB, 'outer')</l>
<c>* ** pattern regions</c>
<l>connection (RegionInoD, RegionsInoD)</l>
<l>count_obj (RegionsInoD, nInoD)</l>
<l>complement (RegionInoD, RegionInoDC)</l>
<l>dilation_circle (RegionInoDC, RegionInoDCd, 1)</l>
<c>* ** space regions</c>
<l>connection (RegionInoDCd, RegionsInoDC)</l>
<l>count_obj (RegionsInoDC, nInoDC)</l>
<c>* ** combined pattern and space</c>
<l>concat_obj (RegionsInoD, RegionsInoDC, RegionsInoDA)</l>
<l>count_obj (RegionsInoDA, nInoDA)</l>
<c>* ** removed for C++ **</c>
<c></c>
<l>VectorCX := {1}</l>
<l>VectorCX.clear()</l>
<l>VectorCY := {1}</l>
<l>VectorCY.clear()</l>
<c>* ****</c>
<l>sz := 41</l>
<c></c>
<l>for j := 2 to nInoD by 1</l>
<l>*     j := 1201</l>
<l>    select_obj (RegionsInoDA, RInoDB, j)</l>
<l>    move_region (RInoDB, RInoDB, -7, -7)</l>
<l>    get_region_contour (RInoDB, RowsInoDB, ColsInoDB)</l>
<l>    gen_contour_region_xld (RInoDB, Contour, 'center')</l>
<l>    smooth_contours_xld (Contour, SmoothedoContur, 15)</l>
<l>    segment_contours_xld (SmoothedoContur, ContoursSplit, 'lines_circles', 1, 1, 5)</l>
<l>    fit_circle_contour_xld (ContoursSplit, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>    gen_region_points (Regions, Row, Column)</l>
<l>    get_contour_angle_xld (Contour, 'rel', 'range', 11, Angles)</l>
<l>    tuple_sum (Angles, Sum)</l>
<l>    create_funct_1d_array (Angles, FAngles)</l>
<l>    derivate_funct_1d (FAngles, 'first', FAnglesDerivative1)</l>
<l>    derivate_funct_1d (FAngles, 'second', FAnglesDerivative2)</l>
<c></c>
<l>    gen_region_points (RR, RowsInoDB, ColsInoDB)</l>
<c></c>
<l>    get_grayval (ImDisplacement, RowsInoDB, ColsInoDB, Displacement1)</l>
<l>    Displacement := Displacement1-127</l>
<c></c>
<l>    Def := [0,0,0,0,0]</l>
<l>* FilterFloatMedNFWM (Displacement, sz, 4, 4, Def, Wfilt, Wch)</l>
<l>    tuple_max (Def, dmax)</l>
<l>    tuple_min (Def, dmin)</l>
<c></c>
<l>    if (dmax &gt; 0)</l>
<l>        tuple_select_mask (Def, Def, Selected)</l>
<l>        tuple_select_mask (RowsInoDB, Def, SelectedR)</l>
<l>        tuple_select_mask (ColsInoDB, Def, SelectedC)</l>
<l>        tuple_length (SelectedC, n)</l>
<l>        tuple_gen_const (n, 10.5, RadC)</l>
<l>        gen_circle (Circle, SelectedR, SelectedC, RadC)</l>
<l>        stop ()</l>
<l>    endif</l>
<c></c>
<l>    if (dmin &lt; 0)</l>
<l>        stop ()</l>
<l>    endif</l>
<c>    * **** removed for C++ **</c>
<l>    VectorCY.insert(j,RowsInoDB)</l>
<l>    VectorCX.insert(j,ColsInoDB)</l>
<c>    * *****</c>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorCX, Cx)</l>
<l>convert_vector_to_tuple (VectorCY, Cy)</l>
<l>gen_region_points (RegionnoB, Cy, Cx)</l>
<l>convert_vector_to_tuple (VectorCX, Cx)</l>
<l>convert_vector_to_tuple (VectorCY, Cy)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AbsRelDefContours2_COPY_1">
<parameters>
<parameter id="Cx"/>
<parameter id="Cy"/>
<parameter id="Def"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageCLC"/>
<parameter id="RegionInoD"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
</parameters>
</docu>
</procedure>
<procedure name="ViaHoles">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Rvia" base_type="iconic" dimension="0"/>
<par name="Rvias" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageVias" base_type="iconic" dimension="0"/>
<par name="RTvia" base_type="iconic" dimension="0"/>
<par name="RTviasi" base_type="iconic" dimension="0"/>
<par name="RTvias" base_type="iconic" dimension="0"/>
<par name="RTV" base_type="iconic" dimension="0"/>
<par name="PVG" base_type="iconic" dimension="0"/>
<par name="PVGs" base_type="iconic" dimension="0"/>
<par name="RegionFillUp" base_type="iconic" dimension="0"/>
<par name="RTviasH" base_type="iconic" dimension="0"/>
<par name="AllRns" base_type="iconic" dimension="0"/>
<par name="P" base_type="iconic" dimension="0"/>
<par name="Rns" base_type="iconic" dimension="0"/>
<par name="PVGr" base_type="iconic" dimension="0"/>
<par name="Rn" base_type="iconic" dimension="0"/>
<par name="RVR" base_type="iconic" dimension="0"/>
<par name="RegionDifference1" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="AreaRTV" base_type="ctrl" dimension="0"/>
<par name="RowsRTV" base_type="ctrl" dimension="0"/>
<par name="ColsRTV" base_type="ctrl" dimension="0"/>
<par name="NumConnected" base_type="ctrl" dimension="0"/>
<par name="NumHoles" base_type="ctrl" dimension="0"/>
<par name="Area2" base_type="ctrl" dimension="0"/>
<par name="RowV" base_type="ctrl" dimension="0"/>
<par name="ColV" base_type="ctrl" dimension="0"/>
<par name="nV" base_type="ctrl" dimension="0"/>
<par name="AreaVH" base_type="ctrl" dimension="0"/>
<par name="RowVH" base_type="ctrl" dimension="0"/>
<par name="ColVH" base_type="ctrl" dimension="0"/>
<par name="AreaV" base_type="ctrl" dimension="0"/>
<par name="nofn" base_type="ctrl" dimension="0"/>
<par name="AllRowsn" base_type="ctrl" dimension="0"/>
<par name="AllColsn" base_type="ctrl" dimension="0"/>
<par name="AllRowsnt" base_type="ctrl" dimension="0"/>
<par name="AllColsnt" base_type="ctrl" dimension="0"/>
<par name="j" base_type="ctrl" dimension="0"/>
<par name="jj" base_type="ctrl" dimension="0"/>
<par name="MinDistance" base_type="ctrl" dimension="0"/>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="Row1t" base_type="ctrl" dimension="0"/>
<par name="Column1t" base_type="ctrl" dimension="0"/>
<par name="Row2t" base_type="ctrl" dimension="0"/>
<par name="Column2t" base_type="ctrl" dimension="0"/>
<par name="a" base_type="ctrl" dimension="0"/>
<par name="r" base_type="ctrl" dimension="0"/>
<par name="c" base_type="ctrl" dimension="0"/>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Cols" base_type="ctrl" dimension="0"/>
<par name="Rowst" base_type="ctrl" dimension="0"/>
<par name="Colst" base_type="ctrl" dimension="0"/>
<par name="HomMat2D1" base_type="ctrl" dimension="0"/>
<par name="cov" base_type="ctrl" dimension="0"/>
<par name="Qx" base_type="ctrl" dimension="0"/>
<par name="Qy" base_type="ctrl" dimension="0"/>
<par name="Qw" base_type="ctrl" dimension="0"/>
<par name="ct" base_type="ctrl" dimension="0"/>
<par name="rt" base_type="ctrl" dimension="0"/>
<par name="DRow" base_type="ctrl" dimension="0"/>
<par name="DCol" base_type="ctrl" dimension="0"/>
<par name="DD" base_type="ctrl" dimension="0"/>
<par name="vhc" base_type="ctrl" dimension="0"/>
<par name="Vh" base_type="ctrl" dimension="0"/>
<par name="ColsV" base_type="ctrl" dimension="0"/>
<par name="Covariance" base_type="ctrl" dimension="0"/>
<par name="dc" base_type="ctrl" dimension="0"/>
<par name="dr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******* VIAs</c>
<c>*** in Teaching ****</c>
<c>**** reference radius</c>
<l>refrad:=500</l>
<l>viathr:=115</l>
<l>viamin:=50</l>
<l>viamax:=130</l>
<l>viadisplmax:=5</l>
<l>connection(Rvia, Rvias)</l>
<l>count_obj(Rvias, nRvias)</l>
<l>area_center(Rvias, Av, Rv, Cv)</l>
<c>**** VIA CAD points region</c>
<l>gen_region_points(Pv, Rv, Cv)</l>
<l>connection(Pv, Pvs)</l>
<l>tuple_gen_const(nRvias, refrad, RofN)</l>
<c>*** circles of reference</c>
<l>area_center(Rvias, AC, RC, CC)</l>
<l>gen_circle(CircleofN, RC, CC, RofN)</l>
<c>**** saving VIA number as image</c>
<l>* gen_image_proto(Im, ImCnum, 0)</l>
<l>get_image_size(Im, Width, Height)</l>
<l>gen_image_const(ImCnum, 'uint2', Width, Height)</l>
<l>for j:=1 to nRvias by 1</l>
<l>    select_obj(Pvs, P, j)</l>
<l>    get_region_points(P, r, c)</l>
<l>    set_grayval(ImCnum, r, c, j)</l>
<l>endfor</l>
<l>stop()</l>
<c>*** </c>
<c>**** saving reference points</c>
<l>TAddrVia:=0</l>
<l>TNumsVia:=[]</l>
<l>TNumRef:=[]</l>
<l>addr:=0</l>
<l>for j:=1 to nRvias by 1</l>
<l>    select_obj(CircleofN, C, j)</l>
<l>    select_obj(Pvs, P, j)</l>
<l>    intersection(C, Pv, PvC)</l>
<l>    connection(PvC, PvCs)</l>
<l>    count_obj(PvCs, nPvCs)</l>
<l>    difference(PvCs, P, PvCs1)</l>
<l>    for jj:=1 to nPvCs by 1</l>
<l>        select_obj(PvCs1, P1, jj)</l>
<l>        get_region_points(P1, r, c)</l>
<l>        get_grayval(ImCnum, r, c, vianum)</l>
<l>        tuple_concat(TNumsVia, vianum,TNumsVia)</l>
<l>    endfor</l>
<l>    tuple_concat(TNumRef, nPvCs-1,TNumRef)</l>
<l>    addr:=addr+nPvCs-1</l>
<l>    tuple_concat(TAddrVia, addr,TAddrVia)</l>
<l>*     if(j==200)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>endfor</l>
<l>stop()</l>
<c>*****************************</c>
<c>*** finding VIA regions *****</c>
<l>* move_region(Rvia, Rviam, 7, -8)</l>
<l>dilation_circle(Rvias, Rviasd, 8.5)</l>
<l>union1(Rviasd, Rviad)</l>
<l>* gen_image_const(Image, 'byte', 512, 512)</l>
<l>gen_image_proto(Im, Img, viathr+20)</l>
<c></c>
<l>* reduce_domain(Im, Rviad, Img)</l>
<c></c>
<l>reduce_domain(Im, Rviad, ImageVias)</l>
<l>overpaint_gray(Img, ImageVias)</l>
<l>threshold(Img, RTvia, viathr, 255)</l>
<c></c>
<l>gen_empty_obj(VIAs)</l>
<l>for j:=1 to nRvias by 1</l>
<l>*     j:=103</l>
<l>    select_obj(Rviasd, Circ, j)</l>
<l>    intersection(Circ, RTvia, RegionIntersection)</l>
<l>    connect_and_holes(RegionIntersection, NumConnected1, NumHoles1)</l>
<l>*     if(NumConnected1!=1)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(NumHoles1!=1)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    fill_up(RegionIntersection, RegionFillUp)</l>
<l>    difference (RegionFillUp, RegionIntersection, RegionHole)</l>
<l>    connection(RegionHole, RegionHoles)</l>
<l>    count_obj(RegionHoles, nholes)</l>
<l>    if(nholes &gt; 1)</l>
<l>        area_center(RegionHoles, Area, Row, Column)</l>
<l>        select_obj(RegionHoles, Hole, 1)</l>
<l>        bh:=0</l>
<l>        for jj:=2 to nholes by 1</l>
<l>            select_obj(RegionHoles, Rh, jj)</l>
<l>            if( Area[jj-1] &gt; Area[bh])</l>
<l>                Hole:=Rh</l>
<l>                bh:=jj-1</l>
<l>            endif</l>
<l>        endfor</l>
<l>        concat_obj(VIAs, Hole, VIAs)</l>
<l>    else</l>
<l>        concat_obj(VIAs, RegionHole, VIAs)</l>
<l>    endif</l>
<l>*     if(j==100)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>endfor</l>
<l>count_obj(VIAs, nVIAs)</l>
<c></c>
<l>select_obj(Rvias, Rs, 121)</l>
<l>select_obj(VIAs, Vs, 121)</l>
<c></c>
<c></c>
<l>area_center(VIAs, AV, RV, CV)</l>
<l>DX:=CC-CV</l>
<l>DY:=RC-RV</l>
<l>tuple_mean(AV, avmean)</l>
<l>tuple_deviation(AV, avdev)</l>
<l>stop()</l>
<c>**** displacement checking cycle</c>
<l>for j:=1 to nRvias by 1</l>
<c>    </c>
<l>    refnum:=TNumRef[j-1]</l>
<l>    if(refnum&lt;2)</l>
<l>        continue</l>
<l>    endif</l>
<l>    refaddr:=TAddrVia[j-1]</l>
<l>    tuple_select_range(TNumsVia, refaddr, refaddr+refnum-1, Selected)</l>
<l>*     gen_empty_obj(VIAsels)</l>
<l>    select_obj(VIAs, VIAsels, Selected)</l>
<l>    area_center(VIAsels, Ar, Row, Column)</l>
<l>    select_obj(Rvias, Rviasels, Selected)</l>
<l>    area_center(Rviasels, ArCAD, RowCAD, ColumnCAD)</l>
<l>    DifR:=Row - RowCAD</l>
<l>    DifC:=Column - ColumnCAD</l>
<l>    tuple_mean( DifR, meandifR)</l>
<l>    tuple_mean( DifC, meandifC)</l>
<c>    </c>
<l>    select_obj(VIAs, VIA, j)</l>
<l>    area_center(VIA, ArV, RowV, ColumnV)</l>
<l>    select_obj(Rvias, Rvia, j)</l>
<l>    area_center(Rvia, Arv, Rowv, Columnv)</l>
<l>    Difr:=RowV-Rowv</l>
<l>    Difc:=ColumnV-Columnv</l>
<c>    </c>
<l>    distance_pp(Difr, Difc, meandifR, meandifC, viadispl)</l>
<l>*     for jj:=1 to refnum by 1</l>
<c>        </c>
<l>*     endfor</l>
<l>endfor</l>
<c></c>
<l>* tuple_gen_const(nRvias, 500, RofN)</l>
<l>* gen_circle(CircleofN, RC, CC, RofN)</l>
<l>stop()</l>
<c>***********************************************</c>
<l>threshold(ImageVias, RTvia, 115, 255)</l>
<l>connection(RTvia, RTviasi)</l>
<l>select_shape(RTviasi,RTvias,'area', 'and', 20, 99999)</l>
<l>area_center(RTvias, AreaRTV, RowsRTV, ColsRTV)</l>
<l>gen_region_points(RTV, RowsRTV, ColsRTV)</l>
<l>* area_holes(RTvias, Area1)</l>
<l>connect_and_holes(RTvias, NumConnected, NumHoles)</l>
<l>area_center(Rvias, Area2, RowV, ColV)</l>
<l>gen_region_points(PVG, RowV, ColV)</l>
<l>connection(PVG, PVGs)</l>
<l>count_obj(PVGs, nV)</l>
<c>*** Finding neighbours</c>
<c>* number of neighbours</c>
<l>fill_up(RTvias, RegionFillUp)</l>
<l>difference(RegionFillUp, RTvias, RTviasH)</l>
<l>count_obj(RTviasH, nRTviasH)</l>
<l>area_center(RTviasH, a, r, c)</l>
<l>stop()</l>
<l>area_center(RTviasH, AreaVH, RowVH, ColVH)</l>
<l>area_center(Rvias, AreaV, RowV, ColV)</l>
<l>nofn:=8</l>
<l>AllRowsn:=[]</l>
<l>AllColsn:=[]</l>
<l>AllRowsnt:=[]</l>
<l>AllColsnt:=[]</l>
<l>gen_empty_obj(AllRns)</l>
<l>for j:=1 to nV by 1</l>
<l>    select_obj(PVGs, P, j)</l>
<l>    gen_empty_obj(Rns)</l>
<l>    for jj:=1 to nofn by 1</l>
<l>        difference(PVG, P, PVGr)</l>
<l>        distance_rr_min(P, PVGr, MinDistance, Row1, Column1, Row2, Column2)</l>
<l>        distance_rr_min(P, RTV, MinDistance, Row1t, Column1t, Row2t, Column2t)</l>
<l>        gen_region_points(Rn, Row2, Column2)</l>
<l>        tuple_concat(AllRowsn,Row2, AllRowsn)</l>
<l>        tuple_concat(AllColsn,Column2, AllColsn)</l>
<l>        concat_obj(Rns, Rn, Rns)</l>
<l>        tuple_concat(AllRowsnt,Row2t, AllRowsnt)</l>
<l>        tuple_concat(AllColsnt,Column2t, AllColsnt)</l>
<l>    endfor</l>
<l>    concat_obj(AllRns, Rns, AllRns)</l>
<l>endfor</l>
<l>stop()</l>
<c>** finding deviation</c>
<l>for j:=1 to nV by 1</l>
<l>    select_obj(RTvias, RVR, j)</l>
<l>    area_center(RVR, a, r, c)</l>
<l>    tuple_select_range(AllRowsn, (j-1)*nofn, j*nofn, Rows)</l>
<l>    tuple_select_range(AllColsn, (j-1)*nofn, j*nofn, Cols)</l>
<l>    tuple_select_range(AllRowsnt, (j-1)*nofn, j*nofn, Rowst)</l>
<l>    tuple_select_range(AllColsnt, (j-1)*nofn, j*nofn, Colst)</l>
<l>    vector_to_proj_hom_mat2d(Cols, Rows, Colst, Rowst, 'normalized_dlt', [], [], [], [], [], [], HomMat2D1, cov)</l>
<l>    projective_trans_point_2d(HomMat2D1, c, r, 1, Qx, Qy, Qw)</l>
<l>    ct:= Qx/Qw</l>
<l>    rt:=Qy/Qw</l>
<l>endfor</l>
<c></c>
<c></c>
<l>DRow:=RowVH-RowV</l>
<l>DCol:=ColVH-ColV</l>
<l>DD:=sqrt(DRow*DRow+DCol*DCol)</l>
<c></c>
<l>vhc:=547</l>
<l>Vh:=[532,543,562,550]</l>
<l>ColsV:=ColV[Vh]</l>
<l>vector_to_proj_hom_mat2d(ColV[Vh], RowV[Vh], ColVH[Vh], RowVH[Vh], 'normalized_dlt', [], [], [], [], [], [], HomMat2D1, Covariance)</l>
<l>r:=RowVH[vhc]</l>
<l>c:=ColVH[vhc]</l>
<l>projective_trans_point_2d(HomMat2D1, c, r, 1, Qx, Qy, Qw)</l>
<l>ct:= Qx/Qw</l>
<l>rt:=Qy/Qw</l>
<l>dc:=ct-ColV[vhc]</l>
<l>dr:=rt-RowV[vhc]</l>
<l>return ()</l>
</body>
<docu id="ViaHoles">
<parameters>
<parameter id="AllColsn"/>
<parameter id="AllColsnt"/>
<parameter id="AllRns"/>
<parameter id="AllRowsn"/>
<parameter id="AllRowsnt"/>
<parameter id="Area2"/>
<parameter id="AreaRTV"/>
<parameter id="AreaV"/>
<parameter id="AreaVH"/>
<parameter id="ColV"/>
<parameter id="ColVH"/>
<parameter id="Cols"/>
<parameter id="ColsRTV"/>
<parameter id="ColsV"/>
<parameter id="Colst"/>
<parameter id="Column1"/>
<parameter id="Column1t"/>
<parameter id="Column2"/>
<parameter id="Column2t"/>
<parameter id="Covariance"/>
<parameter id="DCol"/>
<parameter id="DD"/>
<parameter id="DRow"/>
<parameter id="HomMat2D1"/>
<parameter id="Im"/>
<parameter id="ImageVias"/>
<parameter id="MinDistance"/>
<parameter id="NumConnected"/>
<parameter id="NumHoles"/>
<parameter id="P"/>
<parameter id="PVG"/>
<parameter id="PVGr"/>
<parameter id="PVGs"/>
<parameter id="Qw"/>
<parameter id="Qx"/>
<parameter id="Qy"/>
<parameter id="RTV"/>
<parameter id="RTvia"/>
<parameter id="RTvias"/>
<parameter id="RTviasH"/>
<parameter id="RTviasi"/>
<parameter id="RVR"/>
<parameter id="RegionDifference1"/>
<parameter id="RegionFillUp"/>
<parameter id="Rn"/>
<parameter id="Rns"/>
<parameter id="Row1"/>
<parameter id="Row1t"/>
<parameter id="Row2"/>
<parameter id="Row2t"/>
<parameter id="RowV"/>
<parameter id="RowVH"/>
<parameter id="Rows"/>
<parameter id="RowsRTV"/>
<parameter id="Rowst"/>
<parameter id="Rvia"/>
<parameter id="Rvias"/>
<parameter id="Vh"/>
<parameter id="a"/>
<parameter id="c"/>
<parameter id="cov"/>
<parameter id="ct"/>
<parameter id="dc"/>
<parameter id="dr"/>
<parameter id="j"/>
<parameter id="jj"/>
<parameter id="nV"/>
<parameter id="nofn"/>
<parameter id="r"/>
<parameter id="rt"/>
<parameter id="vhc"/>
</parameters>
</docu>
</procedure>
<procedure name="NFWMfarfromFWM">
<interface>
<io>
<par name="Regsmbnc" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Rclfwm" base_type="iconic" dimension="0"/>
<par name="Rfarfwm" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dfwm" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="clfwm" base_type="ctrl" dimension="0"/>
<par name="farfwm" base_type="ctrl" dimension="0"/>
<par name="Clnum" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** </c>
<l>count_obj(Regsmbnc, nRegsmbnc)</l>
<l>clfwm := 0</l>
<l>clfwnm:=0</l>
<l>farfwm:=0</l>
<l>gen_empty_obj(Rclfwm)</l>
<l>gen_empty_obj(Rfarfwm)</l>
<l>Clnum:=[]</l>
<l>for j:=1 to nRegsmbnc by 1</l>
<l>*     if(j==113)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(Regsmbnc, ObjectSelected1, j)</l>
<l>    area_center(ObjectSelected1, ao, ro, co)</l>
<l>    dilation_circle(ObjectSelected1, ObjectSelected1d, dfwm)</l>
<l>    intersection(ObjectSelected1d, SkeletonFWM, RegionIntersection1)</l>
<l>    area_center(RegionIntersection1, a, r, c)</l>
<l>*     distance_pr(SkeletonFWM, r, c, dist, DistanceMax1)</l>
<l>*         distance_rr_min(SkeletonFWM,ObjectSelected1,  dist, Row11, Column11, Row21, Column21)</l>
<l>*         distance_rr_min_dil(ObjectSelected1, SkeletonFWM, dist)</l>
<l>*     if(dist&gt;20)</l>
<l>    if(a&gt;0)</l>
<l>       clfwm:=clfwm+1</l>
<l>*        gen_circle(Cmbpfwm, ro, co, 10)</l>
<l>       concat_obj(Rclfwm, ObjectSelected1, Rclfwm)</l>
<l>       tuple_concat(Clnum, j, Clnum)</l>
<l>    else</l>
<l>        farfwm:=farfwm+1</l>
<l>        concat_obj(Rfarfwm, ObjectSelected1, Rfarfwm)</l>
<l>    endif</l>
<l>*     if(dist&gt;20)</l>
<l>* clfwm := clfwm+1</l>
<l>*     endif</l>
<l>endfor</l>
<l>* nfwm := nRegsmbnc-farfwm</l>
<l>return ()</l>
</body>
<docu id="NFWMfarfromFWM">
<parameters>
<parameter id="Clnum"/>
<parameter id="Rclfwm"/>
<parameter id="Regsmbnc"/>
<parameter id="Rfarfwm"/>
<parameter id="SkeletonFWM"/>
<parameter id="clfwm"/>
<parameter id="dfwm"/>
<parameter id="farfwm"/>
</parameters>
</docu>
</procedure>
<procedure name="ChecknIRB">
<interface>
<io>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Sksel" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="nGND" base_type="ctrl" dimension="0"/>
<par name="stseq" base_type="ctrl" dimension="0"/>
<par name="overf" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
<par name="nIRB" base_type="ctrl" dimension="0"/>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="jFWM" base_type="ctrl" dimension="0"/>
<par name="a" base_type="ctrl" dimension="0"/>
<par name="Rse" base_type="ctrl" dimension="0"/>
<par name="Cse" base_type="ctrl" dimension="0"/>
<par name="nse" base_type="ctrl" dimension="0"/>
<par name="vIR" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>count_obj(RegionsGND, nGND)</l>
<l>stseq:=nGND+1</l>
<l>overf:=255-stseq</l>
<l>i:=1744</l>
<l>nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>for jFWM:=1 to nFWM by 1</l>
<l>    select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     area_center(Sksel, a, r, c )</l>
<l>    get_region_points(Sksel, Rse, Cse)</l>
<l>    tuple_length(Rse, nse)</l>
<l>    if(nse&gt;0)</l>
<l>        get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>        nIRB:=jFWM%overf+stseq</l>
<l>        if(nIRB!=vIR)</l>
<l>            stop()</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="ChecknIRB">
<parameters>
<parameter id="Cse"/>
<parameter id="ImageIR"/>
<parameter id="RegionsGND"/>
<parameter id="Rse"/>
<parameter id="SkeletonsFWM"/>
<parameter id="Sksel"/>
<parameter id="a"/>
<parameter id="i"/>
<parameter id="jFWM"/>
<parameter id="nFWM"/>
<parameter id="nGND"/>
<parameter id="nIRB"/>
<parameter id="nse"/>
<parameter id="overf"/>
<parameter id="stseq"/>
<parameter id="vIR"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortFU3">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nSh" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>set_system('neighborhood', 8)</l>
<l>difference (SkeletonGS, RegionIS, RegionSkGSIS)</l>
<l>connection (RegionSkGSIS, RegionsSkGSIS)</l>
<l>area_center (RegionsSkGSIS, Area, RowShC, ColShC)</l>
<l>tuple_length (RowShC, nShC)</l>
<l>nSh := 0</l>
<l>gen_empty_obj (RegionsSh)</l>
<l>for j := 1 to nShC by 1</l>
<l>    if(j==1561)</l>
<l>        stop()</l>
<l>    endif</l>
<l>    select_obj (RegionsSkGSIS, RegionSel, j)</l>
<l>    get_region_points (RegionSel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>    get_grayval (DirImageS, row, col, dirShC)</l>
<l>    get_grayval (WidthImageS, row, col, widthShC)</l>
<c></c>
<l>*     angsShC := dirShC*3.1415926/256.0</l>
<l>*     region_features (RegionSel, 'rect2_len1', l1)</l>
<l>*     region_features (RegionSel, 'rect2_len2', l2)</l>
<l>*     region_features(RegionSel, 'rect2_phi', phi)</l>
<c>    </c>
<l>    smallest_rectangle2(RegionSel, Row, Column, Phi, Length1, Length2)</l>
<c>    </c>
<l>*     tuple_max2 (widthShC*coef/2, l1+wgap*2, recw)</l>
<l>*     gen_rectangle2 (Rect, row, col, angsShC, widthShC*coef/2, recw)</l>
<l>    gen_rectangle2 (Rect, Row, Column, Phi, Length1+wgap*1, widthShC*coef/2+wgap)</l>
<l>*     gen_rectangle2 (Rect, Row, Column, Phi, Length1+wgap*2, Length2+wgap*2)</l>
<l>    intersection (Rect, RegionIS, RegionISR)</l>
<l>    connection (RegionISR, RegionsIRSCon)</l>
<l>    count_obj (RegionsIRSCon, nR)</l>
<l>    intersection (Rect, SkeletonGS, SkelGSR)</l>
<l>    connection (SkelGSR, SkelGSRCon)</l>
<l>    count_obj (SkelGSRCon, nS)</l>
<c></c>
<l>    for n := 1 to nS by 1</l>
<l>        select_obj (SkelGSRCon, SkelS, n)</l>
<l>        numint := 0</l>
<l>        gen_empty_obj (Reg)</l>
<l>        for nn := 1 to nR by 1</l>
<l>            select_obj (RegionsIRSCon, RegR, nn)</l>
<l>            intersection (SkelS, RegR, RInt)</l>
<l>            area_center (RInt, a, r, c)</l>
<l>            if (a&gt;0)</l>
<l>                numint := numint+1</l>
<l>                concat_obj (Reg, RegR, Reg)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (numint &gt; 1)</l>
<c>            *** trying to verify</c>
<l>*             expand_region(RegionSel, RegionIS,RegionExpanded, widthShC*3, 'image')</l>
<l>*             dilation_circle(RegionExpanded, RegionDilation, 1.5)</l>
<l>*             difference(RegionDilation, RegionIS, RegionIntersection)</l>
<c>            *** trying to verify end</c>
<l>            nSh := nSh+1</l>
<l>*             if(nSh==23)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>            difference (Rect, Reg, Regd)</l>
<c></c>
<l>            concat_obj (RegionsSh, Regd, RegionsSh)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortFU3">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegionIS"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
<parameter id="coef"/>
<parameter id="nSh"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="FindFWMProcArea">
<interface>
<oo>
<par name="RegionFWMPA" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="PInt1y_tuple" base_type="ctrl" dimension="0"/>
<par name="PInt1x_tuple" base_type="ctrl" dimension="0"/>
<par name="PInt2y_tuple" base_type="ctrl" dimension="0"/>
<par name="PInt2x_tuple" base_type="ctrl" dimension="0"/>
<par name="fwmpatype" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_region_points(RIntTup1, PInt1y_tuple, PInt1x_tuple)</l>
<l>gen_region_points(RIntTup2, PInt2y_tuple, PInt2x_tuple)</l>
<l>if(fwmpatype==1)</l>
<c>    **** finding FWM processed area Type 1</c>
<l>    gen_region_line(RegionLines, PInt1y_tuple, PInt1x_tuple, PInt2y_tuple, PInt2x_tuple)</l>
<l>    union1(RegionLines, RegionUnion1)</l>
<l>*     closing_circle(RegionUnion1, RegionFWMPA, 1.5)</l>
<l>    dilation_circle(RegionUnion1, RegionFWMPA, 1.5)</l>
<l>else</l>
<c>    **** finding FWM processed area Type 2</c>
<l>    union2(RIntTup1, RIntTup2, RIntTup)</l>
<l>    PInt3y_tuple:=(PInt1y_tuple+PInt2y_tuple)/2</l>
<l>    PInt3x_tuple:=(PInt1x_tuple+PInt2x_tuple)/2</l>
<l>    gen_region_points(RIntTup3, PInt3y_tuple, PInt3x_tuple)</l>
<l>    union2(RIntTup, RIntTup3, RIntTup)</l>
<l>    PInt4y_tuple:=(PInt1y_tuple+PInt3y_tuple)/2</l>
<l>    PInt4x_tuple:=(PInt1x_tuple+PInt3x_tuple)/2</l>
<l>    gen_region_points(RIntTup4, PInt4y_tuple, PInt4x_tuple)</l>
<l>    union2(RIntTup, RIntTup4, RIntTup)</l>
<l>    PInt5y_tuple:=(PInt2y_tuple+PInt3y_tuple)/2</l>
<l>    PInt5x_tuple:=(PInt2x_tuple+PInt3x_tuple)/2</l>
<l>    gen_region_points(RIntTup5, PInt5y_tuple, PInt5x_tuple)</l>
<l>    union2(RIntTup, RIntTup5, RIntTup) </l>
<c>    ** 0.45 sec</c>
<l>    closing_circle(RIntTup,RegionFWMPA, 3.5)</l>
<c>    ** 0.45 sec</c>
<l>*     dilation_circle(RIntTup,RegionFWMPA, 2.5)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="FindFWMProcArea">
<parameters>
<parameter id="PInt1x_tuple"/>
<parameter id="PInt1y_tuple"/>
<parameter id="PInt2x_tuple"/>
<parameter id="PInt2y_tuple"/>
<parameter id="RegionFWMPA"/>
<parameter id="fwmpatype"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachVIA">
<interface>
<io>
<par name="Rvias" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="refrad" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TAddrVia" base_type="ctrl" dimension="0"/>
<par name="TNumsVia" base_type="ctrl" dimension="0"/>
<par name="TNumRef" base_type="ctrl" dimension="0"/>
<par name="nRvias" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>* connection (Rvias, Rvias)</l>
<l>count_obj(Rvias, nRvias)</l>
<l>area_center(Rvias, Av, Rv, Cv)</l>
<c>**** VIA CAD points region</c>
<l>gen_region_points(Pv, Rv, Cv)</l>
<l>connection(Pv, Pvs)</l>
<l>tuple_gen_const(nRvias, refrad, RofN)</l>
<c>*** circles of reference</c>
<l>area_center(Rvias, AC, RowsC, ColsC)</l>
<l>gen_circle(CircleofN, RowsC, ColsC, RofN)</l>
<c>**** saving VIA number as image</c>
<l>* gen_image_proto(Im, ImCnum, 0)</l>
<l>get_image_size(Im, Width, Height)</l>
<l>gen_image_const(ImCnum, 'uint2', Width, Height)</l>
<l>for j:=1 to nRvias by 1</l>
<l>    select_obj(Pvs, P, j)</l>
<l>    get_region_points(P, r, c)</l>
<l>    set_grayval(ImCnum, r, c, j)</l>
<l>endfor</l>
<l>* stop()</l>
<c>*** </c>
<c>**** saving reference points</c>
<l>TAddrVia:=0</l>
<l>TNumsVia:=[]</l>
<l>TNumRef:=[]</l>
<l>addr:=0</l>
<l>for j:=1 to nRvias by 1</l>
<l>    select_obj(CircleofN, C, j)</l>
<l>    select_obj(Pvs, P, j)</l>
<l>    intersection(C, Pv, PvC)</l>
<l>    connection(PvC, PvCs)</l>
<l>    count_obj(PvCs, nPvCs)</l>
<l>    difference(PvCs, P, PvCs1)</l>
<l>    for jj:=1 to nPvCs by 1</l>
<l>        select_obj(PvCs1, P1, jj)</l>
<l>        get_region_points(P1, r, c)</l>
<l>get_grayval (ImCnum, r, c, nv)</l>
<l>tuple_concat (TNumsVia, nv, TNumsVia)</l>
<l>    endfor</l>
<l>    tuple_concat(TNumRef, nPvCs-1,TNumRef)</l>
<l>    addr:=addr+nPvCs-1</l>
<l>    tuple_concat(TAddrVia, addr,TAddrVia)</l>
<l>*     if(j==200)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>endfor</l>
<l>* stop()</l>
<l>return ()</l>
</body>
<docu id="TeachVIA">
<parameters>
<parameter id="Im"/>
<parameter id="Rvias"/>
<parameter id="TAddrVia"/>
<parameter id="TNumRef"/>
<parameter id="TNumsVia"/>
<parameter id="nRvias"/>
<parameter id="refrad"/>
</parameters>
</docu>
</procedure>
<procedure name="VIAFindandProc">
<interface>
<io>
<par name="Rvias" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="VIAs" base_type="iconic" dimension="0"/>
<par name="VIAlow" base_type="iconic" dimension="0"/>
<par name="VIAhi" base_type="iconic" dimension="0"/>
<par name="VIAdisplace" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="viathr" base_type="ctrl" dimension="0"/>
<par name="TNumRef" base_type="ctrl" dimension="0"/>
<par name="TAddrVia" base_type="ctrl" dimension="0"/>
<par name="TNumsVia" base_type="ctrl" dimension="0"/>
<par name="viamax" base_type="ctrl" dimension="0"/>
<par name="viamin" base_type="ctrl" dimension="0"/>
<par name="viadisplmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>* RviaOut := Rvia</l>
<c>*** finding and inspecting VIA regions *****</c>
<l>* move_region (RviaOut, Rviam, 7, -8)</l>
<l>count_obj(Rvias, nVias)</l>
<l>dilation_circle(Rvias, Rviasd, 9.5)</l>
<l>union1(Rviasd, Rviad)</l>
<l>* gen_image_const(Image, 'byte', 512, 512)</l>
<l>gen_image_proto(Im, Img, viathr+20)</l>
<c></c>
<l>* reduce_domain(Im, Rviad, Img)</l>
<c></c>
<l>reduce_domain(Im, Rviad, ImageVias)</l>
<l>overpaint_gray(Img, ImageVias)</l>
<l>threshold(Img, RTvia, viathr, 255)</l>
<c></c>
<l>gen_empty_obj(VIAs)</l>
<l>for j:=1 to nVias by 1</l>
<l>*     j:=103</l>
<l>    select_obj(Rviasd, Circ, j)</l>
<l>    intersection(Circ, RTvia, RegionIntersection)</l>
<l>    connect_and_holes(RegionIntersection, NumConnected1, NumHoles1)</l>
<l>*     if(NumConnected1!=1)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(NumHoles1!=1)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    fill_up(RegionIntersection, RegionFillUp)</l>
<l>    difference (RegionFillUp, RegionIntersection, RegionHole)</l>
<l>    connection(RegionHole, RegionHoles)</l>
<l>    count_obj(RegionHoles, nholes)</l>
<l>    if(nholes &gt; 1)</l>
<l>        area_center(RegionHoles, Area, Row, Column)</l>
<l>        select_obj(RegionHoles, Hole, 1)</l>
<l>        bh:=0</l>
<l>        for jj:=2 to nholes by 1</l>
<l>            select_obj(RegionHoles, Rh, jj)</l>
<l>            if( Area[jj-1] &gt; Area[bh])</l>
<l>                Hole:=Rh</l>
<l>                bh:=jj-1</l>
<l>            endif</l>
<l>        endfor</l>
<l>        concat_obj(VIAs, Hole, VIAs)</l>
<l>    else</l>
<l>        concat_obj(VIAs, RegionHole, VIAs)</l>
<l>    endif</l>
<l>*     if(j==100)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>endfor</l>
<l>* count_obj(VIAs, nVIAs)</l>
<c></c>
<l>* select_obj(Rvias, Rs, 121)</l>
<l>* select_obj(VIAs, Vs, 121)</l>
<c></c>
<c></c>
<l>* area_center(VIAs, AV, RV, CV)</l>
<l>* DX:=CC-CV</l>
<l>* DY:=RC-RV</l>
<l>* tuple_mean(AV, avmean)</l>
<l>* tuple_deviation(AV, avdev)</l>
<l>* stop()</l>
<l>gen_empty_obj(VIAlow)</l>
<l>gen_empty_obj(VIAhi)</l>
<l>gen_empty_obj (VIAdisplace)</l>
<c></c>
<c>**** displacement checking cycle</c>
<l>for j:=1 to nVias by 1</l>
<c>    </c>
<l>    refnum:=TNumRef[j-1]</l>
<l>    if(refnum&lt;2)</l>
<l>        continue</l>
<l>    endif</l>
<l>    refaddr:=TAddrVia[j-1]</l>
<l>    tuple_select_range(TNumsVia, refaddr, refaddr+refnum-1, Selected)</l>
<l>*     gen_empty_obj(VIAsels)</l>
<l>    select_obj(VIAs, VIAsels, Selected)</l>
<l>    area_center(VIAsels, Ar, Row, Column)</l>
<c>    </c>
<l>    select_obj(Rvias, Rviasels, Selected)</l>
<l>    area_center(Rviasels, ArCAD, RowCAD, ColumnCAD)</l>
<l>    DifR:=Row - RowCAD</l>
<l>    DifC:=Column - ColumnCAD</l>
<l>    tuple_mean( DifR, meandifR)</l>
<l>    tuple_mean( DifC, meandifC)</l>
<c>    </c>
<l>    select_obj(VIAs, VIA, j)</l>
<l>    area_center(VIA, ArV, RowV, ColumnV)</l>
<l>    if(ArV &gt; viamax)</l>
<l>        concat_obj(VIAhi, VIA, VIAhi)</l>
<l>    elseif(ArV &lt; viamin)</l>
<l>        concat_obj(VIAlow, VIA, VIAlow)</l>
<l>    endif</l>
<c>    </c>
<l>    select_obj (Rvias, RviaOut, j)</l>
<l>    area_center (RviaOut, Arv, Rowv, Columnv)</l>
<l>    Difr:=RowV-Rowv</l>
<l>    Difc:=ColumnV-Columnv</l>
<c>    </c>
<l>    distance_pp(Difr, Difc, meandifR, meandifC, viadispl)</l>
<l>    if(viadispl &gt; viadisplmax)</l>
<l>        concat_obj(VIAdisplace, VIA, VIAdisplace)</l>
<l>    endif</l>
<c>        </c>
<l>*     for jj:=1 to refnum by 1</l>
<c>        </c>
<l>*     endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="VIAFindandProc">
<parameters>
<parameter id="Im"/>
<parameter id="Rvias"/>
<parameter id="TAddrVia"/>
<parameter id="TNumRef"/>
<parameter id="TNumsVia"/>
<parameter id="VIAdisplace"/>
<parameter id="VIAhi"/>
<parameter id="VIAlow"/>
<parameter id="VIAs"/>
<parameter id="viadisplmax"/>
<parameter id="viamax"/>
<parameter id="viamin"/>
<parameter id="viathr"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain107">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL106 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<l>ROut := R</l>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>union2 (ROut, RecOvl, ROut)</l>
<c></c>
<l>difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>intersection (Gi, RC, G)</l>
<l>intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 99999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<c></c>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGi-1 by 1</l>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            VectorRM.insert(j, RowsGi[j])</l>
<l>            VectorCM.insert(j, ColsGi[j])</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>*     if ( w &gt;= (WminP[0]-wside) and w &lt;= (WminP[0]+wside)) </l>
<l>*         VectorRM.insert(j, RowsGi[j])</l>
<l>*         VectorCM.insert(j, ColsGi[j])</l>
<l>*     endif</l>
<l>*     if ( w &gt;= (WminP[1]-wside) and w &lt;= (WminP[1]+wside)) </l>
<l>*         VectorRM.insert(j, RowsGi[j])</l>
<l>*         VectorCM.insert(j, ColsGi[j])</l>
<l>*     endif</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsM)</l>
<l>convert_vector_to_tuple (VectorCM, ColsM)</l>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<l>* wsides := 2</l>
<l>RowsM := []</l>
<l>ColsM := 0</l>
<l>VectorRM := {1}</l>
<l>VectorRM.clear()</l>
<l>VectorCM := {1}</l>
<l>VectorCM.clear()</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>    w := WGSi[j]</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>            VectorRM.insert(j, RowsGSi[j])</l>
<l>            VectorCM.insert(j, ColsGSi[j])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>convert_vector_to_tuple (VectorCM, ColsMS)</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<c></c>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, cutendMSS, RadendMSS)</l>
<l>gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>union1(CMSSE, CMSSEu)</l>
<l>difference(RegionsmainSs, CMSSEu, RegionsmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c>* *************************************</c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain107">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildNonFWM8">
<interface>
<io>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="SkelN" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="nCGc" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="wgntype" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildNonFWM8 220726 ****</c>
<c>** corrected for -1</c>
<c>* 220111 fixed bug in inside/outside detection (lines 109-114)</c>
<l>RowN := []</l>
<l>ColN := []</l>
<l>PnumN := []</l>
<l>pnum:=[]</l>
<l>WN := []</l>
<c>*** address for each region (1 or several contours)</c>
<l>PaddrRN := 0</l>
<c>*** address for each contour</c>
<l>PaddrCN := []</l>
<c>**** number of contours per region</c>
<l>* PregN := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregCN := []</l>
<c>* * number of countours per region</c>
<l>PCinRnumN := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontRN := []</l>
<c>** current Region address</c>
<l>paddrR := 0</l>
<c>** current Contour address</c>
<l>paddrC := 0</l>
<l>pcontn := 1</l>
<l>indcn:=0</l>
<l>AngN:= []</l>
<l>PlenN:=[]</l>
<l>Y1N:=[]</l>
<l>X1N:=[]</l>
<l>Y2N:=[]</l>
<l>X2N:=[]</l>
<l>WGN:=[]</l>
<c></c>
<l>count_obj (BoundariesNFWM, nNonWFM)</l>
<c></c>
<l>gen_empty_obj(ContoursAll)</l>
<l>gen_empty_obj(RegsAll)</l>
<l>* count_obj (SkeletonsGThin, nSGThin)</l>
<l>pn:=0</l>
<l>for j := 1 to nNonWFM by 1</l>
<c>     **** non-FWM region ( full and only boundary regions)</c>
<l>    select_obj (RegionsNFWM, RCgc, j)</l>
<l>    area_center(RCgc, a, r, c)</l>
<l>*     if(j==100)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    if(a&gt;0)</l>
<l>        select_obj (BoundariesNFWM, RCgb, j)</l>
<l>        concat_obj(RegsAll, RCgb, RegsAll)</l>
<l>        skeleton(RCgc,SkeletonRCgc)</l>
<l>        get_region_points(SkeletonRCgc,r, c)</l>
<l>        get_grayval (ImageIR, r, c, gv)</l>
<l>        tuple_median(gv, pnum)</l>
<l>        inner_circle(RCgc, rmin, cmin, radmin)</l>
<c>        ** inner radius to be used as CAD half width</c>
<l>        gen_circle(Circle, rmin, cmin, radmin)</l>
<c>    </c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld(RCgb, Contours1, 3, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours1, Contours, 3, 1, 'attr_forget')</l>
<l>        smooth_contours_xld(Contours, ContoursSmi, sm_factor)</l>
<l>        select_contours_xld(ContoursSmi, ContoursSm, 'contour_length', 30.0, 20000000., -0.5, 0.5)</l>
<l>        count_obj(ContoursSm, nCo)</l>
<l>        tuple_concat (PCinRnumN, nCo, PCinRnumN)</l>
<c>        *** contours of each non-FWM region ( 1 or several)</c>
<l>        nnco:=0</l>
<l>        tuple_concat (PcontRN, pcontn, PcontRN)</l>
<l>        pcontn := pcontn+nCo</l>
<l>        for jj:=1 to nCo by 1</l>
<l>            select_obj(ContoursSm, Contour, jj)</l>
<l>            get_contour_xld (Contour, Row, Col)</l>
<l>            tuple_length (Row, pN)</l>
<l>*             if(pN&gt;30)</l>
<l>                nnco:=nnco+1</l>
<c>                </c>
<l>                concat_obj(ContoursAll, Contour, ContoursAll)</l>
<l>                tuple_gen_const(pN, radmin*2., W)</l>
<l>                tuple_gen_const (pN, j, J)</l>
<l>                tuple_concat (RowN, Row, RowN)</l>
<l>                tuple_concat (ColN, Col, ColN)</l>
<c>                </c>
<l>                 tuple_concat (WN, W, WN)</l>
<l>                tuple_concat (PaddrCN, paddrC, PaddrCN)</l>
<l>                indcn:=indcn+1</l>
<l>                tuple_concat (PregCN, j, PregCN)</l>
<l>                paddrC := paddrC + pN</l>
<l>                get_contour_angle_xld (Contour, 'abs', 'regress', lookaround, AnglesG)</l>
<l>                tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>                Ang:=AnglesG1</l>
<l>                tuple_concat (AngN, Ang, AngN)</l>
<c>    </c>
<l>                Y1t := Row-sin(Ang)*(3)</l>
<l>                X1t := Col+cos(Ang)*(3)</l>
<c>                </c>
<l>                Y1n := Row-sin(Ang)*(wpl)</l>
<l>                X1n := Col+cos(Ang)*(wpl)</l>
<l>                Y2n := Row+sin(Ang)*(wpl)</l>
<l>                X2n := Col-cos(Ang)*(wpl)</l>
<c>                </c>
<l>                tuple_gen_const(pN, pnum, Pnum)</l>
<l>                tuple_concat (PnumN, Pnum, PnumN)</l>
<c>      </c>
<c>                **** swapping P1 and P2 if necessary</c>
<l>*                 test_region_point (RegionsNFWM, Y1t[pN/2], X1t[pN/2], IsInside)</l>
<l>                n:=pN/6</l>
<l>                test_region_point (RegionsNFWM, Y1t[n], X1t[n],     IsInside1)</l>
<l>                test_region_point (RegionsNFWM, Y1t[2*n], X1t[2*n], IsInside2)</l>
<l>                test_region_point (RegionsNFWM, Y1t[3*n], X1t[3*n], IsInside3)</l>
<l>                test_region_point (RegionsNFWM, Y1t[4*n], X1t[4*n], IsInside4)</l>
<l>                test_region_point (RegionsNFWM, Y1t[5*n], X1t[5*n], IsInside5)</l>
<l>                tuple_median([IsInside1, IsInside2, IsInside3, IsInside4, IsInside5], IsInside)</l>
<l>                if(IsInside)</l>
<l>                    Yt:= Y1n</l>
<l>                    Xt:= X1n</l>
<l>                    X1n:=X2n</l>
<l>                    Y1n:=Y2n</l>
<l>                    X2n:=Xt</l>
<l>                    Y2n:=Yt</l>
<l>                endif</l>
<c>                ****          </c>
<l>                dev_set_color('green')</l>
<l>                disp_line(200000, Y1n, X1n, Y2n, X2n)</l>
<l>                distance_pp(Y1n, X1n, Y2n, X2n, D)</l>
<l>                tuple_gen_const( pN, 1, Ones)</l>
<l>                gen_rectangle2(Reg2,(Y1n+Y2n)/2., (X1n+X2n)/2., Ang, D/2.,Ones)</l>
<l>                gen_region_points(RC, (Y1n+Y2n)/2., (X1n+X2n)/2.)</l>
<l>                intersection(Reg2, SkelN, Ps)</l>
<l>                union1(SkelN, SN)</l>
<l>                distance_pr(SN,(Y1n+Y2n)/2., (X1n+X2n)/2.,  Dmin, Dmax)</l>
<c>    </c>
<c>                </c>
<l>                tuple_concat (Y1N, Y1n, Y1N)</l>
<l>                tuple_concat (X1N, X1n, X1N)</l>
<l>                tuple_concat (Y2N, Y2n, Y2N)</l>
<l>                tuple_concat (X2N, X2n, X2N)</l>
<l>                if(wgntype==0)</l>
<l>                    tuple_concat (WGN, Dmin, WGN)</l>
<l>                else </l>
<l>                    tuple_gen_const(pN, radmin, Wgn )</l>
<l>                    tuple_concat (WGN, Wgn, WGN)</l>
<l>                endif</l>
<l>        endfor</l>
<l>        tuple_concat (PaddrRN, paddrC, PaddrRN)</l>
<l>    else</l>
<l>         tuple_concat (PCinRnumN, 0, PCinRnumN)</l>
<l>         tuple_concat (PcontRN, -1, PcontRN)</l>
<l>*          tuple_concat (PaddrCN, -1, PaddrCN)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="MSBuildNonFWM8">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrRN"/>
<parameter id="PcontRN"/>
<parameter id="PnumN"/>
<parameter id="PnumRN"/>
<parameter id="PregCN"/>
<parameter id="RegionsNFWM"/>
<parameter id="SkelN"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthImageP"/>
<parameter id="X1N"/>
<parameter id="X2N"/>
<parameter id="Y1N"/>
<parameter id="Y2N"/>
<parameter id="lookaround"/>
<parameter id="nCGc"/>
<parameter id="sm_factor"/>
<parameter id="wgntype"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSNBuildNonFWM1">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWMBcut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="wgntype" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="WN" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>union1(RegionG, RegionGu)</l>
<l>union1(SkeletonPartsP, SkeletonFWM)</l>
<l>junctions_skeleton(SkeletonFWM,EndPointsu, JuncPoints)</l>
<l>boundary(RegionGu, RegionGB, 'outer')</l>
<l>connection(EndPointsu, EndPoints)</l>
<l>count_obj(EndPoints, nEP)</l>
<l>area_center(EndPoints, A, Row, Col)</l>
<l>get_grayval(WidthImageP, Row, Col, Hw)</l>
<l>get_grayval(DirImageP, Row, Col, Dir)</l>
<l>Ang:=Dir*rad(180)/256.0</l>
<l>* tuple_length(Row, n)</l>
<l>tuple_gen_const(nEP, 2, Ones)</l>
<c></c>
<c></c>
<l>gen_rectangle2(Rectangles, Row, Col, Ang, Hw/2+7, Ones)</l>
<l>union2(RegionGS, Rectangles, Forb)</l>
<l>union1(Rectangles, Rectanglesu)</l>
<l>* expand_region(SkeletonFWM, Forb,RegionExpandedi, 'maximal', 'image')</l>
<l>expand_region(SkeletonFWM, Forb,RegionExpandedi, 50, 'image')</l>
<l>* opening_circle(RegionExpandedi, RegionExpanded, 1.0)</l>
<l>dilation_circle(RegionExpandedi, RegionFWM, 1.0)</l>
<l>difference(RegionG, RegionFWM, RegionDifference2)</l>
<l>closing_circle(RegionDifference2, RegionNFWM, 2.5)</l>
<l>connection(RegionNFWM, RegionsNFWM)</l>
<l>boundary(RegionsNFWM, RegionsNFWMB, 'outer')</l>
<l>difference(RegionsNFWMB, RegionG, RegionsNFWMBcut)</l>
<l>union1(RegionsNFWMBcut, RegionNFWMBcut)</l>
<l>area_center(RegionNFWMBcut, Area1, Row2, Column)</l>
<l>count_obj(RegionsNFWMBcut, nNFWMcad)</l>
<c>**** MSBuildNonFWM8 220726 ****</c>
<c>** corrected for -1</c>
<c>* 220111 fixed bug in inside/outside detection (lines 109-114)</c>
<l>RowN := []</l>
<l>ColN := []</l>
<l>PnumN := []</l>
<l>pnum:=[]</l>
<l>WN := []</l>
<c>*** address for each region (1 or several contours)</c>
<l>PaddrRN := 0</l>
<c>*** address for each contour</c>
<l>PaddrCN := []</l>
<c>**** number of contours per region</c>
<l>* PregN := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregCN := []</l>
<c>* * number of countours per region</c>
<l>PCinRnumN := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontRN := []</l>
<c>** current Region address</c>
<l>paddrR := 0</l>
<c>** current Contour address</c>
<l>paddrC := 0</l>
<l>pcontn := 1</l>
<l>indcn:=0</l>
<l>AngN:= []</l>
<l>PlenN:=[]</l>
<l>Y1N:=[]</l>
<l>X1N:=[]</l>
<l>Y2N:=[]</l>
<l>X2N:=[]</l>
<l>WGN:=[]</l>
<c></c>
<l>get_domain(ImageIR, Dom)</l>
<c></c>
<l>* count_obj (BoundariesNFWM, nNonWFM)</l>
<c></c>
<l>gen_empty_obj(ContoursAll)</l>
<l>gen_empty_obj(RegsAll)</l>
<l>* RegionsNFWM:=RegionsNFWMBcut</l>
<l>for j:=1 to nNFWMcad by 1</l>
<l>    select_obj(RegionsNFWMBcut, Obj, j)</l>
<l>*     select_obj(RegionsNFWM, ObjR, j)</l>
<l>*     inner_circle(RCgc, rmin, cmin, radmin)</l>
<l>    gen_contours_skeleton_xld(Obj, Contours1, 1, 'filter')</l>
<l>    count_obj(Contours1, nCont)</l>
<l>    union_adjacent_contours_xld(Contours1, Contours, 3, 1, 'attr_forget')</l>
<l>    smooth_contours_xld(Contours, ContoursSmi, sm_factor)</l>
<l>    select_contours_xld(ContoursSmi, ContoursSm, 'contour_length', 30.0, 20000000., -0.5, 0.5)</l>
<l>    count_obj(ContoursSm, nCo)</l>
<l>    tuple_concat (PCinRnumN, nCo, PCinRnumN)</l>
<c>          *** contours of each non-FWM region ( 1 or several)</c>
<l>        nnco:=0</l>
<l>        tuple_concat (PcontRN, pcontn, PcontRN)</l>
<l>        pcontn := pcontn+nCo</l>
<l>        for jj:=1 to nCo by 1</l>
<l>            select_obj(ContoursSm, Contour, jj)</l>
<l>            get_contour_xld (Contour, Row, Col)</l>
<l>            tuple_length (Row, pN)</l>
<l>*             if(pN&gt;30)</l>
<l>                nnco:=nnco+1</l>
<c>                </c>
<l>                concat_obj(ContoursAll, Contour, ContoursAll)</l>
<l>                skeleton(Obj,SkeletonRCgc)</l>
<l>                intersection(SkeletonRCgc, Dom, SkeletonRCgc)</l>
<l>                get_region_points(SkeletonRCgc,r, c)</l>
<l>*                 tuple_max(c, cm)</l>
<l>                get_grayval (ImageIR, r, c, gv)</l>
<l>                tuple_median(gv, pnum)</l>
<l>*                 tuple_gen_const(pN, radmin*2., W)</l>
<l>                tuple_gen_const (pN, j, J)</l>
<l>                tuple_concat (RowN, Row, RowN)</l>
<l>                tuple_concat (ColN, Col, ColN)</l>
<c>                </c>
<l>*                  tuple_concat (WN, W, WN)</l>
<l>                tuple_concat (PaddrCN, paddrC, PaddrCN)</l>
<l>                indcn:=indcn+1</l>
<l>                tuple_concat (PregCN, j, PregCN)</l>
<l>                paddrC := paddrC + pN</l>
<l>                get_contour_angle_xld (Contour, 'abs', 'regress', lookaround, AnglesG)</l>
<l>                tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>                Ang:=AnglesG1</l>
<l>                tuple_concat (AngN, Ang, AngN)</l>
<c>    </c>
<l>                Y1t := Row-sin(Ang)*(3)</l>
<l>                X1t := Col+cos(Ang)*(3)</l>
<c>                </c>
<l>                Y1n := Row-sin(Ang)*(wpl)</l>
<l>                X1n := Col+cos(Ang)*(wpl)</l>
<l>                Y2n := Row+sin(Ang)*(wpl)</l>
<l>                X2n := Col-cos(Ang)*(wpl)</l>
<c>                </c>
<l>                tuple_gen_const(pN, pnum, Pnum)</l>
<l>                tuple_concat (PnumN, Pnum, PnumN)</l>
<c>      </c>
<c>                **** swapping P1 and P2 if necessary</c>
<l>*                 test_region_point (RegionsNFWM, Y1t[pN/2], X1t[pN/2], IsInside)</l>
<l>                n:=pN/6</l>
<l>                test_region_point (RegionsNFWM, Y1t[n], X1t[n],     IsInside1)</l>
<l>                test_region_point (RegionsNFWM, Y1t[2*n], X1t[2*n], IsInside2)</l>
<l>                test_region_point (RegionsNFWM, Y1t[3*n], X1t[3*n], IsInside3)</l>
<l>                test_region_point (RegionsNFWM, Y1t[4*n], X1t[4*n], IsInside4)</l>
<l>                test_region_point (RegionsNFWM, Y1t[5*n], X1t[5*n], IsInside5)</l>
<l>                tuple_median([IsInside1, IsInside2, IsInside3, IsInside4, IsInside5], IsInside)</l>
<l>                if(IsInside)</l>
<l>                    Yt:= Y1n</l>
<l>                    Xt:= X1n</l>
<l>                    X1n:=X2n</l>
<l>                    Y1n:=Y2n</l>
<l>                    X2n:=Xt</l>
<l>                    Y2n:=Yt</l>
<l>                endif</l>
<c>                ****          </c>
<l>                dev_set_color('green')</l>
<c>*                 get_window_attr(</c>
<l>*                 disp_line(H1C65EF90020, Y1n, X1n, Y2n, X2n)</l>
<l>*                 distance_pp(Y1n, X1n, Y2n, X2n, D)</l>
<l>*                 tuple_gen_const( pN, 1, Ones)</l>
<l>*                 gen_rectangle2(Reg2,(Y1n+Y2n)/2., (X1n+X2n)/2., Ang, D/2.,Ones)</l>
<l>*                 gen_region_points(RC, (Y1n+Y2n)/2., (X1n+X2n)/2.)</l>
<l>*                 intersection(Reg2, SkelN, Ps)</l>
<l>*                 union1(SkelN, SN)</l>
<l>*                 distance_pr(SN,(Y1n+Y2n)/2., (X1n+X2n)/2.,  Dmin, Dmax)</l>
<c>    </c>
<c>                </c>
<l>                tuple_concat (Y1N, Y1n, Y1N)</l>
<l>                tuple_concat (X1N, X1n, X1N)</l>
<l>                tuple_concat (Y2N, Y2n, Y2N)</l>
<l>                tuple_concat (X2N, X2n, X2N)</l>
<l>*                 if(wgntype==0)</l>
<l>*                     tuple_concat (WGN, Dmin, WGN)</l>
<l>*                 else </l>
<l>*                     tuple_gen_const(pN, radmin, Wgn )</l>
<l>*                     tuple_concat (WGN, Wgn, WGN)</l>
<l>*                 endif</l>
<l>        endfor</l>
<l>        tuple_concat (PaddrRN, paddrC, PaddrRN)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="MSNBuildNonFWM1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnumN"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrRN"/>
<parameter id="PcontRN"/>
<parameter id="PnumN"/>
<parameter id="PnumRN"/>
<parameter id="PregCN"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsNFWMBcut"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonPartsP"/>
<parameter id="WGN"/>
<parameter id="WN"/>
<parameter id="WidthImageP"/>
<parameter id="X1N"/>
<parameter id="X2N"/>
<parameter id="Y1N"/>
<parameter id="Y2N"/>
<parameter id="lookaround"/>
<parameter id="sm_factor"/>
<parameter id="wgntype"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSNProc32">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc32 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.28  adopted for Non-FWM</c>
<l>normint:=0</l>
<c>******************</c>
<l>* gen_region_points(P1, iy1, ix1)</l>
<l>* gen_region_points(P2, iy2, ix2)</l>
<l>* get_grayval (ImageIRB, iy1, ix1, v1)</l>
<l>* get_grayval (ImageIRB, iy2, ix2, v2)</l>
<c></c>
<l>* if(v1!=0)</l>
<l>*     dX1 := (ix2 - ix1)</l>
<l>*     dY1 := (iy2 - iy1)</l>
<l>*     ix1:=ix1-dX1</l>
<l>*     iy1:=iy1-dY1</l>
<l>*     gen_region_points(P1m, iy1, ix1)</l>
<l>* endif</l>
<c></c>
<l>* if(v2!=1)</l>
<l>*     dX1 := (ix2 - ix1)</l>
<l>*     dY1 := (iy2 - iy1)</l>
<l>*     ix2:=ix2+dX1</l>
<l>*     iy2:=iy2+dY1</l>
<l>*     gen_region_points(P2m, iy2, ix2)</l>
<l>*     get_grayval (ImageIRB, iy2, ix2, v2)</l>
<c></c>
<l>* endif</l>
<c></c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;pPat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==20)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('yellow')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        concat_obj(PC, Pc, PC)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        if((vp==0 or (vp&gt;1 and vp!= pnum)) or (vn==0 or (vn&gt;1 and vn!= pnum)) )    </l>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-65535-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                ii:=ii+1</l>
<l>                if(ii&gt;5)</l>
<l>*                     stop()</l>
<l>                    ii:=5</l>
<l>                    break</l>
<l>                endif</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==1 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>    endif</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        ii:=ii+1</l>
<l>        if(Pval[pind-2]==0)</l>
<l>            PIntY[ii]:=PPy[pind-1]</l>
<l>            PIntX[ii]:=PPx[pind-1]</l>
<l>            PInti[ii]:=pind-1</l>
<l>            PCLC[ii]:=clc</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    shift:=0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>        get_grayval (Im, PPy[PInti[j]], PPx[PInti[j]],  g)</l>
<l>        g0[1] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>        g0[2] := g</l>
<l>        SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW segment</c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* stop()</l>
<c>*** finding SP points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>        if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>            continue</l>
<l>        else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>* wc := sqrt( (PCX - ix2)*(PCX - ix2) + (PCY - iy2)*(PCY - iy2) )</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>if(intnum==2)</l>
<l>    normint:=1</l>
<l>else</l>
<l>    normint:=0</l>
<l>endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSNProc32">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="normint"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSProc33">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc33 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>            PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('yellow')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        concat_obj(PC, Pc, PC)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        *if((vp==pat0space1 or (vp&gt;1 and vp!= pnum)) or (vn==pat0space1 or (vn&gt;1 and vn!= pnum)) )    </l>
<l>        if((vp==pat0space1 ) or (vn==pat0space1 ) )    </l>
<c>    </c>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>            get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-65535-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                PIRBS[ii]:=irbs</l>
<l>                ii:=ii+1</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<l>* tuple_select_range(PIntY, 0, intnum-1, PIntYs) </l>
<l>* tuple_select_range(PIntX, 0, intnum-1, PIntXs) </l>
<l>* get_grayval(ImageCLC, PIntYs, PIntXs, Grayval)</l>
<l>* Ind</l>
<l>* tuple_replace(PCLC, PIntXs, PIntXs, Replaced)</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==1 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>        get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>        irbs:=PIRBS[ii-1]</l>
<l>    endif</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        ii:=ii+1</l>
<l>        if(Pval[pind-2]==0)</l>
<l>            PIntY[ii]:=PPy[pind-1]</l>
<l>            PIntX[ii]:=PPx[pind-1]</l>
<l>            PInti[ii]:=pind-1</l>
<l>            PCLC[ii]:=clc</l>
<l>            PIRBS[ii]:=irbs</l>
<l>            ii:=ii+1</l>
<l>        endif</l>
<l>        Psubpix[ii]:=0</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    shift:=0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    get_grayval (Im, PPy[PInti[j]], PPx[PInti[j]],  g)</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<c>    </c>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>        SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>    if(g0[2]-g0[0]&gt;0)</l>
<l>        Pdir[j] := 1</l>
<l>    elseif(g0[0]-g0[2]&gt;0)</l>
<l>        Pdir[j] := -1</l>
<l>    endif</l>
<l>    if(pdir &gt; 0)</l>
<l>        Pdir[j] := -1</l>
<l>    elseif(pdir &lt; 0)</l>
<l>        Pdir[j] := 1</l>
<l>    endif</l>
<l>    if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>        Pdir[j] := 1</l>
<l>    endif</l>
<l>    if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>        Pdir[j] := -1</l>
<l>    endif</l>
<l>    pdir:=Pdir[j]</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>    get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>    if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>        clc:=0</l>
<l>        for dx:=-3 to 3 by 1</l>
<l>            for dy:=-3 to 3 by 1</l>
<l>                get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>                if(vclc!=0)</l>
<l>                    clc:=vclc</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endfor</l>
<l>        PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>    else</l>
<l>        PCLC[j]:=vclc</l>
<l>    endif</l>
<l>    Pnums[j]:=vpnums</l>
<l>endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<c>    </c>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<l>        if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>            continue</l>
<l>        endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>dev_set_color('red')</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>        if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>            continue</l>
<l>        else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>    stop()</l>
<l>endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSProc33">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain108">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain109 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220827  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<c></c>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, cutendMSS, RadendMSS)</l>
<l>gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>union1(CMSSE, CMSSEu)</l>
<l>difference(RegionsmainSs, CMSSEu, RegionsmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSi, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain108">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN1">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN1 : new detect short proc. 11.08.2022</c>
<c></c>
<l>intersection(SkeletonGS, RegionInoPHnoIsl, ShCandAll)</l>
<l>connection(ShCandAll, ShCands)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>for j:=1 to nShCands by 1</l>
<l>*     intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*     connection(RInt, RInts)</l>
<l>*     if(j==5085)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(ShCands, ShCand, j)</l>
<l>    area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>    get_region_points(ShCand, Rows, Columns)</l>
<l>    get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>    tuple_median(SpW, spw)</l>
<l>    get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>    tuple_median(SpD, spd)</l>
<l>    sa:=spd*3.14159/256</l>
<l>    if(spw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+10, Length2+spw+10)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    endif</l>
<c>    </c>
<l>*     gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>    connection(RegionISR2, RegionsISR2)</l>
<l>    intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>    connection(RegionGSR2, RegionsGSR2)</l>
<l>    count_obj(RegionsGSR2, nGSR2)</l>
<l>    for jj:=1 to nGSR2 by 1</l>
<l>        select_obj(RegionsGSR2, Rsel, jj)</l>
<l>        test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGSR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGSR2, Rskel, jj)</l>
<l>    intersection( RegionsISR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<l>        concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortN1">
<parameters>
<parameter id="DirImageS"/>
<parameter id="R2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN1">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN1 : new detect open proc. 11.08.2022</c>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==139)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+3, Length2+ppw+3)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskel, jj)</l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>        concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>         dilation_circle(Rskel, RskelSd, 1)</l>
<l>         concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="R2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="NFWMConnected">
<interface>
<io>
<par name="Rclfwmbutnfrm" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="RegionInoDC" base_type="iconic" dimension="0"/>
<par name="RegionNFWM" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RconnectedNFWM" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expv" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>union1(Rclfwmbutnfrm, Rclfwmbutnfrmu)</l>
<l>connection(Rclfwmbutnfrmu, Rclfwmbutnfrmuc)</l>
<l>count_obj(Rclfwmbutnfrmuc, n)</l>
<l>hw:=90</l>
<l>gen_empty_obj (RconnectedNFWM)</l>
<l>for j:=1 to n by 1</l>
<l>*     if(j==44)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(Rclfwmbutnfrmuc, Obj, j)</l>
<c>    </c>
<l>    area_center(Obj, a, r, c)</l>
<l>    gen_rectangle1(Rect, r-hw, c-hw, r+hw, c+hw)</l>
<l>    intersection(Rect, RegionInoDC, RegionInoDCr)</l>
<l>    get_region_points(Obj, Rows, Cols)</l>
<l>*     get_grayval(ImDisplacement, Rows, Cols, D)</l>
<l>*     tuple_max(D, dm)</l>
<l>*     expv:= (dm-127)*3</l>
<l>*     expv:=10</l>
<l>    expand_region(Obj, RegionInoDCr, RegionExpanded1, expv, 'image')</l>
<l>    intersection(RegionExpanded1, RegionNFWM, RegionIntersection)</l>
<l>    area_center(RegionIntersection, a, r, c)</l>
<l>    if(a!=0)</l>
<l>        concat_obj (RconnectedNFWM, Obj, RconnectedNFWM)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>read_object (HoObj, 'E:/PATTERN/ho_Obj.hobj')</l>
<l>read_object (HoRegioninodcr, 'E:/PATTERN/ho_RegionInoDCr.hobj')</l>
<l>expv:=60</l>
<l>expand_region(HoObj, HoRegioninodcr, RegionExpanded1, expv, 'image')</l>
<l>return ()</l>
</body>
<docu id="NFWMConnected">
<parameters>
<parameter id="ImDisplacement"/>
<parameter id="Rclfwmbutnfrm"/>
<parameter id="RconnectedNFWM"/>
<parameter id="RegionInoDC"/>
<parameter id="RegionNFWM"/>
<parameter id="expv"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectIsl2n">
<interface>
<io>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nIslfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>fill_up_shape (RegionIS, RegionIfu, 'area', 1, fumax)</l>
<l>* fill_up (RegionIS, RegionIfu2)</l>
<c></c>
<l>difference (RegionIfu, RegionIS, RegionPHfui)</l>
<l>fill_up (RegionPHfui, RegionsIslfu)</l>
<l>connection (RegionsIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<l>* difference (RegionIS, RegionsIslfu, RegionIfu)</l>
<l>union2 (RegionIS, RegionsIslfu, RegionIfu)</l>
<l>return ()</l>
</body>
<docu id="DetectIsl2n">
<parameters>
<parameter id="Im"/>
<parameter id="RegionIS"/>
<parameter id="RegionIfu"/>
<parameter id="RegionsIslfu"/>
<parameter id="fumax"/>
<parameter id="nIslfu"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectIsl5">
<interface>
<io>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nIslfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>fill_up_shape (RegionIS, RegionISfu, 'area', 1, fumax)</l>
<l>* smallest_rectangle1(RegionIS, Row1, Column1, Row2, Column2)</l>
<l>* gen_rectangle1(R1, Row1, Column1, Row2/2, Column2/2)</l>
<l>* intersection(RegionIS, R1, RegionIS1)</l>
<l>* fill_up_shape (RegionIS1, RegionISfu1, 'area', 1, 8000)</l>
<l>* fill_up_shape (RegionIS, RegionISfu, 'area', 1, 8000)</l>
<l>* fill_up (RegionIS, RegionISfuns)</l>
<l>difference (RegionISfu, RegionIS, RegionIslfu)</l>
<l>* difference (RegionIslfu, RegionG, RegionIslfunG)</l>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<l>select_shape(RegionsIslfu, RegionsBig, 'area', 'and', fumax, aislmax)</l>
<l>union1(RegionsBig, RegionsBigu)</l>
<l>difference(RegionIslfu, RegionsBigu, RegionIslfu)</l>
<c></c>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<c></c>
<l>count_obj(RegionsBig, nBig)</l>
<l>for j := 1 to nBig by 1</l>
<l>    select_obj(RegionsBig, RBig, j)</l>
<l>    intersection(RBig, RegionG, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    if(Area==0)</l>
<l>        concat_obj(RegionsIslfu, RBig, RegionsIslfu)</l>
<l>    endif</l>
<l>endfor</l>
<l>* gen_empty_obj (RegionsIslfu)</l>
<l>* nIslfu := 0</l>
<l>* for j := 1 to nIslfum by 1</l>
<l>*     select_obj (RegionsIslfu, ObjectSelected, j)</l>
<l>*     intersection (ObjectSelected, SkeletonG, RegionInt)</l>
<l>*     area_center (RegionInt, a, r, c)</l>
<l>*     if (a==0)</l>
<l>*         concat_obj (RegionsIslfu, ObjectSelected, RegionsIslfu)</l>
<l>*         nIslfu := nIslfu+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>difference (RegionIfu, RegionsIslfu, RegionIi)</l>
<l>connection (RegionIi, RegionsIi)</l>
<l>select_shape (RegionsIi, RegionsI, 'area', 'and', 10, 99999999)</l>
<l>union1 (RegionsI, RegionI)</l>
<l>return ()</l>
</body>
<docu id="DetectIsl5">
<parameters>
<parameter id="Im"/>
<parameter id="RegionG"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionIfu"/>
<parameter id="RegionsIslfu"/>
<parameter id="SkeletonG"/>
<parameter id="aislmax"/>
<parameter id="fumax"/>
<parameter id="nIslfu"/>
</parameters>
</docu>
</procedure>
<procedure name="SelectMBandSPofNFWM">
<interface>
<io>
<par name="Regsmbnall" base_type="iconic" dimension="0"/>
<par name="Regsspnall" base_type="iconic" dimension="0"/>
<par name="Rd" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="RegionInoDC" base_type="iconic" dimension="0"/>
<par name="RegionNFWM" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RMBnfwm" base_type="iconic" dimension="0"/>
<par name="RSPnfwm" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dfwm" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***** Selecting NFWM MB and SP 2022.08.17</c>
<c>*** SelectMBandSPofNFWM</c>
<c>****** MB ****</c>
<c></c>
<l>difference(Regsmbnall, Rd, RegsmbnallnoR)</l>
<l>intersection(RegsmbnallnoR, RegionInoD, RegsmbnallnoRinod)</l>
<l>NFWMfarfromFWM (RegsmbnallnoRinod, SkeletonFWM, Rmbclfwm, Rmbfarfwm, dfwm, nclfwm, nfarfwm, Clnum)</l>
<c></c>
<l>difference(Rmbclfwm, RegionMS, Rmbclfwmbutnfrm)</l>
<l>NFWMConnected (Rmbclfwmbutnfrm, ImDisplacement, RegionInoDC, RegionNFWM, RconnectedNFWMmb, expv)</l>
<l>concat_obj(Rmbfarfwm, RconnectedNFWMmb, RMBnfwm)</l>
<c></c>
<c>****** SP ****</c>
<l>difference(Regsspnall, Rd, RegsspnallnoR)</l>
<l>intersection(RegsspnallnoR, RegionInoD, RegsspnallnoRinod)</l>
<l>NFWMfarfromFWM (RegsspnallnoRinod, SkeletonFWM, Rclfwm, Rfarfwm, dfwm, nclfwm, nfarfwm, Clnum)</l>
<c></c>
<l>* intersection(Rclfwm, RegionMS, Rclfwmbelong)</l>
<l>difference(Rclfwm, RegionMS, Rclfwmbutnfrm)</l>
<l>NFWMConnected (Rclfwmbutnfrm, ImDisplacement, RegionInoDC, RegionNFWM, RconnectedNFWM, expv1)</l>
<l>concat_obj(Rfarfwm, RconnectedNFWM, RSPnfwm)</l>
<c></c>
<c></c>
<c></c>
<l>* read_object (HoRclfwmbutnfrm, 'E:/PATTERN/ho_Rclfwmbutnfrm.hobj')</l>
<l>* read_object (HoRegioninodc, 'E:/PATTERN/ho_RegionInoDC.hobj')</l>
<l>* read_object (HoRegionnfwm, 'E:/PATTERN/ho_RegionNFWM.hobj')</l>
<c></c>
<l>* symm_difference(Rclfwmbutnfrm, HoRclfwmbutnfrm, D1)</l>
<l>* test_equal_region(Rclfwmbutnfrm, HoRclfwmbutnfrm, e3)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* union1(HoRclfwmbutnfrm, Rclfwmbutnfrmu)</l>
<l>* connection(Rclfwmbutnfrmu, Rclfwmbutnfrmuc)</l>
<l>* count_obj(Rclfwmbutnfrmuc, nc)</l>
<l>* get_system('neighborhood', n)</l>
<l>* symm_difference(RegionInoDC, HoRegioninodc, D2)</l>
<l>* symm_difference(RegionNFWM, HoRegionnfwm, D3)</l>
<c></c>
<l>* read_object (HoRclfwm, 'E:/PATTERN/ho_Rclfwm.hobj')</l>
<l>* read_object (HoRegsspnallnorinod, 'E:/PATTERN/ho_RegsspnallnoRinod.hobj')</l>
<l>* read_object (HoRd, 'E:/PATTERN/ho_Rd.hobj')</l>
<l>* test_equal_region(Rd, HoRd, e0)</l>
<l>* symm_difference(RegsspnallnoRinod, HoRegsspnallnorinod, D5)</l>
<l>* test_equal_region(RegsspnallnoRinod, HoRegsspnallnorinod, e)</l>
<c></c>
<l>* symm_difference(Rclfwm, HoRclfwm, D6)</l>
<l>* test_equal_region(Rclfwm, HoRclfwm, e2)</l>
<l>return ()</l>
</body>
<docu id="SelectMBandSPofNFWM">
<parameters>
<parameter id="ImDisplacement"/>
<parameter id="RMBnfwm"/>
<parameter id="RSPnfwm"/>
<parameter id="Rd"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoDC"/>
<parameter id="RegionMS"/>
<parameter id="RegionNFWM"/>
<parameter id="Regsmbnall"/>
<parameter id="Regsspnall"/>
<parameter id="SkeletonFWM"/>
<parameter id="dfwm"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC -without vectors 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<l>* VectorCX := {1}</l>
<l>* VectorCX.clear()</l>
<l>* VectorCY := {1}</l>
<l>* VectorCY.clear()</l>
<c></c>
<l>* VaddrC := {1}</l>
<l>* VaddrC.clear()</l>
<c></c>
<l>* VnumC := {1}</l>
<l>* VnumC.clear()</l>
<c></c>
<l>* VseqC := {1}</l>
<l>* VseqC.clear()</l>
<c></c>
<l>* VpnC := {1}</l>
<l>* VpnC.clear()</l>
<l>addr:=0</l>
<l>Cx:=[]</l>
<l>Cy:=[]</l>
<l>CNum:=[]</l>
<l>CAddr:=[]</l>
<l>CSeq:=[]</l>
<l>CPN:=[]</l>
<c></c>
<c>* vector insertion index</c>
<l>i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=44</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<l>    tuple_concat(Cy, RowsC, Cy)</l>
<l>    tuple_concat(Cx, ColsC, Cx)</l>
<l>*     VectorCY.insert(i,RowsC)</l>
<l>*     VectorCX.insert(i,ColsC)</l>
<l>    tuple_length(RowsC, n1)</l>
<c>   </c>
<l>    tuple_concat(CNum, n1, CNum)</l>
<l>    tuple_concat(CAddr, addr, CAddr)</l>
<l>*     VnumC.insert(i, n1)</l>
<l>*     VaddrC.insert(i, addr)</l>
<l>    addr:= addr+n1</l>
<l>    tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<l>    tuple_concat(CSeq, Seq, CSeq)</l>
<l>*     VseqC.insert(i, Seq)</l>
<l>    tuple_gen_const(n1, pn, Pn)</l>
<l>    tuple_concat(CPN, Pn, CPN)</l>
<l>*     VpnC.insert(i, Pn)</l>
<l>    i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<c>            ****</c>
<l>*             gen_region_points(RCont,RowsC, ColsC)</l>
<l>            tuple_concat(Cy, RowsC, Cy)</l>
<l>            tuple_concat(Cx, ColsC, Cx)</l>
<l>*             VectorCY.insert(i,RowsC)</l>
<l>*             VectorCX.insert(i,ColsC)</l>
<l>            tuple_length(RowsC, n)</l>
<l>            tuple_concat(CNum, n, CNum)</l>
<l>            tuple_concat(CAddr, addr, CAddr)</l>
<l>*             VnumC.insert(i, n)</l>
<l>*             VaddrC.insert(i, addr)</l>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n/2-0.5, 0.5, Seq)</l>
<l>            tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>            tuple_concat(CSeq, Seq, CSeq)</l>
<l>*             VseqC.insert(i, Seq)</l>
<l>            tuple_gen_const(n, pn, Pn)</l>
<l>            tuple_concat(CPN, Pn, CPN)</l>
<l>*             VpnC.insert(i, Pn)</l>
<l>            i:=i+1</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>* convert_vector_to_tuple(VectorCX, Cx)</l>
<l>* convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>* convert_vector_to_tuple(VnumC, CNum)</l>
<l>* convert_vector_to_tuple(VaddrC, CAddr)</l>
<l>* convert_vector_to_tuple(VseqC, CSeq)</l>
<l>* convert_vector_to_tuple(VpnC, CPN)</l>
<l>get_image_size(ImageCLC, Width, Height)</l>
<l>tuple_length(Cy, n)</l>
<l>tuple_max(Cx, xmax)</l>
<l>tuple_max(Cy, ymax)</l>
<l>set_grayval(ImageCLC, Cy, Cx, CSeq)</l>
<l>set_grayval(ImageIRB, Cy, Cx, CPN)</l>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC2">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC -without vectors 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<l>* VectorCX := {1}</l>
<l>* VectorCX.clear()</l>
<l>* VectorCY := {1}</l>
<l>* VectorCY.clear()</l>
<c></c>
<l>* VaddrC := {1}</l>
<l>* VaddrC.clear()</l>
<c></c>
<l>* VnumC := {1}</l>
<l>* VnumC.clear()</l>
<c></c>
<l>* VseqC := {1}</l>
<l>* VseqC.clear()</l>
<c></c>
<l>* VpnC := {1}</l>
<l>* VpnC.clear()</l>
<l>addr:=0</l>
<l>Cx:=[]</l>
<l>Cy:=[]</l>
<l>CNum:=[]</l>
<l>CAddr:=[]</l>
<l>CSeq:=[]</l>
<l>CPN:=[]</l>
<c></c>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=44</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<l>*     tuple_concat(Cy, RowsC, Cy)</l>
<l>*     tuple_concat(Cx, ColsC, Cx)</l>
<l>*     VectorCY.insert(i,RowsC)</l>
<l>*     VectorCX.insert(i,ColsC)</l>
<l>    tuple_length(RowsC, n1)</l>
<c>   </c>
<l>*     tuple_concat(CNum, n1, CNum)</l>
<l>*     tuple_concat(CAddr, addr, CAddr)</l>
<l>*     VnumC.insert(i, n1)</l>
<l>*     VaddrC.insert(i, addr)</l>
<l>    addr:= addr+n1</l>
<l>    tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<l>*     tuple_int(Seq, Seq)</l>
<l>*     tuple_concat(CSeq, Seq, CSeq)</l>
<l>*     VseqC.insert(i, Seq)</l>
<l>    tuple_gen_const(n1, pn, Pn)</l>
<l>*     tuple_concat(CPN, Pn, CPN)</l>
<l>*     VpnC.insert(i, Pn)</l>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<c>            ****</c>
<l>*             gen_region_points(RCont,RowsC, ColsC)</l>
<l>*             tuple_concat(Cy, RowsC, Cy)</l>
<l>*             tuple_concat(Cx, ColsC, Cx)</l>
<l>*             VectorCY.insert(i,RowsC)</l>
<l>*             VectorCX.insert(i,ColsC)</l>
<l>            tuple_length(RowsC, n)</l>
<l>*             tuple_concat(CNum, n, CNum)</l>
<l>*             tuple_concat(CAddr, addr, CAddr)</l>
<l>*             VnumC.insert(i, n)</l>
<l>*             VaddrC.insert(i, addr)</l>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n/2-0.5, 0.5, Seq)</l>
<l>            tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>*             tuple_int(Seq, Seq)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<l>*             tuple_concat(CSeq, Seq, CSeq)</l>
<l>*             VseqC.insert(i, Seq)</l>
<l>            tuple_gen_const(n, pn, Pn)</l>
<l>*             tuple_concat(CPN, Pn, CPN)</l>
<l>*             VpnC.insert(i, Pn)</l>
<l>*             i:=i+1</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>* convert_vector_to_tuple(VectorCX, Cx)</l>
<l>* convert_vector_to_tuple(VectorCY, Cy)</l>
<c></c>
<l>* convert_vector_to_tuple(VnumC, CNum)</l>
<l>* convert_vector_to_tuple(VaddrC, CAddr)</l>
<l>* convert_vector_to_tuple(VseqC, CSeq)</l>
<l>* convert_vector_to_tuple(VpnC, CPN)</l>
<l>* get_image_size(ImageCLC, Width, Height)</l>
<l>* tuple_length(Cy, n)</l>
<l>* tuple_max(Cx, xmax)</l>
<l>* tuple_max(Cy, ymax)</l>
<l>* set_grayval(ImageCLC, Cy, Cx, CSeq)</l>
<l>* set_grayval(ImageIRB, Cy, Cx, CPN)</l>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC2">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC3">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC3 -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<c></c>
<l>addr:=0</l>
<c></c>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=44</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    tuple_length(RowsC, n1)</l>
<l>     addr:= addr+n1</l>
<l>    tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>    tuple_gen_const(n1, pn, Pn)</l>
<l>    gen_region_points(RR, RowsC, ColsC)</l>
<l>    set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<c></c>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        count_obj(RHoles, nHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>*             if(jj==16)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<c>            ****</c>
<l>*             gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>            tuple_length(RowsC, n)</l>
<c></c>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n/2-0.5, 0.5, Seq)</l>
<l>            tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>*             tuple_int(Seq, Seq)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>            tuple_gen_const(n, pn, Pn)</l>
<l>            set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<c></c>
<l>*             i:=i+1</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC3">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMainL109">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMainL109 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220827  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 5000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<c></c>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, cutendMSS, RadendMSS)</l>
<l>gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>union1(CMSSE, CMSSEu)</l>
<l>difference(RegionsmainSs, CMSSEu, RegionsmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSi, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMainL109">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain109">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain110 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain109">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="SaveDefImages">
<interface>
<io>
<par name="RegDefs" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegShOp" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="crad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="dname" base_type="ctrl" dimension="0"/>
<par name="dpath" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>**** SaveDefImages - saving selected type of defect</c>
<l>set_system('neighborhood', 8)</l>
<l>count_obj(RegDefs, nMBnfwm1)</l>
<l>if(nMBnfwm1==0)</l>
<l>    return()</l>
<l>endif</l>
<l>area_center(RegDefs, A, Row, Col)</l>
<c></c>
<l>tuple_gen_const(nMBnfwm1, crad, Crad)</l>
<l>gen_circle(C, Row, Col, Crad)</l>
<l>union1(C, Cu)</l>
<l>connection(Cu, Cuc)</l>
<l>union1(RegDefs, Rmbnfwmu)</l>
<l>intersection(Cuc, Rmbnfwmu, Rmbnfwmu2)</l>
<l>* connection(Rmbnfwmu, Rmbnfwmuc)</l>
<l>count_obj(Rmbnfwmu2, nMBnfwm)</l>
<l>kk:=1</l>
<l>for k:=1 to nMBnfwm by 1</l>
<l>    select_obj(Rmbnfwmu2, ObjMB, k)</l>
<l>    area_center(ObjMB, a, r, c)</l>
<l>    if(a==0 or r==0 or c==0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    intersection(ObjMB, RegShOp, RegionIntersection)</l>
<l>    area_center(RegionIntersection, ai, ri, ci)</l>
<l>    if(ai!=0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    smallest_rectangle1(ObjMB, r1, c1, r2, c2)</l>
<l>    gen_rectangle1(R1, r1-gap, c1-gap, r2+gap, c2+gap)</l>
<l>    reduce_domain(Im, R1, ImageReduced)</l>
<l>    crop_domain(ImageReduced, ImagePart)</l>
<l>    tuple_int(c, ci)</l>
<l>    tuple_int(r, ri)</l>
<l>    str:=dname+kk+'-x'+ci+'-y'+ri</l>
<l>    kk:=kk+1</l>
<l>    write_image(ImagePart, 'tiff', 0, dpath+str)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="SaveDefImages">
<parameters>
<parameter id="Im"/>
<parameter id="RegDefs"/>
<parameter id="RegShOp"/>
<parameter id="crad"/>
<parameter id="dname"/>
<parameter id="dpath"/>
<parameter id="gap"/>
</parameters>
</docu>
</procedure>
<procedure name="BuldIRBS2">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ImIRBSOut := ImIRBS</l>
<c>** dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'outer')</l>
<l>count_obj (SkeletonsFWMS, nSFWMS1)</l>
<l>union1(SkeletonsFWMS, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, ConnectedRegions)</l>
<l>count_obj(ConnectedRegions, n)</l>
<l>dilation_circle(SkeletonFWMS, SkeletonFWMSd, 2.5)</l>
<l>difference(SkeletonFWMSd, RegionInoD, SkeletonFWMSm)</l>
<l>connection(SkeletonFWMSm, ConnectedRegions)</l>
<l>count_obj(ConnectedRegions, n)</l>
<l>* intersection(SkeletonsFWMS, RegionInoD,RegionIntersection)</l>
<l>* union2(SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region(RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region(SkeletonFWMSm, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'outer')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceIRBS, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuldIRBS2">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS2">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>** modified 20220904 to ibcrease speed</c>
<c>*** few RegionsFWMS have wrong number (-1) in ImIRBSOut (20220908)!!</c>
<l>ImIRBSOut := ImIRBS</l>
<l>set_system('neighborhood', 8)</l>
<c>** dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* boundary (RegionsFWMS, RegionsFWMSB, 'outer')</l>
<l>count_obj (SkeletonsFWMS, nSFWMS1)</l>
<l>union1(SkeletonsFWMS, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMSc)</l>
<l>count_obj(SkeletonsFWMSc, n1)</l>
<l>dilation_circle(SkeletonFWMS, SkeletonFWMSd, 2.0)</l>
<l>connection(SkeletonFWMSd, SkeletonsFWMSd)</l>
<l>count_obj(SkeletonsFWMSd, n2)</l>
<l>difference(SkeletonFWMSd, RegionInoD, SkeletonFWMSm)</l>
<l>connection(SkeletonFWMSm, SkeletonsFWMSmc)</l>
<l>count_obj(SkeletonsFWMSmc, n3)</l>
<l>* intersection(SkeletonsFWMS, RegionInoD,RegionIntersection)</l>
<l>* union2(SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region(RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region(SkeletonsFWMSmc, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceIRBS, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS2">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc33">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc33 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>* previous clc </c>
<l>        pclc:=-2</l>
<l>        fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>    PIntY[ii]:=PPy[0]</l>
<l>    PIntX[ii]:=PPx[0]</l>
<l>    PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>    get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>    get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>    if(Pval[0]==pnum)</l>
<l>        PCLC[ii]:=clc</l>
<l>    else</l>
<c>        * no clc yet</c>
<l>        PCLC[ii]:=-2</l>
<l>    endif</l>
<l>    ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>    if(Pval[0]==1)</l>
<l>        fi1:=1</l>
<l>    endif</l>
<c>    </c>
<l>    if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>            PIntY[ii]:=PPy[0]</l>
<l>            PIntX[ii]:=PPx[0]</l>
<l>            PInti[ii]:=0</l>
<l>            PCLC[ii]:=clc</l>
<l>            PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>            ii:=ii+1</l>
<l>    endif</l>
<l>else</l>
<l>    fi1:=0</l>
<l>endif</l>
<c>***********  All Br. pixels*******</c>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    dev_display(Pc)</l>
<l>*     get_grayval(Im, yc, xc, g)</l>
<l>    v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>    if(fi1==1)</l>
<l>        if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>            ii:=ii-1</l>
<l>            fi1:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        fi1:=0</l>
<c>        * previous and next values</c>
<l>        vp:=Pval[i-1]</l>
<l>        vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>        dev_set_color('yellow')</l>
<l>        gen_region_points (Pc, yc, xc)</l>
<l>        concat_obj(PC, Pc, PC)</l>
<l>        dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>        *if(vp==0 or vn==0 or (vp==1 and vn==1))</l>
<l>        *if((vp==pat0space1 or (vp&gt;1 and vp!= pnum)) or (vn==pat0space1 or (vn&gt;1 and vn!= pnum)) )    </l>
<l>        if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>            get_grayval(ImageCLC, yc, xc, clc)</l>
<l>            get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>*             dclc:=min2(abs(clc-pclc), abs(clc-65535-pclc))</l>
<l>*             if(dclc &lt; clcmax)</l>
<l>                PIntY[ii]:=yc</l>
<l>                PIntX[ii]:=xc</l>
<l>                PInti[ii]:=i</l>
<l>                Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>                if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>                    ii:=ii+1</l>
<l>                    PIntY[ii-1]:=yc-0.35*signY</l>
<l>                    PIntX[ii-1]:=xc-0.35*signX</l>
<l>                    Psubpix[ii-1]:=0</l>
<l>                    PIntY[ii]:=yc+0.35*signY</l>
<l>                    PIntX[ii]:=xc+0.35*signX</l>
<l>                    PInti[ii]:=i</l>
<l>                    Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>                endif</l>
<c>                </c>
<l>                PCLC[ii]:=clc</l>
<l>                PIRBS[ii]:=irbs</l>
<l>                ii:=ii+1</l>
<l>                pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>        endif</l>
<l>      endif</l>
<l>    vp:=v</l>
<l>*     gp:=g</l>
<l>endfor</l>
<l>* tuple_select_range(PIntY, 0, intnum-1, PIntYs) </l>
<l>* tuple_select_range(PIntX, 0, intnum-1, PIntXs) </l>
<l>* get_grayval(ImageCLC, PIntYs, PIntXs, Grayval)</l>
<l>* Ind</l>
<l>* tuple_replace(PCLC, PIntXs, PIntXs, Replaced)</l>
<c>*checking last MS pixel</c>
<l>if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>    if(Pval[pind-1]==pnum)</l>
<l>        get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>        get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>    else</l>
<l>        clc:=PCLC[ii-1]</l>
<l>        irbs:=PIRBS[ii-1]</l>
<l>    endif</l>
<l>    PIntY[ii]:=PPy[pind-1]</l>
<l>    PIntX[ii]:=PPx[pind-1]</l>
<l>    PInti[ii]:=pind-1</l>
<l>    PCLC[ii]:=clc</l>
<l>    ii:=ii+1</l>
<l>    if(Pval[pind-2]==1)</l>
<l>        PIntY[ii]:=PPy[pind-1]</l>
<l>        PIntX[ii]:=PPx[pind-1]</l>
<l>        PInti[ii]:=pind-1</l>
<l>        PCLC[ii]:=clc</l>
<l>        PIRBS[ii]:=irbs</l>
<l>        ii:=ii+1</l>
<l>    endif</l>
<l>    Psubpix[ii]:=0</l>
<l>endif</l>
<c>**************************</c>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>    wmin := 0.</l>
<l>    wmax := 0.</l>
<l>    shift:=0.</l>
<l>    return()</l>
<l>endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<c>    </c>
<l>    if(Psubpix[j]==0)</l>
<l>        FIntX[j]:=PIntX[j]</l>
<l>        FIntY[j]:=PIntY[j]</l>
<l>    else</l>
<l>            SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>    endif</l>
<l>    if(g0[2]-g0[0]&gt;0)</l>
<l>        Pdir[j] := 1</l>
<l>    elseif(g0[0]-g0[2]&gt;0)</l>
<l>        Pdir[j] := -1</l>
<l>    endif</l>
<l>    if(pdir &gt; 0)</l>
<l>        Pdir[j] := -1</l>
<l>    elseif(pdir &lt; 0)</l>
<l>        Pdir[j] := 1</l>
<l>    endif</l>
<l>    if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>        Pdir[j] := 1</l>
<l>    endif</l>
<l>    if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>        Pdir[j] := -1</l>
<l>    endif</l>
<l>    pdir:=Pdir[j]</l>
<l>endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>nmwc:=0</l>
<c>* MW segment</c>
<l>mw:=-1</l>
<l>dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>    get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>    if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>        clc:=0</l>
<l>        for dx:=-3 to 3 by 1</l>
<l>            for dy:=-3 to 3 by 1</l>
<l>                get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>                if(vclc!=0)</l>
<l>                    clc:=vclc</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endfor</l>
<l>        PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>    else</l>
<l>        PCLC[j]:=vclc</l>
<l>    endif</l>
<l>    Pnums[j]:=vpnums</l>
<l>endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    pclc:=PCLC[j]</l>
<l>    clc:=PCLC[j+1]</l>
<c>    </c>
<l>    dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>    if(dclc&gt;clcmax)</l>
<l>        if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>            continue</l>
<l>        endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>        d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>        d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>        d:=sqrt( min2(d1,d2) )</l>
<l>        if(d&lt;dmin)</l>
<l>            mw:=j</l>
<l>            nmwc:=nmwc+1</l>
<l>            dmin:=d</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if(mw==-1)</l>
<l>    mw:=0</l>
<l>*     stop()</l>
<l>endif</l>
<l>dev_set_color('red')</l>
<l>gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>jSPdn:=mw</l>
<l>jSPup:=mw+1</l>
<c></c>
<l>for j:=0 to intnum-1 by 2</l>
<l>    if(j==mw)</l>
<l>        continue</l>
<l>    else</l>
<l>        clc:=PCLC[j]</l>
<l>        clc1:=PCLC[mw]</l>
<l>        clc2:=PCLC[mw+1]</l>
<l>        dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>        dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>            if(j&lt;mw)</l>
<l>                dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPdn:=j</l>
<l>                endif</l>
<l>            else</l>
<l>                dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>                if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>                    continue</l>
<l>                else</l>
<l>                    jSPup:=j+1</l>
<l>                endif</l>
<l>            endif</l>
<l>*         endif</l>
<l>    endif</l>
<l>endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>    stop()</l>
<l>endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc33">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="SubPixCrdS">
<interface>
<ic>
<par name="g0" base_type="ctrl" dimension="0"/>
<par name="i0" base_type="ctrl" dimension="0"/>
<par name="PPx" base_type="ctrl" dimension="0"/>
<par name="PPy" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="err" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_real (thr, rthr)</l>
<l>if (sub==0)</l>
<l>    PIntX[0] := PPx[i0]</l>
<l>    PIntY[0] := PPy[i0]</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>Px[1]:=PPx[i0]</l>
<l>Px[0]:=PPx[i0-1]</l>
<l>Px[2]:=PPx[i0+1]</l>
<l>Py[1]:=PPy[i0]</l>
<l>Py[0]:=PPy[i0-1]</l>
<l>Py[2]:=PPy[i0+1]</l>
<c>**** finding min, max and their indices</c>
<l>jmin:=-1</l>
<l>jmax:=-1</l>
<l>gmin:=256</l>
<l>gmax:=0</l>
<l>* for j:=0 to 2 by 1</l>
<l>*     if(g0[j]&gt;gmax)</l>
<l>*        gmax:= g0[j]</l>
<l>*        jmax:=j</l>
<l>*     endif</l>
<l>*     if(g0[j]&lt;gmin)</l>
<l>*        gmin:= g0[j]</l>
<l>*        jmin:=j</l>
<l>*     endif</l>
<l>* endfor</l>
<c></c>
<l>* for j:=0 to 2 by 1</l>
<l>*     if(j==jmin or j==jmax)</l>
<l>*         continue</l>
<l>*     endif</l>
<l>*     jmid:=j</l>
<l>*     gmid:=g0[j]</l>
<l>* endfor</l>
<l>err:=0</l>
<l>jmid:=1</l>
<l>gmid:=g0[1]</l>
<l>if(g0[0] &gt; g0[2])</l>
<l>    jmax:=0</l>
<l>    gmax:=g0[0]</l>
<l>    jmin:=2</l>
<l>    gmin:=g0[2]</l>
<l>else</l>
<l>    jmax:=2</l>
<l>    gmax:=g0[2]</l>
<l>    jmin:=0</l>
<l>    gmin:=g0[0]</l>
<l>endif</l>
<l>* gmax:=max2(g0[0], g0[2])</l>
<l>* gmin:=min2(g0[0], g0[2])</l>
<c></c>
<l>if(gmax &lt; rthr)</l>
<l>    PIntX[0]:=Px[jmax]</l>
<l>    PIntY[0]:=Py[jmax]</l>
<l>    err:=1</l>
<l>elseif(gmin &gt; rthr)</l>
<l>    PIntX[0]:=Px[jmin]</l>
<l>    PIntY[0]:=Py[jmin]</l>
<l>    err:=1</l>
<c>** normal interpolation case</c>
<l>elseif(gmid&gt;thr)</l>
<c>    </c>
<l>    dg:=gmid-gmin</l>
<l>    if(dg!=0)</l>
<l>        dd := (g0[jmid]-rthr)/dg</l>
<l>        PIntX[0] := Px[jmid]-(Px[jmid]-Px[jmin])*dd</l>
<l>        PIntY[0] := Py[jmid]-(Py[jmid]-Py[jmin])*dd</l>
<l>    else</l>
<l>        PIntX[0] := (Px[jmid]+Px[jmin])/2.</l>
<l>        PIntY[0] := (Py[jmid]+Py[jmin])/2.</l>
<l>    endif</l>
<l>elseif(gmid&lt;=thr)</l>
<l>    dg:=gmax-gmid</l>
<l>    if(dg!=0)</l>
<l>        dd := (g0[jmax]-rthr)/dg</l>
<l>        PIntX[0] := Px[jmax]+(Px[jmid]-Px[jmax])*dd</l>
<l>        PIntY[0] := Py[jmax]+(Py[jmid]-Py[jmax])*dd</l>
<l>    else</l>
<l>        PIntX[0] := (Px[jmid]+Px[jmax])/2.</l>
<l>        PIntY[0] := (Py[jmid]+Py[jmax])/2.</l>
<l>    endif    </l>
<l>endif</l>
<c>    </c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* if (g0[0] &gt;thr and g0[1] &gt;thr and g0[2] &gt;thr)</l>
<l>*     if (g0[0] &lt;= g0[1] and g0[0] &lt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     elseif (g0[1] &lt;= g0[0] and g0[1] &lt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0+1]</l>
<l>*         PIntY[0] := PPy[i0+1]</l>
<l>*     elseif (g0[2] &lt;= g0[1] and g0[2] &lt;= g0[0])</l>
<l>*         PIntX[0] := PPx[i0-1]</l>
<l>*         PIntY[0] := PPy[i0-1]</l>
<l>*     endif</l>
<l>*     return ()</l>
<l>* endif</l>
<l>* if (g0[0] &lt;thr and g0[1] &lt;thr and g0[2] &lt;thr)</l>
<l>*     if (g0[0] &gt;= g0[1] and g0[0] &gt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     elseif (g0[1] &gt;= g0[0] and g0[1] &gt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0+1]</l>
<l>*         PIntY[0] := PPy[i0+1]</l>
<l>*     elseif (g0[2] &gt;= g0[1] and g0[2] &gt;= g0[0])</l>
<l>*         PIntX[0] := PPx[i0-1]</l>
<l>*         PIntY[0] := PPy[i0-1]</l>
<l>*     endif</l>
<l>*     return ()</l>
<l>* endif</l>
<c></c>
<l>* if(g0[1]&gt;rthr)</l>
<l>*     if(g0[0]&lt;=rthr)</l>
<l>*         dg10 := g0[1]-g0[0]</l>
<l>*         dd0 := (g0[1]-rthr)/dg10</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     elseif(g0[2]&lt;=rthr)</l>
<l>*         dg12 := g0[1]-g0[2]</l>
<l>*         dd0 := (g0[1]-rthr)/dg12</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* elseif(g0[1]&lt;rthr)</l>
<l>*     if(g0[0]&gt;rthr)</l>
<l>*         dg01 := g0[0]-g0[1]</l>
<l>*         dd0 := (g0[1]-rthr)/dg01</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     elseif(g0[2]&lt;rthr)</l>
<l>*         dg12 := g0[1]-g0[2]</l>
<l>*         dd0 := (g0[1]-rthr)/dg12</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endif</l>
<c></c>
<l>* if(g0[2]&gt;g0[0])</l>
<l>*     dg20 := g0[2]-g0[1]</l>
<l>*     if (dg20!=0)</l>
<l>*         dd0 := (g0[1]-rthr)/dg20</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<l>* elseif(g0[2]&lt;g0[0])</l>
<l>*     dg10 := g0[1]-g0[0]</l>
<l>*     if (dg10!=0)</l>
<l>*         dd0 := -(g0[1]-rthr)/dg10</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<l>    *endif</l>
<l>* endif</l>
<c></c>
<l>* if ((g0[1] - g0[0]) &gt; (g0[1] - g0[2]))</l>
<l>*     dg10 := g0[1]-g0[0]</l>
<l>*     if (dg10!=0)</l>
<l>*         dd0 := -(g0[1]-rthr)/dg10</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<l>* else</l>
<l>*     dg20 := g0[2]-g0[1]</l>
<l>*     if (dg20!=0)</l>
<l>*         dd0 := (g0[1]-rthr)/dg20</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<c></c>
<l>* endif</l>
<l>return ()</l>
</body>
<docu id="SubPixCrdS">
<parameters>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="PPx"/>
<parameter id="PPy"/>
<parameter id="err"/>
<parameter id="g0"/>
<parameter id="i0"/>
<parameter id="sub"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc34">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc33 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>** 2022.09.15 MSSpProc34() modified very narrow space</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>merr:=0</l>
<l>err:=0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>** finding all boundary intersection points</c>
<l>for i := 0 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        PIntY[ii]:=yc</l>
<l>        PIntX[ii]:=xc</l>
<l>        PInti[ii]:=i</l>
<l>        ii:=ii+1</l>
<l>    endif</l>
<l>endfor</l>
<l>intnum:=ii</l>
<l>jSPdn:=0</l>
<l>jSPup:=ii-1</l>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>if(intnum==0)</l>
<l>    w:=0.5</l>
<l>    wmin:=0.5</l>
<l>    return()</l>
<l>elseif(intnum==1)</l>
<l>    wmax:=1.0</l>
<l>    wmin:=1.0</l>
<l>    i:=PInti[0]</l>
<l>*     return()</l>
<l>    intnum:=2</l>
<l>    PInti[0]:=i-1</l>
<l>    PInti[1]:=i+1</l>
<l>    jSPup:=1</l>
<l>endif</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    i:=PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i],  g)</l>
<l>*     typ:=j%2</l>
<l>*     if(g&lt;thr)</l>
<l>*         if(typ==0)</l>
<l>*             i:=i-1</l>
<l>*         else</l>
<l>*             i:=i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i],  g)    </l>
<l>*     endif</l>
<l>    PIntcor[j]:=i</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[i+1], PPx[i+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax:=max(g0)</l>
<l>*     gmin:=min(g0)</l>
<l>*     gmax:=max2(g0[0], g0[1])</l>
<l>    if(i&lt;pind-1 and i&gt;0)</l>
<l>        SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX:=PIntX[j]</l>
<l>        fIntY:=PIntY[j]</l>
<l>    endif</l>
<l>*     SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    if(err==1)</l>
<l>        merr:=1</l>
<l>    endif</l>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*         SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>* stop()</l>
<l>* gen_region_points(PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi:=PInti[i]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* previous clc </c>
<l>*         pclc:=-2</l>
<l>*         fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>* if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii]:=PPy[0]</l>
<l>*     PIntX[ii]:=PPx[0]</l>
<l>*     PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>*     get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if(Pval[0]==pnum)</l>
<l>*         PCLC[ii]:=clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii]:=-2</l>
<l>*     endif</l>
<l>*     ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>*     if(Pval[0]==1)</l>
<l>*         fi1:=1</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>*             PIntY[ii]:=PPy[0]</l>
<l>*             PIntX[ii]:=PPx[0]</l>
<l>*             PInti[ii]:=0</l>
<l>*             PCLC[ii]:=clc</l>
<l>*             PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>*             ii:=ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1:=0</l>
<l>* endif</l>
<c>***********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>*     if(fi1==1)</l>
<l>*         if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii:=ii-1</l>
<l>*             fi1:=0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1:=0</l>
<c>        * previous and next values</c>
<l>*         vp:=Pval[i-1]</l>
<l>*         vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>*         dev_set_color('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj(PC, Pc, PC)</l>
<l>*         dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>*             get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval(ImageIRBS, yc, xc, irbs)</l>
<c>*            </c>
<l>*                 PIntY[ii]:=yc</l>
<l>*                 PIntX[ii]:=xc</l>
<l>*                 PInti[ii]:=i</l>
<l>*                 Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>*                 if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>*                     ii:=ii+1</l>
<l>*                     PIntY[ii-1]:=yc-0.35*signY</l>
<l>*                     PIntX[ii-1]:=xc-0.35*signX</l>
<l>*                     Psubpix[ii-1]:=0</l>
<l>*                     PIntY[ii]:=yc+0.35*signY</l>
<l>*                     PIntX[ii]:=xc+0.35*signX</l>
<l>*                     PInti[ii]:=i</l>
<l>*                     Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<c>                </c>
<l>*                 PCLC[ii]:=clc</l>
<l>*                 PIRBS[ii]:=irbs</l>
<l>*                 ii:=ii+1</l>
<l>*                 pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>*         endif</l>
<l>*       endif</l>
<l>*     vp:=v</l>
<l>*     gp:=g</l>
<l>* endfor</l>
<c></c>
<c>*checking last MS pixel</c>
<l>* if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if(Pval[pind-1]==pnum)</l>
<l>*         get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc:=PCLC[ii-1]</l>
<l>*         irbs:=PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii]:=PPy[pind-1]</l>
<l>*     PIntX[ii]:=PPx[pind-1]</l>
<l>*     PInti[ii]:=pind-1</l>
<l>*     PCLC[ii]:=clc</l>
<l>*     ii:=ii+1</l>
<l>*     if(Pval[pind-2]==1)</l>
<l>*         PIntY[ii]:=PPy[pind-1]</l>
<l>*         PIntX[ii]:=PPx[pind-1]</l>
<l>*         PInti[ii]:=pind-1</l>
<l>*         PCLC[ii]:=clc</l>
<l>*         PIRBS[ii]:=irbs</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii]:=0</l>
<l>* endif</l>
<c>**************************</c>
<l>* gen_region_points(PInt, PIntY, PIntX) </l>
<l>* intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>* if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>*     wmin := 0.</l>
<l>*     wmax := 0.</l>
<l>*     shift:=0.</l>
<l>*     return()</l>
<l>* endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>* pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>*     g0[1] := g</l>
<l>*     if(PInti[j]&gt;0)</l>
<l>*         get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*         g0[0] := g</l>
<l>*     else</l>
<l>*         g0[0] := g0[1]</l>
<l>*     endif</l>
<l>*     if(PInti[j]&lt;pind-1)</l>
<l>*        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>*        g0[2] := g</l>
<l>*     else</l>
<l>*         g0[2] := g0[1]</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*             SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*         FIntX[j]:=fIntX</l>
<l>*         FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>*     if(g0[2]-g0[0]&gt;0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     elseif(g0[0]-g0[2]&gt;0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     if(pdir &gt; 0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     elseif(pdir &lt; 0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     pdir:=Pdir[j]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>* nmwc:=0</l>
<c>* MW segment</c>
<l>* mw:=-1</l>
<l>* dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*     get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*     if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*         clc:=0</l>
<l>*         for dx:=-3 to 3 by 1</l>
<l>*             for dy:=-3 to 3 by 1</l>
<l>*                 get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                 if(vclc!=0)</l>
<l>*                     clc:=vclc</l>
<l>*                     break</l>
<l>*                 endif</l>
<l>*             endfor</l>
<l>*         endfor</l>
<l>*         PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>*     else</l>
<l>*         PCLC[j]:=vclc</l>
<l>*     endif</l>
<l>*     Pnums[j]:=vpnums</l>
<l>* endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     pclc:=PCLC[j]</l>
<l>*     clc:=PCLC[j+1]</l>
<c>    </c>
<l>*     dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*     if(dclc&gt;clcmax)</l>
<l>*         if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*             continue</l>
<l>*         endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*         d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*         d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*         d:=sqrt( min2(d1,d2) )</l>
<l>*         if(d&lt;dmin)</l>
<l>*             mw:=j</l>
<l>*             nmwc:=nmwc+1</l>
<l>*             dmin:=d</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* if(mw==-1)</l>
<l>*     mw:=0</l>
<l>*     stop()</l>
<l>* endif</l>
<l>* dev_set_color('red')</l>
<l>* gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>* jSPdn:=mw</l>
<l>* jSPup:=mw+1</l>
<c></c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     if(j==mw)</l>
<l>*         continue</l>
<l>*     else</l>
<l>*         clc:=PCLC[j]</l>
<l>*         clc1:=PCLC[mw]</l>
<l>*         clc2:=PCLC[mw+1]</l>
<l>*         dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*         dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>*             if(j&lt;mw)</l>
<l>*                 dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPdn:=j</l>
<l>*                 endif</l>
<l>*             else</l>
<l>*                 dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPup:=j+1</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>* if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>*     stop()</l>
<l>* endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>* wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>wmin:=wmax</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc34">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c>* </c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'off'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="TeachingMain110">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain110 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain110">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRB">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBin" base_type="iconic" dimension="0"/>
<par name="ImIRealBin" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBout" base_type="iconic" dimension="0"/>
<par name="ImIRealBout" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="TInoDtoIRB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** BuildIRBandReal *** builds ImageIRB and ImageRealB</c>
<c>*** 220628 - TInoDtoIRB - connection InoD&lt;-&gt;CAD</c>
<l>count_obj(RegionsInoD, n)</l>
<l>ImIRBout:=ImIRBin</l>
<l>ImIRealBout:=ImIRealBin</l>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* tuple_gen_sequence (1, n, 1, SequenceINBi)</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary(RegionsInoD, RegionsInoDB, 'inner')</l>
<l>union1(RegionsInoD, RegionInoD)</l>
<l>paint_region (RegionInoD, ImIRBin, ImIRBout, 1, 'fill')</l>
<l>TInoDtoIRB:=[]</l>
<l>for j:=1 to n by 1</l>
<l>*     if(j==57)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>    select_obj(RegionsInoDB, RInoDB, j)</l>
<l>*     intersection(RInoDB, SkeletonFWM, RegionIntersection)</l>
<l>*     area_center(RegionIntersection, a, r, c)</l>
<l>*     if(a==0)</l>
<l>*         continue</l>
<l>*     endif</l>
<l>    get_region_points(RInoDB, Rows, Columns)</l>
<l>    tuple_length(Rows, nPts)</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    inner_circle(RInoD, r, c, radius)</l>
<l>    if(radius &gt; 2.0)</l>
<l>        erosion_circle(RInoD, RInoDd, 1.5)</l>
<l>    else</l>
<l>        RInoDd:=RInoD</l>
<l>    endif</l>
<c>    </c>
<l>    get_region_points(RInoDd, Rowsd, Columnsd)</l>
<l>    tuple_length(Rowsd, nPtsd)</l>
<l>    Rsel:=[Rowsd[nPtsd/2], Rowsd[nPtsd/4], Rowsd[nPtsd*3/4]] </l>
<l>    Csel:=[Columnsd[nPtsd/2], Columnsd[nPtsd/4], Columnsd[nPtsd*3/4]]</l>
<c></c>
<l>*     Rsel:=[Rows[nPts/2], Rows[nPts/4], Rows[nPts*3/4], Rows[nPts*3/8], Rows[nPts*5/8]] </l>
<l>*     Csel:=[Columns[nPts/2], Columns[nPts/4], Columns[nPts*3/4], Columns[nPts*3/8], Columns[nPts*5/8]]</l>
<l>*     gen_region_points(PP, Rsel, Csel)</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_grayval(ImageIR16, Rsel,Csel, Grayval16)</l>
<l>    tuple_median(Grayval16, pn16)</l>
<l>*     get_grayval(ImageIR16, Rsel[1],Csel[1], pn16)</l>
<l>    *     pn:= SequenceIRB[j-1]</l>
<l>    tuple_gen_const(nPts, pn, Npn)</l>
<l>    set_grayval(ImIRBout, Rows, Columns, Npn)</l>
<l>*     tuple_gen_const(nPts, j, Nj)</l>
<l>*     set_grayval(ImIRealBout, Rows, Columns, Nj)</l>
<l>*     tuple_concat(TInoDtoIRB,pn16,TInoDtoIRB)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BuildIRB">
<parameters>
<parameter id="ImIRBin"/>
<parameter id="ImIRBout"/>
<parameter id="ImIRealBin"/>
<parameter id="ImIRealBout"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="RegionsInoD"/>
<parameter id="SkeletonFWM"/>
<parameter id="TInoDtoIRB"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc34">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc34 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>merr:=0</l>
<l>err:=0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>** finding all boundary intersection points</c>
<l>for i := 0 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        PIntY[ii]:=yc</l>
<l>        PIntX[ii]:=xc</l>
<l>        PInti[ii]:=i</l>
<l>        ii:=ii+1</l>
<l>    endif</l>
<l>endfor</l>
<l>intnum:=ii</l>
<l>jSPdn:=0</l>
<l>jSPup:=ii-1</l>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>if(intnum==0)</l>
<l>    wmax:=0.0</l>
<l>    wmin:=0.0</l>
<l>    return()</l>
<l>elseif(intnum==1)</l>
<l>    wmax:=1.0</l>
<l>    wmin:=1.0</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c></c>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    i:=PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i],  g)</l>
<l>*     typ:=j%2</l>
<l>*     if(g&lt;thr)</l>
<l>*         if(typ==0)</l>
<l>*             i:=i-1</l>
<l>*         else</l>
<l>*             i:=i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i],  g)    </l>
<l>*     endif</l>
<l>    PIntcor[j]:=i</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[i+1], PPx[i+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax:=max(g0)</l>
<l>*     gmin:=min(g0)</l>
<l>*     gmax:=max2(g0[0], g0[1])</l>
<l>    if(i&lt;pind-1 and i&gt;0)</l>
<l>        SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX:=PPx[i]</l>
<l>        fIntY:=PPy[i]</l>
<l>    endif</l>
<c>    </c>
<l>    if(err==1)</l>
<l>        merr:=1</l>
<l>    endif</l>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*         SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points(PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi:=PInti[i]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* previous clc </c>
<l>*         pclc:=-2</l>
<l>*         fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>* if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii]:=PPy[0]</l>
<l>*     PIntX[ii]:=PPx[0]</l>
<l>*     PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>*     get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if(Pval[0]==pnum)</l>
<l>*         PCLC[ii]:=clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii]:=-2</l>
<l>*     endif</l>
<l>*     ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>*     if(Pval[0]==1)</l>
<l>*         fi1:=1</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>*             PIntY[ii]:=PPy[0]</l>
<l>*             PIntX[ii]:=PPx[0]</l>
<l>*             PInti[ii]:=0</l>
<l>*             PCLC[ii]:=clc</l>
<l>*             PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>*             ii:=ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1:=0</l>
<l>* endif</l>
<c>***********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>*     if(fi1==1)</l>
<l>*         if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii:=ii-1</l>
<l>*             fi1:=0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1:=0</l>
<c>        * previous and next values</c>
<l>*         vp:=Pval[i-1]</l>
<l>*         vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>*         dev_set_color('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj(PC, Pc, PC)</l>
<l>*         dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>*             get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval(ImageIRBS, yc, xc, irbs)</l>
<c>*            </c>
<l>*                 PIntY[ii]:=yc</l>
<l>*                 PIntX[ii]:=xc</l>
<l>*                 PInti[ii]:=i</l>
<l>*                 Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>*                 if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>*                     ii:=ii+1</l>
<l>*                     PIntY[ii-1]:=yc-0.35*signY</l>
<l>*                     PIntX[ii-1]:=xc-0.35*signX</l>
<l>*                     Psubpix[ii-1]:=0</l>
<l>*                     PIntY[ii]:=yc+0.35*signY</l>
<l>*                     PIntX[ii]:=xc+0.35*signX</l>
<l>*                     PInti[ii]:=i</l>
<l>*                     Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<c>                </c>
<l>*                 PCLC[ii]:=clc</l>
<l>*                 PIRBS[ii]:=irbs</l>
<l>*                 ii:=ii+1</l>
<l>*                 pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>*         endif</l>
<l>*       endif</l>
<l>*     vp:=v</l>
<l>*     gp:=g</l>
<l>* endfor</l>
<c></c>
<c>*checking last MS pixel</c>
<l>* if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if(Pval[pind-1]==pnum)</l>
<l>*         get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc:=PCLC[ii-1]</l>
<l>*         irbs:=PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii]:=PPy[pind-1]</l>
<l>*     PIntX[ii]:=PPx[pind-1]</l>
<l>*     PInti[ii]:=pind-1</l>
<l>*     PCLC[ii]:=clc</l>
<l>*     ii:=ii+1</l>
<l>*     if(Pval[pind-2]==1)</l>
<l>*         PIntY[ii]:=PPy[pind-1]</l>
<l>*         PIntX[ii]:=PPx[pind-1]</l>
<l>*         PInti[ii]:=pind-1</l>
<l>*         PCLC[ii]:=clc</l>
<l>*         PIRBS[ii]:=irbs</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii]:=0</l>
<l>* endif</l>
<c>**************************</c>
<l>* gen_region_points(PInt, PIntY, PIntX) </l>
<l>* intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>* if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>*     wmin := 0.</l>
<l>*     wmax := 0.</l>
<l>*     shift:=0.</l>
<l>*     return()</l>
<l>* endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>* pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>*     g0[1] := g</l>
<l>*     if(PInti[j]&gt;0)</l>
<l>*         get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*         g0[0] := g</l>
<l>*     else</l>
<l>*         g0[0] := g0[1]</l>
<l>*     endif</l>
<l>*     if(PInti[j]&lt;pind-1)</l>
<l>*        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>*        g0[2] := g</l>
<l>*     else</l>
<l>*         g0[2] := g0[1]</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*             SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*         FIntX[j]:=fIntX</l>
<l>*         FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>*     if(g0[2]-g0[0]&gt;0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     elseif(g0[0]-g0[2]&gt;0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     if(pdir &gt; 0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     elseif(pdir &lt; 0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     pdir:=Pdir[j]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>* nmwc:=0</l>
<c>* MW segment</c>
<l>* mw:=-1</l>
<l>* dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*     get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*     if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*         clc:=0</l>
<l>*         for dx:=-3 to 3 by 1</l>
<l>*             for dy:=-3 to 3 by 1</l>
<l>*                 get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                 if(vclc!=0)</l>
<l>*                     clc:=vclc</l>
<l>*                     break</l>
<l>*                 endif</l>
<l>*             endfor</l>
<l>*         endfor</l>
<l>*         PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>*     else</l>
<l>*         PCLC[j]:=vclc</l>
<l>*     endif</l>
<l>*     Pnums[j]:=vpnums</l>
<l>* endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     pclc:=PCLC[j]</l>
<l>*     clc:=PCLC[j+1]</l>
<c>    </c>
<l>*     dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*     if(dclc&gt;clcmax)</l>
<l>*         if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*             continue</l>
<l>*         endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*         d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*         d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*         d:=sqrt( min2(d1,d2) )</l>
<l>*         if(d&lt;dmin)</l>
<l>*             mw:=j</l>
<l>*             nmwc:=nmwc+1</l>
<l>*             dmin:=d</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* if(mw==-1)</l>
<l>*     mw:=0</l>
<l>*     stop()</l>
<l>* endif</l>
<l>* dev_set_color('red')</l>
<l>* gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>* jSPdn:=mw</l>
<l>* jSPup:=mw+1</l>
<c></c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     if(j==mw)</l>
<l>*         continue</l>
<l>*     else</l>
<l>*         clc:=PCLC[j]</l>
<l>*         clc1:=PCLC[mw]</l>
<l>*         clc2:=PCLC[mw+1]</l>
<l>*         dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*         dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>*             if(j&lt;mw)</l>
<l>*                 dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPdn:=j</l>
<l>*                 endif</l>
<l>*             else</l>
<l>*                 dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPup:=j+1</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>* if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>*     stop()</l>
<l>* endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>* wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>wmin:=wmax</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc34">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc34_COPY_1">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc33 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<l>normint := 0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<l>for i := 0 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>endfor</l>
<l>intnum := ii</l>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    return ()</l>
<l>endif</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>    wmin := wmax</l>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc34_COPY_1">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="SubPixCrdP">
<interface>
<ic>
<par name="g0" base_type="ctrl" dimension="0"/>
<par name="i0" base_type="ctrl" dimension="0"/>
<par name="PPx" base_type="ctrl" dimension="0"/>
<par name="PPy" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="err" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_real (thr, rthr)</l>
<l>if (sub==0)</l>
<l>    PIntX[0] := PPx[i0]</l>
<l>    PIntY[0] := PPy[i0]</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>Px[1]:=PPx[i0]</l>
<l>Px[0]:=PPx[i0-1]</l>
<l>Px[2]:=PPx[i0+1]</l>
<l>Py[1]:=PPy[i0]</l>
<l>Py[0]:=PPy[i0-1]</l>
<l>Py[2]:=PPy[i0+1]</l>
<c>**** finding min, max and their indices</c>
<l>jmin:=-1</l>
<l>jmax:=-1</l>
<l>gmin:=256</l>
<l>gmax:=0</l>
<c></c>
<l>err:=0</l>
<l>jmid:=1</l>
<l>gmid:=g0[1]</l>
<l>if(g0[0] &gt; g0[2])</l>
<l>    jmax:=0</l>
<l>    gmax:=g0[0]</l>
<l>    jmin:=2</l>
<l>    gmin:=g0[2]</l>
<l>else</l>
<l>    jmax:=2</l>
<l>    gmax:=g0[2]</l>
<l>    jmin:=0</l>
<l>    gmin:=g0[0]</l>
<l>endif</l>
<l>* gmax:=max2(g0[0], g0[2])</l>
<l>* gmin:=min2(g0[0], g0[2])</l>
<c></c>
<l>if(gmax &lt; rthr)</l>
<l>    PIntX[0]:=Px[jmax]</l>
<l>    PIntY[0]:=Py[jmax]</l>
<l>    err:=1</l>
<l>elseif(gmin &gt; rthr)</l>
<l>    PIntX[0]:=Px[jmin]</l>
<l>    PIntY[0]:=Py[jmin]</l>
<l>    err:=1</l>
<c>** normal interpolation case</c>
<l>elseif(gmid&gt;=thr)</l>
<c>    </c>
<l>    dg:=gmid-gmin</l>
<l>    if(dg!=0)</l>
<l>        dd := (g0[jmid]-rthr)/dg</l>
<l>        PIntX[0] := Px[jmid]-(Px[jmid]-Px[jmin])*dd</l>
<l>        PIntY[0] := Py[jmid]-(Py[jmid]-Py[jmin])*dd</l>
<l>    else</l>
<l>        PIntX[0] := (Px[jmid]+Px[jmin])/2.</l>
<l>        PIntY[0] := (Py[jmid]+Py[jmin])/2.</l>
<l>    endif</l>
<l>elseif(gmid&lt;thr)</l>
<l>    dg:=gmax-gmid</l>
<l>    if(dg!=0)</l>
<l>        dd := (g0[jmax]-rthr)/real(dg)</l>
<l>        PIntX[0] := Px[jmax]-(Px[jmid]-Px[jmax])*dd</l>
<l>        PIntY[0] := Py[jmax]-(Py[jmid]-Py[jmax])*dd</l>
<l>    else</l>
<l>        PIntX[0] := (Px[jmid]+Px[jmax])/2.</l>
<l>        PIntY[0] := (Py[jmid]+Py[jmax])/2.</l>
<l>    endif    </l>
<l>endif</l>
<c>    </c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* if (g0[0] &gt;thr and g0[1] &gt;thr and g0[2] &gt;thr)</l>
<l>*     if (g0[0] &lt;= g0[1] and g0[0] &lt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     elseif (g0[1] &lt;= g0[0] and g0[1] &lt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0+1]</l>
<l>*         PIntY[0] := PPy[i0+1]</l>
<l>*     elseif (g0[2] &lt;= g0[1] and g0[2] &lt;= g0[0])</l>
<l>*         PIntX[0] := PPx[i0-1]</l>
<l>*         PIntY[0] := PPy[i0-1]</l>
<l>*     endif</l>
<l>*     return ()</l>
<l>* endif</l>
<l>* if (g0[0] &lt;thr and g0[1] &lt;thr and g0[2] &lt;thr)</l>
<l>*     if (g0[0] &gt;= g0[1] and g0[0] &gt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     elseif (g0[1] &gt;= g0[0] and g0[1] &gt;= g0[2])</l>
<l>*         PIntX[0] := PPx[i0+1]</l>
<l>*         PIntY[0] := PPy[i0+1]</l>
<l>*     elseif (g0[2] &gt;= g0[1] and g0[2] &gt;= g0[0])</l>
<l>*         PIntX[0] := PPx[i0-1]</l>
<l>*         PIntY[0] := PPy[i0-1]</l>
<l>*     endif</l>
<l>*     return ()</l>
<l>* endif</l>
<c></c>
<l>* if(g0[1]&gt;rthr)</l>
<l>*     if(g0[0]&lt;=rthr)</l>
<l>*         dg10 := g0[1]-g0[0]</l>
<l>*         dd0 := (g0[1]-rthr)/dg10</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     elseif(g0[2]&lt;=rthr)</l>
<l>*         dg12 := g0[1]-g0[2]</l>
<l>*         dd0 := (g0[1]-rthr)/dg12</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* elseif(g0[1]&lt;rthr)</l>
<l>*     if(g0[0]&gt;rthr)</l>
<l>*         dg01 := g0[0]-g0[1]</l>
<l>*         dd0 := (g0[1]-rthr)/dg01</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     elseif(g0[2]&lt;rthr)</l>
<l>*         dg12 := g0[1]-g0[2]</l>
<l>*         dd0 := (g0[1]-rthr)/dg12</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endif</l>
<c></c>
<l>* if(g0[2]&gt;g0[0])</l>
<l>*     dg20 := g0[2]-g0[1]</l>
<l>*     if (dg20!=0)</l>
<l>*         dd0 := (g0[1]-rthr)/dg20</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<l>* elseif(g0[2]&lt;g0[0])</l>
<l>*     dg10 := g0[1]-g0[0]</l>
<l>*     if (dg10!=0)</l>
<l>*         dd0 := -(g0[1]-rthr)/dg10</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<l>    *endif</l>
<l>* endif</l>
<c></c>
<l>* if ((g0[1] - g0[0]) &gt; (g0[1] - g0[2]))</l>
<l>*     dg10 := g0[1]-g0[0]</l>
<l>*     if (dg10!=0)</l>
<l>*         dd0 := -(g0[1]-rthr)/dg10</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0-1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0-1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<l>* else</l>
<l>*     dg20 := g0[2]-g0[1]</l>
<l>*     if (dg20!=0)</l>
<l>*         dd0 := (g0[1]-rthr)/dg20</l>
<l>*         if(abs(dd0) &lt; 1.)</l>
<l>*             PIntX[0] := PPx[i0]+(PPx[i0]-PPx[i0+1])*dd0</l>
<l>*             PIntY[0] := PPy[i0]+(PPy[i0]-PPy[i0+1])*dd0</l>
<l>*         else</l>
<l>*             PIntX[0] := PPx[i0]</l>
<l>*             PIntY[0] := PPy[i0]</l>
<l>*         endif</l>
<c>        </c>
<l>*     else</l>
<l>*         PIntX[0] := PPx[i0]</l>
<l>*         PIntY[0] := PPy[i0]</l>
<l>*     endif</l>
<c></c>
<l>* endif</l>
<l>return ()</l>
</body>
<docu id="SubPixCrdP">
<parameters>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="PPx"/>
<parameter id="PPy"/>
<parameter id="err"/>
<parameter id="g0"/>
<parameter id="i0"/>
<parameter id="sub"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain110_COPY_1">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain110 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain110_COPY_1">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain111">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain111 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>gen_circle(Cr, 11895, 3182, 10)</l>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain111">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS3">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*****BuildIRBS3 - 14.09.2022</c>
<l>ImIRBSOut := ImIRBS</l>
<c>** dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<l>dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<l>union1(SkeletonsFWMSd, SkeletonsFWMSdu)</l>
<l>difference(SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<l>* difference(SkeletonsFWMSdu, RegionInoD, SkeletonsFWMSmu)</l>
<l>* connection(SkeletonsFWMSmu, SkeletonsFWMSm)</l>
<l>* intersection(SkeletonsFWMS, RegionInoD,RegionIntersection)</l>
<l>* union2(SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region(RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region(SkeletonsFWMSm, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi+stseq, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS3">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain112">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain111 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c></c>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain112">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain113">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain113 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP (RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>tuple_length(RowMSS, nMSS)</l>
<l>tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c></c>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain113">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing2">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionsPHfu" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thr2" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l> * DomainImOut := DomainIm</l>
<l>* ImOut := Im</l>
<l>* RegionsShmOut := RegionsShm</l>
<l>* ArOut := Ar</l>
<l>* arOut := ar</l>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>*     complement(R, RC)</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<c></c>
<c>* </c>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<l>test_equal_region(RegionIi, RegionI, IsEqual)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI2, RegionIi2, thr2, Width, Height)</l>
<c>*************************************</c>
<c></c>
<c>*** REMOVING Isl and PH *****</c>
<c>*******  Find Pinholes 1 ****</c>
<l>fill_up_shape (RegionI, RegionIfu, 'area', 1, fumax)</l>
<l>difference(Domain, RegionIfu, RegionISfI)</l>
<l>* fill_up_shape (RegionISfI, RegionIfuSfIf, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfuSfIf, RegionIf)</l>
<c>***********</c>
<l>* fill_up_shape (RegionI2, RegionIfu2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu2, RegionISfI2)</l>
<c>*******  Find Islands 2  ***</c>
<l>fill_up_shape (RegionI2, RegionISf2, 'area', 1, fumax)</l>
<l>difference(Domain, RegionISf2, RegionIf2)</l>
<l>* stop()</l>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<l>DetectPH2 (RegionI, Im, RegionsPHfuAll, RegionInoPh, fumax, nPHfu)</l>
<c></c>
<c>***** removing too small Pinholes from the list</c>
<l>select_shape(RegionsPHfuAll, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPHfu, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPHfu, nPH)</l>
<l>complement(RegionInoPh, RegionIS1)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS1, RC, RegionIS)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<l>* DetectIsl2n (RegionIS, Im, RegionsIslfuAll, RegionInoIsl, fumax, nIslfu)</l>
<l>* aislmax:=8000</l>
<l>* fumax:=1000</l>
<l>DetectIsl5 (RegionIS1, SkeletonG, RegionInoPh, RegionG, Im, RegionsIslfuAll, RegionInoPHnoIsl, fumax, aislmax, nIslfu)</l>
<l>difference(RegionI, RegionInoPHnoIsl,RegionDifference)</l>
<c>***** removing too small Islandss from the list</c>
<l>select_shape(RegionsIslfuAll, RegionsIslfu1, 'area', 'and', Islamin, 999999)</l>
<l>select_shape(RegionsIslfu1, RegionsIslfu, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIslfu, nIsl)</l>
<l>union1(RegionsIslfu, RegionIslfu)</l>
<l>difference(RegionI, RegionIslfu, RegionI)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH and Isl)</c>
<c></c>
<l>RegionInoD:=RegionInoPHnoIsl</l>
<c></c>
<c>************</c>
<l>* complement(RegionI, RegionIS)</l>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<c>*** zachem SkGR vmesto SkG?</c>
<l>* DetectOpenFU3 (SkeletonGnoR, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegionsOpCon, 3.0, 4, d1, nOp)</l>
<l>difference(DomainI, RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>DetectOpenN1 (SkeletonGnoR, RegionInoPHnoIsl, RegionISnoPHnoIsl, WidthImageP, DirImageP, RegionsOp, RegionsOpCon, R2)</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<l>union2(RegionInoPHnoIsl, RegionsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>* complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<c></c>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c>********** new Short</c>
<c></c>
<l>DetectShortN1 (SkeletonGS, RegionInoPHnoIsl, RegionISnoPHnoIsl, WidthImageS, DirImageS, RegionsShi, R2)</l>
<l>dev_display(RegionsShi)</l>
<c>*******</c>
<l>DetectOpenN1 (SkeletonGnoR, RegionIf2, RegionISf2, WidthImageP, DirImageP, RegionsOp2, RegionsOpCon2, R2)</l>
<l>DetectShortN1 (SkeletonGS, RegionIf2, RegionISf2, WidthImageS, DirImageS, RegionsShi2, R2)</l>
<c></c>
<c></c>
<l>* stop()</l>
<l>* DetectShortFU3 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>* DetectShortFU (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShio, 3.0, 4, nSh)</l>
<l>set_system('neighborhood', 4)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<l>difference(RegionInoPHnoIsl,RegionRemoveSh, RegionInoPHnoIslnoSh)</l>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<l>union2(RegionInoPHnoIslnoSh, RegionOpCon, RegionInoD)</l>
<c></c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing2">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsIslfu"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPHfu"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aislmax"/>
<parameter id="d1"/>
<parameter id="fumax"/>
<parameter id="path"/>
<parameter id="thr"/>
<parameter id="thr2"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing2Sp">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionI2" base_type="iconic" dimension="0"/>
<par name="RegionIS2" base_type="iconic" dimension="0"/>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="RegionInoD2" base_type="iconic" dimension="0"/>
<par name="RegionsInoD2" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thr2" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>****** Main Image Processing ****</c>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>*     complement(R, RC)</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<c></c>
<c>* </c>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<l>test_equal_region(RegionIi, RegionI, IsEqual)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI2, RegionIi2, thr2, Width, Height)</l>
<c>*************************************</c>
<c></c>
<c>*** REMOVING Isl and PH *****</c>
<c>*******  Find Pinholes 1 ****</c>
<l>* fill_up_shape (RegionI, RegionIfu, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu, RegionISfI)</l>
<l>* fill_up_shape (RegionISfI, RegionIfuSfIf, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfuSfIf, RegionIf)</l>
<c>***********</c>
<l>* fill_up_shape (RegionI2, RegionIfu2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu2, RegionISfI2)</l>
<c>*******  Find Islands 2  ***</c>
<l>* fill_up_shape (RegionI2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionIf2)</l>
<l>* stop()</l>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<c>**** for RegionIi2:</c>
<l>DetectPH2 (RegionIi2, Im, RegionsPHfuAll2, RegionI2noPh2, fumax, nPHfu)</l>
<c>**** for RegionIi:</c>
<l>union2(RegionIi, RegionsPHfuAll2, RegionI1noPh2)</l>
<l>difference(Domain, RegionI1noPh2, RegionIS1noPh2)</l>
<c>*//////// removing too small Pinholes from the list///////</c>
<l>select_shape(RegionsPHfuAll2, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPH, nPH)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>difference(Domain, RegionI2noPh2, RegionIS2noPh2)</l>
<l>* complement(RegionI2noPh2, RegionIS2noPh22)</l>
<l>* symm_difference(RegionIS2noPh2, RegionIS2noPh22, RegionDifference)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS2noPh2, RC, RegionIS2noPh2)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<l>* DetectIsl2n (RegionIS, Im, RegionsIslfuAll, RegionInoIsl, fumax, nIslfu)</l>
<l>* aislmax:=8000</l>
<l>* fumax:=1000</l>
<c>*** RegionInoPHnoIsl - removed PH2 and Isl1</c>
<c>**** for RegionIi1:</c>
<l>DetectIsl5 (RegionIS1noPh2, SkeletonG, RegionI1noPh2, RegionG, Im, RegionsIslfuAll, RegionI1noPh2noIsl1, fumax, aislmax, nIslfu)</l>
<l>difference(RegionI2noPh2, RegionsIslfuAll,RegionI2noPh2noIsl1)</l>
<c></c>
<l>difference(Domain, RegionI1noPh2noIsl1, RegionIS1noPh2noIsl1)</l>
<l>difference(Domain, RegionI2noPh2noIsl1, RegionIS2noPh2noIsl1)</l>
<c>*/////// removing too small Islandss from the list ////////*</c>
<l>select_shape (RegionsIslfuAll, RegionsIsl, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIsl, RegionsIsl, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIsl, nIsl)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>* union1(RegionsIslfu2, RegionIslfu2)</l>
<l>* difference(RegionI, RegionIslfu2, RegionI)</l>
<c></c>
<c></c>
<l>* fill_up_shape (RegionI1noPh2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionI1noPh2noIsl1)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH2 and Isl1)</c>
<c>************************************</c>
<l>* RegionInoD:=RegionInoPHnoIsl</l>
<c>*************************************</c>
<l>* difference(RegionIi, RegionIi2, RegionDifference)</l>
<l>* symm_difference(RegionIi, RegionIi2, RegionDifference)</l>
<c>************</c>
<l>* complement(RegionI, RegionIS)</l>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<c>*** zachem SkGR vmesto SkG?</c>
<l>* DetectOpenFU3 (SkeletonGnoR, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegionsOpCon, 3.0, 4, d1, nOp)</l>
<l>* difference(DomainI, RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>DetectOpenN1 (SkeletonGnoR, RegionI2noPh2noIsl1, RegionIS2noPh2noIsl1, WidthImageP, DirImageP, RegionsOp, RegionsOpCon, R2)</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<l>* union2(RegionInoPHnoIsl, RegionsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>* complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<c></c>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c>********** new Short</c>
<c></c>
<l>DetectShortN1 (SkeletonGS, RegionI1noPh2noIsl1, RegionIS1noPh2noIsl1, WidthImageS, DirImageS, RegionsShi, R2)</l>
<l>dev_display(RegionsShi)</l>
<c>*******</c>
<l>* DetectOpenN1 (SkeletonGnoR, RegionIf2, RegionISf2, WidthImageP, DirImageP, RegionsOp2, RegionsOpCon2, R2)</l>
<l>* DetectShortN1 (SkeletonGS, RegionIf2, RegionISf2, WidthImageS, DirImageS, RegionsShi2, R2)</l>
<c></c>
<c></c>
<l>* stop()</l>
<l>* DetectShortFU3 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>* DetectShortFU (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShio, 3.0, 4, nSh)</l>
<l>set_system('neighborhood', 4)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<c>******* fixing Shifts ******</c>
<l>difference(RegionI1noPh2noIsl1, RegionRemoveSh, RegionI1noPh2noIsl1noSh1)</l>
<l>difference(RegionI2noPh2noIsl1, RegionRemoveSh, RegionI2noPh2noIsl1noSh1)</l>
<c></c>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c>***** final RegionInoD 1,2 ******</c>
<l>union2(RegionI1noPh2noIsl1noSh1, RegionOpCon, RegionInoDi)</l>
<l>difference(RegionInoDi, R, RegionInoD)</l>
<l>union2(RegionI2noPh2noIsl1noSh1, RegionOpCon, RegionInoD2i)</l>
<l>difference(RegionInoD2i, R, RegionInoD2)</l>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>connection(RegionInoD2, RegionsInoD2)</l>
<c></c>
<l>get_region_points(RegionI1noPh2, Rows, Columns)</l>
<l>tuple_max(Columns, Max1)</l>
<c></c>
<c></c>
<l>get_region_points(RegionInoD2, Rows, Columns)</l>
<l>tuple_max(Columns, Max2)</l>
<l>get_region_points(RegionInoD, Rows, Columns)</l>
<l>tuple_max(Columns, Max)</l>
<c></c>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>* connection(RegionInoD, RegionsInoD)</l>
<l>* difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>* difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>* connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing2Sp">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionI"/>
<parameter id="RegionI2"/>
<parameter id="RegionIS"/>
<parameter id="RegionIS2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoD2"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsInoD2"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPH"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aislmax"/>
<parameter id="d1"/>
<parameter id="fumax"/>
<parameter id="path"/>
<parameter id="thr"/>
<parameter id="thr2"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC3MT">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC3MT -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<c></c>
<l>addr:=0</l>
<c></c>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>* jmid:=100</l>
<l>* jmid2:=1200</l>
<l>jmid:=nInoD/4</l>
<l>jmid2:=nInoD*2/4</l>
<l>jmid3:=nInoD*3/4</l>
<c></c>
<l>jbeg1:=1</l>
<l>jend1:=jmid</l>
<l>jbeg2:=jmid+1</l>
<l>jend2:=jmid2</l>
<l>jbeg3:=jmid2+1</l>
<l>jend3:=jmid3</l>
<l>jbeg4:=jmid3+1</l>
<l>jend4:=nInoD</l>
<c></c>
<l>par_start&lt;ThreadID1&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg1, jend1, lstep)</l>
<l>par_start&lt;ThreadID2&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg2, jend2, lstep)</l>
<l>par_start&lt;ThreadID3&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg3, jend3, lstep)</l>
<l>par_start&lt;ThreadID4&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg4, jend4, lstep)</l>
<c></c>
<l>par_join([ThreadID1,ThreadID2,ThreadID3,ThreadID4])</l>
<l>* BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, 1, nInoD, lstep)</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC3MT">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLCThread">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="jbeg" base_type="ctrl" dimension="0"/>
<par name="jend" base_type="ctrl" dimension="0"/>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>* addrOut := addr</l>
<l>for j:=jbeg to jend by 1</l>
<l>*     j:=44</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    tuple_length(RowsC, n1)</l>
<l>*     addrOut := addrOut+n1</l>
<l>    tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>    tuple_gen_const(n1, pn, Pn)</l>
<l>    gen_region_points(RR, RowsC, ColsC)</l>
<l>    set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<c></c>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        count_obj(RHoles, nHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>*             if(jj==16)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<c>            ****</c>
<l>*             gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>            tuple_length(RowsC, n)</l>
<c></c>
<l>*             addrOut := addrOut+n</l>
<l>*             tuple_gen_sequence(0, n/2-0.5, 0.5, Seq)</l>
<l>            tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>*             tuple_int(Seq, Seq)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>            tuple_gen_const(n, pn, Pn)</l>
<l>            set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<c></c>
<l>*             i:=i+1</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLCThread">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="RegionsInoD"/>
<parameter id="jbeg"/>
<parameter id="jend"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC3MTc">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC3MTc -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<c></c>
<l>addr:=0</l>
<c></c>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>* jmid:=100</l>
<l>* jmid2:=1200</l>
<l>jmid:=nInoD/3</l>
<l>jmid2:=nInoD*2/3</l>
<c></c>
<l>jbeg1:=1</l>
<l>jend1:=jmid</l>
<l>jbeg2:=jmid+1</l>
<l>jend2:=jmid2</l>
<l>jbeg3:=jmid2+1</l>
<l>jend3:=nInoD</l>
<c></c>
<l>Jbeg[0]:=1</l>
<l>Jend[0]:=nInoD/5</l>
<l>Jbeg[1]:=nInoD/5+1</l>
<l>Jend[1]:=nInoD*2/5</l>
<l>Jbeg[2]:=nInoD*2/5+1</l>
<l>Jend[2]:=nInoD*3/5</l>
<l>Jbeg[3]:=nInoD*3/5+1</l>
<l>Jend[3]:=nInoD*4/5</l>
<l>Jbeg[4]:=nInoD*4/5+1</l>
<l>Jend[4]:=nInoD</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>ThreadIDs := []</l>
<l>  for Index := 1 to 5 by 1</l>
<c>    par_start &lt;ThreadIDs.at(Index - 1)&gt; :BuildIRBand  CLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, Jbeg1[Index - 1], Jend1[Index - 1], lstep)</c>
<l>  endfor</l>
<l>par_join(ThreadIDs)</l>
<l>* par_start&lt;ThreadID1&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg1, jend1, lstep)</l>
<l>* par_start&lt;ThreadID2&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg2, jend2, lstep)</l>
<l>* par_start&lt;ThreadID3&gt; :BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, jbeg3, jend3, lstep)</l>
<c></c>
<l>* par_join([ThreadID1,ThreadID2,ThreadID3])</l>
<l>* BuildIRBandCLCThread (RegionsInoD, ImageIR, ImageCLC, ImageIRB, 1, nInoD, lstep)</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC3MTc">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc34_COPY_1">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSProc34 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<l>normint := 0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<l>for i := 0 to pind-1 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    if (v==pnum)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>endfor</l>
<l>intnum := ii</l>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>    wmin := wmax</l>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc34_COPY_1">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="AnglesFWMcirc2">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkelsEPver" base_type="iconic" dimension="0"/>
<par name="CircsEPver" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="epr" base_type="ctrl" dimension="0"/>
<par name="significantangleSP" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Procedure AnglesFWMcirc - finding circles at significant FWM wire angle</c>
<c>* 2022/11/15 - fixed problem with looped skeletons</c>
<c>* 2022/04/23</c>
<c></c>
<l>* connection(SkeletonGi, SkeletonsGi)</l>
<l>junctions_skeleton(SkeletonsFWM, EndPoints3, JuncPoints3)</l>
<l>union1(JuncPoints3, RegionUnion)</l>
<l>difference(SkeletonsFWM, RegionUnion, SkeletonsFWMnj)</l>
<l>union1(SkeletonsFWMnj, SkeletonGinj)</l>
<l>connection(SkeletonGinj, ConnectedRegions1)</l>
<l>split_skeleton_lines(ConnectedRegions1, 3, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>gen_region_line(RegionLines, BeginRow, BeginCol, EndRow, EndCol)</l>
<c></c>
<l>* split_skeleton_lines(SkeletonsFWM, 2, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>* gen_region_line(RegionLines, BeginRow, BeginCol, EndRow, EndCol)</l>
<l>junctions_skeleton(RegionLines, EndPointsL, JuncPointsL)</l>
<l>union1(EndPointsL, EndPointsLU)</l>
<l>area_center(EndPointsLU, nEP, R1, C1)</l>
<l>get_region_points(EndPointsLU, RowsEPU, ColsEPU)</l>
<l>count_obj(EndPointsL, nEPL)</l>
<c></c>
<l>tuple_gen_const(nEP, epr, Erad)</l>
<l>gen_circle(CircsEP, RowsEPU, ColsEPU, Erad)</l>
<l>count_obj(CircsEP, nCircsEP)</l>
<c></c>
<c>**region CircsEPU - angle region of FWM, SP should be removed for that region</c>
<l>* union1 (CircsEP, SkelsEPUver)</l>
<l>intersection (CircsEP, SkeletonsFWM, SkelsEP)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* connection (SkelsEPver, SkelsEPver)</l>
<l>count_obj(SkelsEP, nSkelsEP)</l>
<l>gen_empty_obj(SkelsEPver)</l>
<l>gen_empty_obj(CircsEPver)</l>
<l>for j:=1 to nSkelsEP by 1</l>
<l>*     if(j==10)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(SkelsEP, ObjectSelected, j)</l>
<l>    select_obj(CircsEP, ObjectSelectedC, j)</l>
<l>    get_region_points(ObjectSelected,Rows, Columns)</l>
<l>    get_grayval(DirImageP, Rows, Columns, Dirs)</l>
<c>    ***** compensating for 255 jump ***</c>
<l>    Dirsi:=Dirs</l>
<l>    tuple_length(Dirs, nD)</l>
<l>    for jjj:=0 to nD-2 by 1</l>
<l>        d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>        if(d &gt; 128)</l>
<l>            d:= d-255</l>
<l>        elseif(d &lt; -128)</l>
<l>            d:= d+255</l>
<l>        endif</l>
<l>        Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>    endfor</l>
<c>    ************************************</c>
<l>    tuple_max(Dirs, dmax)</l>
<l>    tuple_min(Dirs, dmin)</l>
<l>    d:=dmax-dmin</l>
<l>    if(d&gt;significantangleSP*180/256)</l>
<c>     ****** significant dir change</c>
<l>     concat_obj(SkelsEPver, ObjectSelected,SkelsEPver)</l>
<l>     concat_obj(CircsEPver, ObjectSelectedC,CircsEPver)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="AnglesFWMcirc2">
<parameters>
<parameter id="CircsEPver"/>
<parameter id="DirImageP"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkelsEPver"/>
<parameter id="epr"/>
<parameter id="significantangleSP"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC41">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC41 -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<l>get_domain(Im, Domain)</l>
<l>addr:=0</l>
<l>nmax:=0</l>
<l>tuple_gen_sequence(0, 400000, lstep, SeqM)</l>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=104</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>*     erosion_circle(RInoD, RegionErosion, 1)</l>
<l>*     get_region_polygon(RegionErosion, 1, RowsP, ColumnsP)</l>
<l>*     get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<l>*     get_region_polygon(RInoD, 0.5, RowsP, ColumnsP)</l>
<l>*     tuple_length(RowsInoD, nId)</l>
<l>*     Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/8]] </l>
<l>*     Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/8]]</l>
<c>    </c>
<l>    tuple_length(RowsC, nIc)</l>
<l>    RselC:=[RowsC[nIc/2], RowsC[nIc/4], RowsC[nIc*3/8]] </l>
<l>    CselC:=[ColsC[nIc/2], ColsC[nIc/4], ColsC[nIc*3/8]]</l>
<l>*     Rsel:=RowsInoD</l>
<l>*     Csel:=ColsInoD</l>
<l>*     get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>*     tuple_median(Grayval, pn)</l>
<c>    </c>
<l>    get_grayval(ImageIR, RselC,CselC, GrayvalC)</l>
<l>    tuple_median(GrayvalC, pnC)</l>
<l>    if(GrayvalC[0]!=GrayvalC[1] or GrayvalC[2]!=GrayvalC[1])</l>
<l>        RselC:=[RowsC[nIc/8], RowsC[nIc/4], RowsC[nIc*3/8], RowsC[nIc/2], RowsC[nIc*5/8], RowsC[nIc*6/8], RowsC[nIc*7/8], RowsC[nIc*2/3], RowsC[nIc/3]] </l>
<l>        CselC:=[ColsC[nIc/8], ColsC[nIc/4], ColsC[nIc*3/8], ColsC[nIc/2], ColsC[nIc*5/8], ColsC[nIc*7/8], ColsC[nIc*7/8], ColsC[nIc*2/3], ColsC[nIc/3]]</l>
<l>        get_grayval(ImageIR, RselC,CselC, GrayvalC2)</l>
<l>        tuple_median(GrayvalC2, pnC)</l>
<l>    endif</l>
<l>*     tuple_max(GrayvalC, ma)</l>
<l>*     tuple_min(GrayvalC, mi)</l>
<l>*     if(ma!=mi)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     tuple_equal(GrayvalC,Grayval,Equal)</l>
<l>*     if(Equal==0)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(pn!=pnC)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    tuple_length(RowsC, n1)</l>
<l>*     if(n1&gt;nmax)</l>
<l>*         nmax:=n1</l>
<l>*     endif</l>
<l>     addr:= addr+n1</l>
<l>*     tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<c>     </c>
<l>    tuple_select_range(SeqM, 0, n1*lstep-lstep, Seq)</l>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<l>*     gen_region_points(Region, RowsC, ColsC)</l>
<c>*     overpaint_region</c>
<c></c>
<l>    tuple_gen_const(n1, pnC, Pn)</l>
<l>    set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<l>*     gen_region_points(RR, RowsC, ColsC)</l>
<l>*     overpaint_region(ImageIRB, RR, pn, 'fill')</l>
<c></c>
<c>    </c>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        count_obj(RHoles, nHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>*             if(jj==3)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>*             complement(Hole, HoleComp)</l>
<l>            difference(Domain, Hole,  HoleComp)</l>
<l>            boundary(HoleComp, HoleB, 'inner')</l>
<c>            </c>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<l>*             get_region_polygon(HoleComp, 1, Rows, Columns)</l>
<c>            </c>
<l>            gen_region_points(HoleP, RowsC, ColsC)</l>
<l>            boundary(HoleP, HolePB, 'outer')</l>
<c>            </c>
<c>            </c>
<l>*             boundary(Hole, HoleB, 'outer')</l>
<c>* *            fill_up(HoleB, HoleBFU)</c>
<l>*             set_system('neighborhood',4)</l>
<l>*             get_region_contour(HoleB, RowsC, ColsC)</l>
<l>*             gen_region_points(HoleP, RowsC, ColsC)</l>
<c>            ****</c>
<l>            tuple_length(RowsC, n)</l>
<l>*             if(n&gt;nmax)</l>
<l>*                 nmax:=1</l>
<l>*             endif</l>
<c></c>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>            tuple_select_range(SeqM, 0, n*lstep-lstep, Seq)</l>
<l>            tuple_max(ColsC, cm)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>            tuple_gen_const(n, pnC, Pn)</l>
<l>            set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<l>*             gen_region_points(RR, RowsC, ColsC)</l>
<l>*             overpaint_region(ImageIRB, RR, pn, 'fill')</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC41">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBandCLC4">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC4 -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB:=ImagePN</l>
<l>ImageCLC:=ImageChainLength</l>
<c></c>
<l>addr:=0</l>
<l>nmax:=0</l>
<l>tuple_gen_sequence(0, 200000, lstep, SeqM)</l>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=44</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>    get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<l>    tuple_length(RowsInoD, nId)</l>
<l>    Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/4]] </l>
<l>    Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/4]]</l>
<c>    </c>
<l>    tuple_length(RowsC, nIc)</l>
<l>    RselC:=[RowsC[nIc/2], RowsC[nIc/4], RowsC[nIc*3/4]] </l>
<l>    CselC:=[ColsC[nIc/2], ColsC[nIc/4], ColsC[nIc*3/4]]</l>
<l>*     Rsel:=RowsInoD</l>
<l>*     Csel:=ColsInoD</l>
<l>    get_grayval(ImageIR, Rsel,Csel, Grayval)</l>
<l>    tuple_median(Grayval, pn)</l>
<c>    </c>
<l>    get_grayval(ImageIR, RselC,CselC, GrayvalC)</l>
<l>    tuple_equal_elem(Grayval,GrayvalC,Equal)</l>
<c>    </c>
<l>    tuple_median(GrayvalC, pnC)</l>
<l>*     if(pn!=pnC)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    tuple_length(RowsC, n1)</l>
<l>*     if(n1&gt;nmax)</l>
<l>*         nmax:=n1</l>
<l>*     endif</l>
<l>     addr:= addr+n1</l>
<l>*     tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<l>    tuple_select_range(SeqM, 0, n1*lstep-lstep, Seq)</l>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<l>    gen_region_points(Region, RowsC, ColsC)</l>
<c>*     overpaint_region</c>
<c></c>
<l>    tuple_gen_const(n1, pnC, Pn)</l>
<l>    set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<l>*     gen_region_points(RR, RowsC, ColsC)</l>
<l>*     overpaint_region(ImageIRB, RR, pn, 'fill')</l>
<c></c>
<c>    </c>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        count_obj(RHoles, nHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>*             if(jj==16)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>            boundary(Hole, HoleB, 'outer')</l>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<c>            ****</c>
<l>            tuple_length(RowsC, n)</l>
<l>*             if(n&gt;nmax)</l>
<l>*                 nmax:=1</l>
<l>*             endif</l>
<c></c>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>            tuple_select_range(SeqM, 0, n*lstep-lstep, Seq)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>            tuple_gen_const(n, pnC, Pn)</l>
<l>            set_grayval(ImageIRB, RowsC, ColsC, Pn)</l>
<l>*             gen_region_points(RR, RowsC, ColsC)</l>
<l>*             overpaint_region(ImageIRB, RR, pn, 'fill')</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBandCLC4">
<parameters>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR"/>
<parameter id="ImageIRB"/>
<parameter id="ImagePN"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="analyze_graph_event">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="MouseMapping" base_type="ctrl" dimension="0"/>
<par name="Button" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectIn" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="PosesIn" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldIn" base_type="ctrl" dimension="0"/>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationlIn" base_type="ctrl" dimension="0"/>
<par name="MaxNumModels" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectOut" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldOut" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure reflects</c>
<c>* - the pose change that was introduced by the user by</c>
<c>*   moving the mouse</c>
<c>* - the selection of a single object</c>
<c>* </c>
<l>global tuple gIsSinglePose</l>
<c>* </c>
<l>ButtonHoldOut := ButtonHoldIn</l>
<l>PosesOut := PosesIn</l>
<l>SelectedObjectOut := SelectedObjectIn</l>
<l>WindowCenteredRotationOut := WindowCenteredRotationlIn</l>
<l>VisualizeTB := max(SelectedObjectOut) != 0</l>
<l>InvLog2 := 1.0 / log(2)</l>
<c>* </c>
<l>if (Button == MouseMapping[6])</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + Alt (32) + left mouse button (1) =&gt; Toggle rotation center position</c>
<c>    * If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2</c>
<l>    count_seconds (Seconds)</l>
<l>    if (WindowCenteredRotationOut == 1)</l>
<l>        WindowCenteredRotationOut := 2</l>
<l>    else</l>
<l>        WindowCenteredRotationOut := 1</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Button == MouseMapping[5] and |ObjectModel3DID| &lt;= MaxNumModels)</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + left mouse button (1) =&gt; Select an object</c>
<l>    try</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'true')</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        get_display_scene_3d_info (WindowHandleBuffer, Scene3D, Row, Column, 'object_index', ModelIndex)</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'false')</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, no selection possible</c>
<l>        return ()</l>
<l>    endtry</l>
<l>    if (ModelIndex == -1)</l>
<c>        * Background click:</c>
<l>        if (sum(SelectedObjectOut) == |SelectedObjectOut|)</l>
<c>            * If all objects are already selected, deselect all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,0)</l>
<l>        else</l>
<c>            * Otherwise select all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,1)</l>
<l>        endif</l>
<l>    else</l>
<c>        * Object click:</c>
<l>        SelectedObjectOut[ModelIndex] := not SelectedObjectOut[ModelIndex]</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>else</l>
<c>    * Change the pose</c>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    NumModels := |ObjectModel3DID|</l>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * Set trackball fixed in the center of the window</c>
<l>    TrackballCenterRow := Height / 2</l>
<l>    TrackballCenterCol := Width / 2</l>
<l>    if (|ObjectModel3DID| &lt; MaxNumModels)</l>
<l>        if (WindowCenteredRotationOut == 1)</l>
<l>            get_trackball_center_fixed (SelectedObjectIn, TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3DID, PosesIn, WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObjectIn, TrackballRadiusPixel, ObjectModel3DID, PosesIn, TBCenter, TBSize)</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (min(SelectedObjectOut) == 0 and max(SelectedObjectOut) == 1)</l>
<c>        * At this point, multiple objects do not necessary have the same</c>
<c>        * pose any more. Consequently, we have to return a tuple of poses</c>
<c>        * as output of visualize_object_model_3d</c>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<l>    count_channels (BackgroundImage, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * Alt (32) =&gt; lower sensitivity</c>
<l>    tuple_rsh (Button, 5, BAnd)</l>
<l>    if (BAnd % 2)</l>
<l>        SensFactor := 0.1</l>
<l>    else</l>
<l>        SensFactor := 1.0</l>
<l>    endif</l>
<l>    IsButtonTrans := MouseMapping[0] == Button or (32 + MouseMapping[0]) == Button</l>
<l>    IsButtonRot := MouseMapping[1] == Button or (32 + MouseMapping[1]) == Button</l>
<l>    IsButtonDist := MouseMapping[2] == Button or (32 + MouseMapping[2]) == Button or MouseMapping[3] == Button or (32 + MouseMapping[3]) == Button or MouseMapping[4] == Button or (32 + MouseMapping[4]) == Button</l>
<l>    if (IsButtonTrans)</l>
<c>        * Translate in XY-direction</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonTrans)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonTrans := ButtonLoop == Button</l>
<l>                MRow2 := MRow1 + (Row - MRow1) * SensFactor</l>
<l>                MCol2 := MCol1 + (Column - MCol1) * SensFactor</l>
<l>                get_line_of_sight (MRow1, MCol1, CamParam, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>                get_line_of_sight (MRow2, MCol2, CamParam, PX, PY, PZ, QX2, QY2, QZ2)</l>
<l>                Len := sqrt(QX1 * QX1 + QY1 * QY1 + QZ1 * QZ1)</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                Translate := [QX2 - QX1,QY2 - QY1,QZ2 - QZ1] * Dist / Len</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut == 1, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonDist)</l>
<c>        * Change the Z distance</c>
<l>        MRow1 := Row</l>
<l>        while (IsButtonDist)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonDist := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                DRow := MRow2 - MRow1</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                TranslateZ := -Dist * DRow * 0.003 * SensFactor</l>
<l>                TBCenter[2] := TBCenter[2] + TranslateZ</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonRot)</l>
<c>        * Rotate the object</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonRot)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonRot := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                MCol2 := Column</l>
<c>                * Transform the pixel coordinates to relative image coordinates</c>
<l>                MX1 := (TrackballCenterCol - MCol1) / (0.5 * MinImageSize)</l>
<l>                MY1 := (TrackballCenterRow - MRow1) / (0.5 * MinImageSize)</l>
<l>                MX2 := (TrackballCenterCol - MCol2) / (0.5 * MinImageSize)</l>
<l>                MY2 := (TrackballCenterRow - MRow2) / (0.5 * MinImageSize)</l>
<c>                * Compute the quaternion rotation that corresponds to the mouse</c>
<c>                * movement</c>
<l>                trackball (MX1, MY1, MX2, MY2, VirtualTrackball, TrackballSize, SensFactor, RelQuaternion)</l>
<c>                * Transform the quaternion to a rotation matrix</c>
<l>                quat_to_hom_mat3d (RelQuaternion, HomMat3DRotRel)</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DIn)</l>
<l>                            hom_mat3d_compose (HomMat3DRotRel, HomMat3DIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DInTmp1)</l>
<l>                    hom_mat3d_compose (HomMat3DRotRel, HomMat3DInTmp1, HomMat3DInTmp)</l>
<l>                    hom_mat3d_translate (HomMat3DInTmp, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut2 := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    PosesOut := PosesOut2</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    endif</l>
<l>    PosesOut := PosesIn</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="analyze_graph_event">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Reflect the pose change that was introduced by the user by moving the mouse</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage"/>
<parameter id="Button"/>
<parameter id="ButtonHoldIn"/>
<parameter id="ButtonHoldOut"/>
<parameter id="CamParam"/>
<parameter id="Column"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="Information"/>
<parameter id="Labels"/>
<parameter id="MaxNumModels"/>
<parameter id="MouseMapping"/>
<parameter id="ObjectModel3DID"/>
<parameter id="PosesIn"/>
<parameter id="PosesOut"/>
<parameter id="Row"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObjectIn"/>
<parameter id="SelectedObjectOut"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="Title"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
<parameter id="WindowCenteredRotationOut"/>
<parameter id="WindowCenteredRotationlIn"/>
<parameter id="WindowHandle"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="append_length_or_values">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Feature" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>if (Mode == 'get_lengths')</l>
<c>    * Output in 'get_lengths' mode is the length of the feature</c>
<l>    ExtendedResults := [AccumulatedResults,|Feature|]</l>
<l>elseif (Mode == 'calculate')</l>
<c>    * Output in 'calculate' mode is the feature vector</c>
<l>    ExtendedResults := [AccumulatedResults,Feature]</l>
<l>else</l>
<l>    ExtendedResults := AccumulatedResults</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_length_or_values">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures.
Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_custom_features and get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="ExtendedResults">
<default_type>real</default_type>
<description lang="en_US">The accumulated results extended by the feature vector or its length.</description>
</parameter>
<parameter id="Feature">
<description lang="en_US">Current feature vector.</description>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_names_or_groups">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Name" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>ExtendedResults := AccumulatedResults</l>
<l>if (Mode == 'get_names')</l>
<l>    FirstOccurrence := |AccumulatedResults| == 0 or find(AccumulatedResults,Name) == -1</l>
<l>    BelongsToGroup := find([Name,Groups],CurrentName) != -1 or CurrentName == 'all'</l>
<l>    if (FirstOccurrence and BelongsToGroup)</l>
<c>        * Output in 'get_names' mode is the name of the feature</c>
<l>        ExtendedResults := [AccumulatedResults,Name]</l>
<l>    endif</l>
<l>elseif (Mode == 'get_groups')</l>
<l>    ExtendedResults := [AccumulatedResults,Groups]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_names_or_groups">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures. Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_custom_features and get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExtendedResults">
<default_type>string</default_type>
<description lang="en_US">The accumulated results extended by the feature name or the feature groups.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Name">
<default_type>string</default_type>
<description lang="en_US">Feature name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_names_or_groups_pyramid">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="Names" base_type="ctrl" dimension="0"/>
<par name="NameRegExp" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>ExtendedResults := AccumulatedResults</l>
<l>if (Mode == 'get_names')</l>
<l>    BelongsToGroup := find(Groups,CurrentName) != -1 or CurrentName == 'all'</l>
<l>    if (CurrentName =~ NameRegExp)</l>
<l>        Names := CurrentName</l>
<l>    elseif (not BelongsToGroup)</l>
<l>        Names := []</l>
<l>    endif</l>
<l>    TmpNames := []</l>
<l>    for J := 0 to |Names| - 1 by 1</l>
<l>        FirstOccurrence := |AccumulatedResults| == 0 or find(AccumulatedResults,Names[J]) == -1</l>
<l>        if (FirstOccurrence)</l>
<c>            * Output in 'get_names' mode is the name of the feature</c>
<l>            TmpNames := [TmpNames,Names[J]]</l>
<l>        endif</l>
<l>    endfor</l>
<l>    ExtendedResults := [AccumulatedResults,TmpNames]</l>
<l>elseif (Mode == 'get_groups')</l>
<l>    ExtendedResults := [AccumulatedResults,Groups]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_names_or_groups_pyramid">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures. Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
</parameter>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExtendedResults">
<default_type>string</default_type>
<description lang="en_US">The accumulated results depending on the mode extended by the feature names or the feature groups.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="NameRegExp">
<default_type>string</default_type>
<description lang="en_US">Regular expression that describes the feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Names">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_color_intensity">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ColorSpace" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate color features</c>
<c>* </c>
<c>* Transform an RGB image into the given ColorSpace</c>
<c>* and calculate the mean gray value and the deviation</c>
<c>* for all three channels.</c>
<c>* </c>
<l>count_channels (Image, Channels)</l>
<l>if (Channels != 3)</l>
<l>    throw (['Error when calculating feature ' + ColorSpace + '_' + Mode,'Please use a 3-channel RGB image or remove color feature from the list.'])</l>
<l>endif</l>
<l>decompose3 (Image, R, G, B)</l>
<l>if (ColorSpace == 'rgb')</l>
<l>    intensity (Region, R, Mean1, Deviation1)</l>
<l>    intensity (Region, G, Mean2, Deviation2)</l>
<l>    intensity (Region, B, Mean3, Deviation3)</l>
<l>else</l>
<l>    trans_from_rgb (R, G, B, I1, I2, I3, ColorSpace)</l>
<l>    intensity (Region, I1, Mean1, Deviation1)</l>
<l>    intensity (Region, I2, Mean2, Deviation2)</l>
<l>    intensity (Region, I3, Mean3, Deviation3)</l>
<l>endif</l>
<l>if (Mode == 'mean')</l>
<l>    Tmp1 := Mean1</l>
<l>    Tmp2 := Mean2</l>
<l>    Tmp3 := Mean3</l>
<l>elseif (Mode == 'deviation')</l>
<l>    Tmp1 := Deviation1</l>
<l>    Tmp2 := Deviation2</l>
<l>    Tmp3 := Deviation3</l>
<l>endif</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (NumRegions &gt; 0)</l>
<l>    Index := [0:3:3 * NumRegions - 1]</l>
<l>    Feature[Index] := Tmp1</l>
<l>    Feature[1 + Index] := Tmp2</l>
<l>    Feature[2 + Index] := Tmp3</l>
<l>else</l>
<l>    Feature := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_color_intensity">
<abstract lang="en_US">This procedure transforms the RGB image Image into the given ColorSpace and calculates the mean gray value and the deviation for all three channels.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate color intensity features.</short>
<parameters>
<parameter id="ColorSpace">
<default_type>string</default_type>
<default_value>'cielab'</default_value>
<description lang="en_US">Target color space.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'rgb'</item>
<item>'cielab'</item>
<item>'hls'</item>
</value_list>
</parameter>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">RGB image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'mean'</default_value>
<description lang="en_US">Feature that is calculated from the transformed color values.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mean'</item>
<item>'deviation'</item>
</values>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined. </description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_edge_density">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the edge density, i.e.</c>
<c>* the ratio of the edge amplitudes to the area of the region.</c>
<c>* </c>
<l>union1 (Region, RegionUnion)</l>
<l>reduce_domain (Image, RegionUnion, ImageReduced)</l>
<l>area_center (Region, Area, Row, Column)</l>
<l>get_image_size (ImageReduced, Width, Height)</l>
<l>if (Width &gt; 1 and Height &gt; 1)</l>
<l>    sobel_amp (ImageReduced, EdgeAmplitude, 'sum_abs', 3)</l>
<l>    area_center_gray (Region, EdgeAmplitude, AreaGray, Row, Column)</l>
<l>    ZeroIndex := find(Area,0)</l>
<l>    if (ZeroIndex != -1)</l>
<l>        Area[ZeroIndex] := 1</l>
<l>        AreaGray[ZeroIndex] := 0</l>
<l>    endif</l>
<l>    Feature := AreaGray / Area</l>
<l>else</l>
<l>    Feature := gen_tuple_const(|Area|,0.0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_edge_density">
<abstract lang="en_US">Calculate the edge density, i.e., the ratio of the edge amplitudes to the area of the region.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate edge density.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_edge_density_histogram">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NumBins" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the edge density histogram, i.e.</c>
<c>* the ratio of the edge amplitude histogram to the area of the region.</c>
<c>* </c>
<l>Feature := []</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (ImageWidth &gt; 1 and ImageHeight &gt; 1)</l>
<l>    access_channel (Image, Channel1, 1)</l>
<l>    sobel_amp (Channel1, EdgeAmplitude, 'sum_abs', 3)</l>
<l>    for J := 1 to NumRegions by 1</l>
<l>        select_obj (Region, RegionSelected, J)</l>
<l>        area_center (RegionSelected, Area, Row, Column)</l>
<l>        if (Area &gt; 0)</l>
<l>            gray_histo_range (RegionSelected, EdgeAmplitude, 0, 255, NumBins, Histo, BinSize)</l>
<l>            Feature := [Feature,real(Histo) / sum(Histo)]</l>
<l>        else</l>
<l>            Feature := [Feature,1.0,gen_tuple_const(NumBins - 1,0.0)]</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    Feature := gen_tuple_const(NumRegions * NumBins,0.0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_edge_density_histogram">
<abstract lang="en_US">Calculate the edge density histogram, i.e. the ratio of the edge amplitude histogram to the area of the region.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate edge density histogram feature.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumBins">
<default_type>integer</default_type>
<default_value>4</default_value>
<description lang="en_US">Number of bins of the edge density histogram.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_grad_dir_histo">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NumBins" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gradient direction histogram</c>
<c>* </c>
<l>access_channel (Image, Channel1, 1)</l>
<l>count_obj (Region, NumRegions)</l>
<l>Feature := []</l>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionSelected, Index)</l>
<l>    reduce_domain (Channel1, RegionSelected, ImageReduced)</l>
<l>    sobel_dir (ImageReduced, EdgeAmplitude, EdgeDirection, 'sum_abs_binomial', 3)</l>
<l>    gray_histo_range (RegionSelected, EdgeDirection, 0, 179, NumBins, Histo, BinSize)</l>
<l>    Sum := sum(Histo)</l>
<l>    if (Sum != 0)</l>
<l>        Feature := [Feature,real(Histo) / Sum]</l>
<l>    else</l>
<l>        Feature := [Feature,Histo]</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_grad_dir_histo">
<abstract lang="en_US">Calculate the gradient direction histogram.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the gradient direction histogram.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumBins">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Number of bins of the gradient direction histogram.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_gray_proj">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gray-value projections and their histograms</c>
<c>* </c>
<l>count_obj (Region, NumRegions)</l>
<l>Feature := []</l>
<c>* </c>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionTmp, Index)</l>
<c>    * Test empty region</c>
<l>    get_region_points (RegionTmp, RowsTmp, ColumnsTmp)</l>
<l>    if (|RowsTmp| == 0)</l>
<l>        HorProjectionFilledUp := gen_tuple_const(Size,-1.0)</l>
<l>        VertProjectionFilledUp := gen_tuple_const(Size,-1.0)</l>
<l>    else</l>
<c>        * Zoom image and region to Size x Size pixels</c>
<l>        smallest_rectangle1 (RegionTmp, Row1, Column1, Row2, Column2)</l>
<l>        move_region (RegionTmp, RegionMoved, -Row1, -Column1)</l>
<l>        crop_rectangle1 (Image, ImageTmp, Row1, Column1, Row2, Column2)</l>
<l>        ScaleHeight := real(Size) / (Row2 - Row1 + 1)</l>
<l>        ScaleWidth := real(Size) / (Column2 - Column1 + 1)</l>
<l>        zoom_image_factor (ImageTmp, ImageTmp, ScaleWidth, ScaleHeight, 'constant')</l>
<l>        zoom_region (RegionMoved, RegionTmp, ScaleWidth, ScaleHeight)</l>
<c>        * Calculate gray value projection</c>
<l>        gray_projections (RegionTmp, ImageTmp, 'simple', HorProjection, VertProjection)</l>
<c>        * Fill up projection in case the zoomed region is smaller than</c>
<c>        * Size x Size pixels due to interpolation effects</c>
<l>        smallest_rectangle1 (RegionTmp, Row1, Column1, Row2, Column2)</l>
<l>        HorProjectionFilledUpFront := [gen_tuple_const(max2(0,Row1),-1.0),HorProjection]</l>
<l>        HorProjectionFilledUp := [HorProjectionFilledUpFront,gen_tuple_const(Size - |HorProjectionFilledUpFront|,-1.0)]</l>
<l>        VertProjectionFilledUpFront := [gen_tuple_const(max2(0,Column1),-1.0),VertProjection]</l>
<l>        VertProjectionFilledUp := [VertProjectionFilledUpFront,gen_tuple_const(Size - |VertProjectionFilledUpFront|,-1.0)]</l>
<l>    endif</l>
<l>    if (Mode == 'hor')</l>
<l>        Feature := [Feature,HorProjectionFilledUp]</l>
<l>    elseif (Mode == 'vert')</l>
<l>        Feature := [Feature,VertProjectionFilledUp]</l>
<l>    elseif (Mode == 'hor_histo')</l>
<l>        tuple_histo_range (HorProjectionFilledUp, 0, 255, Size, Histo, BinSize)</l>
<l>        Feature := [Feature,Histo]</l>
<l>    elseif (Mode == 'vert_histo')</l>
<l>        tuple_histo_range (VertProjectionFilledUp, 0, 255, Size, Histo, BinSize)</l>
<l>        Feature := [Feature,Histo]</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_gray_proj">
<abstract lang="en_US">Calculate gray-value projections and their histograms.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate gray-value projections and their histograms.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'hor'</default_value>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'hor'</item>
<item>'vert'</item>
<item>'hor_histo'</item>
<item>'vert_histo'</item>
</value_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Resolution of the gray value projection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_polar_gray_proj">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Features" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gray-value projections of</c>
<c>* polar-transformed image regions.</c>
<c>* </c>
<l>count_obj (Region, NumRegions)</l>
<l>Features := []</l>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionSelected, Index)</l>
<l>    smallest_circle (RegionSelected, Row, Column, Radius)</l>
<l>    polar_trans_image_ext (Image, PolarTransImage, Row, Column, 0, rad(360), 0, max([Radius,1]), Width, Height, 'bilinear')</l>
<c>    * </c>
<l>    if (Mode == 'hor_gray')</l>
<l>        gray_projections (PolarTransImage, PolarTransImage, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_gray')</l>
<l>        gray_projections (PolarTransImage, PolarTransImage, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_amp')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'sum_abs', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_amp')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'sum_abs', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_x')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'x_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_x')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'x_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_y')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'y_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_y')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'y_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    else</l>
<l>        throw ('Unknown Mode: ' + Mode + ' in calc_feature_polar_proj')</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_polar_gray_proj">
<abstract lang="en_US">Calculate gray-value projections of polar-transformed image regions.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate gray-value projections of polar-transformed image regions.</short>
<parameters>
<parameter id="Features">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<default_value>40</default_value>
<description lang="en_US">Height of the polar transformed image.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'hor_gray'</item>
<item>vert_gray'</item>
<item>'hor_sobel_amp'</item>
<item>'vert_sobel_amp'</item>
<item>'hor_sobel_x'</item>
<item>'vert_sobel_x'</item>
<item>'hor_sobel_y'</item>
<item>'vert_sobel_y'</item>
</value_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">Width of the polar transformed image.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_pyramid">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FeatureName" base_type="ctrl" dimension="0"/>
<par name="NumLevels" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate a feature for different pyramid levels</c>
<c>* </c>
<l>Zoom := 0.5</l>
<l>Feature := []</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (NumRegions &gt; 0)</l>
<l>    for I := 1 to NumLevels by 1</l>
<l>        if (I &gt; 1)</l>
<l>            zoom_image_factor (ImageZoom, ImageZoom, Zoom, Zoom, 'constant')</l>
<l>            zoom_region (RegionZoom, RegionZoom, Zoom, Zoom)</l>
<l>            calculate_features (RegionZoom, ImageZoom, FeatureName, Features)</l>
<l>        else</l>
<l>            copy_obj (Image, ImageZoom, 1, 1)</l>
<l>            copy_obj (Region, RegionZoom, 1, NumRegions)</l>
<l>            calculate_features (RegionZoom, ImageZoom, FeatureName, Features)</l>
<l>            FeatureLength := |Features| / NumRegions</l>
<l>            Step := NumLevels * FeatureLength</l>
<l>        endif</l>
<l>        Indices := []</l>
<l>        for J := 0 to NumRegions - 1 by 1</l>
<l>            Start := J * Step + (I - 1) * FeatureLength</l>
<l>            End := Start + FeatureLength - 1</l>
<l>            Indices := [Indices,[Start:End]]</l>
<l>        endfor</l>
<l>        Feature[Indices] := Features</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_pyramid">
<abstract lang="en_US">Calculate a feature on multiple image pyramid levels.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate a feature on different image pyramid levels.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FeatureName">
<default_type>string</default_type>
<description lang="en_US">Name of the feature that shall be calculated on multiple pyramid levels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumLevels">
<default_type>integer</default_type>
<default_value>4</default_value>
<description lang="en_US">Number of pyramid levels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
<values>
<item>2</item>
<item>3</item>
<item>4</item>
</values>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Features" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate features given in FeatureNames</c>
<c>* for the input regions in Region</c>
<c>* (if needed supported by the underlying</c>
<c>* gray-value or color image Image).</c>
<c>* </c>
<l>get_features (Region, Image, FeatureNames, 'calculate', Features)</l>
<l>return ()</l>
</body>
<docu id="calculate_features">
<abstract lang="en_US">calculate_features calculates the features indicated in FeatureNames for each input region in Region, if necessary using the underlying gray values of  Image, and returns the feature vectors in Features. If the input region contains several unconnected components that are to be classified individually, they should be separated, e.g., using connection before calculating the features.

The feature vectors in Features are sorted as follows:
The full first feature comes first for regions, then the second feature, and so on ([F1R1, F1R2,...,F1Rm,F2R1,...,F2Rm,...,FnRm] with FiRj being the feature vector for the i-th feature and the j-th region). This corresponds to the 'feature_column' order used by add_sample_class_train_data.

_____________________________________________________

HOW TO USE THE CALCULATE_FEATURE_SET.HDPL LIBRARY
_____________________________________________________

1. Overview

The library contains a set of convenience procedures to calculate features of pre-segmented regions and images. The contained features belong to several groups. This makes it easier to access only features with particular characteristics.

2. Available procedures

- query_feature_group_names
Query all available feature groups.

- query_feature_names_by_group
Get a list of all features and the groups they belong to.

- get_feature_names
Get a list of all features belonging to one or more given groups.

- get_feature_lengths
Get the lengths of the feature vectors of given features.

- calculate_features
Calculate multiple features of one or more input regions in one call.

While already a large number of features is contained in the library, it is designed in a way that it can be easily extended by user-defined features. To do this, simply follow the instructions contained in the comments of the get_custom_feature procedure. There also exists a convenience procedure that allows to test if features are implemented according to the library specifications.

- test_features (Names)
 If a problem is detected, the test_features procedure throws an exception.

3. Usage

The procedure is designed to be used together with HALCON's automatic feature selection.
First, choose the features of the group(s) that are suitable for your application. E.g.:

get_feature_names ('REGION', RegionFeatureNames)

Then, prepare training data structure for automatic feature selection:

get_feature_lengths (RegionFeatureNames, Lengths)
create_class_train_data (sum(Lengths), ClassTrainDataHandle)
set_feature_lengths_class_train_data (ClassTrainDataHandle, Lengths, RegionFeatureNames)

Then, calculate features for the samples and add them to the class_train_data:

calculate_features (RegionsClass0, Image, RegionFeatureNames, Features0)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features0, 0)
calculate_features (RegionsClass1, Image, RegionFeatureNames, Features1)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features1, 1)

Then, select the best features automatically:

select_feature_set_mlp (ClassTrainDataHandle, 'greedy', [], [], MLPHandle, SelectedFeatures, Score)

Finally, use the resulting classifier to classify the data:

calculate_features (ObjectSelected, Image, SelectedFeatures, Features)
classify_class_mlp (MLPHandle, Features, 1, Class, Confidence)

For more information of the implemented features, see get_features.
</abstract>
<alternatives>
<item>region_features</item>
<item>gray_features</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<example lang="en_US">* Query group names and corresponding features 
query_feature_group_names (AllGroupNames)
query_feature_names_by_group (AllGroupNames, FeatureNames, Groups)
* Get region features and their lengths
get_feature_names ('REGION', RegionFeatureNames)
get_feature_lengths (RegionFeatureNames, Lengths)
* Prepare training data structure 
create_class_train_data (sum(Lengths), ClassTrainDataHandle)
set_feature_lengths_class_train_data (ClassTrainDataHandle, Lengths, RegionFeatureNames)
* Segment training samples
read_image (Image, 'clip')
binary_threshold (Image, Region, 'otsu', 'dark', UsedThreshold)
connection (Region, ConnectedRegions)
select_obj (ConnectedRegions, RegionsClass0, [2,5,9]) 
select_obj (ConnectedRegions, RegionsClass1, [3,8,13])
* Train class 0
calculate_features (RegionsClass0, Image, RegionFeatureNames, Features0)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features0, 0)
* Train class 1
calculate_features (RegionsClass1, Image, RegionFeatureNames, Features1)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features1, 1)
* Select suitable features
select_feature_set_mlp (ClassTrainDataHandle, 'greedy', [], [], MLPHandle, SelectedFeatures, Score)
* Classify all regions with selected feature(s)
Color := ['blue','orange']
count_obj (ConnectedRegions, Number)
for I := 1 to Number by 1
select_obj (ConnectedRegions, ObjectSelected, I)
calculate_features (ObjectSelected, Image, SelectedFeatures, Features)
classify_class_mlp (MLPHandle, Features, 1, Class, Confidence)
dev_set_color (Color[Class])
dev_display (ObjectSelected)
endfor

</example>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>connection</item>
<item>select_shape</item>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
</predecessor>
<see_also>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
<item>add_sample_class_train_data</item>
<item>select_feature_set_knn</item>
<item>select_feature_set_svm</item>
<item>select_feature_set_mlp</item>
</see_also>
<short lang="en_US">Calculate one or more features of a given image and/or region.</short>
<successor>
<item>add_sample_class_train_data</item>
<item>classify_class_knn</item>
<item>classify_class_svm</item>
<item>classify_class_mlp</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<default_value>'area'</default_value>
<description lang="en_US">Names of the feature to be calculated. These names are typically obtained from get_feature_names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'area'</item>
<item>'width'</item>
<item>'height'</item>
<item>'ra'</item>
<item>'rb'</item>
<item>'phi'</item>
<item>'roundness'</item>
<item>'num_sides'</item>
<item>'num_connected'</item>
<item>'num_holes'</item>
<item>'area_holes'</item>
<item>'max_diameter'</item>
<item>'orientation'</item>
<item>'outer_radius'</item>
<item>'inner_radius'</item>
<item>'inner_width'</item>
<item>'inner_height'</item>
<item>'circularity'</item>
<item>'compactness'</item>
<item>'convexity'</item>
<item>'rectangularity'</item>
<item>'anisometry'</item>
<item>'bulkiness'</item>
<item>'struct_factor'</item>
<item>'dist_mean'</item>
<item>'dist_deviation'</item>
<item>'euler_number'</item>
<item>'rect2_phi'</item>
<item>'rect2_len1'</item>
<item>'rect2_len2'</item>
<item>'contlength'</item>
<item>'porosity'</item>
<item>'gray_area'</item>
<item>'gray_ra'</item>
<item>'gray_rb'</item>
<item>'gray_phi'</item>
<item>'gray_min'</item>
<item>'gray_max'</item>
<item>'gray_range'</item>
<item>'gray_mean'</item>
<item>'gray_deviation'</item>
<item>'gray_plane_deviation'</item>
<item>'gray_anisotropy'</item>
<item>'gray_entropy'</item>
<item>'gray_hor_proj'</item>
<item>'gray_vert_proj'</item>
<item>'gray_hor_proj_histo'</item>
<item>'gray_vert_proj_histo'</item>
<item>'grad_dir_histo'</item>
<item>'edge_density'</item>
<item>'edge_density_histogram'</item>
<item>'edge_density_pyramid_2'</item>
<item>'edge_density_pyramid_3'</item>
<item>'edge_density_pyramid_4'</item>
<item>'edge_density_histogram_pyramid_2'</item>
<item>'edge_density_histogram_pyramid_3'</item>
<item>'edge_density_histogram_pyramid_4'</item>
<item>'cooc'</item>
<item>'cooc_pyramid_2'</item>
<item>'cooc_pyramid_3'</item>
<item>'cooc_pyramid_4'</item>
<item>'polar_gray_proj'</item>
<item>'polar_grad_proj'</item>
<item>'polar_grad_x_proj'</item>
<item>'polar_grad_y_proj'</item>
<item>'polar_gray_proj_histo'</item>
<item>'cielab_mean'</item>
<item>'cielab_dev'</item>
<item>'hls_mean'</item>
<item>'hls_dev'</item>
<item>'rgb_mean'</item>
<item>'rgb_dev'</item>
</values>
</parameter>
<parameter id="Features">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image, from which the features are calculated.</description>
<sem_type>image</sem_type>
</parameter>
<parameter id="Region">
<description lang="en_US">Input region(s), from which the features are calculated.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_lines_gauss_parameters">
<interface>
<ic>
<par name="MaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sigma" base_type="ctrl" dimension="0"/>
<par name="Low" base_type="ctrl" dimension="0"/>
<par name="High" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Check control parameters</c>
<l>if (|MaxLineWidth| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 1')</l>
<l>endif</l>
<l>if (not is_number(MaxLineWidth))</l>
<l>    throw ('Wrong type of control parameter: 1')</l>
<l>endif</l>
<l>if (MaxLineWidth &lt;= 0)</l>
<l>    throw ('Wrong value of control parameter: 1')</l>
<l>endif</l>
<l>if (|Contrast| != 1 and |Contrast| != 2)</l>
<l>    throw ('Wrong number of values of control parameter: 2')</l>
<l>endif</l>
<l>if (min(is_number(Contrast)) == 0)</l>
<l>    throw ('Wrong type of control parameter: 2')</l>
<l>endif</l>
<c>* Set and check ContrastHigh</c>
<l>ContrastHigh := Contrast[0]</l>
<l>if (ContrastHigh &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<c>* Set or derive ContrastLow</c>
<l>if (|Contrast| == 2)</l>
<l>    ContrastLow := Contrast[1]</l>
<l>else</l>
<l>    ContrastLow := ContrastHigh / 3.0</l>
<l>endif</l>
<c>* Check ContrastLow</c>
<l>if (ContrastLow &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<l>if (ContrastLow &gt; ContrastHigh)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the parameters Sigma, Low, and High for lines_gauss</c>
<l>if (MaxLineWidth &lt; sqrt(3.0))</l>
<c>    * Note that LineWidthMax &lt; sqrt(3.0) would result in a Sigma &lt; 0.5,</c>
<c>    * which does not make any sense, because the corresponding smoothing</c>
<c>    * filter mask would be of size 1x1.</c>
<c>    * To avoid this, LineWidthMax is restricted to values greater or equal</c>
<c>    * to sqrt(3.0) and the contrast values are adapted to reflect the fact</c>
<c>    * that lines that are thinner than sqrt(3.0) pixels have a lower contrast</c>
<c>    * in the smoothed image (compared to lines that are sqrt(3.0) pixels wide).</c>
<l>    ContrastLow := ContrastLow * MaxLineWidth / sqrt(3.0)</l>
<l>    ContrastHigh := ContrastHigh * MaxLineWidth / sqrt(3.0)</l>
<l>    MaxLineWidth := sqrt(3.0)</l>
<l>endif</l>
<c>* Convert LineWidthMax and the given contrast values into the input parameters</c>
<c>* Sigma, Low, and High required by lines_gauss</c>
<l>HalfWidth := MaxLineWidth / 2.0</l>
<l>Sigma := HalfWidth / sqrt(3.0)</l>
<l>Help := -2.0 * HalfWidth / (sqrt(6.283185307178) * pow(Sigma,3.0)) * exp(-0.5 * pow(HalfWidth / Sigma,2.0))</l>
<l>High := fabs(ContrastHigh * Help)</l>
<l>Low := fabs(ContrastLow * Help)</l>
<l>return ()</l>
</body>
<docu id="calculate_lines_gauss_parameters">
<abstract lang="en_US">calculate_lines_gauss_parameters calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted.

MaxLineWidth defines the maximum width of the lines to be extracted with lines_gauss.

Contrast should be set to the gray value contrast of a typical line to be extracted. All lines that have a higher contrast will be extracted in any case.

Optionally, the parameter Contrast may contain a second value, which then defines the minimum contrast of the lines to be extracted. This second value of the parameter Contrast must not be larger than the first value. If only one value is given, the minimum contrast is set to Contrast/3.0. A smaller value for the minimum contrast results in longer lines, which extend into areas with low contrast. A higher value results in shorter but more salient lines.

Note that lines_gauss uses a hysteresis thresholding approach, that uses the parameters Low and High, which are calculated from MaxLineWidth and the two contrast values described above. In simple terms, the hysteresis thresholding approach works such that all points that lie on lines with a contrast above (the first value of) Contrast are considered as salient line points. These salient line points are extended with neighboring line points as long as those line points have a contrast above the minimum contrast.</abstract>
<chapters lang="de_DE">
<item>Filter</item>
<item>Linien</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Lines</item>
</chapters>
<example lang="en_US">read_image (Image, 'mreut')
*
calculate_lines_gauss_parameters (30, 60, Sigma, Low, High)
*
lines_gauss (Image, Lines, Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')
dev_display (Image)
dev_display (Lines)</example>
<keywords lang="en_US">
<item>extract lines</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<references lang="en_US">Carsten Steger: Unbiased Extraction of Curvilinear Structures from 2D and 3D Images. Dissertation. Fakultät für Informatik, Technische Universität München, 1998.</references>
<short lang="en_US">Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted.</short>
<successor>
<item>lines_gauss</item>
</successor>
<parameters>
<parameter id="Contrast">
<default_type>real</default_type>
<default_value>60</default_value>
<description lang="en_US">Typical contrast of the lines to be extracted with lines_gauss. Optionally, a tuple with two values may be given. Then, the second value defines the minimum contrast of the lines to be extracted and must not be larger than the first value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>20</item>
<item>40</item>
<item>60</item>
<item>80</item>
<item>100</item>
<item>150</item>
<item>[60,5]</item>
<item>[60, 50]</item>
</values>
</parameter>
<parameter id="High">
<default_type>real</default_type>
<description lang="en_US">Parameter High to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Low">
<default_type>real</default_type>
<description lang="en_US">Parameter Low to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="MaxLineWidth">
<default_type>real</default_type>
<default_value>5</default_value>
<description lang="en_US">Maximum width of the lines to be extracted with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>3</item>
<item>5</item>
<item>10</item>
<item>20</item>
<item>30</item>
</values>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<description lang="en_US">Parameter Sigma to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_tool_in_base_robot_path_poses">
<interface>
<ic>
<par name="ToolInModelRobotPathPoses" base_type="ctrl" dimension="1"/>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ToolInBaseRobotPathPoses" base_type="ctrl" dimension="1"/>
</oc>
</interface>
<body>
<c>* </c>
<l>read_message_tuple (Poses, 'OrderOfTransform', OrderOfTransform)</l>
<l>read_message_tuple (Poses, 'OrderOfRotation', OrderOfRotation)</l>
<l>read_message_tuple (Poses, 'ViewOfTransform', ViewOfTransform)</l>
<c>* </c>
<l>for Index1 := 0 to ToolInModelRobotPathPoses.length() - 1 by 1</l>
<l>    pose_compose (ModelInBasePose, ToolInModelRobotPathPoses.at(Index1), ToolInBaseRobotPathPose)</l>
<l>    convert_pose_type (ToolInBaseRobotPathPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ToolInBaseRobotPathPose)</l>
<l>    ToolInBaseRobotPathPoses.at(Index1) := ToolInBaseRobotPathPose</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calculate_tool_in_base_robot_path_poses">
<abstract lang="en_US">This procedure uses the pose of an object ModelInBasePose and the robot path poses ToolInModelRobotPathPoses to calculate the poses which can be used to approach, grasp, ... the object. 

To get the correct pose type for your robot, the input message Poses must contain the parameters OrderOfTransform, OrderOfRotation, and ViewOfTransform.</abstract>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Posen</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Poses</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the poses to grasp an object.</short>
<parameters>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the current match.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Must contain the parameters OrderOfTransform, OrderOfRotation, and ViewOfTransform.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBaseRobotPathPoses">
<default_type>real</default_type>
<description lang="en_US">Poses to approach, grasp, ... the current object.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInModelRobotPathPoses">
<default_type>real</default_type>
<description lang="en_US">Trained poses to approach, grasp, ... an object.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_camera_and_plane_single_image">
<interface>
<ic>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>read_message_obj (ImageCaltab, CalibObjectData, 'ImageCaltab')</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>read_message_tuple (CalibObjectData, 'StartCamParam', StartCamParam)</l>
<c>* </c>
<c>* Check input</c>
<l>if (StartCamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* </c>
<c>* Create a HALCON calibration data model.</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<c>* Set the needed calibration information.</c>
<l>set_calib_data_cam_param (CalibDataID, 0, [], StartCamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CalPlateDescr)</l>
<c>* Find the calibration plate.</c>
<l>find_calib_object (ImageCaltab, CalibDataID, 0, 0, 0, [], [])</l>
<c>* Calibrating from only one view requires some parameter to be excluded</c>
<c>* from the optimization.</c>
<l>set_calib_data (CalibDataID, 'camera', 0, 'excluded_settings', 'focus')</l>
<c>* Calibrate the camera.</c>
<l>calibrate_cameras (CalibDataID, ErrorCamCalibInPixel)</l>
<c>* Get the calibration results.</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParam)</l>
<l>get_calib_data (CalibDataID, 'calib_obj_pose', [0,0], 'pose', PlaneInCamPose0)</l>
<l>set_origin_pose (PlaneInCamPose0, 0, 0, CalPlateThickness, PlaneInCamPose)</l>
<c>* Convert pose to standard pose type.</c>
<l>convert_pose_type (PlaneInCamPose, 'Rp+T', 'gba', 'point', PlaneInCamPose)</l>
<c>* </c>
<c>* Add data to output message.</c>
<l>set_message_tuple (CalibObjectData, 'ErrorCamCalibInPixel', ErrorCamCalibInPixel)</l>
<l>set_message_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>set_message_tuple (CalibObjectData, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* Clean up.</c>
<l>clear_calib_data (CalibDataID)</l>
<l>return ()</l>
</body>
<docu id="calibrate_camera_and_plane_single_image">
<abstract lang="en_US">This procedure calibrates a camera with a single image of a calibration plate in the measurement plane. The input message CalibObjectData containing the necessary data can easily be collected with the procedure collect_single_image_calibration_data.

The optimized camera parameters are stored in CamParam.
The output parameter ErrorCamCalibInPixel returns the error of the camera calibration of the current setup.
The plane that is defined by the calibration plate is first corrected using the thickness of the calibration plate and then stored in the parameter PlaneInCamPose. These three parameters are saved in the message CalibObjectData, in addition to the already available input parameters.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Monokular</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Monocular</item>
</chapters>
<keywords lang="en_US">
<item>set_message_tuple</item>
</keywords>
<library lang="en_US">MVTec Internal Procedures</library>
<predecessor>
<item>collect_single_image_calibration_data</item>
</predecessor>
<short lang="en_US">Calibrate a camera with a single image.</short>
<successor>
<item>get_message_tuple</item>
</successor>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_hand_eye_stationary_cam_approx">
<interface>
<ic>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="RowsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ColumnsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePoses" base_type="ctrl" dimension="1"/>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>read_message_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>read_message_tuple (CalibObjectData, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* </c>
<c>* Check input</c>
<l>if (|RowsTouchingPointInPlane| &lt; 3 or |ColumnsTouchingPointInPlane| &lt; 3 or ToolInBasePoses.length() &lt; 3)</l>
<l>    throw ('Please specify at least three image coordinates and robot poses.')</l>
<l>endif</l>
<l>if (|RowsTouchingPointInPlane| != |ColumnsTouchingPointInPlane| or |RowsTouchingPointInPlane| != ToolInBasePoses.length())</l>
<l>    throw ('The number of image coordinates and robot poses have to be equal.')</l>
<l>endif</l>
<l>if (CamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* </c>
<c>* If points on top of the calibration plate are approached, we have to adapt the PlaneInCamPose accordingly.</c>
<l>set_origin_pose (PlaneInCamPose, 0, 0, -CalPlateThickness, PlaneInCamPose)</l>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePoses.at(0), OrderOfTransform0, OrderOfRotation0, ViewOfTransform0)</l>
<l>convert_pose_type (ToolInBasePoses.at(0), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(0))</l>
<l>for Index := 1 to ToolInBasePoses.length() - 1 by 1</l>
<l>    get_pose_type (ToolInBasePoses.at(Index), OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    if (OrderOfTransform0 != OrderOfTransform or OrderOfRotation0 != OrderOfRotation or ViewOfTransform0 != ViewOfTransform)</l>
<l>        throw ('ToolInBasePoses have different pose types.')</l>
<l>    endif</l>
<c>    * Convert to default pose type.</c>
<l>    convert_pose_type (ToolInBasePoses.at(Index), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(Index))</l>
<l>endfor</l>
<c>* </c>
<c>* Collect the robot translations.</c>
<l>create_pose (RobotTouchingPointInToolCoordinates[0], RobotTouchingPointInToolCoordinates[1], RobotTouchingPointInToolCoordinates[2], 0, 0, 0, 'Rp+T', 'gba', 'point', TouchingPointInToolPose)</l>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<l>for Index := 0 to |RowsTouchingPointInPlane| - 1 by 1</l>
<l>    pose_compose (ToolInBasePoses.at(Index), TouchingPointInToolPose, TouchingPointInBasePose)</l>
<l>    XBase := [XBase,TouchingPointInBasePose[0]]</l>
<l>    YBase := [YBase,TouchingPointInBasePose[1]]</l>
<l>    ZBase := [ZBase,TouchingPointInBasePose[2]]</l>
<l>endfor</l>
<c>* </c>
<c>* Get the plane coordinates of the input image points.</c>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, 'm', XPlane, YPlane)</l>
<l>tuple_gen_const (|XPlane|, 0, ZPlane)</l>
<l>vector_to_hom_mat3d ('rigid', XPlane, YPlane, ZPlane, XBase, YBase, ZBase, HomMat3DPlaneToBase)</l>
<l>hom_mat3d_to_pose (HomMat3DPlaneToBase, PlaneInBasePose)</l>
<c>* If points on top of the calibration plate are approached, we have to readapt the Plane accordingly.</c>
<l>set_origin_pose (PlaneInCamPose, 0, 0, CalPlateThickness, PlaneInCamPose)</l>
<l>set_origin_pose (PlaneInBasePose, 0, 0, CalPlateThickness, PlaneInBasePose)</l>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, BaseInPlanePose, BaseInCamPose)</l>
<c>* </c>
<c>* Get the BaseInCamPose.</c>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, BaseInPlanePose, BaseInCamPose)</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (BaseInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, BaseInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInBasePose)</l>
<c></c>
<c>* Get the difference of the points in the plane as seen by the camera</c>
<c>* to the points in the plane as approached by the robot.</c>
<l>affine_trans_point_3d (HomMat3DPlaneToBase, XPlane, YPlane, ZPlane, XPlaneBase, YPlaneBase, ZPlaneBase)</l>
<l>DiffX := XPlaneBase - XBase</l>
<l>DiffY := YPlaneBase - YBase</l>
<l>DiffZ := ZPlaneBase - ZBase</l>
<l>SqrDiff := DiffX * DiffX + DiffY * DiffY + DiffZ * DiffZ</l>
<l>PlanePointsRMS := sqrt(sum(SqrDiff) / |DiffX|)</l>
<l>PlanePointsMaxDiff := max(sqrt(SqrDiff))</l>
<c>* </c>
<c>* Create output message.</c>
<l>create_message (HandEyeCalibData)</l>
<l>set_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>set_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsRMS', PlanePointsRMS)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsMaxDiff', PlanePointsMaxDiff)</l>
<l>return ()</l>
</body>
<docu id="calibrate_hand_eye_stationary_cam_approx">
<abstract lang="en_US">This procedures performs an approximate hand-eye calibration of a six-axis robot for the case where a camera is stationary with respect to the robot. The measurement plane of the robot has to be observable and known with respect to the camera.

The parameter RobotTouchingPointInToolCoordinates describes a point on the gripper that touches the measurement plane. If the tool coordinate system already lies in the gripper, the touching point is a 1 x 3 vector with all its entries being zero. Otherwise, the vector describes the translation in x-, y- and z-direction of the tool origin to the touching point.
Please note that the touching point has to be fixed w.r.t. the tool coordinate system, but does not have to be located on the surface of the gripper, i.e. it can lie halfway between two fingers of a gripper.

The parameters RowsTouchingPointInPlane and ColsTouchingPointInPlane are the image coordinates in row and column direction, respectively that have been approached by the touching point. The corresponding robot poses have to be specified in the parameter ToolInBasePoses. 

Please note that at least three row, column and robot poses have to be used and that these parameters have to be of equal
size. It is further important that all row and column coordinates lie in the plane PlaneInCamPose and that the touching point of the robot has to approach the plane exactly at these points.

The input message CalibObjectData must contain the following data: 
  - The internal camera parameters have to be specified in the parameter CamParam.
  - The parameter PlaneInCamPose describes the measurement plane with respect to the camera.
  - The parameter CalPlateThickness describes the thickness of the calibration plate, in meters.

The output parameters are stored in the message HandEyeCalibData. The following data is stored:
  - The camera parameters CamParam.
  - The parameter BaseInCamPose, which is the pose of the robot's base with respect to the camera.
  - The parameter PlaneInBasePose, which is the pose of the plane with respect to the robot's base.
  - The parameters PlaneInCamPose, which is the pose of the plane with respect to the camera.
  - A qualitative statement about the calibration and the measurement plane is given in the parameters PlanePointsRMS and PlanePointsMaxDiff: The PlanePointsRMS describes the root mean square error of the difference between the rows and columns projected into the measurement plane and the identical points that have been approached by the touching point. The PlanePointsMaxDiff describes the maximum error of the Euclidean distances of the projected and the approached points. </abstract>
<alternatives>
<item>calibrate_hand_eye_stationary_cam_approx_without_calib_plate</item>
<item>calibrate_hand_eye</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_nearest_finder_pattern_coordinates</item>
</predecessor>
<short lang="en_US">Perform a hand-eye calibration with a stationary camera.</short>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ColumnsTouchingPointInPlane">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Column coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US"> Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowsTouchingPointInPlane">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Row coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePoses">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Robot positions that have been acquired while touching the corresponding image points.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_hand_eye_stationary_cam_approx_without_calib_plate">
<interface>
<ic>
<par name="RowsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ColumnsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePoses" base_type="ctrl" dimension="1"/>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="DistanceObjectTouchingPointToPlane" base_type="ctrl" dimension="0"/>
<par name="DistancePlaneToCamera" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Check input.</c>
<l>if (|RowsTouchingPointInPlane| &lt; 4 or |ColumnsTouchingPointInPlane| &lt; 4 or ToolInBasePoses.length() &lt; 4)</l>
<l>    throw ('Please specify at least four image coordinates and robot poses.')</l>
<l>endif</l>
<l>if (|RowsTouchingPointInPlane| != |ColumnsTouchingPointInPlane| or |RowsTouchingPointInPlane| != ToolInBasePoses.length())</l>
<l>    throw ('The number of image coordinates and robot poses have to be equal.')</l>
<l>endif</l>
<l>if (Width &lt;= 0 or Height &lt;= 0)</l>
<l>    throw ('Width or Height must be greater than 0.')</l>
<l>endif</l>
<l>if (DistancePlaneToCamera &lt;= 0)</l>
<l>    throw ('DistancePlaneToCamera must be greater than 0.')</l>
<l>endif</l>
<l>if (DistancePlaneToCamera &lt;= 0)</l>
<l>    throw ('DistanceObjectTouchingPointToPlane must be greater than 0.')</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePoses.at(0), OrderOfTransform0, OrderOfRotation0, ViewOfTransform0)</l>
<l>convert_pose_type (ToolInBasePoses.at(0), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(0))</l>
<l>for Index := 1 to ToolInBasePoses.length() - 1 by 1</l>
<l>    get_pose_type (ToolInBasePoses.at(Index), OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    if (OrderOfTransform0 != OrderOfTransform or OrderOfRotation0 != OrderOfRotation or ViewOfTransform0 != ViewOfTransform)</l>
<l>        throw ('ToolInBasePoses have different pose types.')</l>
<l>    endif</l>
<c>    * Convert to default pose type.</c>
<l>    convert_pose_type (ToolInBasePoses.at(Index), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(Index))</l>
<l>endfor</l>
<c>* </c>
<c>* Collect the robot translations.</c>
<l>create_pose (RobotTouchingPointInToolCoordinates[0], RobotTouchingPointInToolCoordinates[1], RobotTouchingPointInToolCoordinates[2], 0, 0, 0, 'Rp+T', 'gba', 'point', RobotTouchingPointToToolXYZPose)</l>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<l>for Index := 0 to |RowsTouchingPointInPlane| - 1 by 1</l>
<l>    pose_compose (ToolInBasePoses.at(Index), RobotTouchingPointToToolXYZPose, TouchingPointInBasePose)</l>
<l>    XBase := [XBase,TouchingPointInBasePose[0]]</l>
<l>    YBase := [YBase,TouchingPointInBasePose[1]]</l>
<l>    ZBase := [ZBase,TouchingPointInBasePose[2]]</l>
<l>endfor</l>
<c>* </c>
<c>*  Use the specified robot translations to obtain the PlaneInBasePose.</c>
<l>gen_object_model_3d_from_points (XBase, YBase, ZBase, OM3DPlanePoints)</l>
<l>fit_primitives_object_model_3d (OM3DPlanePoints, 'primitive_type', 'plane', OM3DPlane)</l>
<l>get_object_model_3d_params (OM3DPlane, 'primitive_pose', TouchingPointPlaneInBasePose)</l>
<c>* </c>
<c>* Obtain fictitious camera parameters.</c>
<l>FocusOrig := 0.008</l>
<l>DiffRow := RowsTouchingPointInPlane[0:|RowsTouchingPointInPlane| - 2] - RowsTouchingPointInPlane[1:|RowsTouchingPointInPlane| - 1]</l>
<l>DiffCol := ColumnsTouchingPointInPlane[0:|ColumnsTouchingPointInPlane| - 2] - ColumnsTouchingPointInPlane[1:|ColumnsTouchingPointInPlane| - 1]</l>
<l>DistPixel := sqrt(DiffRow * DiffRow + DiffCol * DiffCol)</l>
<l>DiffX := XBase[0:|XBase| - 2] - XBase[1:|XBase| - 1]</l>
<l>DiffY := YBase[0:|YBase| - 2] - YBase[1:|YBase| - 1]</l>
<l>DiffZ := ZBase[0:|ZBase| - 2] - ZBase[1:|ZBase| - 1]</l>
<l>DistWorld := sqrt(DiffX * DiffX + DiffY * DiffY + DiffZ * DiffZ)</l>
<l>Quotient := median(DistWorld / DistPixel)</l>
<c>* Camera parameter will be generated in the following form:</c>
<l>* SX := Quotient * FocusOrig / DistancePlaneToCamera</l>
<l>* SY := SX</l>
<l>* gen_cam_par_area_scan_division (FocusOrig, 0, SX, SY, Width / 2.0, Height / 2.0, Width, Height, HandEyeCalibData)</l>
<c>* </c>
<c>* Use the specified image points and robot translations to obtain the BaseInCamPose.</c>
<l>FocusShift := [0.1,0.2,0.33,0.5,0.75,1.0,1.5,2,3,3.125,3.5,4]</l>
<l>BestIndex := -1</l>
<c>* The value of focus should not have much influence when camera and plane are parallel,</c>
<c>* but just in case, check different values.</c>
<l>ErrorBasePoseInPixel := 1e9</l>
<l>for NumFocus := 0 to |FocusShift| - 1 by 1</l>
<l>    Focus := FocusOrig * FocusShift[NumFocus]</l>
<l>    SX := Quotient * Focus / DistancePlaneToCamera</l>
<l>    SY := SX</l>
<l>    gen_cam_par_area_scan_division (Focus, 0, SX, SY, Width / 2.0, Height / 2.0, Width, Height, CamParam0)</l>
<l>    vector_to_pose (XBase, YBase, ZBase, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, CamParam0, 'iterative', 'error', BaseInCamPose0, ErrorBasePoseInPixelTmp)</l>
<l>    if (ErrorBasePoseInPixel &gt; ErrorBasePoseInPixelTmp)</l>
<l>        BaseInCamPose := BaseInCamPose0</l>
<l>        ErrorBasePoseInPixel := ErrorBasePoseInPixelTmp</l>
<l>        CamParam := CamParam0</l>
<l>    endif</l>
<l>endfor</l>
<c>* Get the PlaneInCamPose.</c>
<l>pose_compose (BaseInCamPose, TouchingPointPlaneInBasePose, TouchingPointPlaneInCamPose)</l>
<c>* </c>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>TouchingPointPlaneInCamPose0Rot := TouchingPointPlaneInCamPose</l>
<l>TouchingPointPlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (TouchingPointPlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (TouchingPointPlaneInCamPose, SwitchZDirection, TouchingPointPlaneInCamPose1)</l>
<l>    TouchingPointPlaneInCamPose := TouchingPointPlaneInCamPose1</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, TouchingPointPlaneInCamPose, TouchingPointPlaneInBasePose)</l>
<l>endif</l>
<c>* </c>
<c>* Get the difference of the points in the plane as seen by the camera</c>
<c>* to the points in the plane as approached by the robot.</c>
<l>image_points_to_world_plane (CamParam, TouchingPointPlaneInCamPose, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, 'm', TouchingPointPlanePointsCamX, TouchingPointPlanePointsCamY)</l>
<l>tuple_gen_const (|TouchingPointPlanePointsCamY|, 0.0, TouchingPointPlanePointsCamZ)</l>
<l>pose_invert (TouchingPointPlaneInBasePose, BaseInTouchingPointPlanePose)</l>
<l>pose_to_hom_mat3d (BaseInTouchingPointPlanePose, HomMat3D1)</l>
<l>affine_trans_point_3d (HomMat3D1, XBase, YBase, ZBase, TouchingPointPlanePointsToolX, TouchingPointPlanePointsToolY, TouchingPointPlanePointsToolZ)</l>
<l>DiffX := TouchingPointPlanePointsCamX - TouchingPointPlanePointsToolX</l>
<l>DiffY := TouchingPointPlanePointsCamY - TouchingPointPlanePointsToolY</l>
<l>DiffZ := TouchingPointPlanePointsCamZ - TouchingPointPlanePointsToolZ</l>
<l>SqrDiff := DiffX * DiffX + DiffY * DiffY + DiffZ * DiffZ</l>
<l>PlanePointsRMS := sqrt(sum(SqrDiff) / |DiffX|)</l>
<l>PlanePointsMaxDiff := max(sqrt(SqrDiff))</l>
<c>* </c>
<l>set_origin_pose (TouchingPointPlaneInBasePose, 0, 0, DistanceObjectTouchingPointToPlane, PlaneInBasePose)</l>
<l>set_origin_pose (TouchingPointPlaneInCamPose, 0, 0, DistanceObjectTouchingPointToPlane, PlaneInCamPose)</l>
<c>* </c>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (BaseInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, BaseInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInBasePose)</l>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInCamPose)</l>
<c>* </c>
<c>* Create output message.</c>
<l>create_message (HandEyeCalibData)</l>
<l>set_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>set_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsRMS', PlanePointsRMS)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsMaxDiff', PlanePointsMaxDiff)</l>
<l>return ()</l>
</body>
<docu id="calibrate_hand_eye_stationary_cam_approx_without_calib_plate">
<abstract lang="en_US">This procedures performs a hand-eye calibration of a six-axis robot for the case where a camera is stationary with respect to the robot. For the camera calibration part of this procedure, the internal camera parameters neither have to be specified nor known. Note that the camera has to look perpendicularly onto the plane.

The parameters RowsTouchingPointInPlane and ColumnsTouchingPointInPlane are the image coordinates that have been approached by the touching point of the robot. The corresponding robot poses have to be specified in the parameter ToolInBasePoses.
Please note that at least four row, column and robot poses have to be used and that these parameters have to be of equal size. To achieve reliable results it is important that these points are well distributed over the entire field of view. To increase the accuracy of the estimation, it is recommended to use more than just four correspondences. 

The parameter RobotTouchingPointInToolCoordinates describes the the touching point of the robot, i. e., a point on the gripper that touches the measurement plane. If the tool coordinate system already lies in the gripper, the touching point is a 1 x 3 vector with all its entries being zero. Otherwise, the vector describes the translation in x-, y- and z-direction of the tool origin to the touching point.
Please note that the touching point has to be fixed with respect to the tool coordinate system, but does not have to be located on the surface of the gripper, i.e. it can lie halfway between two fingers of a gripper.

The parameter DistancePlaneToCamera describes the (orthogonal) distance between the measurement plane and the camera center.

The image size has to be specified in the parameter Width and Height.

If you approached a three-dimensional object to gather the parameters RowsTouchingPointInPlane and ColumnsTouchingPointInPlane, you have to specify the height of this object's touching point above the plane in DistanceObjectTouchingPointToPlane.

The output parameters are stored in the message HandEyeCalibData. The following data is stored:
  - The result of the camera calibration is returned in the parameter CamParam.
  - The parameter BaseInCamPose, which is the pose of the robot's base with respect to the camera.
  - The parameter PlaneInBasePose, which is the pose of the plane with respect to the robot's base.
  - The parameters PlaneInCamPose, which is the pose of the plane with respect to the camera.
  - A qualitative statement about the calibration and the measurement plane is given in the parameters PlanePointsRMS and PlanePointsMaxDiff: The PlanePointsRMS describes the root mean square error of the difference between the rows and columns projected into the measurement plane and the identical points that have been approached by the touching point. The PlanePointsMaxDiff describes the maximum error of the Euclidean distances of the projected and the approached points. 
</abstract>
<alternatives>
<item>calibrate_hand_eye_stationary_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_robot_touching_point</item>
<item>get_image_size</item>
</predecessor>
<short lang="en_US">Perform a hand-eye calibration with a stationary camera.</short>
<parameters>
<parameter id="ColumnsTouchingPointInPlane">
<default_type>real</default_type>
<description lang="en_US">Column coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistanceObjectTouchingPointToPlane">
<default_type>real</default_type>
<description lang="en_US"> Height of the touching point above the plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistancePlaneToCamera">
<default_type>real</default_type>
<description lang="en_US">Perpendicular distance from camera to plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowsTouchingPointInPlane">
<default_type>real</default_type>
<description lang="en_US">Row coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePoses">
<default_type>real</default_type>
<description lang="en_US">Robot positions that have been acquired while touching the corresponding image points.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_robot_touching_point">
<interface>
<ic>
<par name="DataDir" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Open a new window.</c>
<l>open_new_window (WindowHandle, WindowHandleGraphics)</l>
<c>* Display introduction.</c>
<l>dev_disp_introduction (WindowHandle, WindowHandleGraphics)</l>
<l>stop ()</l>
<c>* </c>
<c>* Read three ToolInBasesPoses which are used</c>
<c>* to calibrate the RobotTouchingPointInToolCoordinates.</c>
<l>for Index := 1 to 3 by 1</l>
<l>    read_pose (DataDir + 'tool_in_base_pose_touching_point_0' + Index + '.dat', ToolInBasePoseTouchingPoint)</l>
<l>    dev_disp_approach_pose_touching_point_instructions (WindowHandle, WindowHandleGraphics, Index)</l>
<l>    stop ()</l>
<c>    * Collect poses in vector.</c>
<l>    ToolInBasePosesTouchingPoint.at(Index-1) := ToolInBasePoseTouchingPoint</l>
<l>endfor</l>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>dev_close_window ()</l>
<c>* </c>
<c>* Calculate the coordinates of the touching point</c>
<c>* of the robot with respect to the robot's tool.</c>
<l>get_robot_touching_point_in_tool_coordinates (ToolInBasePosesTouchingPoint, RobotTouchingPointInToolCoordinates)</l>
<c>* </c>
<c>* Visualize results.</c>
<l>visualize_calibrated_touching_point (RobotTouchingPointInToolCoordinates, ToolInBasePosesTouchingPoint, WindowHandle)</l>
<l>return ()</l>
</body>
<docu id="calibrate_robot_touching_point">
<abstract lang="en_US">This procedure helps you to calibrate the touching point of your robot, i.e., the touching point with respect to the tool coordinate system of the robot.

These coordinates are necessary, for example, for the hand-eye calibration in the HDevelop example program calibrate_hand_eye_stationary_cam_approx.hdev.</abstract>
<alternatives>
<item>get_robot_touching_point_in_tool_coordinates</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calibrate the X, Y, Z coordinates of a touching point of a robot.</short>
<parameters>
<parameter id="DataDir">
<default_type>string</default_type>
<default_value>''</default_value>
<description lang="en_US">Directory where the camera parameters and poses are read.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">The X, Y, Z coordinates of the touching point relative to the tool of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_hand_eye_calibration_input_poses">
<interface>
<ic>
<par name="CalibDataID" base_type="ctrl" dimension="0"/>
<par name="RotationTolerance" base_type="ctrl" dimension="0"/>
<par name="TranslationTolerance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Warnings" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure checks the hand-eye calibration input poses that are stored in</c>
<c>* the calibration data model CalibDataID for consistency.</c>
<c>* </c>
<c>* For this check, it is necessary to know the accuracy of the input poses.</c>
<c>* Therefore, the RotationTolerance and TranslationTolerance must be</c>
<c>* specified that approximately describe the error in the rotation and in the</c>
<c>* translation part of the input poses, respectively. The rotation tolerance must</c>
<c>* be passed in RotationTolerance in radians. The translation tolerance must be</c>
<c>* passed in TranslationTolerance in the same unit in which the input poses were</c>
<c>* given, i.e., typically in meters. Therefore, the more accurate the</c>
<c>* input poses are, the lower the values for RotationTolerance and</c>
<c>* TranslationTolerance should be chosen. If the accuracy of the robot's tool</c>
<c>* poses is different from the accuracy of the calibration object poses, the</c>
<c>* tolerance values of the poses with the lower accuracy (i.e., the higher</c>
<c>* tolerance values) should be passed.</c>
<c>* </c>
<c>* Typically, check_hand_eye_calibration_input_poses is called after all</c>
<c>* calibration poses have been set in the calibration data model and before the</c>
<c>* hand eye calibration is performed. The procedure checks all pairs of robot</c>
<c>* tool poses and compares them to the corresponding pair of calibration object</c>
<c>* poses. For each inconsistent pose pair, a string is returned in Warnings that</c>
<c>* indicates the inconsistent pose pair. For larger values for RotationTolerance</c>
<c>* or TranslationTolerance, i.e., for less accurate input poses, fewer warnings</c>
<c>* will be generated because the check is more tolerant, and vice versa. The</c>
<c>* procedure is also helpful if the errors that are returned by the hand-eye</c>
<c>* calibration are larger than expected to identify potentially erroneous poses.</c>
<c>* Note that it is not possible to check the consistency of a single pose but</c>
<c>* only of pose pairs. Nevertheless, if a certain pose occurs multiple times in</c>
<c>* different warning messages, it is likely that the pose is erroneous.</c>
<c>* Erroneous poses that result in inconsistent pose pairs should removed</c>
<c>* from the calibration data model by using remove_calib_data_observ and</c>
<c>* remove_calib_data before performing the hand-eye calibration.</c>
<c>* </c>
<c>* check_hand_eye_calibration_input_poses also checks whether enough calibration</c>
<c>* pose pairs are passed with a significant relative rotation angle, which</c>
<c>* is necessary for a robust hand-eye calibration.</c>
<c>* </c>
<c>* check_hand_eye_calibration_input_poses also verifies that the correct</c>
<c>* calibration model was chosen in create_calib_data. If a model of type</c>
<c>* 'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration</c>
<c>* of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or</c>
<c>* 'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed.</c>
<c>* Therefore, if all input poses for an articulated robot are parallel or if some</c>
<c>* robot poses for a SCARA robot are tilted, a corresponding message is returned</c>
<c>* in Warnings. Furthermore, if the number of tilted input poses for articulated</c>
<c>* robots is below a certain value, a corresponding message in Warnings indicates</c>
<c>* that the accuracy of the result of the hand-eye calibration might be low.</c>
<c>* </c>
<c>* If no problems have been detected in the input poses, an empty tuple is</c>
<c>* returned in Warnings.</c>
<c>* </c>
<c>* </c>
<c>* Define the minimum fraction of pose pairs with a rotation angle exceeding</c>
<c>* 2*RotationTolerance.</c>
<l>MinLargeRotationFraction := 0.1</l>
<c>* Define the minimum fraction of screw axes pairs with an angle exceeding</c>
<c>* 2*RotationTolerance for articulated robots.</c>
<l>MinLargeAnglesFraction := 0.1</l>
<c>* Factor that is used to multiply the standard deviations to obtain an error</c>
<c>* threshold.</c>
<l>StdDevFactor := 3.0</l>
<c>* </c>
<c>* Check input control parameters.</c>
<l>if (|CalibDataID| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 1')</l>
<l>endif</l>
<l>if (|RotationTolerance| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 2')</l>
<l>endif</l>
<l>if (|TranslationTolerance| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 3')</l>
<l>endif</l>
<l>try</l>
<l>    get_calib_data (CalibDataID, 'model', 'general', 'type', Type)</l>
<l>catch (Exception)</l>
<l>    throw ('Wrong value of control parameter: 1')</l>
<l>endtry</l>
<l>if (RotationTolerance &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<l>if (TranslationTolerance &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 3')</l>
<l>endif</l>
<c>* </c>
<c>* Read out the calibration data model.</c>
<l>IsHandEyeScara := Type == 'hand_eye_scara_stationary_cam' or Type == 'hand_eye_scara_moving_cam'</l>
<l>IsHandEyeArticulated := Type == 'hand_eye_stationary_cam' or Type == 'hand_eye_moving_cam'</l>
<c>* This procedure only works for hand-eye calibration applications.</c>
<l>if (not IsHandEyeScara and not IsHandEyeArticulated)</l>
<l>    throw ('check_hand_eye_calibration_input_poses only works for hand-eye calibrations')</l>
<l>endif</l>
<l>get_calib_data (CalibDataID, 'model', 'general', 'num_cameras', NumCameras)</l>
<l>get_calib_data (CalibDataID, 'model', 'general', 'num_calib_objs', NumCalibObjs)</l>
<c>* </c>
<c>* Get all valid calibration pose indices.</c>
<l>query_calib_data_observ_indices (CalibDataID, 'camera', 0, I1, PosesIdx)</l>
<l>RefCalibDataID := CalibDataID</l>
<l>UseTemporaryCopy := false</l>
<c>* If necessary, calibrate the interior camera parameters.</c>
<l>if (IsHandEyeArticulated)</l>
<c>    * For articulated (non-SCARA) robots, we have to check whether the camera</c>
<c>    * is already calibrated. Otherwise, the queried poses might not be very</c>
<c>    * accurate.</c>
<l>    try</l>
<l>        get_calib_data (CalibDataID, 'calib_obj_pose', [0,PosesIdx[0]], 'pose', CamPoseCal)</l>
<l>    catch (Exception)</l>
<l>        if (NumCameras != 0 and NumCalibObjs != 0)</l>
<c>            * If the interior camera parameters are not calibrated yet, perform</c>
<c>            * the camera calibration by using a temporary copy of the calibration</c>
<c>            * data model.</c>
<l>            serialize_calib_data (CalibDataID, SerializedItemHandle)</l>
<l>            deserialize_calib_data (SerializedItemHandle, TmpCalibDataID)</l>
<l>            clear_serialized_item (SerializedItemHandle)</l>
<l>            RefCalibDataID := TmpCalibDataID</l>
<l>            UseTemporaryCopy := true</l>
<l>            calibrate_cameras (TmpCalibDataID, Error)</l>
<l>        endif</l>
<l>    endtry</l>
<l>endif</l>
<c>* Query all robot tool and calibration object poses.</c>
<l>for Index := 0 to |PosesIdx| - 1 by 1</l>
<l>    try</l>
<c>        * For an articulated robot with a camera and a calibration object,</c>
<c>        * a calibrated poses should always be available.</c>
<l>        get_calib_data (RefCalibDataID, 'calib_obj_pose', [0,PosesIdx[Index]], 'pose', CamPoseCal)</l>
<l>    catch (Exception)</l>
<c>        * For a SCARA robot or for an articulated robots with a general</c>
<c>        * sensor and no calibration object, directly use the observed poses.</c>
<l>        get_calib_data_observ_pose (RefCalibDataID, 0, 0, PosesIdx[Index], CamPoseCal)</l>
<l>    endtry</l>
<c>    * Transform the calibration object poses to dual quaternions.</c>
<l>    pose_to_dual_quat (CamPoseCal, CamDualQuatCal)</l>
<l>    CamDualQuatsCal.at(Index) := CamDualQuatCal</l>
<c>    * Transform the robot tool pose to dual quaternions.</c>
<l>    get_calib_data (RefCalibDataID, 'tool', PosesIdx[Index], 'tool_in_base_pose', BasePoseTool)</l>
<l>    pose_to_dual_quat (BasePoseTool, BaseDualQuatTool)</l>
<l>    BaseDualQuatsTool.at(Index) := BaseDualQuatTool</l>
<l>endfor</l>
<l>NumCalibrationPoses := |PosesIdx|</l>
<l>if (UseTemporaryCopy)</l>
<l>    clear_calib_data (TmpCalibDataID)</l>
<l>endif</l>
<c>* </c>
<c>* In the first test, check the poses for consistency. The principle of</c>
<c>* the hand-eye calibration is that the movement of the robot from time</c>
<c>* i to time j is represented by the relative pose of the calibration</c>
<c>* object from i to j in the camera coordinate system and also by the</c>
<c>* relative pose of the robot tool from i to j in the robot base</c>
<c>* coordinate system. Because both relative poses represent the same 3D</c>
<c>* rigid transformation, but only seen from two different coordinate</c>
<c>* systems, their screw axes differ but their screw angle and their</c>
<c>* screw translation should be identical. This knowledge can be used to</c>
<c>* check the consistency of the input poses. Furthermore, remember the</c>
<c>* screw axes for all robot movements to later check whether the</c>
<c>* correct calibration model (SCARA or articulated) was selected by the</c>
<c>* user.</c>
<l>Warnings := []</l>
<l>LX2s := []</l>
<l>LY2s := []</l>
<l>LZ2s := []</l>
<l>TranslationToleranceSquared := TranslationTolerance * TranslationTolerance</l>
<l>RotationToleranceSquared := RotationTolerance * RotationTolerance</l>
<l>for Index1 := 0 to NumCalibrationPoses - 2 by 1</l>
<l>    CamDualQuatCal1 := CamDualQuatsCal.at(Index1)</l>
<l>    dual_quat_conjugate (CamDualQuatCal1, Cal1DualQuatCam)</l>
<l>    BaseDualQuatTool1 := BaseDualQuatsTool.at(Index1)</l>
<l>    dual_quat_conjugate (BaseDualQuatTool1, Tool1DualQuatBase)</l>
<l>    for Index2 := Index1 + 1 to NumCalibrationPoses - 1 by 1</l>
<c>        * For two robot poses, ...</c>
<c>        * ... compute the movement of the calibration object in the</c>
<c>        * camera coordinate system.</c>
<l>        CamDualQuatCal2 := CamDualQuatsCal.at(Index2)</l>
<l>        dual_quat_compose (Cal1DualQuatCam, CamDualQuatCal2, DualQuat1)</l>
<c>        * </c>
<c>        * ... compute the movement of the tool in the robot base</c>
<c>        * coordinate system.</c>
<l>        BaseDualQuatTool2 := BaseDualQuatsTool.at(Index2)</l>
<l>        dual_quat_compose (Tool1DualQuatBase, BaseDualQuatTool2, DualQuat2)</l>
<c>        * </c>
<c>        * Check whether the two movements are consistent. If the two</c>
<c>        * movements are consistent, the scalar parts of the corresponding</c>
<c>        * dual quaternions should be equal. For the equality check, we</c>
<c>        * have to take the accuracy of the input poses into account, which</c>
<c>        * are given by RotationTolerance and TranslationTolerance.</c>
<l>        dual_quat_to_screw (DualQuat1, 'moment', LX1, LY1, LZ1, MX1, MY1, MZ1, Rot1, Trans1)</l>
<l>        dual_quat_to_screw (DualQuat2, 'moment', LX2, LY2, LZ2, MX2, MY2, MZ2, Rot2, Trans2)</l>
<l>        while (Rot1 &gt; rad(180.0))</l>
<l>            Rot1 := Rot1 - rad(360.0)</l>
<l>        endwhile</l>
<l>        while (Rot2 &gt; rad(180.0))</l>
<l>            Rot2 := Rot2 - rad(360.0)</l>
<l>        endwhile</l>
<c>        * </c>
<l>        Rot1 := fabs(Rot1)</l>
<l>        Trans1 := fabs(Trans1)</l>
<l>        Rot2 := fabs(Rot2)</l>
<l>        Trans2 := fabs(Trans2)</l>
<l>        MeanRot := 0.5 * (Rot1 + Rot2)</l>
<l>        MeanTrans := 0.5 * (Trans1 + Trans2)</l>
<l>        SinTheta2 := sin(0.5 * MeanRot)</l>
<l>        CosTheta2 := cos(0.5 * MeanRot)</l>
<l>        SinTheta2Squared := SinTheta2 * SinTheta2</l>
<l>        CosTheta2Squared := CosTheta2 * CosTheta2</l>
<c>        * </c>
<c>        * 1. Check the scalar part of the real part of the dual quaternion,</c>
<c>        * which encodes the rotation component of the screw:</c>
<c>        *   q[0] = cos(theta/2)</c>
<c>        * Here, theta is the screw rotation angle.</c>
<l>        ErrorRot := fabs(Rot1 - Rot2)</l>
<l>        while (ErrorRot &gt; rad(180.0))</l>
<l>            ErrorRot := ErrorRot - rad(360.0)</l>
<l>        endwhile</l>
<l>        ErrorRot := fabs(ErrorRot)</l>
<c>        * Compute the standard deviation of the scalar part of the real part</c>
<c>        * by applying the law of error propagation.</c>
<l>        StdDevQ0 := 0.5 * SinTheta2 * RotationTolerance</l>
<c>        * Multiply the standard deviation by a factor to increase the certainty.</c>
<l>        ToleranceDualQuat0 := StdDevFactor * StdDevQ0</l>
<l>        ErrorDualQuat0 := fabs(fabs(DualQuat2[0]) - fabs(DualQuat1[0]))</l>
<c>        * </c>
<c>        * 2. Check the scalar part of the dual part of the dual quaternion,</c>
<c>        * which encodes translation and rotation components of the screw:</c>
<c>        *   q[4] = -d/2*sin(theta/2)</c>
<c>        * Here, d is the screw translation.</c>
<c>        * </c>
<c>        * Compute the standard deviation of the scalar part of the dual part</c>
<c>        * by applying the law of error propagation.</c>
<l>        StdDevQ4 := sqrt(0.25 * SinTheta2Squared * TranslationToleranceSquared + 0.0625 * MeanTrans * MeanTrans * CosTheta2Squared * RotationToleranceSquared)</l>
<c>        * Multiply the standard deviation by a factor to increase the certainty.</c>
<l>        ToleranceDualQuat4 := StdDevFactor * StdDevQ4</l>
<l>        ErrorDualQuat4 := fabs(fabs(DualQuat2[4]) - fabs(DualQuat1[4]))</l>
<c>        * If one of the two errors exceeds the computed thresholds, return</c>
<c>        * a warning for the current pose pair.</c>
<l>        if (ErrorDualQuat0 &gt; ToleranceDualQuat0 or ErrorDualQuat4 &gt; ToleranceDualQuat4)</l>
<l>            Message := 'Inconsistent pose pair (' + PosesIdx[Index1]$'2d' + ',' + PosesIdx[Index2]$'2d' + ')'</l>
<l>            Warnings := [Warnings,Message]</l>
<l>        endif</l>
<c>        * </c>
<c>        * Remember the screw axes (of the robot tool movements) for screws</c>
<c>        * with a significant rotation part. For movements without rotation</c>
<c>        * the direction of the screw axis is determined by the translation</c>
<c>        * part only. Hence, the direction of the screw axis cannot be used</c>
<c>        * to decide whether an articulated or a SCARA robot is used.</c>
<l>        if (Rot2 &gt; StdDevFactor * RotationTolerance)</l>
<l>            LX2s := [LX2s,LX2]</l>
<l>            LY2s := [LY2s,LY2]</l>
<l>            LZ2s := [LZ2s,LZ2]</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<c>* In the second test, we check whether enough calibration poses with a</c>
<c>* significant rotation part are available for calibration.</c>
<l>NumPairs := |LX2s|</l>
<l>NumPairsMax := NumCalibrationPoses * (NumCalibrationPoses - 1) / 2</l>
<l>if (NumPairs &lt; 2)</l>
<l>    Message := 'There are not enough rotated calibration poses available.'</l>
<l>    Warnings := [Warnings,Message]</l>
<c>    * In this case, we can skip further test.</c>
<l>    return ()</l>
<l>endif</l>
<l>LargeRotationFraction := real(NumPairs) / NumPairsMax</l>
<l>if (NumPairs &lt; 4 or LargeRotationFraction &lt; MinLargeRotationFraction)</l>
<l>    Message := 'Only few rotated robot poses available, which might result in a reduced accuracy of the calibration results.'</l>
<l>    Warnings := [Warnings,Message]</l>
<l>endif</l>
<c>* </c>
<c>* In the third test, we compute the angle between the screw axes with</c>
<c>* a significant rotation part. For SCARA robots, this angle must be 0 in</c>
<c>* all cases. For articulated robots, for a significant fraction of robot</c>
<c>* poses, this angle should exceed a certain threshold. For this test, we</c>
<c>* use the robot tool poses as they are assumed to be more accurate than the</c>
<c>* calibration object poses.</c>
<l>NumPairPairs := NumPairs * (NumPairs - 1) / 2</l>
<l>NumPairPairsMax := NumPairsMax * (NumPairsMax - 1) / 2</l>
<l>Angles := gen_tuple_const(NumPairPairs,0)</l>
<l>Idx := 0</l>
<l>for Index1 := 0 to NumPairs - 2 by 1</l>
<l>    LXA := LX2s[Index1]</l>
<l>    LYA := LY2s[Index1]</l>
<l>    LZA := LZ2s[Index1]</l>
<l>    for Index2 := Index1 + 1 to NumPairs - 1 by 1</l>
<l>        LXB := LX2s[Index2]</l>
<l>        LYB := LY2s[Index2]</l>
<l>        LZB := LZ2s[Index2]</l>
<c>        * Compute the scalar product, i.e. the cosine of the screw</c>
<c>        * axes. To obtain valid values, crop the cosine to the</c>
<c>        * interval [-1,1].</c>
<l>        ScalarProduct := max([min([LXA * LXB + LYA * LYB + LZA * LZB,1]),-1])</l>
<c>        * Compute the angle between the axes in the range [0,pi/2].</c>
<l>        Angles[Idx] := acos(fabs(ScalarProduct))</l>
<l>        Idx := Idx + 1</l>
<l>    endfor</l>
<l>endfor</l>
<c>* Large angles should significantly exceed the RotationTolerance.</c>
<l>LargeAngles := sum(Angles [&gt;] StdDevFactor * RotationTolerance)</l>
<c>* Calculate the fraction of pairs of movements, i.e., pairs of pose</c>
<c>* pairs, that have a large angle between their corresponding screw</c>
<c>* axes.</c>
<l>LargeAnglesFraction := real(LargeAngles) / NumPairPairsMax</l>
<c>* For SCARA robots, all screw axes should be parallel, i.e., no</c>
<c>* two screw axes should have a large angle.</c>
<l>if (IsHandEyeScara and LargeAngles &gt; 0)</l>
<l>    Message := 'The robot poses indicate that this might be an articulated robot, although a SCARA robot was selected in the calibration data model.'</l>
<l>    Warnings := [Warnings,Message]</l>
<l>endif</l>
<c>* For articulated robots, the screw axes should have a large</c>
<c>* angles.</c>
<l>if (IsHandEyeArticulated)</l>
<l>    if (LargeAngles == 0)</l>
<c>        * If there is no pair of movements with a large angle between</c>
<c>        * their corresponding screw axes, this might be a SCARA robot.</c>
<l>        Message := 'The robot poses indicate that this might be a SCARA robot (no tilted robot poses available), although an articulated robot was selected in the calibration data model.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    elseif (LargeAngles &lt; 3)</l>
<c>        * If there are at most 2 movements with a large angle between</c>
<c>        * their corresponding screw axes, the calibration might be</c>
<c>        * unstable.</c>
<l>        Message := 'Not enough tilted robot poses available for an accurate calibration of an articulated robot.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    elseif (LargeAnglesFraction &lt; MinLargeAnglesFraction)</l>
<c>        * If there is only a low fraction of pairs of movements with</c>
<c>        * a large angle between their corresponding screw axes, the</c>
<c>        * accuracy of the calibration might be low.</c>
<l>        Message := 'Only few tilted robot poses available, which might result in a reduced accuracy of the calibration results.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="check_hand_eye_calibration_input_poses">
<abstract lang="en_US">check_hand_eye_calibration_input_poses checks the hand-eye calibration input poses that are stored in the calibration data model CalibDataID for consistency.

For this check, it is necessary to know the accuracy of the input poses. Therefore, in RotationTolerance and TranslationTolerance a tolerance must be specified that approximately describes the error in the rotation and in the translation part of the input poses, respectively. The rotation tolerance must be passed in RotationTolerance in radians. The translation tolerance must be passed in  TranslationTolerance in the same unit in which the input poses were given, i.e., typically in meters. Therefore, the more accurate the input poses are, the lower the values for RotationTolerance and TranslationTolerance should be chosen. If the accuracy of the robot's tool poses is different from the accuracy of the calibration object poses, the tolerance values of the poses with the lower accuracy (i.e., the higher tolerance values) should be passed.

Typically, check_hand_eye_calibration_input_poses is called after all calibration poses have been set in the calibration data model and before the hand eye calibration is performed. The procedure checks all pairs of robot tool poses and compares them to the corresponding pair of calibration object poses. For each inconsistent pose pair, in Warnings a string is returned that indicates the inconsistent pose pair. For larger values for RotationTolerance or TranslationTolerance, i.e., for less accurate input poses, fewer warnings will be generated because the check is more tolerant, and vice versa. The procedure is also helpful, if the errors that are returned by the hand-eye calibration are larger than expected to identify potentially erroneous poses.

Note that it is not possible to check the consistency of a single pose but only of pose pairs. Nevertheless, if a certain pose occurs multiple times in different warning messages, it is likely that the pose is erroneous. Erroneous poses that result in inconsistent pose pairs should be removed from the calibration data model by using remove_calib_data_observ and remove_calib_data before performing the hand-eye calibration.

check_hand_eye_calibration_input_poses also checks whether enough calibration pose pairs are passed with a significant relative rotation angle, which is necessary for a robust hand-eye calibration.

check_hand_eye_calibration_input_poses also verifies that the correct calibration model was chosen in create_calib_data. If a model of type 'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or 'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed. Therefore, if for an articulated robot all input poses are parallel or if for a SCARA robot some robot poses are tilted, a corresponding message is returned in Warnings. Furthermore, if for articulated robots, the number of tilted input poses is below a certain value, a corresponding message in Warnings indicates that the accuracy of the result of the hand-eye calibration might be low. 

If no problems have been detected in the input poses, an empty tuple is returned in Warnings.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<example lang="en_US">check_hand_eye_calibration_input_poses (CalibDataID, 0.04, 0.002, Warnings)
if (|Warnings| != 0)
    * There are warnings that should be checked before performing
    * the hand-eye calibration
    stop ()
endif
calibrate_hand_eye (CalibDataID, Errors)</example>
<keywords lang="en_US">
<item>hand</item>
<item>eye</item>
<item>hand-eye</item>
<item>calibration</item>
<item>poses</item>
<item>error</item>
<item>errors</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_calib_data</item>
<item>set_calib_data</item>
<item>set_calib_data_cam_param</item>
<item>set_calib_data_calib_object</item>
<item>find_calib_object</item>
<item>read_calib_data</item>
</predecessor>
<see_also>
<item>remove_calib_data</item>
<item>remove_calib_data_observ</item>
</see_also>
<short lang="de_DE">Check the input poses for the hand-eye calibration for consistency</short>
<short lang="en_US">Check the input poses of the hand-eye calibration for consistency.</short>
<successor>
<item>calibrate_hand_eye</item>
</successor>
<parameters>
<parameter id="CalibDataID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the calibration data model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>calib_data</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RotationTolerance">
<default_type>real</default_type>
<default_value>0.05</default_value>
<description lang="en_US">Tolerance of the rotation part of the input poses [rad].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
<values>
<item>0.02</item>
<item>0.03</item>
<item>0.04</item>
<item>0.05</item>
<item>0.06</item>
<item>0.08</item>
<item>0.1</item>
</values>
</parameter>
<parameter id="TranslationTolerance">
<default_type>real</default_type>
<default_value>0.005</default_value>
<description lang="en_US">Tolerance of the translation part of the input poses [m].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
<values>
<item>[0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01]</item>
</values>
</parameter>
<parameter id="Warnings">
<default_type>string</default_type>
<description lang="en_US">Tuple of strings with warnings that contain the identified problems. If no inconsistencies or other problems have been detected, an empty tuple is returned.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="collect_single_image_calibration_data">
<interface>
<ic>
<par name="ImageCaltabFileName" base_type="ctrl" dimension="0"/>
<par name="CalPlateDescr" base_type="ctrl" dimension="0"/>
<par name="CalPlateThickness" base_type="ctrl" dimension="0"/>
<par name="StartCamParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Read an image of the calibration plate</c>
<c>* that is placed in the measurement plane of the robot.</c>
<l>read_image (ImageCaltab, ImageCaltabFileName)</l>
<l>dev_disp_calibration_data_instructions (ImageCaltab)</l>
<l>stop ()</l>
<c>* </c>
<c>* Specify the finder pattern of the calibration plate you used.</c>
<c>* The information can usually be found in the used description file.</c>
<l>FinderRow := [13,6,6,20,20]</l>
<l>FinderColumn := [15,6,24,6,24]</l>
<c>* Specify the number of marks per row.</c>
<l>MarksPerRow := 31</l>
<c>* </c>
<c>* Create output message.</c>
<l>create_message (CalibObjectData)</l>
<l>set_message_obj (ImageCaltab, CalibObjectData, 'ImageCaltab')</l>
<l>set_message_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>set_message_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>set_message_tuple (CalibObjectData, 'StartCamParam', StartCamParam)</l>
<l>set_message_tuple (CalibObjectData, 'FinderRow', FinderRow)</l>
<l>set_message_tuple (CalibObjectData, 'FinderColumn', FinderColumn)</l>
<l>set_message_tuple (CalibObjectData, 'MarksPerRow', MarksPerRow)</l>
<l>return ()</l>
</body>
<docu id="collect_single_image_calibration_data">
<abstract lang="en_US">This procedure helps you collect the data for the procedure calibrate_camera_and_plane_single_image. The collected data is stored in the output message CalibObjectData.

The parameter ImageCaltabFileName is the image of the observed calibration plate. The corresponding description file has to be specified in the parameter CalPlateDescr. The starting parameters of the camera have to be passed in the parameter StartCamParam. In order to compensate a potential thickness of the calibration plate, the parameter CalPlateThickness has to be set to a value greater 0.0.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Monokular</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Monocular</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Collect the data to calibrate a camera with a single image.</short>
<successor>
<item>calibrate_camera_and_plane_single_image</item>
<item>get_message_tuple</item>
</successor>
<parameters>
<parameter id="CalPlateDescr">
<default_type>string</default_type>
<description lang="en_US"> Description file of the used calibration plate.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="CalPlateThickness">
<description lang="en_US">Thickness of the used calibration plate.</description>
</parameter>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageCaltabFileName">
<default_type>string</default_type>
<description lang="en_US">Image of the observed calibration plate.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="StartCamParam">
<description lang="en_US">Starting parameters of the camera.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="color_string_to_rgb">
<interface>
<ic>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RGB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>open_window (0, 0, 1, 1, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>set_part (WindowHandleBuffer, 0, 0, -1, -1)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, 0, 0)</l>
<l>try</l>
<l>    set_color (WindowHandleBuffer, Color)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter Color (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>disp_obj (Rectangle, WindowHandleBuffer)</l>
<l>dump_window_image (Image, WindowHandleBuffer)</l>
<l>close_window (WindowHandleBuffer)</l>
<l>get_grayval (Image, 0, 0, RGB)</l>
<l>RGB := RGB + [0,0,0]</l>
<l>return ()</l>
</body>
<docu id="color_string_to_rgb">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Parameter</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Parameters</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Color"/>
<parameter id="RGB"/>
</parameters>
</docu>
</procedure>
<procedure name="convert_decoded_string_code39_to_code32">
<interface>
<ic>
<par name="DecodedDataStringCode39" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ConvertedDataStringCode32" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure converts a decoded string of a 'Code 32'</c>
<c>* barcode that was read with the bar code reader for 'Code 39'</c>
<c>* to the 'Code 32' decoding.</c>
<c>* </c>
<c>* Basically a 'Code 32' bar code corresponds to a 'Code 39' with</c>
<c>* 8 digits and a checksum digit % 10 whereas even positions are</c>
<c>* weighted twice.</c>
<c>* The 9-digit number is represented to the base 32 and written</c>
<c>* with chars (via the symbol table) analogous to a hexadecimal number.</c>
<c>* </c>
<c>* Initialize symbol table</c>
<l>Symbols := ['0','1','2','3','4','5','6','7','8','9','B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z']</l>
<c>* Check the chars in the decoded 'Code 39' string.</c>
<c>* It must consist of exactly 6 chars and must not</c>
<c>* contain any invalid chars. If these conditions are</c>
<c>* fulfilled, convert the string to 'Code 32', else</c>
<c>* return an empty string.</c>
<l>if (DecodedDataStringCode39 =~ '^[' + sum(Symbols) + ']{6}$')</l>
<c>    * </c>
<c>    * Convert the value of each digit in the decoded 'Code 39' string</c>
<l>    ConvertedDataStringCode32 := 0</l>
<l>    for Digit := 0 to 5 by 1</l>
<l>        ConvertedDataStringCode32 := ConvertedDataStringCode32 + find(Symbols,DecodedDataStringCode39{Digit})</l>
<l>        if (Digit &lt; 5)</l>
<l>            ConvertedDataStringCode32 := ConvertedDataStringCode32 * 32</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Write the converted string as 9 digit string with leading zeros</c>
<l>    ConvertedDataStringCode32 := ConvertedDataStringCode32$'9.9d'</l>
<c>    * </c>
<c>    * Verify the checksum (last digit)</c>
<l>    CheckDigit := number(ConvertedDataStringCode32{8})</l>
<l>    CheckSum := 0</l>
<l>    for Digit := 0 to 7 by 1</l>
<c>        * Sum first 8 digits, but even digits have weight 2</c>
<l>        Value := (1 + Digit % 2) * number(ConvertedDataStringCode32{Digit})</l>
<c>        * But actually we only want the cross digit sum,</c>
<c>        * This 'formula' works for 0-19</c>
<l>        if (Value &gt;= 10)</l>
<l>            Value := Value - 9</l>
<l>        endif</l>
<l>        CheckSum := CheckSum + Value</l>
<l>    endfor</l>
<l>    CheckSum := CheckSum % 10</l>
<c>    * </c>
<c>    * If the checksum fits, return the converted 'Code 32' string,</c>
<c>    * else return an empty string</c>
<l>    if (CheckDigit != CheckSum)</l>
<c>        * Bad checksum</c>
<l>        ConvertedDataStringCode32 := ''</l>
<l>    else</l>
<c>        * Always printed with leading A</c>
<l>        ConvertedDataStringCode32 := 'A' + ConvertedDataStringCode32</l>
<l>    endif</l>
<l>else</l>
<c>    * Wrong number of chars or invalid chars</c>
<l>    ConvertedDataStringCode32 := ''</l>
<l>endif</l>
<l>return ()</l>
<c>* </c>
</body>
<docu id="convert_decoded_string_code39_to_code32">
<abstract lang="en_US">This procedure converts the decoded data string of a bar code of type 'Code 32' that was read with the bar code reader for 'Code 39'.

In case a bar code of type 'Code 32' is read with the bar code reader find_bar_code with code type 'Code 39' the resulting data string has to be converted to the 'Code 32' decoding. This procedure can be used to perform this conversion.

1. Step: Find and decode the 'Code 32' bar code with the HALCON bar code reader for type 'Code 39'.
2. Step: Convert the decoded data string from type 'Code 39' to the corresponding 'Code 32' decoding using the procedure convert_decoded_string_code39_to_code32.

Note that only one data string can be passed to the input parameter 'DecodedStringCode39' for conversion.</abstract>
<chapters lang="de_DE">
<item>Identifizierung</item>
<item>Barcode</item>
</chapters>
<chapters lang="en_US">
<item>Identification</item>
<item>Bar Code</item>
</chapters>
<example lang="en_US">create_bar_code_model ([], [], BarCodeHandle)
find_bar_code (Image, SymbolRegions, BarCodeHandle, 'Code 39', DecodedDataStrings)
convert_code39_to_code32 (DecodedDataStrings, ConvertedDataStringsCode32)</example>
<keywords lang="en_US">
<item>convert decoded string of bar code type 'Code 39' to 'Code 32'</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_bar_code</item>
</predecessor>
<short lang="en_US">Convert a decoded string of a bar code of type 'Code 39' to the type 'Code 32'.</short>
<successor>
<item>disp_message</item>
</successor>
<parameters>
<parameter id="ConvertedDataStringCode32">
<default_type>string</default_type>
<description lang="en_US">The converted data string of bar code type 'Code 32'</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DecodedDataStringCode39">
<default_type>string</default_type>
<description lang="en_US">The decoded data string of bar code type 'Code 39' to be converted</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="determine_optimum_pose_distance">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="ImageCoverage" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Determine the optimum distance of the object to obtain</c>
<c>* a reasonable visualization</c>
<c>* </c>
<l>NumModels := |ObjectModel3DID|</l>
<l>Rows := []</l>
<l>Cols := []</l>
<l>MinMinZ := 1e30</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'bounding_box1', BB)</l>
<c>* Calculate diameter over all objects to be visualized</c>
<l>Seq := [0:6:|BB| - 1]</l>
<l>DXMax := max(BB[Seq + 3]) - min(BB[Seq])</l>
<l>DYMax := max(BB[Seq + 4]) - min(BB[Seq + 1])</l>
<l>DZMax := max(BB[Seq + 5]) - min(BB[Seq + 2])</l>
<l>Diameter := sqrt(DXMax * DXMax + DYMax * DYMax + DZMax * DZMax)</l>
<l>if (sum(abs(BB)) == 0.0)</l>
<l>    BB := [-abs(rand(3) * 1e-20),abs(rand(3) * 1e-20)]</l>
<l>endif</l>
<c>* Allow the visualization of single points or extremely small objects</c>
<l>ZAdd := 0.0</l>
<l>if (max(Diameter) &lt; 1e-10)</l>
<l>    ZAdd := 0.01</l>
<l>endif</l>
<c>* Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead</c>
<c>* to projection errors</c>
<l>if (min(Diameter) &lt; 1e-10)</l>
<l>    Diameter := Diameter - sgn(sgn(Diameter - 1e-10) - 1) * 1e-10</l>
<l>endif</l>
<l>IBB := [0:6:|BB| - 1]</l>
<l>BB0 := BB[IBB]</l>
<l>BB1 := BB[IBB + 1]</l>
<l>BB2 := BB[IBB + 2]</l>
<l>BB3 := BB[IBB + 3]</l>
<l>BB4 := BB[IBB + 4]</l>
<l>BB5 := BB[IBB + 5]</l>
<l>X := [BB0,BB3,BB0,BB0,BB3,BB3,BB0,BB3]</l>
<l>Y := [BB1,BB1,BB4,BB1,BB4,BB1,BB4,BB4]</l>
<l>Z := [BB2,BB2,BB2,BB5,BB2,BB5,BB5,BB5]</l>
<l>PoseInter := replace(PoseIn,2,-min(Z) + 2 * max(Diameter))</l>
<l>pose_to_hom_mat3d (PoseInter, HomMat3D)</l>
<c>* Determine the maximum extension of the projection</c>
<l>affine_trans_point_3d (HomMat3D, X, Y, Z, QX, QY, QZ)</l>
<l>project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>MinMinZ := min(QZ)</l>
<l>get_cam_par_data (CamParam, 'cx', Cx)</l>
<l>get_cam_par_data (CamParam, 'cy', Cy)</l>
<l>DR := Rows - Cy</l>
<l>DC := Cols - Cx</l>
<l>DR := max(DR) - min(DR)</l>
<l>DC := max(DC) - min(DC)</l>
<l>MaxDist := sqrt(DR * DR + DC * DC)</l>
<c>* </c>
<l>if (MaxDist &lt; 1e-10)</l>
<c>    * If the object has no extension in the above projection (looking along</c>
<c>    * a line), we determine the extension of the object in a rotated view</c>
<l>    hom_mat3d_rotate_local (HomMat3D, rad(90), 'x', HomMat3DRotate)</l>
<l>    affine_trans_point_3d (HomMat3DRotate, X, Y, Z, QX, QY, QZ)</l>
<l>    project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>    DR := Rows - Cy</l>
<l>    DC := Cols - Cx</l>
<l>    DR := max(DR) - min(DR)</l>
<l>    DC := max(DC) - min(DC)</l>
<l>    MaxDist := max([MaxDist,sqrt(DR * DR + DC * DC)])</l>
<l>endif</l>
<c>* </c>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>get_cam_par_data (CamParam, 'image_height', ImageHeight)</l>
<l>MinImageSize := min([ImageWidth,ImageHeight])</l>
<c>* </c>
<l>Z := PoseInter[2]</l>
<l>Zs := MinMinZ</l>
<l>ZDiff := Z - Zs</l>
<l>ScaleZ := MaxDist / (0.5 * MinImageSize * ImageCoverage * 2.0)</l>
<l>ZNew := ScaleZ * Zs + ZDiff + ZAdd</l>
<l>PoseOut := replace(PoseInter,2,ZNew)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="determine_optimum_pose_distance">
<abstract lang="en_US">determine_optimum_pose_distance determines the optimum translation in z direction to obtain a reasonable visualization of the given 3D object models, e.g., with disp_object_model_3d.

Based on the given camera parameters (CamParam), which also define the size of the image into which the 3D object models are to be projected and the requested image coverage, the necessary translation of the 3D object models in z direction, i.e., the third element of the pose, is calculated.

</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_object_models_center</item>
<item>create_pose</item>
</predecessor>
<short lang="en_US">Determine the optimum distance of the object to obtain a reasonable visualization</short>
<successor>
<item>disp_object_model_3d</item>
<item>render_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageCoverage">
<default_type>real</default_type>
<default_value>0.9</default_value>
<description lang="en_US">Desired image coverage of the 3D object models to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<description lang="en_US">3D pose of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Pose with adapted translation in z direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_approach_pose_touching_point_instructions">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>Text := 'Calibrate touching point'</l>
<l>Text[1] := ''</l>
<l>Text[2] := 'General workflow'</l>
<l>Text[3] := '----------------'</l>
<l>Text[4] := 'Approach a fixed point in the plane with your gripper, and read the'</l>
<l>Text[5] := 'pose as ToolInBasePoseTouchingPoint.'</l>
<l>Text[6] := 'Then, approach the same point at least twice again, rotating the tool'</l>
<l>Text[7] := 'around at least two axis and reading the corresponding '</l>
<l>Text[8] := 'ToolInBasePoseTouchingPoint.'</l>
<l>Text[9] := ''</l>
<l>Text[10] := 'Read ToolInBasePoseTouchingPoint ' + Index + '/3, then press F5.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>Color := gen_tuple_const(3,'gray')</l>
<l>Color[Index - 1] := '#fbba00'</l>
<l>dev_disp_text ('   1   ', 'window', 255, 12, 'black', ['box_color','shadow'], [Color[0],'false'])</l>
<l>dev_disp_text ('   2   ', 'window', 255, 112, 'black', ['box_color','shadow'], [Color[1],'false'])</l>
<l>dev_disp_text ('   3   ', 'window', 255, 212, 'black', ['box_color','shadow'], [Color[2],'false'])</l>
<c>* </c>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>dev_clear_window ()</l>
<l>read_image (Image, '3d_machine_vision/handeye/instruction_images/tool_in_base_pose_touching_point')</l>
<l>dev_display (Image)</l>
<l>HighlighColumn := 255 + (Index * 200)</l>
<l>gen_rectangle1 (Rectangle, 320, HighlighColumn - 100, 630, HighlighColumn + 100)</l>
<l>dev_set_line_width (4)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('#fbba00')</l>
<l>dev_display (Rectangle)</l>
<l>dev_disp_text ('Read this pose', 'image', 6350, HighlighColumn - 105, 'black', 'box_color', '#fbba00')</l>
<l>return ()</l>
</body>
<docu id="dev_disp_approach_pose_touching_point_instructions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Index">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_calibration_data_instructions">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<l>dev_display (Image)</l>
<l>Text := 'In the code, please'</l>
<l>Text[1] := '- read an image of a calibration plate in the measurement plane,'</l>
<l>Text[2] := '- specify the location of the calibration plate description file,'</l>
<l>Text[3] := '- specify the thickness of the calibration plate (in meters) and'</l>
<l>Text[4] := '- specify initial camera parameters.'</l>
<l>Text[5] := ''</l>
<l>Text[6] := ' (If you did NOT use a standard HALCON calibration plate, '</l>
<l>Text[7] := '  but used create_caltab to create your own calibration plate,'</l>
<l>Text[8] := '  you also need to adapt the parameters FinderRow, FinderColumn,'</l>
<l>Text[9] := '  and MarksPerRow accordingly.)'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_data_instructions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_calibration_data_instructions2">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<l>dev_display (Image)</l>
<l>Text := 'If you did NOT use a standard HALCON calibration plate, '</l>
<l>Text[1] := 'but used create_caltab to create your own calibration plate,'</l>
<l>Text[2] := 'please adapt the parameters FinderRow, FinderColumn, and MarksPerRow'</l>
<l>Text[3] := 'in the code.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_data_instructions2">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_introduction">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>Text := 'With this procedure, we calibrate the coordinates of the touching point'</l>
<l>Text[1] := 'of a robot with respect to the robot\'s tool.'</l>
<l>Text[2] := ''</l>
<l>Text[3] := 'The touching point is a point that has to be fixed with respect to'</l>
<l>Text[4] := 'the tool coordinate system, but does not have to be located on the'</l>
<l>Text[5] := 'surface of the gripper. It can, for example, lie halfway between'</l>
<l>Text[6] := 'two fingers of a gripper.'</l>
<l>Text[7] := ''</l>
<l>Text[8] := 'The touching point should be chosen such that it can approach '</l>
<l>Text[9] := 'a point in the plane easily and accurately.'</l>
<l>Text[10] := ''</l>
<l>Text[11] := 'The coordinates of this point (RobotTouchingPointInToolCoordinates)'</l>
<l>Text[12] := 'are necessary, for example, to perform a hand-eye calibration of a robot'</l>
<l>Text[13] := 'with a stationary camera.'</l>
<l>Text[14] := ''</l>
<l>Text[15] := 'This procedure is used in the example'</l>
<l>Text[16] := 'calibrate_hand_eye_stationary_cam_approx.hdev.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>read_image (InstructionImage, '3d_machine_vision/handeye/instruction_images/robot_touching_point_in_tool_coordinates')</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_resize_window_fit_image (InstructionImage, 0, Width + 10, 600, -1)</l>
<l>dev_display (InstructionImage)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="dev_disp_introduction">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<short lang="en_US">Display the introduction for the procedure calibrate_robot_touching_point.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_data_code_2d_print_quality_results">
<interface>
<ic>
<par name="DataCodeHandle" base_type="ctrl" dimension="0"/>
<par name="ResultHandle" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="QualityStandard" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the print quality results for data matrix ECC 200 codes.</c>
<c>* </c>
<c>* </c>
<c>* Available modes</c>
<l>MODE_RMMG := 'reflectance_margin_module_grades'</l>
<l>MODE_GRID := 'grid'</l>
<l>MODE_BAD := 'bad_modules'</l>
<l>SupportedModes := [MODE_RMMG,MODE_GRID,MODE_BAD]</l>
<c>* Available standards</c>
<l>SupportedQualityStandards := ['isoiec15415','isoiec_tr_29158','aimdpm_1_2006']</l>
<c>* Available generic parameters</c>
<l>GEN_CENTER := 'center'</l>
<l>GEN_CIRCLE := 'circle'</l>
<l>GEN_LEGEND := 'legend'</l>
<l>GEN_MAX_GRADE := 'max_grade'</l>
<c>* Defaults</c>
<l>DisplayCenter := false</l>
<l>DisplayCircle := true</l>
<l>DisplayLegend := true</l>
<l>MaxGrade := 3</l>
<c>* </c>
<c>* Check modes</c>
<l>if (|Mode| != 1)</l>
<l>    throw ('Please specify exactly one of following modes:' + sum(' ' + SupportedModes))</l>
<l>endif</l>
<l>if (find(SupportedModes,Mode) == -1)</l>
<l>    throw ('Unknown Mode: ' + Mode)</l>
<l>endif</l>
<c>* </c>
<c>* Check QualityStandard</c>
<l>if (find(SupportedQualityStandards,QualityStandard) == -1)</l>
<l>    throw ('Unknown QualityStandard: ' + QualityStandard)</l>
<l>else</l>
<l>    QualityStandard := 'quality_' + QualityStandard</l>
<l>endif</l>
<c>* </c>
<c>* Check generic parameters</c>
<c>* </c>
<c>* Override defaults in special modes</c>
<l>if (Mode == MODE_GRID)</l>
<l>    DisplayCenter := true</l>
<l>    DisplayCircle := false</l>
<l>    DisplayLegend := false</l>
<l>    MaxGrade := 4</l>
<l>    if (|Color| == 0)</l>
<l>        Color := 'gray'</l>
<l>    endif</l>
<l>elseif (Mode == MODE_BAD)</l>
<l>    DisplayCenter := false</l>
<l>    DisplayCircle := true</l>
<l>    DisplayLegend := false</l>
<l>    MaxGrade := 0</l>
<l>endif</l>
<c>* </c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<c>    * Check if number of values matches number of parameters</c>
<l>    throw ('GenParamName and GenParamValue do not match.')</l>
<l>else</l>
<c>    * Set generic parameters</c>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<c>        * 'center'</c>
<l>        if (GenParamName[I] == GEN_CENTER)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'center\': ' + GenParamValue[I] + ' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayCenter := GenParamValue[I] == 'true'</l>
<c>            * 'circle'</c>
<l>        elseif (GenParamName[I] == GEN_CIRCLE)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'circle\': ' + GenParamValue[I] + ' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayCircle := GenParamValue[I] == 'true'</l>
<l>        elseif (GenParamName[I] == GEN_LEGEND)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'legend\': ' + GenParamValue[I] + ' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayLegend := GenParamValue[I] == 'true'</l>
<l>        elseif (GenParamName[I] == GEN_MAX_GRADE)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] &lt; 0 or GenParamValue[I] &gt; 4)</l>
<l>                throw ('Wrong parameter value for generic parameter \'max_grade\': ' + GenParamValue[I] + ' Please use a value between 0 and 4.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            MaxGrade := int(GenParamValue[I])</l>
<l>        else</l>
<c>            * Unknown parameter</c>
<l>            throw ('Unknown generic parameter: \'' + GenParamName[I])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check Color</c>
<l>if (|Color| == 0)</l>
<l>    Color := ['red','orange','yellow','cyan','green']</l>
<l>endif</l>
<c>* Build color tuple with rotating colors if too few colors are specified</c>
<l>while (|Color| &lt; MaxGrade + 1)</l>
<l>    Color := [Color,Color]</l>
<l>endwhile</l>
<c>* </c>
<c>* Visualization</c>
<c>* </c>
<c>* Get modulation grades, rows and cols for all symbol modules incl.</c>
<c>* the 4 quiet zones adjacent to the symbol and the finder patterns.</c>
<l>QualityParameter := QualityStandard + '_reflectance_margin_module_grades'</l>
<l>QualityRows := QualityStandard + '_rows'</l>
<l>QualityCols := QualityStandard + '_cols'</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityParameter, ModuleGrades)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityRows, Rows)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityCols, Cols)</l>
<l>QualityLabels := QualityStandard + '_labels'</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityStandard, Grades)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityLabels, Labels)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, 'module_height', ModuleHeight)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, 'module_width', ModuleWidth)</l>
<l>Aperture := Grades[find(Labels,'Aperture')]</l>
<l>Radius := 0.5 * Aperture * min2(ModuleHeight,ModuleWidth)</l>
<c>* </c>
<c>* Iterate over all possible modulation grades to visualize</c>
<l>for Grade := 0 to MaxGrade by 1</l>
<l>    GradeIdx := find(ModuleGrades,Grade)</l>
<l>    if (GradeIdx &lt; 0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    GradeRows := Rows[GradeIdx]</l>
<l>    GradeCols := Cols[GradeIdx]</l>
<l>    GradeRadius := gen_tuple_const(|GradeRows|,Radius)</l>
<l>    dev_set_color (Color[Grade])</l>
<l>    if (DisplayCircle)</l>
<l>        gen_circle_contour_xld (Circle, GradeRows, GradeCols, GradeRadius, rad(0), rad(360), 'positive', 1)</l>
<l>        dev_display (Circle)</l>
<l>    endif</l>
<l>    if (DisplayCenter)</l>
<l>        gen_cross_contour_xld (Cross, GradeRows, GradeCols, 2 * Radius, rad(0))</l>
<l>        dev_display (Cross)</l>
<l>    endif</l>
<l>endfor</l>
<l>if (DisplayLegend)</l>
<c>    * Display legend with modulation grades</c>
<l>    dev_disp_text (['Reflectance Margin','Module Grade ' + [0:MaxGrade]], 'window', 'bottom', 'left', ['white',Color], 'box_color', '#00000080')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_data_code_2d_print_quality_results">
<abstract lang="en_US">This procedure can be used to display data code modules with print quality problems according to the data code standards ISO/IEC 15415 or AIM/DPM-1-2006.
The procedure calculates the reflectance margin module grades as described in ISO/IEC 15415 Chapter 7.8.4.3 (analogously for other standards), and displays the grades in different colors.
Unused modules are not displayed.

3 different modes are available that use different presets for the visualization:'reflectance_margin_module_grades' (default), 'bad_modules', 'grid'

'reflectance_margin_module_grades':
Display all modules with a grade less than 4 in different colors.
Used generic parameter settings: 'circle' = 'true', 'center' = 'false', 'legend' = 'true', 'max_grade' = 3.

'bad_modules':
Display only modules with a reflectance margin module grade of 0. These are modules that either are completely wrong (i.e., white instead of black and vice versa), or modules with a very bad modulation (i.e., with a gray value close to the calculated threshold between black and white modules).
Used generic parameter settings: 'circle' = 'true', 'center' = 'false', 'legend' = 'false', 'max_grade' = 0.

'grid':
Shows crosses at the positions where the module grades are calculated.
Used generic parameter settings: 'circle' = 'false', 'center' = 'true', 'legend' = 'false', 'max_grade' = 4.

The used standard can be specified in QualityStandard. Available values: 'isoiec15415', 'aimdpm_1_2006'.

The color palette used to display the module grades can be specified in Color. Color expects one color for each displayed grade. If less colors than grades are used, the colors are cycled through.


Available generic parameters:

'circle':
For every module, display a circle with a radius corresponding to the calculated aperture.
Possible values: 'true', 'false' 

'center':
For every module, display a cross at the position where the module grade is calculated.
Possible values: 'true', 'false'

'legend':
Display a legend that shows the used colors for each grade.
Possible values: 'true', 'false'

'max_grade':
Display only modules that have a grade less or equal to this value.
Possible values: 0,1,2,3,4
</abstract>
<chapters lang="de_DE">
<item>Identifizierung</item>
<item>Datacode</item>
</chapters>
<chapters lang="en_US">
<item>Identification</item>
<item>Data Code</item>
</chapters>
<example lang="en_US">create_data_code_2d_model ('Data Matrix ECC 200', [], [], DataCodeHandle)
set_data_code_2d_param (DataCodeHandle, 'default_parameters', 'enhanced_recognition')
read_image (Image, 'datacode/ecc200/ecc200_print_quality_02')
find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandle, DecodedDataStrings)
dev_display(Image)
Mode := 'reflectance_margin_module_grades'
dev_display_data_code_2d_print_quality_results (DataCodeHandle, ResultHandle, Mode, 'isoiec15415', [], [], [])    </example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display print quality information for individual data code modules.
</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color(s) of the displayed modules.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>['red','#cc0000','#990000','#660000']</item>
<item>'gray'</item>
</values>
</parameter>
<parameter id="DataCodeHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 2D data code model.</description>
<mixed_type>false</mixed_type>
<sem_type>datacode_2d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of optional parameters to configure the output.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'center'</item>
<item>'circle'</item>
<item>'legend'</item>
<item>'max_range'</item>
</value_list>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the optional parameters.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>0</item>
<item>1</item>
<item>2</item>
<item>3</item>
<item>4</item>
</value_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'reflectance_margin_module_grades'</default_value>
<description lang="en_US">Display mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'reflectance_margin_module_grades'</item>
<item>'bad_modules'</item>
<item>'grid'</item>
</value_list>
</parameter>
<parameter id="QualityStandard">
<default_type>string</default_type>
<default_value>'isoiec15415'</default_value>
<description lang="en_US">Quality standard used for calculation of the module grades.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'isoiec15415'</item>
<item>'isoiec_tr_29158'</item>
<item>'aimdpm_1_2006'</item>
</value_list>
</parameter>
<parameter id="ResultHandle">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Handle of the 2D data code result handle.</description>
<mixed_type>false</mixed_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ncc_matching_results">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Correlation-Based Matching.</c>
<c>* </c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_ncc_model_region (ModelRegion, ModelID[Index])</l>
<l>        gen_contour_region_xld (ModelRegion, ModelContours, 'border_holes')</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_rotate (HomMat2DIdentity, Angle[Match], 0, 0, HomMat2DRotate)</l>
<l>                hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>                affine_trans_pixel (HomMat2DTranslate, 0, 0, RowTrans, ColTrans)</l>
<l>                gen_cross_contour_xld (Cross, RowTrans, ColTrans, 6, Angle[Match])</l>
<l>                dev_display (Cross)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_ncc_matching_results">
<abstract lang="en_US">The procedure dev_display_ncc_matching_results displays the results of correlation-based matching. 

In ModelID, the NCC models for which results should be displayed are passed. This parameter typically contains the same values that were returned by the operators find_ncc_model or find_ncc_models.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective NCC model, the number of colors has to correspond to the number of NCC models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results.


Row, Column, and Angle contain the position and rotation information of the found instances of the NCC models.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operator find_ncc_models can be used directly.
</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Korrelationsbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Correlation-Based</item>
</chapters>
<example lang="en_US">read_image (Image, 'circle_plate')
* 
gen_rectangle2 (Template, 420, 786, 0, 50, 50)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model1ID)
*
gen_rectangle2 (Template, 710, 790, 0, 100, 100)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model2ID)
*
ModelIDs := [Model1ID,Model2ID]
rotate_image (ImageTemplate, ImageRotate, 10, 'constant')
find_ncc_models (ImageRotate, ModelIDs,  -rad(45), rad(90), 0.8, 2, 0.5, 'true', 0, Row, Column, Angle, Score, Model)
*
dev_display_ncc_matching_results (ModelIDs, ['green', 'blue'], Row, Column, Angle, Model)
</example>
<keywords lang="de_DE">
<item>Ergebnisse des korrelationsbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of correlation-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_ncc_model</item>
<item>find_ncc_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse der korrelationsbasierten Matchings.</short>
<short lang="en_US">Display the results of Correlation-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the NCC models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>ncc_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_shape_matching_results">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ScaleR" base_type="ctrl" dimension="0"/>
<par name="ScaleC" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Shape-Based Matching.</c>
<c>* </c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|ScaleR| == 1)</l>
<l>        tuple_gen_const (NumMatches, ScaleR, ScaleR)</l>
<l>    endif</l>
<l>    if (|ScaleC| == 1)</l>
<l>        tuple_gen_const (NumMatches, ScaleC, ScaleC)</l>
<l>    endif</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_shape_model_contours (ModelContours, ModelID[Index], 1)</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_scale (HomMat2DIdentity, ScaleR[Match], ScaleC[Match], 0, 0, HomMat2DScale)</l>
<l>                hom_mat2d_rotate (HomMat2DScale, Angle[Match], 0, 0, HomMat2DRotate)</l>
<l>                hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_shape_matching_results">
<abstract lang="en_US">The procedure dev_display_shape_matching_results displays the results of shape-based matching. 

In ModelID, the shape models for which results should be displayed are passed. This parameter typically contains the same values that were passed to the operator that was used to find the instances of the shape model.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective shape model, the number of colors has to correspond to the number of shape models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results.

Row, Column, and Angle contain the position and rotation information of the found instances of the shape models.

ScaleR and ScaleC contain the scale of the found instances of the shape model. If find_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC should be set to 1.0. If find_scaled_shape_model(s) was used to find the instances of the shape model, ScaleR contains the scale of the found instances and ScaleC should be set to 1.0. If find_aniso_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC contain the respective anisotropic scales of the found instances.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle, ScaleR, and ScaleC refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operators find_shape_models, find_scaled_shape_models, or find_aniso_shape_models can be used directly.
</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Formbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<example lang="en_US">read_image(Image,'mreut')
gen_rectangle1(Rectangle1, 30, 20, 100, 200)
gen_rectangle1 (Rectangle2, 130, 120, 200, 200)
reduce_domain (Image, Rectangle1, ImageReduced1)
reduce_domain (Image, Rectangle2, ImageReduced2)
create_scaled_shape_model(ImageReduced1, 'auto', -0.39, 0.79,
                          'auto', 0.9, 1.1, 'auto', 'auto',
                          'use_polarity', 'auto', 'auto', ModelID1)
create_scaled_shape_model(ImageReduced2, 'auto', -0.39, 0.79,
                          'auto', 0.9, 1.1, 'auto', 'auto',
                          'use_polarity', 'auto', 'auto', ModelID2)
find_scaled_shape_models (Image, [ModelID1,ModelID2], -0.39, 0.78,
                          0.9, 1.1, 0.5, 2, 0.5, 'least_squares', 0, 0.9,
                          Row, Column, Angle, Scale, Score, Model)
dev_display_shape_matching_results ([ModelID1,ModelID2], ['red','green'],
                          Row, Column, Angle, Scale, 1.0, Model)
</example>
<keywords lang="de_DE">
<item>Ergebnisse des formbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of shape-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_shape_model</item>
<item>find_shape_models</item>
<item>find_scaled_shape_model</item>
<item>find_scaled_shape_models</item>
<item>find_aniso_shape_model</item>
<item>find_aniso_shape_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse des formbasierten Matchings.</short>
<short lang="en_US">Display the results of Shape-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the shape models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleC">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instances of the models inthe column direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleR">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instances of the models inthe row direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure opens a new graphics window and adjusts the size</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct image aspect ratio.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority,</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; ImageWidth or MinHeight &gt; ImageHeight)</l>
<l>    ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])</l>
<l>endif</l>
<l>TempWidth := ImageWidth * ResizeFactor</l>
<l>TempHeight := ImageHeight * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := ImageWidth * ResizeFactor</l>
<l>WindowHeight := ImageHeight * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_image">
<abstract lang="en_US">This procedure  opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the given image is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_open_window_fit_size</item>
<item>dev_open_window</item>
</alternatives>
<chapters>
<item>Develop</item>
</chapters>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">read_image (Image, 'mreut')
*
* Open a new graphics window with the default size limits.
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
dev_open_window_fit_image (Image, 50, 50, [300,600], [200,400],
                           WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_image</item>
<item>dev_resize_window_fit_size</item>
</see_also>
<short>Opens a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<short lang="de_DE">Open a new graphics window that preserves the aspect ratio of the given image.</short>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">Image to the size of which the new window is adapted.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[300,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure open a new graphic window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_size">
<abstract lang="en_US">The procedure dev_open_window_fit_size opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is set to -1, the following default value is used: [500,800].
If HeightLimit is set to -1, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_open_window_fit_image</item>
<item>dev_open_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">*
* Open a new graphics window with the default size limits.
dev_open_window_fit_size (0, 0, 640, 480, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
* The window is intended to display a large image with a width
* of 2000 pixel and a height of 15000 pixel while preserving the
* aspect ratio. Note that in this case the minimum width is
* neglected.
dev_open_window_fit_size (50, 50, 2000, 15000, [300,600], [400,800],
                          WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_size</item>
<item>dev_resize_window_fit_image</item>
</see_also>
<short lang="de_DE">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_resize_window_fit_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure adjusts the size of the current window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct image aspect ratio.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority,</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<l>get_image_pointer1 (Image, Pointer, Type, ImageWidth, ImageHeight)</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; ImageWidth or MinHeight &gt; ImageHeight)</l>
<l>    ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])</l>
<l>endif</l>
<l>TempWidth := ImageWidth * ResizeFactor</l>
<l>TempHeight := ImageHeight * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := ImageWidth * ResizeFactor</l>
<l>WindowHeight := ImageHeight * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_resize_window_fit_image">
<abstract lang="en_US">This procedure resizes the current graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the given image is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_resize_window_fit_size</item>
<item>dev_set_window_extents</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 200, 200, 'black', WindowHandle)
*
read_image (Image, 'mreut')
*
dev_resize_window_fit_image (Image, 0, 0, -1, -1)
</example>
<keywords lang="de_DE">
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
</predecessor>
<see_also>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</see_also>
<short lang="de_DE">Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<short lang="en_US">Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">Image to the size of which the window is adapted.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[300,600]</item>
<item>[500,800]</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_resize_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure adjusts the size of the current window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_resize_window_fit_size">
<abstract lang="en_US">This procedure resizes the current graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_resize_window_fit_image</item>
<item>dev_set_window_extents</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
*
gen_image_const (Image, 'byte', 2000, 128)
*
dev_resize_window_fit_size (0, 0, 2000, 128, -1, -1)</example>
<keywords lang="de_DE">
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
</predecessor>
<see_also>
<item>dev_open_window_fit_size</item>
<item>dev_open_window_fit_image</item>
<item>dev_set_window_extents</item>
</see_also>
<short lang="de_DE">Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height</short>
<short lang="en_US">Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_on">
<interface/>
<body>
<c>* This procedure sets different update settings to 'on'.</c>
<c>* </c>
<l>dev_update_pc ('on')</l>
<l>dev_update_var ('on')</l>
<l>dev_update_window ('on')</l>
<l>return ()</l>
</body>
<docu id="dev_update_on">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'on'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_off</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="disp_3d_coord_system">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="CoordAxesLength" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 3D coordinate system.</c>
<c>* It needs the procedure gen_arrow_contour_xld.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window where the coordinate system shall be displayed</c>
<c>* CamParam: The camera paramters</c>
<c>* Pose: The pose to be displayed</c>
<c>* CoordAxesLength: The length of the coordinate axes in world coordinates</c>
<c>* </c>
<c>* Check, if Pose is a correct pose tuple.</c>
<l>if (|Pose| != 7)</l>
<l>    return ()</l>
<l>endif</l>
<l>get_cam_par_data (CamParam, 'camera_type', CameraType)</l>
<l>IsTelecentric := strstr(CameraType,'telecentric') != -1</l>
<l>if (Pose[2] == 0.0 and not IsTelecentric)</l>
<c>    * For projective cameras:</c>
<c>    * Poses with Z position zero cannot be projected</c>
<c>    * (that would lead to a division by zero error).</c>
<l>    return ()</l>
<l>endif</l>
<c>* Convert to pose to a transformation matrix</c>
<l>pose_to_hom_mat3d (Pose, TransWorld2Cam)</l>
<c>* Project the world origin into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, 0, OrigCamX, OrigCamY, OrigCamZ)</l>
<l>project_3d_point (OrigCamX, OrigCamY, OrigCamZ, CamParam, Row0, Column0)</l>
<c>* Project the coordinate axes into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, CoordAxesLength, 0, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxX, ColumnAxX)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, CoordAxesLength, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxY, ColumnAxY)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, CoordAxesLength, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxZ, ColumnAxZ)</l>
<c>* </c>
<c>* Generate an XLD contour for each axis</c>
<l>distance_pp ([Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], Distance)</l>
<l>HeadLength := int(max([max(Distance) / 12.0,5.0]))</l>
<l>gen_arrow_contour_xld (Arrows, [Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], HeadLength, HeadLength)</l>
<c>* </c>
<c>* Display coordinate system</c>
<l>disp_xld (Arrows, WindowHandle)</l>
<c>* </c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_rgb (WindowHandle, Red[0], Green[0], Blue[0])</l>
<l>set_tposition (WindowHandle, RowAxX + 3, ColumnAxX + 3)</l>
<l>write_string (WindowHandle, 'X')</l>
<l>set_rgb (WindowHandle, Red[1 % |Red|], Green[1 % |Green|], Blue[1 % |Blue|])</l>
<l>set_tposition (WindowHandle, RowAxY + 3, ColumnAxY + 3)</l>
<l>write_string (WindowHandle, 'Y')</l>
<l>set_rgb (WindowHandle, Red[2 % |Red|], Green[2 % |Green|], Blue[2 % |Blue|])</l>
<l>set_tposition (WindowHandle, RowAxZ + 3, ColumnAxZ + 3)</l>
<l>write_string (WindowHandle, 'Z')</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>return ()</l>
</body>
<docu id="disp_3d_coord_system">
<abstract lang="en_US">This procedure displays a 3D coordinate system at the given Pose using the camera parameters CamParam in the window WindowHandle. The length of the displayed axes can be specified in world coordinates with the parameter CoordAxesLength. The axes are displayed in the first three currently set colors, which can be checked with get_rgb.
If only a single color is set, this color is used for all three axes.</abstract>
<attention lang="en_US">This procedure needs the procedure gen_arrow_contour_xld.</attention>
<chapters>
<item>Matching-3D</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
Pose:=[0,0,2.0,-30,-15,60,0]
gen_cam_par_area_scan_division (0.012, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
disp_3d_coord_system (WindowHandle, CamParam, Pose, 0.1)</example>
<keywords lang="de_DE">
<item>3D-Koordinatensystem anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display 3D coordinate system</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_set_colored</item>
<item>set_rgb</item>
<item>vector_to_pose</item>
<item>camera_calibration</item>
<item>find_calib_descriptor_model</item>
<item>find_planar_calib_deformable_model</item>
<item>dev_display</item>
<item>find_marks_and_pose</item>
<item>find_shape_model_3d</item>
<item>get_circle_pose</item>
<item>get_rectangle_pose</item>
</predecessor>
<see_also>
<item>create_pose</item>
</see_also>
<short>Display the axes of a 3d coordinate system</short>
<short lang="de_DE">Display the axes of a 3d coordinate system</short>
<short lang="en_US">Display the axes of a 3d coordinate system</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>['area_scan_division',0.012,0.0,5e-6,5e-6,320,240,640,480]</default_value>
<description lang="en_US">Interior camera parameters</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CoordAxesLength">
<default_type>integer</default_type>
<default_value>0.05</default_value>
<description lang="en_US">The length of the coordinate axes in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.01</item>
<item>0.02</item>
<item>0.05</item>
<item>0.1</item>
<item>0.2</item>
<item>0.5</item>
</values>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<default_value>[0.0,0.0,1.0,0.0,0.0,0.0,0]</default_value>
<description lang="en_US">The pose to be displayed</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window where the coordinate system shall be displayed</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 'Continue' text button</c>
<c>* in the lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* </c>
<c>* Use the continue message set in the global variable gTerminationButtonLabel.</c>
<c>* If this variable is not defined, set a standard text instead.</c>
<l>global tuple gTerminationButtonLabel</l>
<l>try</l>
<l>    ContinueMessage := gTerminationButtonLabel</l>
<l>catch (Exception)</l>
<l>    ContinueMessage := 'Continue'</l>
<l>endtry</l>
<c>* Display the continue button</c>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_string_extents (WindowHandle, ' ' + ContinueMessage + ' ', Ascent, Descent, TextWidth, TextHeight)</l>
<l>disp_text_button (WindowHandle, ContinueMessage, 'window', Height - TextHeight - 22, Width - TextWidth - 12, 'black', '#f28f26')</l>
<l>return ()</l>
</body>
<docu id="disp_continue_button">
<abstract lang="en_US">Displays a continue button at the lower right corner.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Displays a continue button.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the button should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays 'Press Run (F5) to continue' in the</c>
<c>* lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* Color: defines the text color.</c>
<c>*    If set to '' or 'auto', the currently set color is used.</c>
<c>* Box: If set to 'true', the text is displayed in a box.</c>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<c>* Display the message.</c>
<l>ContinueMessage := 'Press Run (F5) to continue'</l>
<l>disp_text (WindowHandle, ContinueMessage, 'window', 'bottom', 'right', Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_continue_message">
<abstract lang="en_US">This procedure displays 'Click 'Run' to continue' in a given Color in the lower right corner of the screen.
If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.</abstract>
<alternatives>
<item>disp_message</item>
<item>write_string</item>
</alternatives>
<attention lang="en_US">This procedure uses the procedure disp_message.
</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
for Index := 1 to 5 by 1
    disp_message (WindowHandle, 'Step '+Index, 'window', 30*Index, -1, 'black', 'true')
    disp_continue_message (WindowHandle, 'black', 'true')
    stop ()
endfor
</example>
<keywords lang="de_DE">
<item>Fortsetzungs-Nachricht anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display continue message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disp_message</item>
<item>set_display_font</item>
<item>write_string</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>disp_message</item>
<item>write_string</item>
</see_also>
<short>This procedure displays 'Press 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="de_DE">This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="en_US">This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.</short>
<successor>
<item>stop</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the text color. If set to '' or 'auto', the currently set color is used.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window, where the text shall be displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_end_of_program_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays 'End of program' in the</c>
<c>* lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* Color: defines the text color.</c>
<c>*    If set to '' or 'auto', the currently set color is used.</c>
<c>* Box: If set to 'true', the text is displayed in a box.</c>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<c>* Display the message.</c>
<l>EndMessage := '      End of program      '</l>
<l>disp_text (WindowHandle, EndMessage, 'window', 'bottom', 'right', Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_end_of_program_message">
<abstract lang="en_US">This procedure displays 'End of program' in a given Color in the lower right corner of the screen.
If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.</abstract>
<alternatives>
<item>disp_continue_message</item>
<item>disp_message</item>
<item>write_string</item>
</alternatives>
<attention lang="en_US">This procedure uses the procedure disp_message.
</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
for Index := 1 to 5 by 1
    disp_message (WindowHandle, 'Step '+Index, 'window', 30*Index, -1, 'black', 'true')
    disp_continue_message (WindowHandle, 'black', 'true')
    stop ()
endfor
disp_end_of_program_message (WindowHandle, 'black', 'true')</example>
<keywords lang="en_US">
<item>display end of program message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disp_continue_message</item>
<item>disp_message</item>
<item>set_display_font</item>
<item>write_string</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>disp_message</item>
<item>write_string</item>
</see_also>
<short>This procedure displays 'Press 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="de_DE">This procedure displays 'End of program' in the lower right corner of the screen.</short>
<short lang="en_US">This procedure displays 'End of program' in the lower right corner of the screen.</short>
<successor>
<item>stop</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the text color. If set to '' or 'auto', the currently set color is used.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window, where the text shall be displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    A tuple of values is allowed to display text at different</c>
<c>*    positions.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    A tuple of values is allowed to display text at different</c>
<c>*    positions.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically...</c>
<c>*    - if |Row| == |Column| == 1: for each new textline</c>
<c>*    = else for each text position.</c>
<c>* Box: If Box[0] is set to 'true', the text is written within an orange box.</c>
<c>*      If set to' false', no box is displayed.</c>
<c>*      If set to a color string (e.g. 'white', '#FF00CC', etc.),</c>
<c>*        the text is written in a box of that color.</c>
<c>*      An optional second value for Box (Box[1]) controls if a shadow is displayed:</c>
<c>*        'true' -&gt; display a shadow in a default color</c>
<c>*        'false' -&gt; display no shadow</c>
<c>*        otherwise -&gt; use given string as color string for the shadow color</c>
<c>* </c>
<c>* It is possible to display multiple text strings in a single call.</c>
<c>* In this case, some restrictions apply:</c>
<c>* - Multiple text positions can be defined by specifying a tuple</c>
<c>*   with multiple Row and/or Column coordinates, i.e.:</c>
<c>*   - |Row| == n, |Column| == n</c>
<c>*   - |Row| == n, |Column| == 1</c>
<c>*   - |Row| == 1, |Column| == n</c>
<c>* - If |Row| == |Column| == 1,</c>
<c>*   each element of String is display in a new textline.</c>
<c>* - If multiple positions or specified, the number of Strings</c>
<c>*   must match the number of positions, i.e.:</c>
<c>*   - Either |String| == n (each string is displayed at the</c>
<c>*                           corresponding position),</c>
<c>*   - or     |String| == 1 (The string is displayed n times).</c>
<c>* </c>
<c>* </c>
<c>* Convert the parameters for disp_text.</c>
<l>if (Row == [] or Column == [])</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* Restore default CoordSystem behavior.</c>
<l>if (CoordSystem != 'window')</l>
<l>    CoordSystem := 'image'</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<l>disp_text (WindowHandle, String, CoordSystem, Row, Column, Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_message">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).

If only a single position is defined, one text line is displayed for each element of String. Also, '\n' will be interpreted as a newline character, i.e. a line break is performed.

If multiple positions are defined, only a single string or one string for each position is allowed in String. In this case, line breaks have to be forced with '\n'.

The position of the text may be specified in window coordinates (CoordSystem = 'window') or in image coordinates (CoordSystem = 'image'), which is useful when using zoomed images.

In addition to supplying (Row, Column) coordinates, it is also possible to pass predefined values to Row and Column to display the text at a fixed position in the window (only if CoordSystem = 'window').

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new text position or for every new textline if a single position is used.

Box:
If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color.
An optional second value for Box controls if a shadow is displayed. Possible values are 'true', 'false', or a valid color string.




</abstract>
<alternatives>
<item>disp_text</item>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 12, ['black','blue'], 'true')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 120, 'white', ['blue','false'])
Angle := [0,90,180,270]
Row := 200 - sin(rad(Angle))*100
Column := 250 + cos(rad(Angle))*100
Color := ['green','red','red','red']
disp_message (WindowHandle, Angle+' deg', 'window', Row, Column, Color, 'false')
gen_cross_contour_xld (Cross, 200, 250, 200, 0)
</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="de_DE">This procedure writes a text message.</short>
<short lang="en_US">This procedure writes a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color. Optionally, a second value controls the appearance of a box shadow.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>'white'</item>
<item>'red'</item>
<item>'forest green'</item>
<item>'black'</item>
<item>'blue'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new position or textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>''</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The horizontal text alignment or the column coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'center'</item>
<item>'left'</item>
<item>'right'</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The vertical text alignment or the row coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'bottom'</item>
<item>'center'</item>
<item>'top'</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.
</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_3d_safe">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>    disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Pose, GenParamName, GenParamValue)</l>
<l>catch (Exception)</l>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<l>    NumModels := |ObjectModel3D|</l>
<l>    if (|Pose| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', Pose)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, Pose, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>    elseif (|Pose| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := Pose[Sequence % 7]</l>
<l>    else</l>
<l>        if (|Pose| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := Pose</l>
<l>        endif</l>
<l>    endif</l>
<l>    tuple_find (GenParamName, 'disp_background', Indices)</l>
<l>    if (Indices &gt; 0)</l>
<l>        if (GenParamValue[Indices] == 'true')</l>
<c>            * display background do not clear background</c>
<l>        else</l>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_clear_window ()</l>
<l>        endif</l>
<l>    else</l>
<c>        * No indication of  'disp_background' clear window</c>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_clear_window ()</l>
<l>    endif</l>
<l>    disp_object_model_no_opengl (ModelContours, ObjectModel3D, GenParamName, GenParamValue, WindowHandle, CamParam, Poses)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_3d_safe">
<abstract lang="en_US">This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available.

See disp_object_model_3d for documentation.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available.</short>
<parameters>
<parameter id="CamParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'depth_persistence'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_pose'</item>
<item>'light_position'</item>
<item>'line_color'</item>
<item>'object_index_persistence'</item>
<item>'point_size'</item>
<item>'quality'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'lut'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'normal_x'</item>
<item>'normal_y'</item>
<item>'normal_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_no_opengl">
<interface>
<oo>
<par name="ModelContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d</c>
<c>* call for small objects. Large objects are sampled down to display.</c>
<l>Idx := find(GenParamName,'point_size')</l>
<l>if (|Idx| and Idx != -1)</l>
<l>    CustomParamName := 'point_size'</l>
<l>    CustomParamValue := GenParamValue[Idx]</l>
<l>    if (CustomParamValue == 1)</l>
<l>        CustomParamValue := 0</l>
<l>    endif</l>
<l>else</l>
<l>    CustomParamName := []</l>
<l>    CustomParamValue := []</l>
<l>endif</l>
<l>get_font (WindowHandleBuffer, Font)</l>
<l>tuple_find (GenParamName, 'disp_background', IndicesDispBackGround)</l>
<l>if (IndicesDispBackGround != -1)</l>
<l>    tuple_find (GenParamName[IndicesDispBackGround], 'false', Indices)</l>
<l>    if (Indices != -1)</l>
<l>        clear_window (WindowHandleBuffer)</l>
<l>    endif</l>
<l>endif</l>
<l>set_display_font (WindowHandleBuffer, 11, 'mono', 'false', 'false')</l>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>disp_message (WindowHandleBuffer, 'OpenGL missing!', 'image', 5, ImageWidth - 130, 'red', 'false')</l>
<l>set_font (WindowHandleBuffer, Font)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_polygons', HasPolygons)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_triangles', HasTri)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_points', HasPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_lines', HasLines)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'num_points', NumPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_primitive_data', IsPrimitive)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'center', Center)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'diameter', Diameter)</l>
<l>get_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>set_system ('opengl_hidden_surface_removal_enable', 'false')</l>
<c>* Sort the objects by inverse z</c>
<l>CenterX := Center[[0:3:|Center| - 1]]</l>
<l>CenterY := Center[[0:3:|Center| - 1] + 1]</l>
<l>CenterZ := Center[[0:3:|Center| - 1] + 2]</l>
<l>PosObjectsZ := []</l>
<l>if (|PosesOut| &gt; 7)</l>
<l>    for I := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>        affine_trans_point_3d (HomMat3DObj, CenterX[I], CenterY[I], CenterZ[I], PosObjCenterX, PosObjCenterY, PosObjCenterZ)</l>
<l>        PosObjectsZ := [PosObjectsZ,PosObjCenterZ]</l>
<l>    endfor</l>
<l>else</l>
<l>    Pose := PosesOut[0:6]</l>
<l>    pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>    affine_trans_point_3d (HomMat3DObj, CenterX, CenterY, CenterZ, PosObjectsX, PosObjectsY, PosObjectsZ)</l>
<l>endif</l>
<l>Idx := inverse(sort_index(PosObjectsZ))</l>
<l>Color := 'white'</l>
<l>set_color (WindowHandleBuffer, Color)</l>
<l>if (|GenParamName| &gt; 0)</l>
<l>    tuple_find (GenParamName, 'colored', Indices1)</l>
<l>    tuple_find (GenParamName, 'color', Indices2)</l>
<l>    if (Indices1[0] != -1)</l>
<l>        if (GenParamValue[Indices1[0]] == 3)</l>
<l>            Color := ['red','green','blue']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 6)</l>
<l>            Color := ['red','green','blue','cyan','magenta','yellow']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 12)</l>
<l>            Color := ['red','green','blue','cyan','magenta','yellow','coral','slate blue','spring green','orange red','pink','gold']</l>
<l>        endif</l>
<l>    elseif (Indices2[0] != -1)</l>
<l>        Color := GenParamValue[Indices2[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>for J := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    I := Idx[J]</l>
<l>    if (HasPolygons[I] == 'true' or HasTri[I] == 'true' or HasPoints[I] == 'true' or HasLines[I] == 'true')</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (NumPoints[I] &lt; 10000)</l>
<l>            project_object_model_3d (ModelContours, ObjectModel3DID[I], CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>        else</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>            sample_object_model_3d (ObjectModel3DID[I], 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>            project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_x', X)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_y', Y)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_z', Z)</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D1)</l>
<l>            affine_trans_point_3d (HomMat3D1, X, Y, Z, Qx, Qy, Qz)</l>
<l>            project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>            clear_object_model_3d (SampledObjectModel3D)</l>
<l>        endif</l>
<l>    else</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (IsPrimitive[I] == 'true')</l>
<l>            try</l>
<l>                convex_hull_object_model_3d (ObjectModel3DID[I], ObjectModel3DConvexHull)</l>
<l>                if (NumPoints[I] &lt; 10000)</l>
<l>                    project_object_model_3d (ModelContours, ObjectModel3DConvexHull, CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                else</l>
<l>                    pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>                    sample_object_model_3d (ObjectModel3DConvexHull, 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>                    project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                    clear_object_model_3d (SampledObjectModel3D)</l>
<l>                endif</l>
<l>                clear_object_model_3d (ObjectModel3DConvexHull)</l>
<l>            catch (Exception)</l>
<l>            endtry</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>set_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_no_opengl">
<abstract lang="en_US">Can replace disp_object_model_3d if there is no OpenGL available.
Projects a Modelcontour and displays this instead of the OpenGL view.

If you have no correct pose or no camera parameters use the disp_object_model_3d_safe instead. For the supported generic parameters  are all which are supported by project_object_model_3d. Additionally, it supports the parameter color_i with i in [0,1,2,...].



</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Can replace disp_object_model_3d if there is no OpenGL available.</short>
<parameters>
<parameter id="CamParam">
<sem_type>calib_data</sem_type>
</parameter>
<parameter id="GenParamName">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="GenParamValue">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="ModelContours">
<description lang="en_US">Contour of the last object model,</description>
<multivalue>false</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">The 3D object model to display</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PosesOut">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<description lang="en_US">Window Handle</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_text_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ButtonColor" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically</c>
<c>*    for each new textline.</c>
<c>* ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).</c>
<c>*              The text is written in a box of that color.</c>
<c>* </c>
<c>* Prepare window.</c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>set_part (WindowHandle, 0, 0, HeightWin - 1, WidthWin - 1)</l>
<c>* </c>
<c>* Default settings.</c>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<l>if (TextColor == [])</l>
<l>    TextColor := ''</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<l>    color_string_to_rgb (ButtonColor, RGB)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter ButtonColor (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>Fac := 0.4</l>
<l>RGBL := RGB + int((255.0 - RGB) * Fac + 0.5)</l>
<l>RGBD := RGB - int(RGB * Fac + 0.5)</l>
<l>ButtonColorBorderL := '#' + sum('' + RGBL$'02x')</l>
<l>ButtonColorBorderD := '#' + sum('' + RGBD$'02x')</l>
<c>* </c>
<l>String := split('' + String + '','\n')</l>
<c>* </c>
<c>* Estimate extentions of text depending on font size.</c>
<l>get_font_extents (WindowHandle, MaxAscent, MaxDescent, MaxWidth, MaxHeight)</l>
<l>if (CoordSystem == 'window')</l>
<l>    R1 := Row</l>
<l>    C1 := Column</l>
<l>else</l>
<c>    * Transform image to window coordinates.</c>
<l>    FactorRow := 1. * HeightWin / (Row2Part - Row1Part + 1)</l>
<l>    FactorColumn := 1. * WidthWin / (Column2Part - Column1Part + 1)</l>
<l>    R1 := (Row - Row1Part + 0.5) * FactorRow</l>
<l>    C1 := (Column - Column1Part + 0.5) * FactorColumn</l>
<l>endif</l>
<c>* </c>
<c>* Display text box depending on text size.</c>
<c>* </c>
<c>* Calculate box extents.</c>
<l>String := ' ' + String + ' '</l>
<l>Width := []</l>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, String[Index], Ascent, Descent, W, H)</l>
<l>    Width := [Width,W]</l>
<l>endfor</l>
<l>FrameHeight := MaxHeight * |String|</l>
<l>FrameWidth := max([0,Width])</l>
<l>R2 := R1 + FrameHeight</l>
<l>C2 := C1 + FrameWidth</l>
<c>* Display rectangles.</c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>set_draw (WindowHandle, 'fill')</l>
<l>BorderWidth := 2</l>
<l>gen_region_polygon_filled (UpperLeft, [R1 - BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C1 - BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_region_polygon_filled (LowerRight, [R2 + BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C2 + BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_rectangle1 (Rectangle, R1, C1, R2, C2)</l>
<l>set_color (WindowHandle, ButtonColorBorderL)</l>
<l>disp_obj (UpperLeft, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColorBorderD)</l>
<l>disp_obj (LowerRight, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColor)</l>
<l>disp_obj (Rectangle, WindowHandle)</l>
<l>set_draw (WindowHandle, DrawMode)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<c>* Write text.</c>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    CurrentColor := TextColor[Index % |TextColor|]</l>
<l>    if (CurrentColor != '' and CurrentColor != 'auto')</l>
<l>        set_color (WindowHandle, CurrentColor)</l>
<l>    else</l>
<l>        set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>    endif</l>
<l>    Row := R1 + MaxHeight * Index</l>
<l>    disp_text (WindowHandle, String[Index], 'window', Row, C1, CurrentColor, 'box', 'false')</l>
<l>endfor</l>
<c>* Reset changed window settings.</c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>return ()</l>
</body>
<docu id="disp_text_button">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).
If String is a tuple, one text line is displayed for each entry. Also, '\n' will be interpreted as a newline character, i.e. a line break is performed. Empty strings (or empty parts before or after a newline) are ignored. To write empty lines, use a whitespace character.

The position of the text may be specified in window coordinates (CoordSystem = 'window') or in image coordinates (CoordSystem = 'image'), which is useful when using zoomed images.

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new textline.

If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.

</abstract>
<alternatives>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', -1, -1, ['black','blue'], 'true')
</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="de_DE">This procedure writes a text message.</short>
<short lang="en_US">This procedure writes a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="ButtonColor">
<default_type>string</default_type>
<default_value>'gray'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'gray'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<default_value>'Text'</default_value>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.
</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'white'</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_title_and_information">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple gInfoDecor</l>
<l>global tuple gInfoPos</l>
<l>global tuple gTitlePos</l>
<l>global tuple gTitleDecor</l>
<c>* </c>
<l>get_window_extents (WindowHandle, WinRow, WinColumn, WinWidth, WinHeight)</l>
<l>Title := split('' + Title + '','\n')</l>
<l>NumTitleLines := |Title|</l>
<l>if (NumTitleLines &gt; 0)</l>
<l>    Row := 12</l>
<l>    if (gTitlePos == 'UpperLeft')</l>
<l>        Column := 12</l>
<l>    elseif (gTitlePos == 'UpperCenter')</l>
<l>        max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        Column := WinWidth / 2 - TextWidth / 2</l>
<l>    elseif (gTitlePos == 'UpperRight')</l>
<l>        if (gTitleDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Title + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        endif</l>
<l>        Column := WinWidth - TextWidth - 10</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Title, 'window', Row, Column, gTitleDecor[0], gTitleDecor[1])</l>
<l>endif</l>
<l>Information := split('' + Information + '','\n')</l>
<l>NumInfoLines := |Information|</l>
<l>if (NumInfoLines &gt; 0)</l>
<l>    if (gInfoPos == 'UpperLeft')</l>
<l>        Row := 12</l>
<l>        Column := 12</l>
<l>    elseif (gInfoPos == 'UpperRight')</l>
<l>        if (gInfoDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Information + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Information, TextWidth)</l>
<l>        endif</l>
<l>        Row := 12</l>
<l>        Column := WinWidth - TextWidth - 12</l>
<l>    elseif (gInfoPos == 'LowerLeft')</l>
<l>        get_string_extents (WindowHandle, Information, Ascent, Descent, Width, Height)</l>
<l>        Row := WinHeight - (max2(0,NumInfoLines - 1) * (Ascent + Descent) + Height) - 12</l>
<l>        Column := 12</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Information, 'window', Row, Column, gInfoDecor[0], gInfoDecor[1])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="disp_title_and_information">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Information"/>
<parameter id="Title"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="dump_image_output">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="ColorImage" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="VisualizeTrackball" base_type="ctrl" dimension="0"/>
<par name="DisplayContinueButton" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="VisualizeRotationCenter" base_type="ctrl" dimension="0"/>
<par name="RotationCenter" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple gAlphaDeselected</l>
<l>global tuple gTerminationButtonLabel</l>
<l>global tuple gDispObjOffset</l>
<l>global tuple gLabelsDecor</l>
<l>global tuple gUsesOpenGL</l>
<c>* </c>
<c>* Display background image</c>
<l>clear_window (WindowHandleBuffer)</l>
<l>if (ColorImage)</l>
<l>    disp_color (BackgroundImage, WindowHandleBuffer)</l>
<l>else</l>
<l>    disp_image (BackgroundImage, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display objects</c>
<l>if (sum(SelectedObject) == |SelectedObject|)</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        try</l>
<l>            display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 5185 or Exception[0] == 5188 or Exception[0] == 5187)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'false')</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, GenParamName, GenParamValue, WindowHandleBuffer, CamParam, Poses)</l>
<l>    endif</l>
<l>else</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        if (SelectedObject[Index] == 1)</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>        else</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', gAlphaDeselected)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    try</l>
<l>        if (gUsesOpenGL == 'false')</l>
<l>            throw ([])</l>
<l>        endif</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        DeselectedIdx := find(SelectedObject,0)</l>
<l>        if (DeselectedIdx != -1)</l>
<l>            DeselectedName := 'color_' + DeselectedIdx</l>
<l>            DeselectedValue := gen_tuple_const(|DeselectedName|,'gray')</l>
<l>        endif</l>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, [GenParamName,DeselectedName], [GenParamValue,DeselectedValue], WindowHandleBuffer, CamParam, Poses)</l>
<l>    endtry</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Display labels</c>
<l>if (Labels != 0)</l>
<l>    set_color (WindowHandleBuffer, gLabelsDecor[0])</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<c>        * Project the center point of the current model</c>
<l>        Pose := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'center', Center)</l>
<l>        affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], CenterCamX, CenterCamY, CenterCamZ)</l>
<l>        project_3d_point (CenterCamX, CenterCamY, CenterCamZ, CamParam, CenterRow, CenterCol)</l>
<l>        Label := Labels[Index]</l>
<l>        if (Label != '')</l>
<l>            get_string_extents (WindowHandleBuffer, Label, Ascent, Descent, TextWidth, TextHeight)</l>
<l>            disp_message (WindowHandleBuffer, Label, 'window', CenterRow - TextHeight / 2 + gDispObjOffset[0], CenterCol - TextWidth / 2 + gDispObjOffset[1], [], gLabelsDecor[1])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the trackball if desired</c>
<l>if (VisualizeTrackball)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    gen_ellipse_contour_xld (TrackballContour, TrackballCenterRow, TrackballCenterCol, 0, TrackballRadiusPixel, TrackballRadiusPixel, 0, 6.28318, 'positive', 1.5)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (TrackballContour, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the rotation center if desired</c>
<l>if (VisualizeRotationCenter != 0 and |RotationCenter| == 3)</l>
<l>    if (RotationCenter[2] &lt; 1e-10)</l>
<l>        RotationCenter[2] := 1e-10</l>
<l>    endif</l>
<l>    project_3d_point (RotationCenter[0], RotationCenter[1], RotationCenter[2], CamParam, RotCenterRow, RotCenterCol)</l>
<l>    Orientation := rad(90)</l>
<l>    if (VisualizeRotationCenter == 1)</l>
<l>        Orientation := rad(45)</l>
<l>    endif</l>
<l>    gen_cross_contour_xld (CrossRotCenter, RotCenterRow, RotCenterCol, TrackballRadiusPixel / 25.0, Orientation)</l>
<l>    set_line_width (WindowHandleBuffer, 3)</l>
<l>    query_color (WindowHandleBuffer, Colors)</l>
<l>    set_color (WindowHandleBuffer, 'light gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display title</c>
<l>disp_title_and_information (WindowHandleBuffer, Title, Information)</l>
<c>* </c>
<c>* Display the 'Exit' button</c>
<l>if (DisplayContinueButton == 'true')</l>
<l>    disp_continue_button (WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dump_image_output">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Renders 3D object models in a buffer window.</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage">
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="CamParam"/>
<parameter id="ColorImage">
<sem_type>string</sem_type>
</parameter>
<parameter id="DisplayContinueButton"/>
<parameter id="GenParamName">
<sem_type>string</sem_type>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Information">
<sem_type>string</sem_type>
</parameter>
<parameter id="Labels">
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Poses">
<sem_type>pose</sem_type>
</parameter>
<parameter id="RotationCenter"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject">
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="Title">
<sem_type>string</sem_type>
</parameter>
<parameter id="TrackballCenterCol">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballCenterRow">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballRadiusPixel">
<sem_type>real</sem_type>
</parameter>
<parameter id="VisualizeRotationCenter"/>
<parameter id="VisualizeTrackball">
<sem_type>real</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="estimate_bounding_box_3d_reconstruction">
<interface>
<ic>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BoundingBox" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The goal of this procedure is to estimate bounding box parameters</c>
<c>* for 3D reconstruction. This is done by intersecting the</c>
<c>* cones of sight of the cameras with a plane defined by the pose</c>
<c>* of the reference calibration plate.</c>
<c>* </c>
<l>if (ObjectHeight == 0)</l>
<l>    throw ('Object height must not be zero.')</l>
<l>endif</l>
<c>* Check whether the coordinate system has been moved by setting a pose</c>
<c>* with the parameter 'coord_transf_pose' in set_camera_setup_param.</c>
<c>* If this is not the case, the origin is still in one of the cameras.</c>
<c>* However, this procedures needs the origin to be in a calibration plate.</c>
<l>get_stereo_model_param (StereoModelID, 'camera_setup_model', CameraSetupModelID)</l>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'reference_camera', ReferenceCamera)</l>
<l>if (ReferenceCamera != -1)</l>
<l>    throw ('Please set the \'coord_transf_pose\' to the pose of an calibration plate that lies horizontally in the image using the get_calib_data and set_camera_setup_param.')</l>
<l>endif</l>
<c>* Check whether the image pairs have been set.</c>
<l>get_stereo_model_image_pairs (StereoModelID, From, To)</l>
<l>if (|From| == 0 or |To| == 0)</l>
<l>    throw ('Please define the image pairs first with \'get_stereo_model_image_pairs.\'')</l>
<l>endif</l>
<c>* </c>
<c>* First, we generate 3D object models that represent the cones of sight of the cameras,</c>
<c>* like in the procedure gen_camera_setup_object_model_3d.</c>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<l>ObjectModel3DCone := []</l>
<l>DistanceCameras := []</l>
<l>for CameraIndex := 0 to NumCameras - 1 by 1</l>
<l>    get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>    DistanceCamera := sqrt((CamPose[0] * CamPose[0]) + (CamPose[1] * CamPose[1]) + (CamPose[2] * CamPose[2]))</l>
<l>    DistanceCameras := [DistanceCameras,DistanceCamera]</l>
<l>    ConeLength := DistanceCamera * 2.0</l>
<c>    * Distinguish cases with/without projection center.</c>
<l>    get_camera_setup_param (CameraSetupModelID, CameraIndex, 'type', Type)</l>
<l>    if (Type =~ 'telecentric')</l>
<l>        gen_cone_telecentric_object_model_3d (CameraSetupModelID, CameraIndex, ConeLength, ObjectModel3D)</l>
<l>    else</l>
<l>        gen_cone_perspective_object_model_3d (CameraSetupModelID, CameraIndex, ConeLength, ObjectModel3D)</l>
<l>    endif</l>
<l>    ObjectModel3DCone := [ObjectModel3DCone,ObjectModel3D]</l>
<l>endfor</l>
<c>* </c>
<c>* Then, we intersect these cones of sight with a plane that lies horizontally</c>
<c>* in the origin of the stereo setup. We do this simultaneously for the</c>
<c>* previously defined image pairs.</c>
<l>gen_empty_obj (PlaneConeIntersections)</l>
<l>for Index1 := 0 to |From| - 1 by 1</l>
<l>    intersect_plane_object_model_3d (ObjectModel3DCone[From[Index1]], [0,0,0,0,0,0,0], ObjectModel3DIntersectionFrom)</l>
<l>    intersect_plane_object_model_3d (ObjectModel3DCone[To[Index1]], [0,0,0,0,0,0,0], ObjectModel3DIntersectionTo)</l>
<c>    * </c>
<c>    * Get the coordinates of the 3D object models that represent the intersection.</c>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionFrom, 'point_coord_x', XFrom)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionFrom, 'point_coord_y', YFrom)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionTo, 'point_coord_x', XTo)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionTo, 'point_coord_y', YTo)</l>
<c>    * </c>
<c>    * The, we want to intersect the intersections of the image pair. We do this in 2D using XLDs.</c>
<c>    * Generate the XLD of the 'From' intersection.</c>
<l>    gen_contour_polygon_xld (ContourFrom, XFrom, YFrom)</l>
<c>    * Generate the XLD of the 'To' intersection.</c>
<l>    gen_contour_polygon_xld (ContourTo, XTo, YTo)</l>
<c>    * </c>
<c>    * The order of the coordinates from get_object_model_3d_params might not be ideal.</c>
<c>    * Thus, we compute the smallest rectangle around the created XLD.</c>
<l>    smallest_rectangle2_xld (ContourFrom, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2_contour_xld (RectangleFrom, Row, Column, Phi, Length1, Length2)</l>
<l>    smallest_rectangle2_xld (ContourTo, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2_contour_xld (RectangleTo, Row, Column, Phi, Length1, Length2)</l>
<c>    * </c>
<c>    * Intersect and concatenate the intersections</c>
<l>    intersection_closed_contours_xld (RectangleFrom, RectangleTo, ContoursIntersection)</l>
<l>    concat_obj (PlaneConeIntersections, ContoursIntersection, PlaneConeIntersections)</l>
<l>    clear_object_model_3d (ObjectModel3DIntersectionFrom)</l>
<l>    clear_object_model_3d (ObjectModel3DIntersectionTo)</l>
<l>endfor</l>
<c>* </c>
<c>* Union all intersections of all image pairs.</c>
<l>gen_empty_obj (PlaneConeIntersectionUnion)</l>
<l>count_obj (PlaneConeIntersections, Number)</l>
<l>for Index2 := 1 to Number by 1</l>
<l>    select_obj (PlaneConeIntersections, ObjectSelected, Index2)</l>
<l>    union2_closed_contours_xld (ObjectSelected, PlaneConeIntersectionUnion, PlaneConeIntersectionUnion)</l>
<l>endfor</l>
<c>* </c>
<c>* Get the coordinates of the resulting XLD, which represents the area</c>
<c>* in 2D where the reconstruction is possible.</c>
<l>get_contour_xld (PlaneConeIntersectionUnion, RowContour, ColumnContour)</l>
<c>* </c>
<c>* Based on this contour, we can easily access the parameters of the bounding box.</c>
<l>if (ObjectHeight &gt; 0)</l>
<l>    BoundingBox := [min(RowContour),min(ColumnContour),-ObjectHeight,max(RowContour),max(ColumnContour),0]</l>
<l>else</l>
<l>    BoundingBox := [min(RowContour),min(ColumnContour),0,max(RowContour),max(ColumnContour),-ObjectHeight]</l>
<l>endif</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>clear_object_model_3d (ObjectModel3DCone)</l>
<l>return ()</l>
</body>
<docu id="estimate_bounding_box_3d_reconstruction">
<abstract lang="en_US">estimate_bounding_box_3d_reconstruction estimates a suitable bounding box for the stereo setup given in StereoModelID. The height of the bounding box is specified in ObjectHeight. 
The bounding box is returned as a tuple in the form [X1, Y1, Z1, X2, Y2, Z2], where [X1,Y1,Z1] and [X2,Y2,Z2] are the coordinates of the upper left and lower right corner.

The parameters of the bounding box are calculated based on the intersection of the cones of sight of the cameras with the world plane.The world plane should be the plane where the recontructed objects are placed. Typically, it is defined by the pose of a calibration plate. For this procedure to work, it is necessary to set a suitable plane as reference coordinate system within the camera setup model with the parameter 'coord_transf_pose' of set_camera_setup_param.
For example, if you want to use the image of the first calibration plate for the reference coordinate system, use 

ReferencePoseIndex := 1
get_calib_data (CalibDataID, 'calib_obj_pose', [0,ReferencePoseIndex], 'pose', ReferencePose)
set_camera_setup_param (CameraSetupModelID, 'general', 'coord_transf_pose', ReferencePose)

Additionally, before calling this procedure, you need the set the image pairs of the stereo reconstruction using get_stereo_model_image_pairs.</abstract>
<chapters lang="de_DE">
<item>3D-Rekonstruktion</item>
<item>Mehrbild-Stereo</item>
</chapters>
<chapters lang="en_US">
<item>3D Reconstruction</item>
<item>Multi-View Stereo</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_cameras</item>
<item>get_calib_data</item>
<item>set_camera_setup_param</item>
<item>set_stereo_model_image_pairs</item>
<item>create_stereo_model</item>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<short lang="en_US">Estimate a bounding box for 3D reconstruction based on a stereo setup.</short>
<successor>
<item>set_stereo_model_param</item>
<item>reconstruct_surface_stereo</item>
<item>clear_object_model_3d</item>
<item>disp_object_model_3d</item>
</successor>
<parameters>
<parameter id="BoundingBox">
<default_type>real</default_type>
<description lang="en_US">The bounding box parameters.</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<default_value>0.05</default_value>
<description lang="en_US">Height of the object that will be reconstructed, in meters.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.01</item>
<item>0.02</item>
<item>0.05</item>
<item>0.1</item>
</values>
</parameter>
<parameter id="StereoModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle to the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c>* </c>
<c>* input parameteres:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c>* </c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c>* </c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c>* </c>
<c>* </c>
<c>* Init</c>
<l>gen_empty_obj (Arrow)</l>
<c>* </c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c>* </c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c>* </c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c>* </c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c>* </c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Coordinates2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.
</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])
</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="de_DE">Creates an arrow shaped XLD contour.</short>
<short lang="en_US">Creates an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowStart" base_type="ctrl" dimension="0"/>
<par name="ArrowEnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DArrow" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure draws an arrow that starts at the point ArrowStart and ends at ArrowEnd.</c>
<c>* </c>
<c>* Get parameters.</c>
<l>DirectionVector := ArrowEnd[0:2] - ArrowStart[0:2]</l>
<l>ArrowLength := sqrt(DirectionVector[0] * DirectionVector[0] + DirectionVector[1] * DirectionVector[1] + DirectionVector[2] * DirectionVector[2])</l>
<l>ConeRadius := 2.0 * ArrowThickness</l>
<l>ConeLength := min([2.0 * ConeRadius,ArrowLength * 0.9])</l>
<l>CylinderLength := ArrowLength - ConeLength</l>
<c>* </c>
<c>* Create cone.</c>
<l>pi := rad(180)</l>
<l>X := 0</l>
<l>Y := 0</l>
<l>Z := CylinderLength + ConeLength</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ConeRadius * cos(Index)]</l>
<l>    Y := [Y,ConeRadius * sin(Index)]</l>
<l>    Z := [Z,CylinderLength]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (X, Y, Z, OM3DConeTmp)</l>
<l>convex_hull_object_model_3d (OM3DConeTmp, OM3DCone)</l>
<l>clear_object_model_3d (OM3DConeTmp)</l>
<c>* </c>
<c>* Create cylinder.</c>
<l>X := []</l>
<l>Y := []</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ArrowThickness * cos(Index)]</l>
<l>    Y := [Y,ArrowThickness * sin(Index)]</l>
<l>endfor</l>
<l>tuple_gen_const (|Y|, 0, ZZero)</l>
<l>tuple_gen_const (|Y|, CylinderLength, ZTop)</l>
<l>gen_object_model_3d_from_points ([X,X], [Y,Y], [ZZero,ZTop], OM3DCylinderTmp)</l>
<l>convex_hull_object_model_3d (OM3DCylinderTmp, OM3DCylinder)</l>
<l>clear_object_model_3d (OM3DCylinderTmp)</l>
<c>* </c>
<c>* Union cone and cylinder Create arrow.</c>
<l>union_object_model_3d ([OM3DCone,OM3DCylinder], 'points_surface', OM3DArrowTmp)</l>
<l>clear_object_model_3d (OM3DCone)</l>
<l>clear_object_model_3d (OM3DCylinder)</l>
<l>Scale := CylinderLength / ArrowLength</l>
<l>OriginX := [0,0,0]</l>
<l>OriginY := [0,0,0]</l>
<l>OriginZ := [0,CylinderLength,ArrowLength]</l>
<l>TargetX := [ArrowStart[0],ArrowStart[0] + Scale * DirectionVector[0],ArrowEnd[0]]</l>
<l>TargetY := [ArrowStart[1],ArrowStart[1] + Scale * DirectionVector[1],ArrowEnd[1]]</l>
<l>TargetZ := [ArrowStart[2],ArrowStart[2] + Scale * DirectionVector[2],ArrowEnd[2]]</l>
<l>vector_to_hom_mat3d ('rigid', OriginX, OriginY, OriginZ, TargetX, TargetY, TargetZ, HomMat3D)</l>
<l>affine_trans_object_model_3d (OM3DArrowTmp, HomMat3D, OM3DArrow)</l>
<l>clear_object_model_3d (OM3DArrowTmp)</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ArrowEnd">
<default_type>real</default_type>
<default_value>[0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowStart">
<default_type>real</default_type>
<default_value>[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<default_value>0.005</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DArrow">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_bounding_box_object_model_3d">
<interface>
<ic>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3DBoundingBox" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency check:</c>
<l>get_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)</l>
<l>if ((BoundingBox[3] &lt; BoundingBox[0]) or (BoundingBox[4] &lt; BoundingBox[1]) or (BoundingBox[5] &lt; BoundingBox[2]))</l>
<l>    throw ('Invalid bounding box or bounding box not set yet.')</l>
<l>endif</l>
<c>* </c>
<c>* Get the eight corner points from the min/max representation.</c>
<l>Points := {[]}</l>
<l>Points.at(0) := [BoundingBox[0],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(1) := [BoundingBox[3],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(2) := [BoundingBox[3],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(3) := [BoundingBox[0],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(4) := [BoundingBox[0],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(5) := [BoundingBox[3],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(6) := [BoundingBox[3],BoundingBox[4],BoundingBox[5]]</l>
<l>Points.at(7) := [BoundingBox[0],BoundingBox[4],BoundingBox[5]]</l>
<c>* </c>
<c>* Sort the corner points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3DBoundingBox)</l>
<c>* </c>
<c>* Set the sides of the cuboid.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,5,4]</l>
<l>Faces := [Faces,4,1,2,6,5]</l>
<l>Faces := [Faces,4,2,3,7,6]</l>
<l>Faces := [Faces,4,3,0,4,7]</l>
<l>Faces := [Faces,4,0,1,2,3]</l>
<l>Faces := [Faces,4,4,5,6,7]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3DBoundingBox, 'polygons', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_bounding_box_object_model_3d">
<abstract lang="en_US">The procedure gen_bounding_box_object_model_3d generates a 3D object model which visualizes the bounding box of a stereo model. The extent of the bounding box is also returned. 

The procedure can be used, e.g., to visualize the setup of the stereo model with its bounding box and cameras which is particularly helpful while adjusting the bounding box. The procedure gen_camera_setup_object_model_3d creates the according 3D object models for cameras and their cones of sight.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_stereo_model</item>
<item>set_stereo_model_param</item>
</predecessor>
<see_also>
<item>reconstruct_surface_stereo</item>
</see_also>
<short lang="en_US">Generate a 3D object model which visualizes the bounding box of a stereo model.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
</successor>
<parameters>
<parameter id="ObjectModel3DBoundingBox">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="StereoModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_division',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_division">
<abstract lang="en_US">gen_cam_par_area_scan_division generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the division model.  For this, the camera parameters must be passed in Focus, Kappa, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_polynomial',Focus,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_polynomial generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus, K1, K2, K3, P1, P2, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a telecentric lens and with distortions modeled by the</c>
<c>* division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_telecentric_division',Magnification,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with a telecentric lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification, Kappa, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a telecentric lens and with distortions modeled by the</c>
<c>* polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification, K1, K2, K3, P1, P2, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_bilateral_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a bilateral telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_bilateral_telecentric_division',Magnification,Kappa,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_bilateral_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_bilateral_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification, Kappa, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="de_DE">Output camera parameter tuple.</description>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a bilateral telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_bilateral_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification, K1, K2, K3, P1, P2, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a tilt lens and with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_division',Focus,Kappa,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_division generates the camera parameter tuple CameraParam for an area scan camera with a tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Focus, Kappa, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_image_side_telecentric_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an image-side telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_image_side_telecentric_division',Focus,Kappa,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_image_side_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_image_side_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Focus, Kappa, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an image-side telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_image_side_telecentric_polynomial',Focus,K1,K2,K3,P1,P2,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus, K1, K2, K3, P1, P2, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_object_side_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an object-side telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_object_side_telecentric_division',Magnification,Kappa,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_object_side_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_object_side_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification, Kappa, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="de_DE">Output camera parameter tuple.</description>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an object-side telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_object_side_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification, K1, K2, K3, P1, P2, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a tilt lens and with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_polynomial',Focus,K1,K2,K3,P1,P2,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus, K1, K2, K3, P1, P2, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a line scan camera.</c>
<c>* </c>
<l>CameraParam := ['line_scan',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan">
<abstract lang="en_US">gen_cam_par_line_scan generates the camera parameter tuple CameraParam for a line scan camera. For this, the camera parameters must be passed in Focus, Kappa, Sx, Sy, Cx, Cy, ImageWidth, ImageHeight, Vx, Vy, Vz. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_and_tool_moving_cam_object_model_3d">
<interface>
<ic>
<par name="ToolInCamPose" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrig" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure helps visualize the camera and its cone, as well</c>
<c>* as the robot's tool in their current positions.</c>
<c>* </c>
<c>* Visualize Tool.</c>
<l>rigid_trans_object_model_3d (OM3DToolOrig, ToolInBasePose, OM3DTool)</l>
<c>* </c>
<c>* Visualize Camera.</c>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, IdentityPose)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCameraOrigin, OM3DConeOrig)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>OM3DCameraOrigin := [OM3DCameraOrigin,OM3DConeOrig]</l>
<c>* </c>
<l>pose_invert (ToolInCamPose, CamInToolPose)</l>
<l>pose_compose (ToolInBasePose, CamInToolPose, CamInBasePose)</l>
<l>rigid_trans_object_model_3d (OM3DCameraOrigin, CamInBasePose, OM3DCamera)</l>
<l>clear_object_model_3d (OM3DCameraOrigin)</l>
<l>return ()</l>
</body>
<docu id="gen_camera_and_tool_moving_cam_object_model_3d">
<abstract lang="en_US">This procedure generates 3D object models for the camera and its cone, as well as the robot's tool in their current positions.

The input parameter ToolInCamPose is directly obtained through hand-eye calibration. ToolInBasePose is the current position of the robot's tool. CameraSize determines the size of the camera. ConeLength specifies the length of the camera's cone. OM3DToolOrig is the 3D object model of the robot's tool in its initial position. CamParam contains the camera parameters, obtained through calibration.

The output parameters OM3DCamera and OM3DTool are respectively the 3D object models of the camera and the robot's tool in their current positions.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate 3D object models for the camera and the robot's tool.</short>
<parameters>
<parameter id="CamParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters.</description>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Visualization factor.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<description lang="en_US">Length of the camera's cone.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrig">
<default_type>integer</default_type>
<description lang="en_US">Initial 3D object model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInCamPose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the camera coordinate system.</description>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_object_model_3d">
<interface>
<ic>
<par name="CameraSetupModel" base_type="ctrl" dimension="0"/>
<par name="CamIndex" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Generate a cylinder (lens) and move it behind the origin in direction z.</c>
<l>create_pose (0.0, 0.0, 0.0, 0, 0, 0, 'Rp+T', 'gba', 'point', LensePose)</l>
<l>CylinderLength := CameraSize / 4.0</l>
<l>gen_cylinder_object_model_3d (LensePose, CameraSize / 2.0, -CylinderLength / 2.0, 0.0, ObjectModel3DLense)</l>
<c>* </c>
<c>* Generate a box (sensor housing) and tilt it, if necessary.</c>
<l>gen_box_object_model_3d (LensePose, 1.0 * CameraSize, 1.0 * CameraSize, 1.0 * CameraSize, ObjectModel3DInit)</l>
<l>get_camera_setup_param (CameraSetupModel, CamIndex, 'params', CamParams)</l>
<l>get_camera_setup_param (CameraSetupModel, CamIndex, 'type', Type)</l>
<c>* </c>
<c>* Distinguish cases with/without tilt.</c>
<l>if (Type =~ 'tilt')</l>
<l>    get_cam_par_data (CamParams, 'tilt', Tilt)</l>
<l>    get_cam_par_data (CamParams, 'rot', Rot)</l>
<l>else</l>
<l>    Tilt := 0</l>
<l>    Rot := 0</l>
<l>endif</l>
<l>hom_mat3d_identity (HomMat3DIdentity)</l>
<l>hom_mat3d_rotate (HomMat3DIdentity, rad(Tilt), [cos(rad(Rot)),sin(rad(Rot)),0], 0, 0, 0, HomMat3DRotate)</l>
<l>hom_mat3d_to_pose (HomMat3DRotate, SensorToLenseRotation)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DInit, SensorToLenseRotation, ObjectModel3DInitTilted)</l>
<c>* </c>
<c>* Move the sensor to a convenient position behind the lens.</c>
<l>get_object_model_3d_params (ObjectModel3DInitTilted, 'bounding_box1', BoundingBox)</l>
<l>affine_trans_point_3d (HomMat3DRotate, 0.0, 0.0, 0.5 * CameraSize, PX, PY, QZ)</l>
<l>create_pose (-PX, -PY, -BoundingBox[5] - CylinderLength / 2.0, 0, 0, 0, 'Rp+T', 'gba', 'point', PoseBack)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DInitTilted, PoseBack, ObjectModel3DInitTiltedBack)</l>
<c>* </c>
<c>* Move to the position of the camera in world coordinates.</c>
<l>get_camera_setup_param (CameraSetupModel, CamIndex, 'pose', CamPose)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DInitTiltedBack, CamPose, OM3DSensor)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DLense, CamPose, OM3DLense)</l>
<l>OM3DCam := [OM3DSensor,OM3DLense]</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_object_model_3d (ObjectModel3DInit)</l>
<l>clear_object_model_3d (ObjectModel3DInitTilted)</l>
<l>clear_object_model_3d (ObjectModel3DInitTiltedBack)</l>
<l>clear_object_model_3d (ObjectModel3DLense)</l>
<l>return ()</l>
</body>
<docu id="gen_camera_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a symbolic 3D object model of a camera.</short>
<parameters>
<parameter id="CamIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="CameraSetupModel">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCam">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_setup_object_model_3d">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3DCamera" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DCone" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<c>* </c>
<c>* Consistency check:</c>
<l>if (NumCameras &lt; 1)</l>
<l>    throw ('No camera set.')</l>
<l>endif</l>
<l>if (is_number(CameraSize))</l>
<l>    if (CameraSize &lt;= 0.0)</l>
<l>        throw ('Invalid value for CameraSize. CameraSize must be positive or \'auto\'.')</l>
<l>    endif</l>
<l>elseif (CameraSize != 'auto')</l>
<l>    throw ('Invalid value for CameraSize. CameraSize must be positive or \'auto\'.')</l>
<l>endif</l>
<l>if (is_number(ConeLength))</l>
<l>    if (ConeLength &lt;= 0.0)</l>
<l>        throw ('Invalid value for ConeLength. ConeLength must be positive or \'auto\'.')</l>
<l>    endif</l>
<l>elseif (ConeLength != 'auto')</l>
<l>    throw ('Invalid value for ConeLength. ConeLength must be positive or \'auto\'.')</l>
<l>endif</l>
<c>* </c>
<l>AutoConeLength := ConeLength == 'auto'</l>
<c>* </c>
<l>ObjectModel3DCamera := []</l>
<l>ObjectModel3DCone := []</l>
<l>AllCameras := [0:NumCameras - 1]</l>
<l>for CurrentCamera := 0 to NumCameras - 1 by 1</l>
<l>    ConcatZ := []</l>
<l>    if (AutoConeLength)</l>
<l>        if (NumCameras &lt; 2)</l>
<l>            throw ('You need at least two cameras for ConeLength == auto.')</l>
<l>        endif</l>
<c>        * Intersect the line of sight of each camera with all other cameras.</c>
<l>        OtherCameras := remove(AllCameras,find(AllCameras,CurrentCamera))</l>
<l>        for Index := 0 to |OtherCameras| - 1 by 1</l>
<l>            get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'params', CamParam0)</l>
<l>            get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'pose', Pose0)</l>
<l>            get_camera_setup_param (CameraSetupModelID, OtherCameras[Index], 'params', CamParam1)</l>
<l>            get_camera_setup_param (CameraSetupModelID, OtherCameras[Index], 'pose', Pose1)</l>
<c>            * Intersect the lines of sight of the camera pair.</c>
<l>            pose_invert (Pose1, PoseInvert)</l>
<l>            pose_compose (PoseInvert, Pose0, RelPose)</l>
<l>            get_cam_par_data (CamParam0, 'cx', CX0)</l>
<l>            get_cam_par_data (CamParam0, 'cy', CY0)</l>
<l>            get_cam_par_data (CamParam1, 'cx', CX1)</l>
<l>            get_cam_par_data (CamParam1, 'cy', CY1)</l>
<l>            try</l>
<l>                intersect_lines_of_sight (CamParam0, CamParam1, RelPose, CY0, CX0, CY1, CX1, X, Y, Z, Dist)</l>
<l>            catch (Exception)</l>
<l>                throw ('Estimating a value for ConeLength automatically was not possible. Please use a number instead.')</l>
<l>            endtry</l>
<l>            ConcatZ := [ConcatZ,Z]</l>
<l>        endfor</l>
<c>        * Use the Z value of the determined coordinates as basis for the ConeLength.</c>
<l>        ConeLength := max(ConcatZ) * 1.05</l>
<l>    endif</l>
<c>    * </c>
<c>    * Create cone of sight 3D object models.</c>
<c>    * Distinguish cases with/without projection center.</c>
<l>    get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'type', CameraType)</l>
<l>    if (CameraType =~ 'telecentric')</l>
<l>        gen_cone_telecentric_object_model_3d (CameraSetupModelID, CurrentCamera, ConeLength, ObjectModel3DConeTmp)</l>
<l>    else</l>
<l>        gen_cone_perspective_object_model_3d (CameraSetupModelID, CurrentCamera, ConeLength, ObjectModel3DConeTmp)</l>
<l>    endif</l>
<l>    ObjectModel3DCone := [ObjectModel3DCone,ObjectModel3DConeTmp]</l>
<c>    * </c>
<c>    * Create camera 3D object models.</c>
<l>    if (CameraSize == 'auto')</l>
<c>        * In auto mode, the camera size for all cameras</c>
<c>        * is defined by the first camera's cone length.</c>
<l>        CameraSize := ConeLength * 0.1</l>
<l>    endif</l>
<l>    gen_camera_object_model_3d (CameraSetupModelID, CurrentCamera, CameraSize, ObjectModel3DCameraTmp)</l>
<l>    ObjectModel3DCamera := [ObjectModel3DCamera,ObjectModel3DCameraTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_camera_setup_object_model_3d">
<abstract lang="en_US">The procedure gen_camera_setup_object_model_3d generates 3D object models which visualize the cameras of a camera setup as well as their fields of view. 

The procedure can be used, e.g., to visualize a stereo setup with its bounding box and cameras which is particularly helpful while adjusting the bounding box. The procedure gen_bounding_box_object_model_3d creates the according 3D object model for the bounding box.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_stereo_model</item>
<item>set_stereo_model_param</item>
</predecessor>
<see_also>
<item>reconstruct_surface_stereo</item>
</see_also>
<short lang="en_US">Generate 3D object models which visualize the cameras of a stereo model.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
<item>gen_bounding_box_object_model_3d</item>
</successor>
<parameters>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>string</default_type>
<default_value>'auto'</default_value>
<description lang="en_US">Size of represented cameras.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'auto'</item>
<item>0.01</item>
<item>0.04</item>
<item>0.08</item>
<item>0.1</item>
<item>0.4</item>
<item>0.8</item>
<item>1</item>
<item>4</item>
<item>8</item>
</values>
</parameter>
<parameter id="ConeLength">
<default_type>string</default_type>
<default_value>'auto'</default_value>
<description lang="en_US">Depth of represented fields of view. </description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'auto'</item>
<item>0.01</item>
<item>0.04</item>
<item>0.08</item>
<item>0.1</item>
<item>0.4</item>
<item>0.8</item>
<item>1</item>
<item>4</item>
<item>8</item>
</values>
</parameter>
<parameter id="ObjectModel3DCamera">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing cameras.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DCone">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing fields of view.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cone_perspective_object_model_3d">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraIndex" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>pose_to_hom_mat3d (CamPose, HomMat3D)</l>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'params', CamParam)</l>
<c>* </c>
<c>* Get the lines of sight of the four corner points of the image.</c>
<c>* Scale them to the given length and transform into world coordinates.</c>
<l>Points := {[]}</l>
<c>* First corner.</c>
<l>get_line_of_sight (0, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(0) := [QX1,QY1,QZ1]</l>
<c>* Second corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(1) := [QX1,QY1,QZ1]</l>
<c>* Third corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(2) := [QX1,QY1,QZ1]</l>
<c>* Fourth corner.</c>
<l>get_line_of_sight (0, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(3) := [QX1,QY1,QZ1]</l>
<c>* </c>
<c>* Get camera center.</c>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 0, QX1, QY1, QZ1)</l>
<l>Points.at(4) := [QX1,QY1,QZ1]</l>
<c>* </c>
<c>* Sort the points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 4 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3D)</l>
<c>* </c>
<c>* Set the sides of the cone.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1]</l>
<l>Faces := [Faces,4,1,2]</l>
<l>Faces := [Faces,4,2,3]</l>
<l>Faces := [Faces,4,3,0]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, 'triangles', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_cone_perspective_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object model representing the view cone of a perspective camera.</short>
<parameters>
<parameter id="CameraIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cone_telecentric_object_model_3d">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraIndex" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>pose_to_hom_mat3d (CamPose, HomMat3D)</l>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'params', CamParam)</l>
<c>* </c>
<c>* Get the lines of sight of the four corner points of the image.</c>
<c>* Scale them to the given length and transform into world coordinates.</c>
<l>Points := {[]}</l>
<c>* First corner.</c>
<l>get_line_of_sight (0, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(0) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(1) := [QX1,QY1,QZ1]</l>
<c>* Second corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(2) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(3) := [QX1,QY1,QZ1]</l>
<c>* Third corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(4) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(5) := [QX1,QY1,QZ1]</l>
<c>* Fourth corner.</c>
<l>get_line_of_sight (0, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(6) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(7) := [QX1,QY1,QZ1]</l>
<c>* </c>
<c>* Sort the points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3D)</l>
<c>* </c>
<c>* Set the sides of the cone.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,3,2]</l>
<l>Faces := [Faces,4,2,3,5,4]</l>
<l>Faces := [Faces,4,4,5,7,6]</l>
<l>Faces := [Faces,4,6,7,1,0]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, 'polygons', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_cone_telecentric_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object model representing the view cone of a telecentric camera.</short>
<parameters>
<parameter id="CameraIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_current_setup_moving_cam_object_model_3d">
<interface>
<ic>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure visualizes the camera, tool, and plane in their</c>
<c>* current positions.</c>
<c>* </c>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInBasePose0', PlaneInBasePose0)</l>
<c>* </c>
<l>if (CameraSize &lt;= 0)</l>
<l>    throw ('CameraSize should be &gt; 0')</l>
<l>endif</l>
<c>* </c>
<c>* Visualize current camera and tool position.</c>
<c>* </c>
<c>* Get the intersection of the optical axis of the camera and the plane</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (BaseInToolPose, PlaneInBasePose0, PlaneInToolPose)</l>
<l>pose_compose (ToolInCamPose, PlaneInToolPose, PlaneInCamPose)</l>
<l>get_cam_par_data (CamParam, 'cx', CX)</l>
<l>get_cam_par_data (CamParam, 'cy', CY)</l>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose, CY, CX, 'm', OptAxisPlaneX, OptAxisPlaneY)</l>
<c>* Transform to camera coordinates</c>
<l>pose_to_hom_mat3d (PlaneInCamPose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, OptAxisPlaneX, OptAxisPlaneY, 0, OptAxisCamX, OptAxisCamY, OptAxisCamZ)</l>
<l>ConeLength := OptAxisCamZ * 1.1</l>
<c>* If the optical axis does not intersect the plane, we still want to visualize the camera.</c>
<l>if (ConeLength &lt;= 0.0)</l>
<l>    ConeLength := CameraSize</l>
<l>endif</l>
<l>gen_camera_and_tool_moving_cam_object_model_3d (ToolInCamPose, ToolInBasePose, CameraSize, ConeLength, OM3DToolOrigin, CamParam, OM3DCamera, OM3DTool)</l>
<c>* </c>
<c>* Create 3D object model of plane.</c>
<l>FactorBorder := 1.5</l>
<l>gen_ground_plane_object_model_3d (OM3DTool, OM3DCamera, OM3DBase, FactorBorder, PlaneInBasePose0, OM3DPlane)</l>
<l>return ()</l>
</body>
<docu id="gen_current_setup_moving_cam_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object models for the camera, robot's tool and plane in their current positions.

CameraSize determines the size of generated 3D object model of the camera.
ToolInBasePose is the current position of the robot's tool. HandEyeCalibData must contain the ToolInCamPose and CamParam as obtained through hand-eye calibration, as well as the PlaneInBasePose.

The input parameters OM3DToolOrigin and OM3DBase are 3D object models of the robot's tool and base respectively.

The output parameter OM3DCamera is a 3D object model of the camera and its cone. OM3DTool is the 3D object model of the robot's tool in its current position. OM3DPlane is the 3D model of the plane.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_moving_cam_for_model_creation</item>
<item>gen_moving_cam_robot_3d</item>
</predecessor>
<short lang="en_US">Generate 3D object models for the camera, robot's tool and plane.</short>
<parameters>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Visualization factor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">Initial 3D object model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_current_setup_stationary_cam_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates the 3D object models of the camera and its</c>
<c>* cone, the plane, the robot's base and the robot's tool at its</c>
<c>* initial position.</c>
<c>* </c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose0)</l>
<l>read_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<c>* </c>
<c>* Visualize base and tool in the origin.</c>
<l>gen_robot_tool_and_base_object_model_3d (ArrowThickness, ArrowLength, OM3DToolOrigin, OM3DBase)</l>
<c>* Visualize camera.</c>
<l>get_cam_par_data (CamParam, 'cx', CX)</l>
<l>get_cam_par_data (CamParam, 'cy', CY)</l>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose0, CY, CX, 'm', OptAxisPlaneX, OptAxisPlaneY)</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, OptAxisPlaneX, OptAxisPlaneY, 0, OptAxisCamX, OptAxisCamY, OptAxisCamZ)</l>
<l>ConeLength := OptAxisCamZ * 1.1</l>
<c>* If the optical axis does not intersect the plane, we still want to visualize the camera.</c>
<l>if (ConeLength &lt;= 0.0)</l>
<l>    ConeLength := CameraSize</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, IdentityPose)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCameraOrigin, OM3DConeOrig)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>OM3DCameraOrigin := [OM3DCameraOrigin,OM3DConeOrig]</l>
<l>pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>rigid_trans_object_model_3d (OM3DCameraOrigin, CamInBasePose, OM3DCamera)</l>
<l>clear_object_model_3d (OM3DCameraOrigin)</l>
<c>* </c>
<c>* Create 3D object model of plane.</c>
<l>FactorBorder := 1.5</l>
<l>pose_compose (CamInBasePose, PlaneInCamPose0, PlaneInBasePose)</l>
<l>gen_ground_plane_object_model_3d (OM3DToolOrigin, OM3DCamera, OM3DBase, FactorBorder, PlaneInBasePose, OM3DPlane)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="gen_current_setup_stationary_cam_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object model for the camera, the plane, the robot's base and the robot's tool in their positions. A stationary camera setup is assumed.

The parameters CameraSize, ArrowThickness and ArrowLength determine the size of generated 3D object models.HandEyeCalibData must contain the BaseInCamPose and CamParam as obtained through hand-eye calibration, as well as the PlaneInBasePose. 

The output parameter OM3DCamera is the 3D object models of the camera and its cone. OM3DPlane is the 3D object of the plane. OM3DBase is the 3D object models defining the robot's base; a lower plane as well as a coordinate system represent the current position of the base. OM3DToolOrigin is the coordinate system at the origin of the robot's tool.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate 3D object models for the camera, the plane, the robot's base and the robot's tool in a stationary camera setup.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Size of the 3D object model of the camera.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dummy_objects">
<interface>
<oo>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* </c>
<c>* Create dummy objects for the feature calculation</c>
<c>* (may be used to determine the lengths of the</c>
<c>* vectors etc.).</c>
<c>* </c>
<l>gen_image_const (Image, 'byte', 3, 3)</l>
<l>compose3 (Image, Image, Image, Image)</l>
<l>get_domain (Image, Region)</l>
<l>return ()</l>
</body>
<docu id="gen_dummy_objects">
<abstract lang="en_US">Generate a dummy image and region.

This is an auxiliary procedure for get_feature_lengths, get_feature_names, query_feature_names_by_group, and query_feature_group_names.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Dummy image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Dummy region.</description>
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_ground_plane_object_model_3d">
<interface>
<ic>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
<par name="FactorBorder" base_type="ctrl" dimension="0"/>
<par name="PlaneInBasePose" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates the 3D object model of</c>
<c>* the plane on which objects are matched and grasped.</c>
<c>* </c>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<c>* Extent of tool in base coordinates.</c>
<l>get_extent_by_axis (OM3DTool, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* Extent of camera in base coordinates.</c>
<l>get_extent_by_axis (OM3DCamera, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* Extent of base in base coordinates.</c>
<l>get_extent_by_axis (OM3DBase, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* </c>
<c>* Joint bounding box.</c>
<l>MinXt := min(XBase)</l>
<l>MinYt := min(YBase)</l>
<l>MinZt := min(ZBase)</l>
<l>MaxXt := max(XBase)</l>
<l>MaxYt := max(YBase)</l>
<l>MaxZt := max(ZBase)</l>
<l>Min := [MinXt,MinYt,MinZt]</l>
<l>Max := [MaxXt,MaxYt,MaxZt]</l>
<c>* </c>
<c>* Joint bounding box extended by a factor of FactorBorder.</c>
<l>MinT := Max * (1.0 - FactorBorder) / 2.0 + Min * (1.0 + FactorBorder) / 2.0</l>
<l>MaxT := Max * (1.0 + FactorBorder) / 2.0 + Min * (1.0 - FactorBorder) / 2.0</l>
<l>BoundingBox := [MinT,MaxT]</l>
<c>* </c>
<c>* Get the eight corner points of the bounding box from the min/max representation.</c>
<l>get_bounding_box_points_from_min_max (BoundingBox, PXBB, PYBB, PZBB)</l>
<c></c>
<c>* Transform to plane coordinates (z is direction of the normal of the plane).</c>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_to_hom_mat3d (BaseInPlanePose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, PXBB, PYBB, PZBB, PX, PY, PZ)</l>
<c>* </c>
<c>* Get outline of projection onto the plane.</c>
<l>Qx := min(PX)</l>
<l>Qx1 := max(PX)</l>
<l>Qy := min(PY)</l>
<l>Qy1 := max(PY)</l>
<l>XPlane := [Qx,Qx,Qx1,Qx1]</l>
<l>YPlane := [Qy,Qy1,Qy1,Qy]</l>
<l>tuple_gen_const (4, 0, ZPlane)</l>
<c>* </c>
<c>* Transform back to base coordinates.</c>
<l>pose_to_hom_mat3d (PlaneInBasePose, HomMat3D1)</l>
<l>affine_trans_point_3d (HomMat3D1, XPlane, YPlane, ZPlane, Qx2, Qy2, Qz)</l>
<c>* </c>
<c>* Generate the visualization.</c>
<l>gen_object_model_3d_from_points (Qx2, Qy2, Qz, OM3DPlane)</l>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,2,3]</l>
<l>set_object_model_3d_attrib_mod (OM3DPlane, 'polygons', [], Faces)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_ground_plane_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object model of the plane, on which we attempt to match and grip.
The input parameters OM3DTool, OM3DCamera, and OM3DBase are the respective 3D object models of the robot's tool, the camera, and the robot's base. FactorBorder controls the extent of the visualized plane. PlaneInBasePose is the adapted pose of the plane in the base coordinate system.
The output parameter OM3DPlane is the 3D object model of the plane.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate the 3D object model of the plane.</short>
<parameters>
<parameter id="FactorBorder">
<default_type>real</default_type>
<description lang="en_US">Extent of the plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PlaneInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the plane.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_matching_object_model_3d">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DModel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates a 3D model from a shape model for</c>
<c>* visualization for a known (rectified) matching plane.</c>
<c>* </c>
<c>* The 3D model consists of the model-contours transformed to</c>
<c>* their real world size. The origin of the 3D model coordinate system</c>
<c>* lies in the origin of the input shape model with the z-axis</c>
<c>* pointing towards the camera. The model contours are displayed</c>
<c>* twice, at z = 0 and z = ObjectHeight.</c>
<c>* </c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true' or RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<c>* </c>
<c>* Get shape model contours.</c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<l>count_obj (ModelContours, Number)</l>
<l>ModelRows := []</l>
<l>ModelCols := []</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (ModelContours, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Row1, Col1)</l>
<l>    ModelRows := [ModelRows,Row1]</l>
<l>    ModelCols := [ModelCols,Col1]</l>
<l>endfor</l>
<c>* Obtain real world size (col = x, row = y), centered around the shape model origin (0,0).</c>
<l>if (RectifyImage == 'true' or RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    PX := ModelCols * ScaleRectification</l>
<l>    PY := ModelRows * ScaleRectification</l>
<l>else</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, ModelRows, ModelCols, 'm', PXPlane, PYPlane)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, 0, 0, 'm', PXPlaneOrig, PYPlaneOrig)</l>
<l>    PX := PXPlane - PXPlaneOrig</l>
<l>    PY := PYPlane - PYPlaneOrig</l>
<l>endif</l>
<c>* Display the contours twice, once in the plane, once above.</c>
<l>tuple_gen_const (|PY|, 0, PZ1)</l>
<l>tuple_gen_const (|PY|, ObjectHeight, PZ2)</l>
<c>* Transform from plane to model coordinate system. The plane</c>
<c>* coordinate system has previously been adapted such that its</c>
<c>* z-axis points away from the camera.</c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', PlanePartRectToModelPose)</l>
<l>pose_to_hom_mat3d (PlanePartRectToModelPose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, [PX,PX], [PY,PY], [PZ1,PZ2], Qx, Qy, Qz)</l>
<l>gen_object_model_3d_from_points (Qx, Qy, Qz, OM3DModel)</l>
<l>return ()</l>
</body>
<docu id="gen_matching_object_model_3d">
<abstract lang="en_US">This procedure generates a 3D object model of the matched object from the contours.

The parameter ModelID is a handle of the matching model. ScaleRect is the rectification scale used.

ObjectHeight is the height of the matched object, which is the difference between the matching and actual planes.

The input message HandEyeCalibData must contain the camera parameters, the input message Poses must contain the pose MatchingPlaneInCamPose, and the input message RectificationData must contain the parameter RectifyImage, and, if the model ist to be rectified, the parameter ScaleRectification.

The output parameter OM3DModel is the 3D object representing the matched object on the plane.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object of the matched model, in the case of rectification.</short>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the shape-based matching model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DModel">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the matched object contour.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the matched object.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Pose data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Rectification data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_robot_tool_and_base_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates 3D models that represent the tool and the base</c>
<c>* of the robot.</c>
<c>* </c>
<l>if (ArrowThickness &lt;= 0)</l>
<l>    throw ('ArrowThickness should be &gt; 0')</l>
<l>endif</l>
<l>if (ArrowLength &lt;= 0)</l>
<l>    throw ('ArrowLength should be &gt; 0')</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<c>* </c>
<c>* 3D model for the tool.</c>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DToolXOrigin)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DToolYOrigin)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DToolZOrigin)</l>
<l>OM3DToolOrigin := [OM3DToolXOrigin,OM3DToolYOrigin,OM3DToolZOrigin]</l>
<c>* </c>
<c>* 3D model for the base.</c>
<l>FactorVisBase := ArrowThickness * 10</l>
<l>gen_box_object_model_3d (IdentityPose, FactorVisBase * 1.5, FactorVisBase * 1.5, FactorVisBase / 12, OM3DBasePlate)</l>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DBaseX)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DBaseY)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DBaseZ)</l>
<l>OM3DBase := [OM3DBaseX,OM3DBaseY,OM3DBaseZ,OM3DBasePlate]</l>
<l>return ()</l>
</body>
<docu id="gen_robot_tool_and_base_object_model_3d">
<abstract lang="en_US">This procedures generates the 3D models of the base and the tool coordinate systems of the robot.

The input parameters ArrowThickness and ArrowLength determine the size of the objects in 3D. 

The output parameters OM3DToolOrigin and OM3DBase carry the handles for the tool and base 3D models respectively.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate base and tool 3D models of the robot.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_tool_to_touching_point_object_model_3d">
<interface>
<ic>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolTouchingPoint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>gen_robot_tool_and_base_object_model_3d (0.0025, 0.05, OM3DToolOrigin, OM3DBase)</l>
<l>gen_object_model_3d_from_points ([0,RobotTouchingPointInToolCoordinates[0]], [0,RobotTouchingPointInToolCoordinates[1]], [0,RobotTouchingPointInToolCoordinates[2]], OM3DToolTouchingPoint)</l>
<l>set_object_model_3d_attrib_mod (OM3DToolTouchingPoint, 'lines', [], [2,0,1])</l>
<l>OM3DToolTouchingPointTmp := [OM3DToolOrigin,OM3DToolTouchingPoint]</l>
<c>* </c>
<l>OM3DToolTouchingPoint := []</l>
<l>for Index := 0 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<l>    rigid_trans_object_model_3d (OM3DToolTouchingPointTmp, ToolInBasePosesTouchingPoint.at(Index), OM3DRigidTrans)</l>
<l>    OM3DToolTouchingPoint := [OM3DToolTouchingPoint,OM3DRigidTrans]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_tool_to_touching_point_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="OM3DToolTouchingPoint">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<sem_type>coordinates</sem_type>
</parameter>
<parameter id="ToolInBasePosesTouchingPoint">
<default_type>real</default_type>
<description lang="en_US">Robot positions.</description>
<multivalue>false</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_bounding_box_points_from_min_max">
<interface>
<ic>
<par name="BoundingBox" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PX" base_type="ctrl" dimension="0"/>
<par name="PY" base_type="ctrl" dimension="0"/>
<par name="PZ" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Points := {[]}</l>
<l>Points.at(0) := [BoundingBox[0],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(1) := [BoundingBox[3],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(2) := [BoundingBox[3],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(3) := [BoundingBox[0],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(4) := [BoundingBox[0],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(5) := [BoundingBox[3],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(6) := [BoundingBox[3],BoundingBox[4],BoundingBox[5]]</l>
<l>Points.at(7) := [BoundingBox[0],BoundingBox[4],BoundingBox[5]]</l>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_bounding_box_points_from_min_max">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Merkmale</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoundingBox">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PX">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PY">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PZ">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_data">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_data returns in ParamValue the value of the</c>
<c>* parameter that is given in ParamName from the tuple of</c>
<c>* camera parameters that is given in CameraParam.</c>
<c>* </c>
<c>* Get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParam, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>ParamValue := []</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    if (ParamNameInd == 'camera_type')</l>
<l>        ParamValue := [ParamValue,CameraType]</l>
<l>        continue</l>
<l>    endif</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        ParamValue := [ParamValue,CameraParam[I]]</l>
<l>    else</l>
<l>        throw ('Unknown camera parameter ' + ParamNameInd)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_data">
<abstract lang="en_US">get_cam_par_data returns the value ParamValue of the camera parameter ParamName from the camera parameter tuple CameraParam. The following parameter names can be queried: 'camera_type', 'focus', 'magnification', 'kappa', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx' ,'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz'. If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam) 
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
gen_image_const (Image, 'byte', ImageWidth, ImageHeight)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'camera_type'</item>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the requested camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_names">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="ParamNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_names returns for each element in the camera</c>
<c>* parameter tuple that is passed in CameraParam the name</c>
<c>* of the respective camera parameter. The parameter names</c>
<c>* are returned in ParamNames. Additionally, the camera</c>
<c>* type is returned in CameraType. Alternatively, instead of</c>
<c>* the camera parameters, the camera type can be passed in</c>
<c>* CameraParam in form of one of the following strings:</c>
<c>*   - 'area_scan_division'</c>
<c>*   - 'area_scan_polynomial'</c>
<c>*   - 'area_scan_tilt_division'</c>
<c>*   - 'area_scan_tilt_polynomial'</c>
<c>*   - 'area_scan_telecentric_division'</c>
<c>*   - 'area_scan_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_division'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_division'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_polynomial'</c>
<c>*   - 'line_scan'</c>
<c>* </c>
<l>CameraParamAreaScanDivision := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanPolynomial := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricDivision := ['magnification','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomial := ['magnification','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltDivision := ['focus','kappa','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltPolynomial := ['focus','k1','k2','k3','p1','p2','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltDivision := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltPolynomial := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivision := ['magnification','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomial := ['magnification','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltDivision := ['magnification','kappa','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltPolynomial := ['magnification','k1','k2','k3','p1','p2','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamLinesScan := ['focus','kappa','sx','sy','cx','cy','image_width','image_height','vx','vy','vz']</l>
<c>* Legacy parameter names</c>
<l>CameraParamAreaScanTiltDivisionLegacy := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricDivisionLegacy := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<c>* </c>
<c>* If the camera type is passed in CameraParam</c>
<l>if (|CameraParam| == 1 and is_string(CameraParam[0]))</l>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'line_scan')</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScan]</l>
<l>    else</l>
<l>        throw ('Unknown camera type \'' + CameraType + '\' passed in CameraParam.')</l>
<l>    endif</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* If the camera parameters are passed in CameraParam</c>
<l>if (not is_string(CameraParam[0]))</l>
<c>    * Format of camera parameters for HALCON 12 and earlier</c>
<l>    switch (|CameraParam|)</l>
<c>        * </c>
<c>        * Area Scan</c>
<l>    case 8:</l>
<c>        * CameraType: 'area_scan_division' or 'area_scan_telecentric_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanDivision</l>
<l>            CameraType := 'area_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricDivisionLegacy</l>
<l>            CameraType := 'area_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 10:</l>
<c>        * CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 12:</l>
<c>        * CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanPolynomial</l>
<l>            CameraType := 'area_scan_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricPolynomialLegacy</l>
<l>            CameraType := 'area_scan_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 14:</l>
<c>        * CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<c>        * </c>
<c>        * Line Scan</c>
<l>    case 11:</l>
<c>        * CameraType: 'line_scan'</c>
<l>        ParamNames := CameraParamLinesScan</l>
<l>        CameraType := 'line_scan'</l>
<l>        break</l>
<l>    default:</l>
<l>        throw ('Wrong number of values in CameraParam.')</l>
<l>    endswitch</l>
<l>else</l>
<c>    * Format of camera parameters since HALCON 13</c>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'line_scan')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScan]</l>
<l>    else</l>
<l>        throw ('Unknown camera type in CameraParam.')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_names">
<abstract lang="en_US">get_cam_par_names returns the names ParamNames of the camera parameters for each element of CameraParam. The parameter names are returned in ParamNames. Additionally, the camera type is returned in CameraType.

Alternatively, instead of the camera parameters, the camera type can be passed in CameraParam in form of one of the following strings:
   - 'area_scan_division'
   - 'area_scan_polynomial'
   - 'area_scan_tilt_division'
   - 'area_scan_tilt_polynomial'
   - 'area_scan_telecentric_division'
   - 'area_scan_telecentric_polynomial'
   - 'area_scan_tilt_bilateral_telecentric_division'
   - 'area_scan_tilt_bilateral_telecentric_polynomial'
   - 'area_scan_tilt_object_side_telecentric_division'
   - 'area_scan_tilt_object_side_telecentric_polynomial'
   - 'line_scan'</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_names (CameraParam, CameraType, ParamNames)
</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Get the names of the parameters in a camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple or camera type.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'area_scan_tilt_image_side_telecentric_division'</item>
<item>'area_scan_tilt_image_side_telecentric_polynomial'</item>
<item>'line_scan'</item>
</values>
</parameter>
<parameter id="CameraType">
<default_type>string</default_type>
<description lang="en_US">The camera type that is described by CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'line_scan'</item>
</value_list>
</parameter>
<parameter id="ParamNames">
<default_type>string</default_type>
<description lang="en_US">Parameter names of the camera parameter tuple or camera type passed in CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_custom_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure can be used to extend the functionality</c>
<c>* of the calculate_feature_set procedure library by</c>
<c>* user-defined features.</c>
<c>* </c>
<c>* Instructions:</c>
<c>* </c>
<c>* 1. Find the template block at the beginning the procedure</c>
<c>* (marked by comments) and duplicate it.</c>
<c>* </c>
<c>* 2. In the copy edit the two marked areas as follows:</c>
<c>* </c>
<c>* 2.1. Feature name and groups:</c>
<c>* Assign a unique identifier for your feature to the variable "Name".</c>
<c>* Then, assign the groups that you want your feature to belong to</c>
<c>* to the variable "Groups".</c>
<c>* </c>
<c>* 2.2. Feature calculation:</c>
<c>* Enter the code that calculates your feature and</c>
<c>* assign the result to the variable "Feature".</c>
<c>* </c>
<c>* 3. Test</c>
<c>* Use the "test_feature" procedure to check,</c>
<c>* if the feature is calculated correctly.</c>
<c>* If the procedure throws an exception,</c>
<c>* maybe the order of the feature vector is wrong</c>
<c>* (See note below).</c>
<c>* </c>
<c>* 4. Integration</c>
<c>* - Save your modified procedure get_custom_features.hdvp</c>
<c>*   to a location of your choice.</c>
<c>*   (We recommend not to overwrite the template.)</c>
<c>* - Make sure, that your version of get_custom_procedures</c>
<c>*   is included in the procedure directories of HDevelop.</c>
<c>*   (Choose Procedures -&gt; Manage Procedures -&gt; Directories -&gt; Add from the HDevelop menu bar.)</c>
<c>* </c>
<c>* Note:</c>
<c>* The current implementation supports region arrays as input.</c>
<c>* In that case, multi-dimensional feature vectors are simply concatenated.</c>
<c>* Example: The feature 'center' has two dimensions [Row,Column].</c>
<c>* If an array of three regions is passed, the correct order of the "Feature" variable is</c>
<c>* [Row1, Column1, Row2, Column2, Row3, Column3].</c>
<c>* </c>
<l>TmpResults := []</l>
<c>* ************************************************</c>
<c>* ************************************************</c>
<c>* **** Copy the following template block     *****</c>
<c>* **** and edit the two marked code sections *****</c>
<c>* **** to add user-defined features          *****</c>
<c>* ************************************************</c>
<c>* ************************************************</c>
<c>* </c>
<c>* ***************************************</c>
<c>* *********** TEMPLATE BLOCK ************</c>
<c>* ***************************************</c>
<c>* </c>
<c>* ********************************************************************</c>
<c>* ** Section 1:</c>
<c>* ** Enter unique feature name and groups to which it belongs here ***</c>
<l>Name := 'custom_feature_numlines'</l>
<l>Groups := 'custom'</l>
<c>* ** Enter unique feature name and groups above this line ************</c>
<c>* ********************************************************************</c>
<l>if (Name == CurrentName)</l>
<c>    * ******************************************************</c>
<c>    * ** Section 2:</c>
<c>    * ** Enter code to calculate feature here **************</c>
<l>    Feature := []</l>
<l>    count_obj (Region, NumRegions)</l>
<l>    for I := 1 to NumRegions by 1</l>
<l>        select_obj (Region, RegionSelected, I)</l>
<l>        gen_contour_region_xld (RegionSelected, Contours, 'border')</l>
<l>        count_obj (Contours, NumContours)</l>
<l>        NumLines := 0</l>
<l>        for J := 1 to NumContours by 1</l>
<l>            select_obj (Contours, ContoursSelected, J)</l>
<l>            segment_contours_xld (ContoursSelected, ContoursSplit, 'lines', 5, 2, 1)</l>
<l>            count_obj (ContoursSplit, NumSplit)</l>
<l>            NumLines := NumLines + NumSplit</l>
<l>        endfor</l>
<l>        Feature := [Feature,NumLines]</l>
<l>    endfor</l>
<c>    * ** Enter code to calculate feature above this line ***</c>
<c>    * ******************************************************</c>
<l>    append_length_or_values (Mode, Feature, TmpResults, TmpResults)</l>
<l>endif</l>
<l>append_names_or_groups (Mode, Name, Groups, CurrentName, TmpResults, TmpResults)</l>
<c>* </c>
<c>* ************************************</c>
<c>* ****** END OF TEMPLATE BLOCK *******</c>
<c>* ************************************</c>
<c>* </c>
<l>Output := TmpResults</l>
<l>return ()</l>
</body>
<docu id="get_custom_features">
<abstract lang="en_US">This procedure can be used to extend the functionality of the calculate_feature_set procedure library by user-defined features.

Instructions:

1. Find the 'template block' at the beginning of the procedure (enclosed by comments) and duplicate it.

2. In the duplicate edit the two marked code sections as follows:

2.1. 'Section 1': Feature name and groups

 Assign a unique identifier for your feature to the variable 'Name'. Then, assign the groups your feature belongs to to the variable 'Groups'.

2.2. 'Section 2': Feature calculation

Enter the code that calculates your feature and assign the result to the variable 'Feature'.

3. Test

Use the "test_feature" procedure to check, if the feature is integrated correctly.
If the procedure throws an exception, first check if the order of the feature vector is correct (see note below).

4. Integration

Save your modified procedure get_custom_features.hdvp to a location of your choice. We recommend not to overwrite the template.

Make sure that your version of get_custom_features is included in the procedure directories of HDevelop (Choose the following  from the HDevelop menu bar: Procedures -&gt; Manage Procedures -&gt; Directories -&gt; Add).

Note that the current implementation supports region arrays as input. In that case, multi-dimensional feature vectors are simply concatenated.

Example: The feature 'center' has two dimensions [Row,Column]. If an array of three regions is passed, the correct order of thevalues in the  variable Feature is [Row1, Column1, Row2, Column2, Row3, Column3].

The Output depends on the processing mode Mode:
If  Mode == 'get_names', the names of all features that belong to the input group in CurrentName are returned.
If  Mode == 'get_lengths', the length of the feature vector of the feature in CurrentName is returned.
If  Mode == 'get_groups', the names of all groups to which the feature in CurrentNamebelongs to are returned.
If  Mode == 'calculate', the feature vector of the feature in CurrentName is returned.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.
</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Procedure Templates</library>
<short lang="en_US">Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library.</short>
<parameters>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name as received from the caller procedure get_features.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray-value image.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode as received from the caller procedure get_features.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Output">
<default_type>string</default_type>
<description lang="en_US">Feature names, feature vector, feature vector lengths, or group names.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_extent_by_axis">
<interface>
<ic>
<par name="OM3D" base_type="ctrl" dimension="0"/>
<par name="XExtent" base_type="ctrl" dimension="0"/>
<par name="YExtent" base_type="ctrl" dimension="0"/>
<par name="ZExtent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XExtentOut" base_type="ctrl" dimension="0"/>
<par name="YExtentOut" base_type="ctrl" dimension="0"/>
<par name="ZExtentOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>XExtentOut := XExtent</l>
<l>YExtentOut := YExtent</l>
<l>ZExtentOut := ZExtent</l>
<l>get_object_model_3d_params (OM3D, 'bounding_box1', BB)</l>
<l>for Index := 0 to |BB| / 6 - 1 by 1</l>
<l>    XExtentOut := [XExtentOut,BB[Index * 6],BB[Index * 6 + 3]]</l>
<l>    YExtentOut := [YExtentOut,BB[Index * 6 + 1],BB[Index * 6 + 4]]</l>
<l>    ZExtentOut := [ZExtentOut,BB[Index * 6 + 2],BB[Index * 6 + 5]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_extent_by_axis">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="OM3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XExtent">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="XExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YExtent">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ZExtent">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ZExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_feature_lengths">
<interface>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Lengths" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the lengths of the feature vectors of</c>
<c>* the features in FeatureNames.</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, FeatureNames, 'get_lengths', Lengths)</l>
<l>return ()</l>
</body>
<docu id="get_feature_lengths">
<abstract lang="en_US">Returns the length of the feature vector for each feature name in FeatureNames.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_feature_names</item>
</predecessor>
<see_also>
<item>get_feature_names</item>
<item>set_feature_lengths_class_train_data</item>
<item>select_feature_set_knn</item>
<item>select_feature_set_svm</item>
<item>select_feature_set_mlp</item>
</see_also>
<short lang="en_US">Returns the length of the feature vector for each feature name.</short>
<successor>
<item>set_feature_lengths_class_train_data</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<default_value>'area'</default_value>
<description lang="en_US">A list of feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'area'</item>
<item>'width'</item>
<item>'height'</item>
<item>'ra'</item>
<item>'rb'</item>
<item>'phi'</item>
<item>'roundness'</item>
<item>'num_sides'</item>
<item>'num_connected'</item>
<item>'num_holes'</item>
<item>'area_holes'</item>
<item>'max_diameter'</item>
<item>'orientation'</item>
<item>'outer_radius'</item>
<item>'inner_radius'</item>
<item>'inner_width'</item>
<item>'inner_height'</item>
<item>'circularity'</item>
<item>'compactness'</item>
<item>'convexity'</item>
<item>'rectangularity'</item>
<item>'anisometry'</item>
<item>'bulkiness'</item>
<item>'struct_factor'</item>
<item>'dist_mean'</item>
<item>'dist_deviation'</item>
<item>'euler_number'</item>
<item>'rect2_phi'</item>
<item>'rect2_len1'</item>
<item>'rect2_len2'</item>
<item>'contlength'</item>
<item>'porosity'</item>
<item>'gray_area'</item>
<item>'gray_ra'</item>
<item>'gray_rb'</item>
<item>'gray_phi'</item>
<item>'gray_min'</item>
<item>'gray_max'</item>
<item>'gray_range'</item>
<item>'gray_mean'</item>
<item>'gray_deviation'</item>
<item>'gray_plane_deviation'</item>
<item>'gray_anisotropy'</item>
<item>'gray_entropy'</item>
<item>'gray_hor_proj'</item>
<item>'gray_vert_proj'</item>
<item>'gray_hor_proj_histo'</item>
<item>'gray_vert_proj_histo'</item>
<item>'grad_dir_histo'</item>
<item>'edge_density'</item>
<item>'edge_density_histogram'</item>
<item>'edge_density_pyramid_2'</item>
<item>'edge_density_pyramid_3'</item>
<item>'edge_density_pyramid_4'</item>
<item>'edge_density_histogram_pyramid_2'</item>
<item>'edge_density_histogram_pyramid_3'</item>
<item>'edge_density_histogram_pyramid_4'</item>
<item>'cooc'</item>
<item>'cooc_pyramid_2'</item>
<item>'cooc_pyramid_3'</item>
<item>'cooc_pyramid_4'</item>
<item>'polar_gray_proj'</item>
<item>'polar_grad_proj'</item>
<item>'polar_grad_x_proj'</item>
<item>'polar_grad_y_proj'</item>
<item>'polar_gray_proj_histo'</item>
<item>'cielab_mean'</item>
<item>'cielab_dev'</item>
<item>'hls_mean'</item>
<item>'hls_dev'</item>
<item>'rgb_mean'</item>
<item>'rgb_dev'</item>
</values>
</parameter>
<parameter id="Lengths">
<default_type>integer</default_type>
<description lang="en_US">The lengths of the feature vectors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_feature_names">
<interface>
<ic>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Names" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return all features that belong to</c>
<c>* at least one of the groups in GroupNames</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, GroupNames, 'get_names', Names)</l>
<l>return ()</l>
</body>
<docu id="get_feature_names">
<abstract lang="en_US">Returns a list of feature names that belong to the feature groups given in GroupNames.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>query_feature_group_names</item>
<item>query_feature_names_by_group</item>
</predecessor>
<see_also>
<item>get_feature_lengths</item>
<item>query_feature_group_names</item>
<item>query_feature_names_by_group</item>
</see_also>
<short lang="en_US">Returns a list of feature names that belong to the feature groups given in GroupNames.</short>
<successor>
<item>get_feature_lengths</item>
<item>calculate_features</item>
<item>tuple_intersection</item>
<item>tuple_union</item>
</successor>
<parameters>
<parameter id="GroupNames">
<default_type>string</default_type>
<default_value>'region'</default_value>
<description lang="en_US">Name(s) of the feature group(s)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'color'</item>
<item>'gray'</item>
<item>'region'</item>
<item>'rot_invar'</item>
<item>'scale_invar'</item>
<item>'texture'</item>
<item>'all'</item>
</values>
</parameter>
<parameter id="Names">
<default_type>string</default_type>
<description lang="en_US">Names of the features belonging to at least one of the input feature groups</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Namelist" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *********************************************************</c>
<c>* Feature procedure</c>
<c>* Contains the names, properties and calculation of</c>
<c>* all supproted features.</c>
<c>* It consists of similar blocks for each feature.</c>
<c>* </c>
<c>* If you like to add your own features, please use</c>
<c>* the external procedure get_custom_features.hdvp</c>
<c>* in the HALCON procedures/templates directory.</c>
<c>* *********************************************************</c>
<c>* </c>
<c>* Insert location of your custom procedure here</c>
<c>* </c>
<l>get_system ('empty_region_result', EmptyRegionResult)</l>
<l>set_system ('empty_region_result', 'true')</l>
<l>AccumulatedResults := []</l>
<l>CustomResults := []</l>
<l>count_obj (Region, NumRegions)</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>* </c>
<l>for I := 0 to |Namelist| - 1 by 1</l>
<l>    CurrentName := Namelist[I]</l>
<c>    * </c>
<l>    get_custom_features (Region, Image, CurrentName, Mode, CustomResults)</l>
<l>    AccumulatedResults := [AccumulatedResults,CustomResults]</l>
<c>    * </c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * HALCON REGION FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * BASIC</c>
<c>    * ************************************</c>
<c>    * ** area ***</c>
<l>    Name := 'area'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_center (Region, Feature, _, _)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** width ***</c>
<l>    Name := 'width'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Column2 - Column1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** height ***</c>
<l>    Name := 'height'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Row2 - Row1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** ra ***</c>
<l>    Name := 'ra'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Ra</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rb ***</c>
<l>    Name := 'rb'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Rb</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** phi ***</c>
<l>    Name := 'phi'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** roundness ***</c>
<l>    Name := 'roundness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Roundness</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_sides ***</c>
<l>    Name := 'num_sides'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Sides</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_connected ***</c>
<l>    Name := 'num_connected'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        connect_and_holes (Region, NumConnected, NumHoles)</l>
<l>        Feature := NumConnected</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_holes ***</c>
<l>    Name := 'num_holes'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        connect_and_holes (Region, NumConnected, NumHoles)</l>
<l>        Feature := NumHoles</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** area_holes ***</c>
<l>    Name := 'area_holes'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_holes (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** max_diameter ***</c>
<l>    Name := 'max_diameter'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        diameter_region (Region, Row1, Column1, Row2, Column2, Diameter)</l>
<l>        Feature := Diameter</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** orientation ***</c>
<l>    Name := 'orientation'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        orientation_region (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * SHAPE</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** outer_radius ***</c>
<l>    Name := 'outer_radius'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_circle (Region, Row, Column, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_radius ***</c>
<l>    Name := 'inner_radius'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_circle (Region, Row, Column, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_width ***</c>
<l>    Name := 'inner_width'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Column2 - Column1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_height ***</c>
<l>    Name := 'inner_height'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Row2 - Row1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** circularity ***</c>
<l>    Name := 'circularity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        circularity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** compactness ***</c>
<l>    Name := 'compactness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        compactness (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** convexity ***</c>
<l>    Name := 'convexity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        convexity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rectangularity ***</c>
<l>    Name := 'rectangularity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        rectangularity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** anisometry ***</c>
<l>    Name := 'anisometry'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := Anisometry</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** bulkiness ***</c>
<l>    Name := 'bulkiness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := Bulkiness</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** struct_factor ***</c>
<l>    Name := 'struct_factor'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := StructureFactor</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** dist_mean ***</c>
<l>    Name := 'dist_mean'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Distance</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** dist_deviation ***</c>
<l>    Name := 'dist_deviation'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Sigma</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** euler_number ***</c>
<l>    Name := 'euler_number'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        euler_number (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_phi ***</c>
<l>    Name := 'rect2_phi'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_len1 ***</c>
<l>    Name := 'rect2_len1'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Length1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_len2 ***</c>
<l>    Name := 'rect2_len2'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Length2</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** contlength ***</c>
<l>    Name := 'contlength'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        contlength (Region, ContLength)</l>
<l>        Feature := ContLength</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * REGION FEATURES</c>
<c>    * ************************************</c>
<c>    * MISC</c>
<c>    * ************************************</c>
<c>    * ** porosity ***</c>
<l>    Name := 'porosity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_holes (Region, AreaHoles)</l>
<l>        area_center (Region, Area, Row, Column)</l>
<l>        if (Area == 0)</l>
<l>            Feature := 0.0</l>
<l>        else</l>
<l>            Feature := real(AreaHoles) / (Area + AreaHoles)</l>
<l>        endif</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * HALCON GRAY VALUE FEATURES</c>
<c>    * ************************************</c>
<c>    * BASIC</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ** gray_area ***</c>
<l>    Name := 'gray_area'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_center_gray (Region, Image, Area, Row, Column)</l>
<l>        Feature := Area</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_ra ***</c>
<l>    Name := 'gray_ra'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Ra</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_rb ***</c>
<l>    Name := 'gray_rb'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Rb</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_phi ***</c>
<l>    Name := 'gray_phi'</l>
<l>    Groups := ['gray','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_min ***</c>
<l>    Name := 'gray_min'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Min</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_max ***</c>
<l>    Name := 'gray_max'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Max</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_range ***</c>
<l>    Name := 'gray_range'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Range</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * TEXTURE</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_mean ***</c>
<l>    Name := 'gray_mean'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        intensity (Region, Image, Mean, Deviation)</l>
<l>        Feature := Mean</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_deviation ***</c>
<l>    Name := 'gray_deviation'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        intensity (Region, Image, Mean, Deviation)</l>
<l>        Feature := Deviation</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_plane_deviation ***</c>
<l>    Name := 'gray_plane_deviation'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        plane_deviation (Region, Image, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_anisotropy ***</c>
<l>    Name := 'gray_anisotropy'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        entropy_gray (Region, Image, Entropy, Anisotropy)</l>
<l>        Feature := Anisotropy</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_entropy ***</c>
<l>    Name := 'gray_entropy'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        entropy_gray (Region, Image, Entropy, Anisotropy)</l>
<l>        Feature := Entropy</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_hor_proj ***</c>
<l>    Name := 'gray_hor_proj'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'hor', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_vert_proj ***</c>
<l>    Name := 'gray_vert_proj'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'vert', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_hor_proj_histo ***</c>
<l>    Name := 'gray_hor_proj_histo'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'hor_histo', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_vert_proj_histo ***</c>
<l>    Name := 'gray_vert_proj_histo'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'vert_histo', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** grad_dir_histo ***</c>
<l>    Name := 'grad_dir_histo'</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumBins := 20</l>
<l>        calc_feature_grad_dir_histo (Region, Image, NumBins, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density ***</c>
<l>    Name := 'edge_density'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_edge_density (Region, Image, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_histogram ***</c>
<l>    Name := 'edge_density_histogram'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumBins := 4</l>
<l>        calc_feature_edge_density_histogram (Region, Image, NumBins, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_pyramid ***</c>
<l>    NameRegExp := 'edge_density_pyramid_([234])'</l>
<l>    Names := 'edge_density_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'edge_density', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_histogram_pyramid ***</c>
<l>    NameRegExp := 'edge_density_histogram_pyramid_([234])'</l>
<l>    Names := 'edge_density_histogram_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'edge_density_histogram', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cooc ***</c>
<l>    Name := 'cooc'</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Feature := []</l>
<l>        cooc_feature_image (Region, Image, 6, 0, Energy, Correlation, Homogeneity, Contrast)</l>
<l>        if (NumRegions &gt; 0)</l>
<l>            Index := [0:4:4 * NumRegions - 1]</l>
<l>            Feature[Index] := Energy</l>
<l>            Feature[1 + Index] := Correlation</l>
<l>            Feature[2 + Index] := Homogeneity</l>
<l>            Feature[3 + Index] := Contrast</l>
<l>        endif</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cooc_pyramid ***</c>
<l>    NameRegExp := 'cooc_pyramid_([234])'</l>
<l>    Names := 'cooc_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'cooc', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * POLAR TRANSFORM FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_gray_proj ***</c>
<l>    Name := 'polar_gray_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_gray', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_proj ***</c>
<l>    Name := 'polar_grad_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_amp', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_x_proj ***</c>
<l>    Name := 'polar_grad_x_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_x', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_y_proj ***</c>
<l>    Name := 'polar_grad_y_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_y', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_gray_proj_histo ***</c>
<l>    Name := 'polar_gray_proj_histo'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'vert_gray', Width, Height, Projection)</l>
<l>        NumBins := 20</l>
<l>        Feature := []</l>
<l>        for Index := 1 to NumRegions by 1</l>
<l>            Start := (Index - 1) * Width</l>
<l>            tuple_histo_range (Projection[Start:Start + Width - 1], 0, 255, NumBins, Histo, BinSize)</l>
<l>            Feature := [Feature,Histo]</l>
<l>        endfor</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * COLOR FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cielab_mean ***</c>
<l>    Name := 'cielab_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'cielab', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cielab_dev ***</c>
<l>    Name := 'cielab_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'cielab', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** hls_mean ***</c>
<l>    Name := 'hls_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'hls', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** hls_dev ***</c>
<l>    Name := 'hls_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'hls', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rgb_mean ***</c>
<l>    Name := 'rgb_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'rgb', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rgb_dev ***</c>
<l>    Name := 'rgb_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'rgb', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<l>endfor</l>
<l>Output := AccumulatedResults</l>
<l>set_system ('empty_region_result', EmptyRegionResult)</l>
<l>return ()</l>
</body>
<docu id="get_features">
<abstract lang="en_US">This procedure contains all feature names, the groups they belong to and the code how to calculate them.

It is designed in a way, that it can be easily used to handle user-defined features. 
The user-defined features have to be defined in an external procedure get_custom_features.hdvp (See there for detailed instructions).

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

Currently, get_features supports the following features (associated groups in parenthesis):

'area' ('REGION','ROT_INVAR'): Area of the region (see area_center).

'width' ('REGION'): Width of the region (see smallest_rectangle1).

'height' ('height'): Height of the region (see smallest_rectangle1).

'ra' ('REGION','ROT_INVAR'): Main radius of the equivalent ellipse (see elliptic_axis).

'rb' ('REGION','ROT_INVAR'): Secondary radius of the equivalent ellipse (see elliptic_axis).

'phi' ('REGION','SCALE_INVAR'): Orientation of the equivalent ellipse (see elliptic_axis).

'roundness' ('REGION','ROT_INVAR','SCALE_INVAR'): Roundness (see roundness).

'num_sides' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of polygon sides (see roundness).

'num_connected' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of connection components (see connect_and_holes).

'num_holes' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of holes (see connect_and_holes).

'area_holes' ('REGION','ROT_INVAR'): Area of the holes of the object (see area_holes).

'max_diameter' ('REGION','ROT_INVAR'): Maximum diameter of the region (see diameter_region).

'orientation' ('REGION','SCALE_INVAR'): Orientation of the region (see orientation_region).

'outer_radius' ('REGION','ROT_INVAR'): Radius of smallest surrounding circle (see smallest_circle).

'inner_radius' ('REGION','ROT_INVAR'): Radius of largest inner circle (see inner_circle).

'inner_width' ('REGION'): Width of the largest axis-parallel rectangle that fits into the region (see inner_rectangle1).

'inner_height' ('REGION'): Height of the largest axis-parallel rectangle that fits into the region (see (see inner_rectangle1).

'circularity' ('REGION','ROT_INVAR','SCALE_INVAR'): Circularity (see circularity).

'compactness' ('REGION','ROT_INVAR','SCALE_INVAR'): Compactness (see compactness).

'convexity' ('REGION','ROT_INVAR','SCALE_INVAR'): Convexity (see convexity).

'rectangularity' ('REGION','ROT_INVAR','SCALE_INVAR'): Rectangularity (see rectangularity).

'anisometry: ('REGION','ROT_INVAR','SCALE_INVAR')' Anisometry (see eccentricity).

'bulkiness: ('REGION','ROT_INVAR','SCALE_INVAR')' Bulkiness (see eccentricity).

'struct_factor: ('REGION','ROT_INVAR','SCALE_INVAR')' Structur Factor (see eccentricity).

'dist_mean' ('REGION','ROT_INVAR'): Mean distance from the region border to the center (see roundness).

'dist_deviation': ('REGION','ROT_INVAR') Deviation of the distance from the region border from the center (see roundness).

'euler_number' ('REGION','ROT_INVAR','SCALE_INVAR'): Euler number (see euler_number).

'rect2_phi' ('REGION','SCALE_INVAR'): Orientation of the smallest surrounding rectangle (see smallest_rectangle2).

'rect2_len1' ('REGION','ROT_INVAR'): Half the length of the smallest surrounding rectangle (see smallest_rectangle2).

'rect2_len2' ('REGION','ROT_INVAR'): Half the width of the smallest surrounding rectangle (see smallest_rectangle2).

'contlength' ('REGION','ROT_INVAR'): Total length of the region's contour (see contlength).

'poriosity' ('REGION','ROT_INVAR','SCALE_INVAR'): Ratio of the area of the holes to the region area.

'gray_area' ('GRAY','ROT_INVAR'): Gray-value volume of region (see area_center_gray).

'gray_ra' ('GRAY','ROT_INVAR'): Major axis of equivallent ellipse (see elliptic_axis_gray).

'gray_rb' ('GRAY','ROT_INVAR'): Minor axis of equivallent ellipse (see elliptic_axis_gray).

'gray_phi' ('GRAY','SCALE_INVAR'): Orientation of equivallent ellipse (see elliptic_axis_gray).

'gray_min' ('GRAY','ROT_INVAR','SCALE_INVAR'): Minimum gray value (see min_max_gray).

'gray_max' ('GRAY','ROT_INVAR','SCALE_INVAR'): Maximum gray value (see min_max_gray).

'gray_range' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value range.

'gray_mean' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Mean gray value (see intensity).

'gray_deviation' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Deviation of gray values (see intensity).

'gray_plane_deviation' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Deviation from the approximating plane (see plane_deviation).

'gray_anisotropy' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Anisotropy (see entropy_gray).

'gray_entropy' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Entropy (see entropy_gray).

'gray_hor_proj' ('GRAY','TEXTURE','SCALE_INVAR'): Horizontal gray-value projection.

'gray_vert_proj' ('GRAY','TEXTURE','SCALE_INVAR'): Vertical gray-value projection.

'gray_hor_proj_histo' ('GRAY','TEXTURE','SCALE_INVAR'): Histogram of horizontal gray-value projection.

'gray_vert_proj_histo' ('GRAY','TEXTURE','SCALE_INVAR'): Histogram of horizontal gray-value projection.

'grad_dir_histo' ('GRAY','TEXTURE'): Gradient direction histogram.

'edge_density' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Ratio of the gray-value volume of the edge image to the region area.

'edge_density_pyramid_[234]' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Edge density for 2, 3, or 4 pyramid levels.

'edge_density_histogram' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Ratio of the gray-value histogram of the edge image to the region area.

'edge_density_histogram_pyramid_[234]' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Edge density histogram for 2, 3, or 4 pyramid levels.

'cooc' ('GRAY','TEXTURE'): Energy, correlation, local homogeneity, and contrast of co-occurrance matrix (see cooc_feature_matrix).

'cooc_pyramid_[234]' ('GRAY','TEXTURE'): 'cooc' feature for 2, 3, or 4 pyramid levels.

'polar_gray_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed image.

'polar_grad_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed edge image.

'polar_grad_x_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed derivative in x direction.

'polar_grad_y_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed derivative in y direction.

'polar_gray_proj_histo' ('GRAY','ROT_INVAR','SCALE_INVAR'): Histogram of the gray-value projection along the radial axis of the polar-transformed image.

'cielab_mean' ('COLOR'): Mean gray values of the L, A, and B channel.

'cielab_dev' ('COLOR'): Gray value deviation of the L, A, and B channel.

'hls_mean' ('COLOR'): Mean gray values of the H, L, and S channel.

'hls_dev' ('COLOR'): Gray value deviation of the H, L, and S channel.

'rgb_mean' ('COLOR'): Mean gray values of the R, G, and B channel.

'rgb_dev' ('COLOR'): Gray value deviation of the R, G, and B channel.</abstract>
<alternatives>
<item>get_custom_features</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calculate_features</item>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
<item>query_feature_names_by_group</item>
<item>query_feature_group_names</item>
</see_also>
<short lang="en_US">This procedure contains all relevant information about the supported features.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Input image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_groups'</item>
<item>'get_length'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Namelist">
<default_type>string</default_type>
<description lang="en_US">Feature names or feature group names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Output">
<default_type>real</default_type>
<description lang="en_US">Feature names, feature vector, feature vector lengths, or group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Region to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_nearest_finder_pattern_coordinates">
<interface>
<io>
<par name="CalibPlateImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowNearFinderPattern" base_type="ctrl" dimension="0"/>
<par name="ColumNearFinderPattern" base_type="ctrl" dimension="0"/>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowFinderPattern" base_type="ctrl" dimension="0"/>
<par name="ColumnFinderPattern" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>read_message_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>read_message_tuple (CalibObjectData, 'MarksPerRow', MarksPerRow)</l>
<l>read_message_tuple (CalibObjectData, 'FinderRow', FinderRow)</l>
<l>read_message_tuple (CalibObjectData, 'FinderColumn', FinderColumn)</l>
<c>* </c>
<c>* Check input.</c>
<c>* </c>
<c>* Check image coordinates.</c>
<l>if (|RowNearFinderPattern| &gt; 1 or |ColumNearFinderPattern| &gt; 1)</l>
<l>    throw ('Please specify only one image coordinate.')</l>
<l>endif</l>
<c>* Check number of marks per row.</c>
<l>if (MarksPerRow &lt; 3)</l>
<l>    throw ('At least three marks per row are necessary for a valid finder pattern.')</l>
<l>endif</l>
<c>* Find calibration plate.</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, [], CamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CalPlateDescr)</l>
<l>try</l>
<l>    find_calib_object (CalibPlateImage, CalibDataID, 0, 0, 0, [], [])</l>
<l>catch (Exception)</l>
<l>    throw ('Calibration plate could not be find, please make sure that at least one finder pattern is visible.')</l>
<l>endtry</l>
<l>get_calib_data_observ_points (CalibDataID, 0, 0, 0, Row, Column, Index1, Pose)</l>
<l>get_calib_data_observ_contours (Contours, CalibDataID, 'caltab', 0, 0, 0)</l>
<c>* Get the finder pattern used to find the calibration plate.</c>
<l>gen_region_contour_xld (Contours, Region, 'filled')</l>
<l>union1 (Region, RegionUnion)</l>
<l>area_center (RegionUnion, Area1, Row2, Column2)</l>
<l>RowTmp := abs(Row - Row2)</l>
<l>ColTmp := abs(Column - Column2)</l>
<l>Diff := sqrt(RowTmp * RowTmp + ColTmp * ColTmp)</l>
<l>tuple_find (Diff, min(Diff), IndexFinal)</l>
<l>RowToApproach1 := Row[IndexFinal]</l>
<l>ColToApproach1 := Column[IndexFinal]</l>
<l>clear_calib_data (CalibDataID)</l>
<c>* Get remaining finder pattern.</c>
<c>* </c>
<c>* Get finder pattern in world coordinates.</c>
<l>caltab_points (CalPlateDescr, XCal, YCal, ZCal)</l>
<l>XFP := XCal[FinderRow * MarksPerRow + FinderColumn]</l>
<l>YFP := YCal[FinderRow * MarksPerRow + FinderColumn]</l>
<c>* Get finder pattern in camera coordinates.</c>
<l>pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>tuple_gen_const (|XFP|, 0.0, ZFP)</l>
<l>affine_trans_point_3d (HomMat3D, XFP, YFP, ZFP, X1, Y1, Z1)</l>
<c>* Project into the image.</c>
<l>project_3d_point (X1, Y1, Z1, CamParam, Row, Column)</l>
<c>* </c>
<c>* Get the image coordinates that are the closest ones to the passed ones.</c>
<l>RowTmp := abs(Row - RowNearFinderPattern)</l>
<l>ColTmp := abs(Column - ColumNearFinderPattern)</l>
<l>Diff := sqrt(RowTmp * RowTmp + ColTmp * ColTmp)</l>
<l>tuple_find (Diff, min(Diff), IndexFinal)</l>
<c>* Return the image coordinates.</c>
<l>RowFinderPattern := Row[IndexFinal]</l>
<l>ColumnFinderPattern := Column[IndexFinal]</l>
<l>return ()</l>
</body>
<docu id="get_nearest_finder_pattern_coordinates">
<abstract lang="en_US">This procedure returns the image coordinates of the central mark of the finder pattern (RowFinderPattern, ColumnFinderPattern) in the CalibPlateImage that is the closest one to the passed image coordinates in the parameters RowNearFinderPattern and ColumnNearFinderPattern.

The message CalibObjectData must contain the parameters CamParam, CalPlateDescr, MarksPerRow, FinderRow and FinderColumn.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_camera_and_plane_single_image</item>
<item>get_mbutton_sub_pix</item>
</predecessor>
<short lang="en_US">Get the coordinates of the central mark of the closest finder pattern.</short>
<successor>
<item>calibrate_hand_eye_stationary_cam</item>
</successor>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CalibPlateImage">
<description lang="en_US">Image of the calibration plate describing the measurement plane.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>uint2</item>
</type_list>
</parameter>
<parameter id="ColumNearFinderPattern">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Column coordinate near the touching point / central mark of the approached finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ColumnFinderPattern">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the central mark of the closest finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowFinderPattern">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the central mark of the closest finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowNearFinderPattern">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Row coordinate near the touching point / central mark of the approached finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_object_models_center">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Center" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Compute the mean of all model centers (weighted by the diameter of the object models)</c>
<l>if (|ObjectModel3DID| &gt; 0)</l>
<l>    get_object_model_3d_params (ObjectModel3DID, 'diameter_axis_aligned_bounding_box', Diameter)</l>
<c>    * Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>    MD := mean(Diameter)</l>
<l>    if (MD &gt; 1e-10)</l>
<l>        Weight := Diameter / MD</l>
<l>    else</l>
<l>        Weight := Diameter</l>
<l>    endif</l>
<l>    SumW := sum(Weight)</l>
<l>    if (SumW &lt; 1e-10)</l>
<l>        Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>        SumW := sum(Weight)</l>
<l>    endif</l>
<l>    Center := [0,0,0]</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        ObjectModel3DIDSelected := ObjectModel3DID[Index]</l>
<l>        get_object_model_3d_params (ObjectModel3DIDSelected, 'center', C)</l>
<l>        Center[0] := Center[0] + C[0] * Weight[Index]</l>
<l>        Center[1] := Center[1] + C[1] * Weight[Index]</l>
<l>        Center[2] := Center[2] + C[2] * Weight[Index]</l>
<l>    endfor</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    Center[0] := Center[0] * InvSum</l>
<l>    Center[1] := Center[1] * InvSum</l>
<l>    Center[2] := Center[2] * InvSum</l>
<l>else</l>
<l>    Center := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_object_models_center">
<abstract lang="en_US">get_object_models_center computes the center of all given 3D object models.

The center is computed as the weighted mean of all centers of the individual 3D object models. The weighting ensures that larger 3D object models have an higher impact on the calculated center.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
</predecessor>
<see_also>
<item>determine_optimum_pose_distance</item>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Compute the center of all given 3D object models.</short>
<successor>
<item>create_pose</item>
<item>determine_optimum_pose_distance</item>
</successor>
<parameters>
<parameter id="Center">
<default_type>real</default_type>
<description lang="en_US">Center of the 3D object models.</description>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_robot_touching_point_in_tool_coordinates">
<interface>
<ic>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* To estimate the touching point with respect to the tool coordinate system, we have to</c>
<c>* arrange three equations in the following form:</c>
<c>* Rp + T = q,</c>
<c>* where R is a is the rotation matrix that rotates a point from the tool to the base coordinate</c>
<c>* system and T is a translation that translates a point from the tool to the base coordinate.</c>
<c>* q is the touching point with respect to the base coordinate system</c>
<c>* and p the unknown touching point with respect to the tool coordinate system.</c>
<c>* </c>
<c>* Approaching the same point three times while rotating the tool leads to three rotation matrices</c>
<c>* R0, R1 and R2 and three translations T0, T1 and T2.</c>
<c>* Solving this equation for the unknown touching point yields therefore:</c>
<c>* R0*p + T0 = q, R1*p + T1 = q and R2*p + T2 = q.</c>
<c>* After building two equations in the form (R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2,</c>
<c>* the DLT (direct linear transformation) can be used to efficiently solve for the unknown</c>
<c>* touching point p.</c>
<c></c>
<c></c>
<c>* Check input.</c>
<l>if (ToolInBasePosesTouchingPoint.length() &lt; 3)</l>
<l>    throw ('Please specify at least three robot poses.')</l>
<l>endif</l>
<c></c>
<c>* Initialize equation.</c>
<l>create_matrix ((ToolInBasePosesTouchingPoint.length() - 1) * 3, 3, 0, LHS)</l>
<l>create_matrix ((ToolInBasePosesTouchingPoint.length() - 1) * 3, 1, 0, RHS)</l>
<l>RotationAxisRelativ := {[]}</l>
<l>DiffToIdentity := {[]}</l>
<c>* Decompose first pose.</c>
<l>pose_to_hom_mat3d (ToolInBasePosesTouchingPoint.at(0), HomMat3D0)</l>
<l>create_matrix (3, 4, HomMat3D0, Mat0)</l>
<l>get_sub_matrix (Mat0, 0, 0, 3, 3, MatRot0)</l>
<l>get_sub_matrix (Mat0, 0, 3, 3, 1, MatTrans0)</l>
<c>* </c>
<l>for Index := 1 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<c>    * Decompose current pose.</c>
<l>    pose_to_hom_mat3d (ToolInBasePosesTouchingPoint.at(Index), HomMat3D)</l>
<l>    create_matrix (3, 4, HomMat3D, Mat)</l>
<l>    get_sub_matrix (Mat, 0, 0, 3, 3, MatRot)</l>
<l>    get_sub_matrix (Mat, 0, 3, 3, 1, MatTrans)</l>
<c>    * Get rotation axis relativ to first pose.</c>
<l>    get_rotation_axis (MatRot, MatRot0, RotationAxisRelativ.at(Index), DiffToIdentity.at(Index))</l>
<c>    * Fill equation.</c>
<l>    sub_matrix_mod (MatRot, MatRot0)</l>
<l>    set_sub_matrix (LHS, MatRot, (Index - 1) * 3, 0)</l>
<l>    sub_matrix_mod (MatTrans, MatTrans0)</l>
<l>    scale_matrix_mod (MatTrans, -1.0)</l>
<l>    set_sub_matrix (RHS, MatTrans, (Index - 1) * 3, 0)</l>
<c>    * Clear.</c>
<l>    clear_matrix (Mat)</l>
<l>    clear_matrix (MatRot)</l>
<l>    clear_matrix (MatTrans)</l>
<l>endfor</l>
<c>* Solve.</c>
<l>solve_matrix (LHS, 'general', 0, RHS, MatrixResultID)</l>
<l>get_full_matrix (MatrixResultID, RobotTouchingPointInToolCoordinates)</l>
<c>* Detailed errors.</c>
<l>DetailedErrors := 0</l>
<l>if (DetailedErrors)</l>
<c>    * Check that the tool was tilted enough compared to the first pose.</c>
<l>    MinDiffToIdentity := 1e8</l>
<l>    for Index := 1 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<l>        if (DiffToIdentity.at(Index) &lt; MinDiffToIdentity)</l>
<l>            MinDiffToIdentity := DiffToIdentity.at(Index)</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check that different rotation axis were used when tilted away from first pose.</c>
<l>    MinCosAngle := 1.5</l>
<l>    for Index := 1 to ToolInBasePosesTouchingPoint.length() - 2 by 1</l>
<l>        for Index1 := Index + 1 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<l>            CosAngle := abs(sum(RotationAxisRelativ.at(Index) * RotationAxisRelativ.at(Index1)))</l>
<l>            if (CosAngle &lt; MinCosAngle)</l>
<l>                MinCosAngle := CosAngle</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>    MaxAngleBetweenRotationAxes := deg(acos(MinCosAngle))</l>
<l>endif</l>
<l>svd_matrix (LHS, 'full', 'both', MatrixUID, MatrixSID, MatrixVID)</l>
<l>get_value_matrix (MatrixSID, [0,1,2], [0,1,2], SingularValues)</l>
<l>MinSingularValue := min(abs(SingularValues))</l>
<l>if (MinSingularValue &lt; 0.15)</l>
<c>    * Consider the rotations of the tool from its first position to each following position.</c>
<c>    * Please rotate the tool enough away from the first position.</c>
<c>    * Furthermore, please use at least two significantly different rotation axis when rotating the tool</c>
<c>    * from its first position (preferably orthogonal directions?).</c>
<c>    * The maximum angle between the corresponding rotation axis is MaxAngleBetweenRotationAxes.</c>
<c>    * </c>
<l>    throw ('The estimated touching point might not be reliable. Try to use at least two different rotation axis and/or increase the rotations around these axis.')</l>
<l>endif</l>
<c>* </c>
<c>* Clear.</c>
<l>clear_matrix (MatrixUID)</l>
<l>clear_matrix (MatrixSID)</l>
<l>clear_matrix (MatrixVID)</l>
<l>clear_matrix (Mat0)</l>
<l>clear_matrix (MatRot0)</l>
<l>clear_matrix (MatTrans0)</l>
<l>clear_matrix (LHS)</l>
<l>clear_matrix (RHS)</l>
<l>return ()</l>
</body>
<docu id="get_robot_touching_point_in_tool_coordinates">
<abstract lang="en_US">This procedure calculates the touching point with respect to the tool coordinate system.

The touching point is a point that has to be fixed with respect to to the tool coordinate system but does not have to be located on the surface of the gripper. It can e.g. lie halfway between two fingers of a gripper.

To determine the touching point, choose a fixed point in the real setup that can be approached easily and accurately. Approach this point with the touching point and register the corresponding tool pose with respect to the base coordinate system. Repeat this at least two times, rotating the tool around at least two axis and register the tool poses.

With the three robot poses approaching the same point, it is possible to arrange the following three equations:
 R0*p + T0 = q
 R1*p + T1 = q 
 R2*p + T2 = q,

where R0, R1 and R2 are the rotation matrices that rotate a point from the tool to the base coordinate system and T0, T1 and T2 are the translations that translate a point from the tool to the base coordinate.
q is the touching point with respect to the base coordinate system and p the unknown touching point with respect to the tool coordinate system.

Solving the above equations for the unknown touching point p yields
(R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2 that can be solved efficiently using the DLT (direct linear transformation).

The calculated touching point is returned in the parameter RobotTouchingPointInToolCoordinates and describes the point with respect to the robot's tool coordinate system.
    </abstract>
<alternatives>
<item>calibrate_robot_touching_point</item>
</alternatives>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_pose</item>
</predecessor>
<short lang="en_US">Calculate the touching point in tool coordinates.</short>
<successor>
<item>visualize_calibrated_touching_point</item>
</successor>
<parameters>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">Touching point with respect to the tool coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="ToolInBasePosesTouchingPoint">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Poses of the robot's tool with respect to robot's base.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_rotation_axis">
<interface>
<ic>
<par name="MatRot" base_type="ctrl" dimension="0"/>
<par name="MatRot0" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAxis" base_type="ctrl" dimension="0"/>
<par name="DiffToIdentity" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Get (R_i)^(-1)R_0</c>
<l>mult_matrix (MatRot, MatRot0, 'ATB', MatrixMultID)</l>
<c>* Get some measure for how far the matrix is from the identity.</c>
<l>create_matrix (3, 3, 'identity', Identity)</l>
<l>sub_matrix (MatrixMultID, Identity, MatrixSubID)</l>
<l>get_full_matrix (MatrixSubID, Values)</l>
<l>DiffToIdentity := sum(Values * Values)</l>
<c>* Get its rotation axis.</c>
<l>svd_matrix (MatrixSubID, 'full', 'both', MatrixUID, MatrixSID, MatrixVID)</l>
<l>get_value_matrix (MatrixSID, [0,1,2], [0,1,2], SingularValues)</l>
<l>AbsSingularValues := abs(SingularValues)</l>
<l>tuple_sort_index (AbsSingularValues, Indices)</l>
<l>get_value_matrix (MatrixVID, [0,1,2], [Indices[0],Indices[0],Indices[0]], RotationAxis)</l>
<c>* Clear matrices.</c>
<l>clear_matrix (MatrixMultID)</l>
<l>clear_matrix (MatrixUID)</l>
<l>clear_matrix (MatrixSID)</l>
<l>clear_matrix (MatrixVID)</l>
<l>clear_matrix (MatrixSubID)</l>
<l>clear_matrix (Identity)</l>
<l>return ()</l>
</body>
<docu id="get_rotation_axis">
<chapters lang="en_US">
<item>Matrix</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DiffToIdentity"/>
<parameter id="MatRot"/>
<parameter id="MatRot0"/>
<parameter id="RotationAxis"/>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>NumModels := |ObjectModel3D|</l>
<l>TBCenter[0] := 0</l>
<l>TBCenter[1] := 0</l>
<l>TBCenter[2] := 0</l>
<l>get_object_model_3d_params (ObjectModel3D, 'center', Centers)</l>
<l>get_object_model_3d_params (ObjectModel3D, 'diameter_axis_aligned_bounding_box', Diameter)</l>
<c>* Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>MD := mean(Diameter)</l>
<l>if (MD &gt; 1e-10)</l>
<l>    Weight := Diameter / MD</l>
<l>else</l>
<l>    Weight := Diameter</l>
<l>endif</l>
<l>SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>if (SumW &lt; 1e-10)</l>
<l>    Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>    SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>endif</l>
<l>for Index := 0 to NumModels - 1 by 1</l>
<l>    if (SelectedObject[Index])</l>
<l>        ObjectModel3DIDSelected := ObjectModel3D[Index]</l>
<l>        PoseSelected := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (PoseSelected, HomMat3D)</l>
<l>        affine_trans_point_3d (HomMat3D, Centers[Index * 3 + 0], Centers[Index * 3 + 1], Centers[Index * 3 + 2], TBCenterCamX, TBCenterCamY, TBCenterCamZ)</l>
<l>        TBCenter[0] := TBCenter[0] + TBCenterCamX * Weight[Index]</l>
<l>        TBCenter[1] := TBCenter[1] + TBCenterCamY * Weight[Index]</l>
<l>        TBCenter[2] := TBCenter[2] + TBCenterCamZ * Weight[Index]</l>
<l>    endif</l>
<l>endfor</l>
<l>if (max(SelectedObject) != 0)</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    TBCenter[0] := TBCenter[0] * InvSum</l>
<l>    TBCenter[1] := TBCenter[1] * InvSum</l>
<l>    TBCenter[2] := TBCenter[2] * InvSum</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera.</short>
<parameters>
<parameter id="ObjectModel3D"/>
<parameter id="Poses"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballRadiusPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center_fixed">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Determine the trackball center for the fixed trackball</c>
<l>NumModels := |ObjectModel3DID|</l>
<l>get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>get_cam_par_data (CamParam, 'image_height', Height)</l>
<c>* </c>
<c>* Project the selected objects</c>
<l>SelectPose := []</l>
<l>for Index1 := 0 to |SelectedObject| - 1 by 1</l>
<l>    SelectPose := [SelectPose,gen_tuple_const(7,SelectedObject[Index1])]</l>
<l>    if (SelectedObject[Index1] == 0)</l>
<l>        set_scene_3d_instance_param (Scene3D, Index1, 'visible', 'false')</l>
<l>    endif</l>
<l>endfor</l>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'true')</l>
<l>display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>set_scene_3d_param (Scene3D, 'visible', 'true')</l>
<c>* </c>
<c>* determine the depth of the object point that appears closest to the trackball</c>
<c>* center</c>
<l>gen_region_points (RegionCenter, TrackballCenterRow, TrackballCenterCol)</l>
<l>distance_transform (RegionCenter, DistanceImage, 'chamfer-3-4-unnormalized', 'false', Width, Height)</l>
<l>get_domain (DistanceImage, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (DistanceImage, Rows, Columns, Grayval)</l>
<l>tuple_sort_index (Grayval, IndicesG)</l>
<l>get_display_scene_3d_info (WindowHandleBuffer, Scene3D, subset(Rows,IndicesG), subset(Columns,IndicesG), 'depth', Value)</l>
<l>tuple_find (sgn(Value), 1, Pos)</l>
<c>* </c>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'false')</l>
<c>* </c>
<c>* </c>
<c>* set TBCenter</c>
<l>if (Pos != -1)</l>
<c>    * if the object is visible in the image</c>
<l>    TBCenter := [0,0,Value[Pos[0]]]</l>
<l>else</l>
<c>    * if the object is not visible in the image, set the z coordinate to -1</c>
<c>    * to indicate, the the previous z value should be used instead</c>
<l>    TBCenter := [0,0,-1]</l>
<l>endif</l>
<c>* </c>
<l>if (max(SelectedObject) != 0)</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center_fixed">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface').</short>
<parameters>
<parameter id="CamParam"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="ObjectModel3DID"/>
<parameter id="Poses"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballCenterCol"/>
<parameter id="TrackballCenterRow"/>
<parameter id="TrackballRadiusPixel"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* ImageDirectory: as the name says</c>
<c>*    If a tuple of directories is given, only the images in the first</c>
<c>*    existing directory are returned.</c>
<c>*    If a local directory is not found, the directory is searched</c>
<c>*    under %HALCONIMAGES%/ImageDirectory.</c>
<c>*    See the Installation Guide for further information</c>
<c>*    in case %HALCONIMAGES% is not set.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c>* </c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima','tif','tiff','gif','bmp','jpg','jpeg','jp2','jxr','png','pcx','ras','xwd','pbm','pnm','pgm','ppm']</l>
<c>    * </c>
<l>endif</l>
<l>if (ImageDirectory == '')</l>
<l>    ImageDirectory := '.'</l>
<l>endif</l>
<l>get_system ('image_dir', HalconImages)</l>
<l>get_system ('operating_system', OS)</l>
<l>if (OS{0:2} == 'Win')</l>
<l>    HalconImages := split(HalconImages,';')</l>
<l>else</l>
<l>    HalconImages := split(HalconImages,':')</l>
<l>endif</l>
<l>Directories := ImageDirectory</l>
<l>for Index := 0 to |HalconImages| - 1 by 1</l>
<l>    Directories := [Directories,HalconImages[Index] + '/' + ImageDirectory]</l>
<l>endfor</l>
<l>tuple_strlen (Directories, Length)</l>
<l>tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>if (OS{0:2} == 'Win')</l>
<l>    for Index := 0 to |Length| - 1 by 1</l>
<l>        if (strlen(Directories[Index]) &gt; 1)</l>
<l>            tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>            if (Substring == '//' or Substring == '\\\\')</l>
<l>                NetworkDrive[Index] := true</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<l>ImageFiles := []</l>
<l>for Index := 0 to |Directories| - 1 by 1</l>
<l>    file_exists (Directories[Index], FileExists)</l>
<l>    if (FileExists)</l>
<l>        list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>        ImageFiles := []</l>
<l>        for i := 0 to |Extensions| - 1 by 1</l>
<l>            tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>            ImageFiles := [ImageFiles,Selection]</l>
<l>        endfor</l>
<l>        tuple_regexp_replace (ImageFiles, ['\\\\','replace_all'], '/', ImageFiles)</l>
<l>        if (NetworkDrive[Index])</l>
<l>            tuple_regexp_replace (ImageFiles, ['//','replace_all'], '/', ImageFiles)</l>
<l>            ImageFiles := '/' + ImageFiles</l>
<l>        else</l>
<l>            tuple_regexp_replace (ImageFiles, ['//','replace_all'], '/', ImageFiles)</l>
<l>        endif</l>
<l>        return ()</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

If a tuple of directories is given in ImageDirectory, only the images in the first existing directory are returned. If a local directory is not found, the directory is searched under %HALCONIMAGES%/ImageDirectory. See the Installation Guide for further information in case %HALCONIMAGES% is not set.
If Extensions is set to 'default' or the empty string '', all image suffixes supported by HALCON are used.
The parameter Options is used as in the operator list_files (see list_files for details), except that the 'files' option is always used. Note that the 'directories' option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="de_DE">Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="max_line_width">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Lines" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxWidth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MaxWidth := 0</l>
<l>for Index := 0 to |Lines| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, Lines[Index], Ascent, Descent, LineWidth, LineHeight)</l>
<l>    MaxWidth := max([LineWidth,MaxWidth])</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="max_line_width">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get string extends of several lines.</short>
<parameters>
<parameter id="Lines"/>
<parameter id="MaxWidth"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="obtain_3d_pose_of_match_moving_cam">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure obtains the 3D pose from the model to the base of</c>
<c>* the robot.</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage != 'no_rectification')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<l>read_message_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInCamPose)</l>
<l>convert_pose_type (PlaneInModelPose, 'Rp+T', 'gba', 'point', PlaneInModelPose)</l>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>if (|Row| == 1)</l>
<l>    vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DObject)</l>
<c>    * Col = x, Row = y.</c>
<l>    if (RectifyImage == 'no_rectification')</l>
<l>        affine_trans_pixel (HomMat2DObject, 0, 0, RowObject, ColObject)</l>
<l>        image_points_to_world_plane (CamParam, MatchingPlaneRectifiedPartInCamPose, RowObject, ColObject, 'm', PXM, PYM)</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,PXM,HomMat2DObject[1],HomMat2DObject[0],0,PYM,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePose)</l>
<l>        pose_compose (ModelToMatchInPlanePose, PlaneInModelPose, ModelInPlanePose)</l>
<l>        pose_compose (MatchingPlaneRectifiedPartInCamPose, ModelInPlanePose, ModelInCamPose)</l>
<l>    elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,HomMat2DObject[5] * ScaleRectification,HomMat2DObject[1],HomMat2DObject[0],0,HomMat2DObject[2] * ScaleRectification,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePartRectPose)</l>
<l>        pose_compose (ModelToMatchInPlanePartRectPose, PlaneInModelPose, ModelInMatchingPlaneRectifiedPartPose)</l>
<l>        pose_compose (MatchingPlaneRectifiedPartInCamPose, ModelInMatchingPlaneRectifiedPartPose, ModelInCamPose)</l>
<l>    else</l>
<l>        throw ('Please set the parameter RectifyImage correctly')</l>
<l>    endif</l>
<l>    pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>    pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, ModelInCamPose, ModelInBasePose)</l>
<c>    * </c>
<l>    convert_pose_type (ModelInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ModelInBasePose)</l>
<l>else</l>
<l>    throw ('Exactly one match should be given as input')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="obtain_3d_pose_of_match_moving_cam">
<abstract lang="en_US">This procedure obtains the pose of the matched model in the robot's base coordinate system to enable grasping it later.

The input parameters Row, Column, and Angle are those of the matched model.

The input message HandEyeCalibData contains the camera parameters CamParam and ToolInCamPose. The input message Poses contains the PlaneInModelPose.

The input message RectificationData contains the RectifyImage which is the rectification option with the possible values 'no_rectification', 'only_rectify', and 'align_and_rectify' as explained in the procedure prepare_poses_and_rectification_data_moving_cam. Moreover, RectificationData contains MatchingPlaneRectifiedPartInCamPose. RectificationData also contains ScaleRectification if image rectification is set by the user. 

The output parameter ModelInBasePose is the pose of the matched model in the robot's base coordinate system.</abstract>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>rectify_image_and_compute_matching_plane_moving_cam</item>
</predecessor>
<short lang="en_US">Obtain the pose of the matched model in the base coordinate system.</short>
<successor>
<item>calculate_tool_in_base_robot_path_poses</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Angle of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: CamParam and ToolInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the model in the robot's base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain PlaneInModelPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: RectifyImage, MatchingPlaneRectifiedPartInCamPose, and (if rectification is set) ScaleRectification.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<description lang="en_US">Current pose of the robot.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="obtain_3d_pose_of_match_stationary_cam">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure obtains the 3D pose from the model to the base of</c>
<c>* the robot.</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>read_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>read_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (PlaneInModelPose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (MatchingPlaneInCamPose, 'Rp+T', 'gba', 'point', MatchingPlaneInCamPose)</l>
<l>convert_pose_type (PlaneInModelPose, 'Rp+T', 'gba', 'point', PlaneInModelPose)</l>
<l>if (|Row| == 1 and |Column| == 1 and |Angle| == 1)</l>
<l>    vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DObject)</l>
<c>    * col = x, row = y</c>
<l>    if (RectifyImage == 'false')</l>
<l>        affine_trans_pixel (HomMat2DObject, 0, 0, RowObject, ColObject)</l>
<l>        image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, RowObject, ColObject, 'm', PXM, PYM)</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,PXM,HomMat2DObject[1],HomMat2DObject[0],0,PYM,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePose)</l>
<l>        pose_compose (ModelToMatchInPlanePose, PlaneInModelPose, ModelInPlanePose)</l>
<l>        pose_compose (MatchingPlaneInCamPose, ModelInPlanePose, ModelInCamPose)</l>
<l>    elseif (RectifyImage == 'true')</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,HomMat2DObject[5] * ScaleRectification,HomMat2DObject[1],HomMat2DObject[0],0,HomMat2DObject[2] * ScaleRectification,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePartRectPose)</l>
<l>        pose_compose (ModelToMatchInPlanePartRectPose, PlaneInModelPose, ModelInPlanePartRectPose)</l>
<l>        pose_compose (MatchingPlaneInCamPose, ModelInPlanePartRectPose, ModelInCamPose)</l>
<l>    else</l>
<l>        throw ('Please set the parameter RectifyImage correctly')</l>
<l>    endif</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, ModelInCamPose, ModelInBasePose)</l>
<c>    * </c>
<l>    convert_pose_type (ModelInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ModelInBasePose)</l>
<l>else</l>
<l>    throw ('Exactly one match should be given as input')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="obtain_3d_pose_of_match_stationary_cam">
<abstract lang="en_US">This procedure obtains the pose of the matched model in the robot's base coordinate system to enable grasping it later, in a stationary camera setup.

The input parameters Row, Column, and Angle are those of the matched model.

The input message HandEyeCalibData must contain the camera parameters CamParam and the pose BaseInCamPose.

The input message Poses must contain the poses PlaneInModelPose and MatchingPlaneInCamPose.

The input message RectificationData must contain the parameter RectifyImage ('true', 'false'), and, if the image is to be rectified, the parameter ScaleRectification.

The output parameter ModelInBasePose is the pose of the matched model in the robot's base coordinate system.</abstract>
<alternatives>
<item>obtain_3d_pose_of_match_moving_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_poses_and_rectification_data_stationary_cam</item>
</predecessor>
<short lang="en_US">Obtain the pose of the matched model in the base coordinate system in a stationary camera setup.</short>
<successor>
<item>calculate_tool_in_base_robot_path_poses</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: CamParam and BaseInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the matched model in the robot's base coordinate system.</description>
<multivalue>false</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: PlaneInModelPose and MatchingPlaneInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: RectifyImage and ScaleRectification.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_new_window">
<interface>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>wait_seconds (0.1)</l>
<l>dev_get_window (WindowHandle)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_open_window_fit_size (0, Width + 8, Width, Height, 600, -1, WindowHandleGraphics)</l>
<l>set_display_font (WindowHandleGraphics, 14, 'mono', 'true', 'false')</l>
<l>set_part_style (WindowHandleGraphics, 2)</l>
<l>return ()</l>
</body>
<docu id="open_new_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a new window next to an existing one.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="parse_filename">
<interface>
<ic>
<par name="FileName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BaseName" base_type="ctrl" dimension="0"/>
<par name="Extension" base_type="ctrl" dimension="0"/>
<par name="Directory" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure gets a filename (with full path) as input</c>
<c>* and returns the directory path, the base filename and the extension</c>
<c>* in three different strings.</c>
<c>* </c>
<c>* In the output path the path separators will be replaced</c>
<c>* by '/' in all cases.</c>
<c>* </c>
<c>* The procedure shows the possibilities of regular expressions in HALCON.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* FileName: The input filename</c>
<c>* </c>
<c>* Output parameters:</c>
<c>* BaseName: The filename without directory description and file extension</c>
<c>* Extension: The file extension</c>
<c>* Directory: The directory path</c>
<c>* </c>
<c>* Example:</c>
<c>* basename('C:/images/part_01.png',...) returns</c>
<c>* BaseName = 'part_01'</c>
<c>* Extension = 'png'</c>
<c>* Directory = 'C:\\images\\' (on Windows systems)</c>
<c>* </c>
<c>* Explanation of the regular expressions:</c>
<c>* </c>
<c>* '([^\\\\/]*?)(?:\\.[^.]*)?$':</c>
<c>* To start at the end, the '$' matches the end of the string,</c>
<c>* so it is best to read the expression from right to left.</c>
<c>* The part in brackets (?:\\.[^.}*) denotes a non-capturing group.</c>
<c>* That means, that this part is matched, but not captured</c>
<c>* in contrast to the first bracketed group ([^\\\\/], see below.)</c>
<c>* \\.[^.]* matches a dot '.' followed by as many non-dots as possible.</c>
<c>* So (?:\\.[^.]*)? matches the file extension, if any.</c>
<c>* The '?' at the end assures, that even if no extension exists,</c>
<c>* a correct match is returned.</c>
<c>* The first part in brackets ([^\\\\/]*?) is a capture group,</c>
<c>* which means, that if a match is found, only the part in</c>
<c>* brackets is returned as a result.</c>
<c>* Because both HDevelop strings and regular expressions need a '\\'</c>
<c>* to describe a backslash, inside regular expressions within HDevelop</c>
<c>* a backslash has to be written as '\\\\'.</c>
<c>* [^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)</c>
<c>* [^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')</c>
<c>* where the '?' after the '*' switches the greediness off,</c>
<c>* that means, that the shortest possible match is returned.</c>
<c>* This option is necessary to cut off the extension</c>
<c>* but only if (?:\\.[^.]*)? is able to match one.</c>
<c>* To summarize, the regular expression matches that part of</c>
<c>* the input string, that follows after the last '/' or '\\' and</c>
<c>* cuts off the extension (if any) after the last '.'.</c>
<c>* </c>
<c>* '\\.([^.]*)$':</c>
<c>* This matches everything after the last '.' of the input string.</c>
<c>* Because ([^.]) is a capturing group,</c>
<c>* only the part after the dot is returned.</c>
<c>* </c>
<c>* '.*[\\\\/]':</c>
<c>* This matches the longest substring with a '/' or a '\\' at the end.</c>
<c>* </c>
<l>tuple_regexp_match (FileName, '.*[\\\\/]', DirectoryTmp)</l>
<l>tuple_substr (FileName, strlen(DirectoryTmp), strlen(FileName) - 1, Substring)</l>
<l>tuple_regexp_match (Substring, '([^\\\\/]*?)(?:\\.[^.]*)?$', BaseName)</l>
<l>tuple_regexp_match (Substring, '\\.([^.]*)$', Extension)</l>
<c>* </c>
<c>* </c>
<c>* Finally all found backslashes ('\\') are converted</c>
<c>* to a slash to get consistent paths</c>
<l>tuple_regexp_replace (DirectoryTmp, ['\\\\','replace_all'], '/', Directory)</l>
<l>return ()</l>
</body>
<docu id="parse_filename">
<abstract lang="en_US">This procedure gets a filename (with full path) as input and returns the directory path (Directory), the base filename (BaseName) and the extension (Extension) in three different strings.</abstract>
<alternatives>
<item>tuple_regexp_select</item>
<item>tuple_regexp_match</item>
<item>tuple_regexp_match</item>
</alternatives>
<attention lang="en_US">In case of hidden files of the form '.name' (e.g. '.profile' etc.), an empty BaseName and Extension=name are returned.</attention>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">FullFileNames:=['C:/images/image_01.png','C:/images/image_02.png','C:/training_image.png']
parse_filename (FullFileName, BaseName, Extension, Directory)
tuple_regexp_select(BaseName,'training',TrainingImages)</example>
<keywords lang="de_DE">
<item>Dateiname parsen</item>
</keywords>
<keywords lang="en_US">
<item>parse file name</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
<item>list_image_files</item>
</predecessor>
<short>This procedure gets a filename (with full path) as input and returns the directory path, the base filename and the extension in three different strings.</short>
<short lang="de_DE">Parse a filename into directory, base filename, and extension</short>
<short lang="en_US">Parse a filename into directory, base filename, and extension</short>
<successor>
<item>tuple_regexp_select</item>
</successor>
<parameters>
<parameter id="BaseName">
<default_type>string</default_type>
<description lang="en_US">The filename without directory description and file extension</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Directory">
<default_type>string</default_type>
<description lang="en_US">The directory path</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Extension">
<default_type>string</default_type>
<description lang="en_US">The file extension</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FileName">
<default_type>string</default_type>
<description lang="en_US">The input filename</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_funct_1d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Function" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots a function in a coordinate system.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* </c>
<c>* Function: 1d function</c>
<c>* </c>
<c>* XLabel: X axis label</c>
<c>* </c>
<c>* XLabel: Y axis label</c>
<c>* </c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>* </c>
<c>* GenParamNames: Generic parameters to control the presentation</c>
<c>*                The parameters are evaluated from left to right.</c>
<c>* </c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possibile values: 'yes' (default), 'no'</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the x axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the x axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'origin_x': X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: same as start_x</c>
<c>*    'origin_y': Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: same as start_y</c>
<c>* </c>
<c>* GenParamValues: Values of the generic parameters of GenericParamNames</c>
<c>* </c>
<c>* </c>
<l>funct_1d_to_pairs (Function, XValues, YValues)</l>
<l>plot_tuple (WindowHandle, XValues, YValues, XLabel, YLabel, Color, GenParamNames, GenParamValues)</l>
<l>return ()</l>
</body>
<docu id="plot_funct_1d">
<abstract lang="en_US">This procedure plots the function Function into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and Ylabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamNames and GenericParamValues.

In particular, following parameters can be set:

Function: A 1d function.

 XLabel: X axis label.

 XLabel: Y axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.

 GenParamNames: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'filled'

    'clip': Clip graph to coordinate system area.
            Possibile values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x axis.
               Default: min(XValues)

    'end_x': Highest x value of the x axis.
             Default: max(XValues)

    'start_y': Lowest y value of the x axis.
               Default: min(YValues)

    'end_y': Highest y value of the x axis.
             Default: max(YValues)

    'origin_x': X coordinate of the intercept point of x- and y-axis.
                Default: same as start_x

    'origin_y': Y coordinate of the intercept point of x- and y-axis.
                Default: same as start_y

 GenParamValues: Values of the generic parameters of GenericParamNames.</abstract>
<alternatives>
<item>plot_tuple</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y := sin(X)
create_funct_1d_pairs (X, Y, Function)
invert_funct_1d (Function, InverseFunction)
GenParamNames := []
GenParamValues := []
plot_funct_1d (WindowHandle, InverseFunction, 'x', 'sin^-1(x)', 'red', GenParamNames, GenParamValues)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_funct_1d_pairs</item>
<item>create_funct_1d_array</item>
<item>compose_funct_1d</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="Function">
<description lang="en_US">Function to be plotted</description>
<mixed_type>false</mixed_type>
<sem_type>function_1d</sem_type>
</parameter>
<parameter id="GenParamNames">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
</values>
</parameter>
<parameter id="GenParamValues">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x axis.</description>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y axis.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_tuple">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="XValues" base_type="ctrl" dimension="0"/>
<par name="YValues" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots tuples representing functions</c>
<c>* or curves in a coordinate system.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* </c>
<c>* XValues: X values of the function to be plotted</c>
<c>*          If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.</c>
<c>*          If XValues is a tuple of strings, the values are taken as categories.</c>
<c>* </c>
<c>* YValues: Y values of the function(s) to be plotted</c>
<c>*          If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.</c>
<c>*          The number of y values must be equal to the number of x values</c>
<c>*          or an integral multiple. In the latter case,</c>
<c>*          multiple functions are plotted, that share the same x values.</c>
<c>* </c>
<c>* XLabel: X axis label</c>
<c>* </c>
<c>* XLabel: Y axis label</c>
<c>* </c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>*        If more than one color is given, multiple functions</c>
<c>*        can be displayed in different colors.</c>
<c>* </c>
<c>* GenParamNames: Generic parameters to control the presentation</c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possibile values: 'yes', 'no' (default)</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the x axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the x axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'origin_x': X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: same as start_x</c>
<c>*    'origin_y': Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: same as start_y</c>
<c>* </c>
<c>* GenParamValues: Values of the generic parameters of GenericParamNames</c>
<c>* </c>
<c>* </c>
<c>* Store current display settings</c>
<l>dev_get_window (PreviousWindowHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_part (WindowHandle, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>get_line_style (WindowHandle, OriginStyle)</l>
<c>* </c>
<c>* Set display parameters</c>
<l>set_line_style (WindowHandle, [])</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<c>* </c>
<c>* Check input coordinates</c>
<c>* </c>
<l>if (XValues == [] and YValues == [])</l>
<c>    * Neither XValues nor YValues are given:</c>
<c>    * Set axes to interval [0,1]</c>
<l>    XAxisEndValue := 1</l>
<l>    YAxisEndValue := 1</l>
<l>    XAxisStartValue := 0</l>
<l>    YAxisStartValue := 0</l>
<l>    XValuesAreStrings := false</l>
<l>else</l>
<l>    if (XValues == [])</l>
<c>        * XValues are omitted:</c>
<c>        * Set equidistant XValues</c>
<l>        XValues := [0:|YValues| - 1]</l>
<l>        XValuesAreStrings := false</l>
<l>    elseif (YValues == [])</l>
<c>        * YValues are omitted:</c>
<c>        * Set equidistant YValues</c>
<l>        YValues := [0:|XValues| - 1]</l>
<l>    endif</l>
<l>    if (|YValues| % |XValues| != 0)</l>
<c>        * Number of YValues does not match number of XValues</c>
<l>        throw ('Number of YValues is no multiple of the number of XValues!')</l>
<l>        return ()</l>
<l>    endif</l>
<l>    XValuesAreStrings := is_string_elem(XValues)</l>
<l>    XValuesAreStrings := sum(XValuesAreStrings) == |XValuesAreStrings|</l>
<l>    if (XValuesAreStrings)</l>
<c>        * XValues are given as strings:</c>
<c>        * Show XValues as ticks</c>
<l>        XTickValues := XValues</l>
<l>        XTicks := 1</l>
<c>        * Set x-axis dimensions</c>
<l>        XValues := [1:|XValues|]</l>
<l>    endif</l>
<c>    * Set default x-axis dimensions</c>
<l>    if (|XValues| &gt; 1)</l>
<l>        XAxisStartValue := min(XValues)</l>
<l>        XAxisEndValue := max(XValues)</l>
<l>    else</l>
<l>        XAxisEndValue := XValues[0] + 0.5</l>
<l>        XAxisStartValue := XValues[0] - 0.5</l>
<l>    endif</l>
<l>endif</l>
<c>* Set default y-axis dimensions</c>
<l>if (|YValues| &gt; 1)</l>
<l>    YAxisStartValue := min(YValues)</l>
<l>    YAxisEndValue := max(YValues)</l>
<l>elseif (|YValues| == 1)</l>
<l>    YAxisStartValue := YValues[0] - 0.5</l>
<l>    YAxisEndValue := YValues[0] + 0.5</l>
<l>else</l>
<l>    YAxisStartValue := 0</l>
<l>    YAxisEndValue := 1</l>
<l>endif</l>
<c>* Set default interception point of x- and y- axis</c>
<l>OriginX := XAxisStartValue</l>
<l>OriginY := YAxisStartValue</l>
<c>* </c>
<c>* Set more defaults</c>
<l>LeftBorder := Width * 0.1</l>
<l>RightBorder := Width * 0.1</l>
<l>UpperBorder := Height * 0.1</l>
<l>LowerBorder := Height * 0.1</l>
<l>AxesColor := 'white'</l>
<l>Style := 'line'</l>
<l>Clip := 'no'</l>
<l>XTicks := 'min_max_origin'</l>
<l>YTicks := 'min_max_origin'</l>
<l>XGrid := 'none'</l>
<l>YGrid := 'none'</l>
<l>GridColor := 'dim gray'</l>
<c>* </c>
<c>* Parse generic parameters</c>
<c>* </c>
<l>NumGenParamNames := |GenParamNames|</l>
<l>NumGenParamValues := |GenParamValues|</l>
<l>if (NumGenParamNames != NumGenParamValues)</l>
<l>    throw ('Number of generic parameter names does not match generic parameter values!')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>SetOriginXToDefault := true</l>
<l>SetOriginYToDefault := true</l>
<l>for GenParamIndex := 0 to |GenParamNames| - 1 by 1</l>
<c>    * </c>
<c>    * Set 'axes_color'</c>
<l>    if (GenParamNames[GenParamIndex] == 'axes_color')</l>
<l>        AxesColor := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'style'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'style')</l>
<l>        Style := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'clip'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'clip')</l>
<l>        Clip := GenParamValues[GenParamIndex]</l>
<l>        if (Clip != 'yes' and Clip != 'no')</l>
<l>            throw ('Unsupported clipping option: \'' + Clip + '\'')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set 'ticks'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'ticks')</l>
<l>        XTicks := GenParamValues[GenParamIndex]</l>
<l>        YTicks := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'ticks_x')</l>
<l>        XTicks := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'ticks_y')</l>
<l>        YTicks := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid')</l>
<l>        XGrid := GenParamValues[GenParamIndex]</l>
<l>        YGrid := GenParamValues[GenParamIndex]</l>
<l>        XGridTicks := XTicks</l>
<c>        * </c>
<c>        * Set 'grid_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid_x')</l>
<l>        XGrid := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid_y')</l>
<l>        YGrid := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_color'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid_color')</l>
<l>        GridColor := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'start_x')</l>
<l>        XAxisStartValue := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'end_x')</l>
<l>        XAxisEndValue := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'start_y')</l>
<l>        YAxisStartValue := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'end_y')</l>
<l>        YAxisEndValue := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'origin_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'origin_x')</l>
<l>        OriginX := GenParamValues[GenParamIndex]</l>
<l>        SetOriginXToDefault := false</l>
<c>        * </c>
<c>        * Set 'origin_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'origin_y')</l>
<l>        OriginY := GenParamValues[GenParamIndex]</l>
<l>        SetOriginYToDefault := false</l>
<c>        * </c>
<c>        * Set 'margin'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin')</l>
<l>        LeftBorder := GenParamValues[GenParamIndex]</l>
<l>        RightBorder := GenParamValues[GenParamIndex]</l>
<l>        UpperBorder := GenParamValues[GenParamIndex]</l>
<l>        LowerBorder := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_left'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_left')</l>
<l>        LeftBorder := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_right'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_right')</l>
<l>        RightBorder := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_top'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_top')</l>
<l>        UpperBorder := GenParamValues[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_bottom'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_bottom')</l>
<l>        LowerBorder := GenParamValues[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamNames[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* </c>
<c>* Check consistency of start and end values</c>
<c>* of the axes.</c>
<l>if (XAxisStartValue &gt; XAxisEndValue)</l>
<l>    throw ('Value for \'start_x\' is greater than value for \'end_x\'')</l>
<l>endif</l>
<l>if (YAxisStartValue &gt; YAxisEndValue)</l>
<l>    throw ('Value for \'start_y\' is greater than value for \'end_y\'')</l>
<l>endif</l>
<c>* </c>
<c>* Set default origin to lower left corner</c>
<l>if (SetOriginXToDefault)</l>
<l>    OriginX := XAxisStartValue</l>
<l>endif</l>
<l>if (SetOriginYToDefault)</l>
<l>    OriginY := YAxisStartValue</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Calculate basic pixel coordinates and scale factors</c>
<c>* </c>
<l>XAxisWidthPx := Width - LeftBorder - RightBorder</l>
<l>XAxisWidth := XAxisEndValue - XAxisStartValue</l>
<l>if (XAxisWidth == 0)</l>
<l>    XAxisStartValue := XAxisStartValue - 0.5</l>
<l>    XAxisEndValue := XAxisEndValue + 0.5</l>
<l>    XAxisWidth := 1</l>
<l>endif</l>
<l>XScaleFactor := XAxisWidthPx / real(XAxisWidth)</l>
<l>YAxisHeightPx := Height - LowerBorder - UpperBorder</l>
<l>YAxisHeight := YAxisEndValue - YAxisStartValue</l>
<l>if (YAxisHeight == 0)</l>
<l>    YAxisStartValue := YAxisStartValue - 0.5</l>
<l>    YAxisEndValue := YAxisEndValue + 0.5</l>
<l>    YAxisHeight := 1</l>
<l>endif</l>
<l>YScaleFactor := YAxisHeightPx / real(YAxisHeight)</l>
<l>YAxisOffsetPx := (OriginX - XAxisStartValue) * XScaleFactor</l>
<l>XAxisOffsetPx := (OriginY - YAxisStartValue) * YScaleFactor</l>
<c>* </c>
<c>* Display grid lines</c>
<c>* </c>
<l>if (GridColor != 'none')</l>
<l>    DotStyle := [5,7]</l>
<l>    set_line_style (WindowHandle, DotStyle)</l>
<l>    dev_set_color (GridColor)</l>
<c>    * </c>
<c>    * Display x grid lines</c>
<l>    if (XGrid != 'none')</l>
<l>        if (XGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (OriginX == XAxisStartValue)</l>
<l>                XGridValues := [XAxisStartValue,XAxisEndValue]</l>
<l>            else</l>
<l>                XGridValues := [XAxisStartValue,OriginX,XAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            XGridStart := ceil(XAxisStartValue / XGrid) * XGrid</l>
<l>            XGridValues := [XGridStart:XGrid:XAxisEndValue]</l>
<l>        endif</l>
<l>        XPosition := (XGridValues - XAxisStartValue) * XScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |XGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXGrid, [Height - LowerBorder,UpperBorder], [LeftBorder + XPosition[IndexGrid],LeftBorder + XPosition[IndexGrid]])</l>
<l>            dev_display (ContourXGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display y grid lines</c>
<l>    if (YGrid != 'none')</l>
<l>        if (YGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (OriginY == YAxisStartValue)</l>
<l>                YGridValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YGridValues := [YAxisStartValue,OriginY,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            YGridStart := ceil(YAxisStartValue / YGrid) * YGrid</l>
<l>            YGridValues := [YGridStart:YGrid:YAxisEndValue]</l>
<l>        endif</l>
<l>        YPosition := (YGridValues - YAxisStartValue) * YScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |YGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYGrid, [Height - LowerBorder - YPosition[IndexGrid],Height - LowerBorder - YPosition[IndexGrid]], [LeftBorder,Width - RightBorder])</l>
<l>            dev_display (ContourYGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<l>set_line_style (WindowHandle, [])</l>
<c>* </c>
<c>* </c>
<c>* Display the coordinate sytem axes</c>
<l>if (AxesColor != 'none')</l>
<c>    * Display axes</c>
<l>    dev_set_color (AxesColor)</l>
<l>    gen_arrow_contour_xld (XArrow, Height - LowerBorder - XAxisOffsetPx, LeftBorder, Height - LowerBorder - XAxisOffsetPx, Width - RightBorder, 0, 0)</l>
<l>    dev_display (XArrow)</l>
<l>    gen_arrow_contour_xld (YArrow, Height - LowerBorder, LeftBorder + YAxisOffsetPx, UpperBorder, LeftBorder + YAxisOffsetPx, 0, 0)</l>
<l>    dev_display (YArrow)</l>
<c>    * Display labels</c>
<l>    get_string_extents (WindowHandle, XLabel, Ascent, Descent, TextWidthXLabel, TextHeightXLabel)</l>
<l>    dev_disp_text (XLabel, 'image', Height - LowerBorder - TextHeightXLabel - XAxisOffsetPx, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>    dev_disp_text (' ' + YLabel, 'image', UpperBorder, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>endif</l>
<c>* </c>
<c>* Display ticks</c>
<c>* </c>
<l>if (AxesColor != 'none')</l>
<l>    dev_set_color (AxesColor)</l>
<l>    if (XTicks != 'none')</l>
<c>        * </c>
<c>        * Display x ticks</c>
<l>        if (XValuesAreStrings)</l>
<c>            * Display string XValues as categories</c>
<l>            XTicks := |XValues| / |XTickValues|</l>
<l>            XPosition := (XValues - XAxisStartValue) * XScaleFactor</l>
<l>        else</l>
<c>            * Display tick values</c>
<l>            if (XTicks == 'min_max_origin')</l>
<c>                * Calculate 'min_max_origin' tick coordinates</c>
<l>                if (OriginX == XAxisStartValue)</l>
<l>                    XTickValues := [XAxisStartValue,XAxisEndValue]</l>
<l>                else</l>
<l>                    XTickValues := [XAxisStartValue,OriginX,XAxisEndValue]</l>
<l>                endif</l>
<l>            else</l>
<c>                * Calculate equidistant tick coordinates</c>
<l>                XTickStart := ceil(XAxisStartValue / XTicks) * XTicks</l>
<l>                XTickValues := [XTickStart:XTicks:XAxisEndValue]</l>
<l>            endif</l>
<l>            XPosition := (XTickValues - XAxisStartValue) * XScaleFactor</l>
<l>            TypeTicks := type(XTicks)</l>
<l>            if (TypeTicks == H_TYPE_STRING)</l>
<c>                * String ('min_max_origin')</c>
<c>                * Format depends on actual values</c>
<l>                TypeTicks := type(XTickValues)</l>
<l>            endif</l>
<l>            if (TypeTicks == H_TYPE_INT)</l>
<c>                * Round to integer</c>
<l>                XTickValues := int(XTickValues)</l>
<l>            else</l>
<c>                * Use floating point numbers</c>
<l>                XTickValues := XTickValues$'.2f'</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |XTickValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx,Height - LowerBorder - XAxisOffsetPx - 5], [LeftBorder + XPosition[IndexTicks],LeftBorder + XPosition[IndexTicks]])</l>
<l>            dev_display (ContourXTick)</l>
<l>            dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder + 2 - XAxisOffsetPx, LeftBorder + XPosition[IndexTicks], AxesColor, 'box', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>    if (YTicks != 'none')</l>
<c>        * </c>
<c>        * Display y ticks</c>
<l>        if (YTicks == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' tick coordinates</c>
<l>            if (OriginY == YAxisStartValue)</l>
<l>                YTickValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YTickValues := [YAxisStartValue,OriginY,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant tick coordinates</c>
<l>            YTickStart := ceil(YAxisStartValue / YTicks) * YTicks</l>
<l>            YTickValues := [YTickStart:YTicks:YAxisEndValue]</l>
<l>        endif</l>
<l>        YPosition := (YTickValues - YAxisStartValue) * YScaleFactor</l>
<l>        TypeTicks := type(YTicks)</l>
<l>        if (TypeTicks == H_TYPE_STRING)</l>
<c>            * String ('min_max_origin')</c>
<c>            * Format depends on actual values</c>
<l>            TypeTicks := type(YTickValues)</l>
<l>        endif</l>
<l>        if (TypeTicks == H_TYPE_INT)</l>
<c>            * Round to integer</c>
<l>            YTickValues := int(YTickValues)</l>
<l>        else</l>
<c>            * Use floating point numbers</c>
<l>            YTickValues := YTickValues$'.2f'</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |YTickValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YPosition[IndexTicks],Height - LowerBorder - YPosition[IndexTicks]], [LeftBorder + YAxisOffsetPx,LeftBorder + YAxisOffsetPx + 5])</l>
<l>            dev_display (ContourYTick)</l>
<l>            get_string_extents (WindowHandle, YTickValues[IndexTicks], Ascent1, Descent1, TextWidthYTicks, TextHeightYTicks)</l>
<l>            dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YPosition[IndexTicks], LeftBorder - TextWidthYTicks - 2 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display function plot</c>
<c>* </c>
<l>if (Color != 'none')</l>
<l>    if (XValues != [] and YValues != [])</l>
<l>        Num := |YValues| / |XValues|</l>
<c>        * </c>
<c>        * Iterate over all functions to be displayed</c>
<l>        for I := 0 to Num - 1 by 1</l>
<c>            * Select y values for current function</c>
<l>            YSelected := YValues[I * |XValues|:(I + 1) * |XValues| - 1]</l>
<c>            * Set color</c>
<l>            if (Color == [])</l>
<l>                set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>            else</l>
<l>                dev_set_color (Color[I % |Color|])</l>
<l>            endif</l>
<c>            * </c>
<c>            * Display in different styles</c>
<c>            * </c>
<l>            if (Style == 'line' or Style == [])</l>
<c>                * Line</c>
<l>                gen_contour_polygon_xld (Contour, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Contour, Contour, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Contour)</l>
<l>            elseif (Style == 'cross')</l>
<c>                * Cross</c>
<l>                gen_cross_contour_xld (Cross, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor, 6, 0.785398)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Cross, Cross, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Cross)</l>
<l>            elseif (Style == 'filled')</l>
<c>                * Filled</c>
<l>                Y1Selected := [0 + OriginY,YSelected,0 + OriginY]</l>
<l>                X1Selected := [min(XValues),XValues,max(XValues)]</l>
<l>                dev_set_draw ('fill')</l>
<l>                gen_region_polygon_filled (Filled, Height - LowerBorder - Y1Selected * YScaleFactor + YAxisStartValue * YScaleFactor, X1Selected * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Filled, Filled, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Filled)</l>
<l>            else</l>
<l>                throw ('Unsupported style: ' + Style)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Reset original display settings</c>
<l>dev_set_part (PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>dev_set_window (PreviousWindowHandle)</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_draw (DrawMode)</l>
<l>set_line_style (WindowHandle, OriginStyle)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<l>return ()</l>
</body>
<docu id="plot_tuple">
<abstract lang="en_US">This procedure plots the functions or curves represented by the coordinates in XValues and YValues into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and Ylabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamNames and GenericParamValues.

In particular, following parameters can be set:

XValues: X values of the function to be plotted.

          If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.
          If XValues is a tuple of strings, the values are taken as categories.

 YValues: Y values of the function(s) to be plotted.

          If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.
          The number of y values must be equal to the number of x values
          or an integral multiple. In the latter case,
          multiple functions are plotted, that share the same x values.

 XLabel: X axis label.

 XLabel: Y axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.
        If more than one color is given, multiple functions 
        can be displayed in different colors.

 GenParamNames: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'filled'

    'clip': Clip graph to coordinate system area.
            Possibile values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x axis.
               Default: min(XValues)

    'end_x': Highest x value of the x axis.
             Default: max(XValues)

    'start_y': Lowest y value of the x axis.
               Default: min(YValues)

    'end_y': Highest y value of the x axis.
             Default: max(YValues)

    'origin_x': X coordinate of the intercept point of x- and y-axis.
                Default: same as start_x

    'origin_y': Y coordinate of the intercept point of x- and y-axis.
                Default: same as start_y

 GenParamValues: Values of the generic parameters of GenericParamNames.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y1 := sin(X)
Y2 := (X * X) * 0.2 - 1
XLabel := 'x'
YLabel := 'y'
Color := ['medium slate blue', 'yellow']
GenParamNames := []
GenParamValues := []
plot_tuple (WindowHandle, X, [Y1, Y2], XLabel, YLabel, Color, GenParamNames, GenParamValues)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>tuple</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>funct_1d_to_pairs</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="GenParamNames">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
</values>
</parameter>
<parameter id="GenParamValues">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x axis.</description>
</parameter>
<parameter id="XValues">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">X values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.x</sem_type>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y axis.</description>
</parameter>
<parameter id="YValues">
<default_type>real</default_type>
<description lang="en_US">Y values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.y</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_poses_and_rectification_data_moving_cam">
<interface>
<ic>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="RectifyImage" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Prepare the needed poses to match and grasp, and compute the rectification map.</c>
<c>* </c>
<c>* RectifyImage Parameter can have one of the following 3 values:</c>
<c>* 'no_rectification', 'align_and_rectify', or 'only_rectify'</c>
<c>* </c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInBasePose0', PlaneInBasePose0)</l>
<c>* </c>
<c>* Check input</c>
<l>if (ObjectHeight &lt; 0.0)</l>
<l>    throw ('The parameter ObjectHeight cannot be negative')</l>
<l>endif</l>
<l>if (CamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose0, 'Rp+T', 'gba', 'point', PlaneInBasePose0)</l>
<c>* </c>
<c>* Create the plane for matching and adapt the PlaneInBasePose0 such</c>
<c>* that the z-axis of the plane points away from the reference camera,</c>
<c>* and x/y coordinates are aligned with the current image, i.e.</c>
<c>* PlaneInCamPose0 has Rot_z=0.</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>pose_compose (BaseInCamPose, PlaneInBasePose0, PlaneInCamPose0)</l>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>PlaneInCamPose0Rot := PlaneInCamPose0</l>
<l>PlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (PlaneInCamPose0, SwitchZDirection, PlaneInCamPose1)</l>
<l>    PlaneInCamPose0 := PlaneInCamPose1</l>
<l>endif</l>
<c>* Align with the current image.</c>
<l>PlaneInCamPose := PlaneInCamPose0</l>
<l>PlaneInCamPose[5] := 0.0</l>
<c>* Adapt the PlaneInBasePose.</c>
<l>pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>pose_compose (CamInBasePose, PlaneInCamPose, PlaneInBasePose)</l>
<c>* </c>
<c>* Create the plane for matching.</c>
<l>create_pose (0, 0, -ObjectHeight, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneInPlanePose)</l>
<l>pose_compose (PlaneInBasePose, MatchingPlaneInPlanePose, MatchingPlaneInBasePose)</l>
<l>pose_compose (PlaneInCamPose, MatchingPlaneInPlanePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage == 'no_rectification')</l>
<l>    MatchingPlaneRectifiedPartInCamPose := MatchingPlaneInCamPose</l>
<l>    ScaleRectification := []</l>
<l>elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<c>    * Determine the scale such that the mapped image has at least</c>
<c>    * the same resolution as the current image.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    gen_grid_region (RegionGrid, 20, 20, 'points', Width, Height)</l>
<l>    get_region_points (RegionGrid, Rows, Columns)</l>
<l>    gen_circle_contour_xld (ContCircle, Rows, Columns, gen_tuple_const(|Rows|,1.0), 0, 6.28318, 'positive', 0.1)</l>
<l>    contour_to_world_plane_xld (ContCircle, ContCircleWorldPlane, CamParam, MatchingPlaneInCamPose, 'm')</l>
<l>    fit_ellipse_contour_xld (ContCircleWorldPlane, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row, Column, Phi, Radius1, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    ScaleRectification := min(Radius2)</l>
<c>    * </c>
<c>    * Rectify the current image and create the shape model.</c>
<c>    * </c>
<c>    * The image dimensions should cover the entire original field</c>
<c>    * of view in the current rectification.</c>
<c>    * Look at border of the current image in the world plane.</c>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInMatchingPlanePose)</l>
<l>    pose_compose (MatchingPlaneInCamPose, MatchingPlaneRectifiedPartInMatchingPlanePose, MatchingPlaneRectifiedPartInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<c>    * Create a map for repeated use.</c>
<l>    gen_image_to_world_plane_map (RectificationMap, CamParam, MatchingPlaneInCamPose, Width, Height, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInCamPose)</l>
<l>convert_pose_type (CamInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, CamInBasePose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInBasePose)</l>
<l>convert_pose_type (MatchingPlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInBasePose)</l>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneRectifiedPartInCamPose)</l>
<c>* </c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', ModelInPlanePose)</l>
<c>* Remember the transformation.</c>
<l>pose_invert (ModelInPlanePose, PlaneInModelPose)</l>
<c>* </c>
<c>* Create message for Poses.</c>
<l>create_message (Poses)</l>
<l>set_message_tuple (Poses, 'PlaneInCamPose', PlaneInCamPose)</l>
<l>set_message_tuple (Poses, 'CamInBasePose', CamInBasePose)</l>
<l>set_message_tuple (Poses, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>set_message_tuple (Poses, 'MatchingPlaneInBasePose', MatchingPlaneInBasePose)</l>
<l>set_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<c>* </c>
<c>* Create message for rectification data.</c>
<l>create_message (RectificationData)</l>
<l>set_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage != 'no_rectification')</l>
<l>    set_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>    set_message_obj (RectificationMap, RectificationData, 'RectificationMap')</l>
<l>endif</l>
<l>set_message_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<l>return ()</l>
</body>
<docu id="prepare_poses_and_rectification_data_moving_cam">
<abstract lang="en_US">This procedure prepares the model needed to later match an object and grasp it in 3D, in a moving camera setup.

The input parameter ToolInBasePose describes the current pose of the robot tool. 

The input message HandEyeCalibData must contain the poses ToolInCamPose and PlaneInBasePose0 as well as the camera parameters CamParam. Please refer to the example calibrate_hand_eye_scara_moving_cam.hdev for more details.

In ObjectHeight, the height of the object to be matched is passed.
 
The parameter RectifyImage can have on of three values: 'no_rectification', 'only_rectify', or 'align_and_rectify'. This parameter is then stored in the output message RectificationData.

The output message Poses contains the following data: 
- The pose PlaneInCamPose is the pose where x and y coordinates are aligned with the current image and the z-axis of the plane points away from the reference camera. 
- The pose PlaneInBasePose is the respective adaptation of PlaneInBasePose0.
- The pose PlaneInModelPose contains the pose of the plane with respect to the model.
- The pose CamInBasePose contains the pose of the camera in the base coordinate system.
- The matching plane is defined as the actual plane translated in the negative z-direction (towards the camera) by the object's height as given by ObjectHeight.The poses MatchingPlaneInCamPose and MatchingPlaneInBasePose are calculated accordingly.

The output message RectificationData contains the following data:
- The above-mentioned parameter RectifyImage.
- The parameters ScaleRectification is the rectification scale as explained in the documentation of the image_to_world_plane operator. 
- The pose MatchingPlaneRectifiedPartInCamPose is the world pose in the camera coordinate system which is used to align the image as explained in image_to_world_plane operator.
- The RectificationMap that can be used with map_image.</abstract>
<alternatives>
<item>prepare_poses_and_rectification_data_stationary_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_message_tuple</item>
</predecessor>
<short lang="en_US">Prepares the model to match and grasp.</short>
<successor>
<item>get_message_tuple</item>
<item>get_message_obj</item>
<item>map_image</item>
<item>create_shape_model</item>
<item>rectify_image_and_compute_matching_plane_moving_cam</item>
<item>obtain_3d_pose_of_match_moving_cam</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: ToolInCamPose, PlaneInBasePose0, and CamParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the object to be matched.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that contains the poses PlaneInCamPose, PlaneInBasePose, PlaneInModelPose, CamInBasePose, MatchingPlaneInCamPose, and MatchingPlaneInBasePose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that contains RectifyImage, ScaleRectification, MatchingPlaneRectifiedPartInCamPose, and RectificationMap.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectifyImage">
<default_type>string</default_type>
<default_value>'only_rectify'</default_value>
<description lang="en_US">Only when the camera is perpendicular to your image plane with constant distance (might reduce runtime): 'no_rectification'
Align the images according to the matching training image and rectify: 'align_and_rectify'
Only rectify: 'only_rectify'</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'no_rectification'</item>
<item>'align_and_rectify'</item>
<item>'only_rectify'</item>
</values>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_poses_and_rectification_data_stationary_cam">
<interface>
<ic>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="RectifyImage" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Prepare the needed poses to match and grasp, and compute the rectification</c>
<c>* map in case rectification is set by the user.</c>
<c>* </c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose0)</l>
<c>* </c>
<c>* Check input</c>
<l>if (ObjectHeight &lt; 0.0)</l>
<l>    throw ('The parameter ObjectHeight cannot be negative')</l>
<l>endif</l>
<l>if (CamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (PlaneInCamPose0, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (PlaneInCamPose0, 'Rp+T', 'gba', 'point', PlaneInCamPose0)</l>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>PlaneInCamPose0Rot := PlaneInCamPose0</l>
<l>PlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (PlaneInCamPose0, SwitchZDirection, PlaneInCamPose0)</l>
<l>endif</l>
<c>* Align with the current image.</c>
<l>PlaneInCamPose := PlaneInCamPose0</l>
<l>PlaneInCamPose[5] := 0.0</l>
<c>* </c>
<c>* Create the plane for matching.</c>
<l>create_pose (0, 0, -ObjectHeight, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, MatchingPlaneInPlanePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage == 'false')</l>
<l>    ScaleRectification := []</l>
<l>elseif (RectifyImage == 'true')</l>
<c>    * Determine the scale such that the mapped image has at least the same</c>
<c>    * resolution as the current image.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    gen_grid_region (RegionGrid, 20, 20, 'points', Width, Height)</l>
<l>    get_region_points (RegionGrid, Rows, Columns)</l>
<l>    gen_circle_contour_xld (ContCircle, Rows, Columns, gen_tuple_const(|Rows|,1.0), 0, 6.28318, 'positive', 0.1)</l>
<l>    contour_to_world_plane_xld (ContCircle, ContCircleWorldPlane, CamParam, MatchingPlaneInCamPose, 'm')</l>
<l>    fit_ellipse_contour_xld (ContCircleWorldPlane, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row, Column, Phi, Radius1, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    ScaleRectification := min(Radius2)</l>
<c>    * </c>
<c>    * Rectify the current image and create the shape model.</c>
<c>    * </c>
<c>    * The image dimensions should cover the entire original field of view</c>
<c>    * in the current rectification.</c>
<c>    * Look at border of the current image in the world plane.</c>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', PoseOffset)</l>
<l>    pose_compose (MatchingPlaneInCamPose, PoseOffset, MatchingPlaneInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<c>    * Create a map for repeated use.</c>
<l>    gen_image_to_world_plane_map (RectificationMap, CamParam, MatchingPlaneInCamPose, Width, Height, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', ModelInPlanePose)</l>
<c>* Remember the transformation.</c>
<l>pose_invert (ModelInPlanePose, PlaneInModelPose)</l>
<c>* </c>
<c>* Create message for Poses.</c>
<l>create_message (Poses)</l>
<l>set_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>set_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>set_message_tuple (Poses, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* </c>
<c>* Create message for rectification data.</c>
<l>create_message (RectificationData)</l>
<l>set_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true')</l>
<l>    set_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>    set_message_obj (RectificationMap, RectificationData, 'RectificationMap')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="prepare_poses_and_rectification_data_stationary_cam">
<abstract lang="en_US">The procedure prepare_poses_and_rectification_data_stationary_cam prepares the model needed to later match an object and grasp it in 3D, in a stationary camera setup. 

In ObjectHeight, the height of the object to be matched is passed.

The parameter RectifyImage specifies whether the input image is to be rectified of not. To improve the 2D matching, it is recommended to set it 'true'. This parameter is then stored in the output message RectificationData.

The input message HandEyeCalibrationData contains the pose PlaneInCamPose0 and the camera parameters CamParam, which can be both found through hand-eye calibration in a moving camera setup. Please refer to the example calibrate_hand_eye_stationary_cam_approx.hdev for more details.

The output message Poses contains the following data: 
- The output pose PlaneInCamPose is the pose where x and y coordinates are aligned with the current image and the z-axis of the plane points away from the reference camera.
- The pose PlaneInModelPose contains the pose of the plane with respect to the model.
- The matching plane is defined as the actual plane translated in the negative z-direction (towards the camera) by the object's height as given by ObjectHeight.The pose MatchingPlaneInCamPose is calculated accordingly.

The output message RectificationData contains the following data:
- The above-mentioned parameter RectifyImage.
- The parameters ScaleRectification is the rectification scale as explained in the documentation of the image_to_world_plane operator. 
- The rectification map that can be used with map_image.</abstract>
<alternatives>
<item>prepare_poses_and_rectification_data_moving_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_message_tuple</item>
</predecessor>
<short lang="en_US">Prepares the model to match and grasp in a stationary camera setup.</short>
<successor>
<item>get_message_tuple</item>
<item>get_message_obj</item>
<item>map_image</item>
<item>create_shape_model</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain CamParam and PlaneInCamPose0.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the object to be matched.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that contains: PlaneInModelPose, MatchingPlaneInCamPose, and PlaneInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that contains: RectifyImage, ScaleRectification, and RectificationMap.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectifyImage">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">Specify whether to rectify the image or not. Set it to 'false' only if the camera is orthogonal to your image plane with constant distance. This might reduce runtime.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="project_point_on_trackball">
<interface>
<ic>
<par name="X" base_type="ctrl" dimension="0"/>
<par name="Y" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="V" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if (VirtualTrackball == 'shoemake')</l>
<c>    * Virtual Trackball according to Shoemake</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X * TrackballSize / R</l>
<l>        YP := Y * TrackballSize / R</l>
<l>        ZP := 0</l>
<l>    endif</l>
<l>else</l>
<c>    * Virtual Trackball according to Bell</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize * 0.70710678)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := 0.6 * TrackballSize * TrackballSize / R</l>
<l>    endif</l>
<l>endif</l>
<l>V := [XP,YP,ZP]</l>
<l>return ()</l>
</body>
<docu id="project_point_on_trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Project an image point onto the trackball</short>
<parameters>
<parameter id="TrackballSize"/>
<parameter id="V"/>
<parameter id="VirtualTrackball"/>
<parameter id="X"/>
<parameter id="Y"/>
</parameters>
</docu>
</procedure>
<procedure name="query_feature_group_names">
<interface>
<oc>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return all available feature groups</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, '', 'get_groups', GroupNames)</l>
<l>GroupNames := uniq(sort(GroupNames))</l>
<l>GroupNames := [GroupNames,'all']</l>
<l>return ()</l>
</body>
<docu id="query_feature_group_names">
<abstract lang="en_US">List all available feature group names.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<alternatives>
<item>query_feature_names_by_group</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calculate_features</item>
<item>get_custom_features</item>
</see_also>
<short lang="en_US">List all available feature group names.</short>
<successor>
<item>get_feature_names</item>
</successor>
<parameters>
<parameter id="GroupNames">
<default_type>string</default_type>
<description lang="en_US">All available feature group names.</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="query_feature_names_by_group">
<interface>
<ic>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return a table (consisting of two tuples)</c>
<c>* of all features and the groups they belong to.</c>
<c>* </c>
<l>FeatureNames := []</l>
<l>Groups := []</l>
<l>gen_dummy_objects (Region, Image)</l>
<l>for I := 0 to |GroupNames| - 1 by 1</l>
<l>    get_features (Region, Image, GroupNames[I], 'get_names', Names)</l>
<l>    FeatureNames := [FeatureNames,Names]</l>
<l>    Groups := [Groups,gen_tuple_const(|Names|,GroupNames[I])]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="query_feature_names_by_group">
<abstract lang="en_US">query_feature_names_by_group returns the tuple FeatureNames, which contains a list of feature names that belong to the feature groups given in GroupNames, and the tuple Groups which contains the respective group names.
I.e., for any given index I, the feature FeatureNames[I] belongs to the group Groups[I].

Note, that groups normally consist of multiple features, and features may belong to multiple groups. Therfore feature names and group names will occur multiple times.
The feature names are sorted by groups, i.e., the resulting tuples may look like this, where 'name1' and 'name3' belong to the groups 1 and 2, and 'name2' only belongs to "GROUP1'.

FeatureNames == ['name1','name2','name3','name1','name3']
Groups == ['GROUP1','GROUP1','GROUP1','GROUP2','GROUP2']

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

</abstract>
<alternatives>
<item>query_feature_group_names</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>calssification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>get_feature_names</item>
<item>calculate_features</item>
<item>get_custom_features</item>
</see_also>
<short lang="en_US">Returns a table of feature names sorted by groups.</short>
<successor>
<item>get_feature_names</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GroupNames">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Group names corresponding to the features in FeatureNames.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_message_obj">
<interface>
<oo>
<par name="ObjectData" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MessageHandle" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>    get_message_obj (ObjectData, MessageHandle, Key)</l>
<l>catch (Exception)</l>
<l>    throw ('The key ' + Key + ' is missing from the message ' + MessageHandle)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="read_message_obj">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Key"/>
<parameter id="MessageHandle"/>
<parameter id="ObjectData"/>
</parameters>
</docu>
</procedure>
<procedure name="read_message_tuple">
<interface>
<ic>
<par name="MessageHandle" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TupleData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>    get_message_tuple (MessageHandle, Key, TupleData)</l>
<l>catch (Exception)</l>
<l>    throw ('The key ' + Key + ' is missing from the message ' + MessageHandle)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="read_message_tuple">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Key">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="MessageHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TupleData">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="rectify_image_and_compute_matching_plane_moving_cam">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageRectified" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure finds the pose of the matching part on the plane</c>
<c>* in the camera coordinate system. Rectification is applied if it</c>
<c>* is set by the user.</c>
<c>* </c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<l>read_message_tuple (Poses, 'MatchingPlaneInBasePose', MatchingPlaneInBasePose)</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInBasePose, 'Rp+T', 'gba', 'point', MatchingPlaneInBasePose)</l>
<c>* </c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>pose_compose (BaseInCamPose, MatchingPlaneInBasePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage == 'no_rectification')</l>
<l>    MatchingPlaneRectifiedPartInCamPose := MatchingPlaneInCamPose</l>
<l>    copy_obj (Image, ImageRectified, 1, 1)</l>
<l>elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    if (RectifyImage == 'only_rectify')</l>
<l>        MatchingPlaneInCamPose[5] := 0.0</l>
<l>    endif</l>
<c>    * The image dimensions should cover the entire original</c>
<c>    * field of view in the current rectification. Look at the</c>
<c>    * border of the current image in the world plane.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInMatchingPlanePose)</l>
<l>    pose_compose (MatchingPlaneInCamPose, MatchingPlaneRectifiedPartInMatchingPlanePose, MatchingPlaneRectifiedPartInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<l>    image_to_world_plane (Image, ImageRectified, CamParam, MatchingPlaneRectifiedPartInCamPose, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneRectifiedPartInCamPose)</l>
<l>set_message_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<l>return ()</l>
</body>
<docu id="rectify_image_and_compute_matching_plane_moving_cam">
<abstract lang="en_US">This procedure prepares the input image in the online phase of robot picking by applying rectification if set by the user. Moreover, the pose of the matching part of the plane in the camera coordinate system is computed.

The input parameter Image is the current image containing potentially the object to be picked. Additionally, the pose ToolInBasePose specifies the current pose of the robot. 

The input message HandEyeCalibData must contain the camera parameters CamParam and the pose ToolInCamPose. The input message RectificationData must contain the parameter RectifyImage, and, if RectifyImage is 'only_rectify' or 'align_and_rectify', the parameter ScaleRectification. The input message Poses must contain the pose MatchingPlaneInBasePose. 

The output parameter ImageRectified is the rectified image, if rectification is set. Additionally, the current MatchingPlaneRectifiedPartInCamPose is added to the message RectificationData.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_poses_and_rectification_data_moving_cam</item>
</predecessor>
<short lang="en_US">Prepare the input image for matching and compute the needed pose.</short>
<successor>
<item>obtain_3d_pose_of_match_moving_cam</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: ToolInCamPose and CamParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image of the object to be matched.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="ImageRectified">
<description lang="en_US">Rectified Image.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain MatchingPlaneInBasePose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that contains MatchingPlaneRectifiedPartInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Current pose of the robot.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="scale_image_range">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageScaled" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Min" base_type="ctrl" dimension="0"/>
<par name="Max" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Convenience procedure to scale the gray values of the</c>
<c>* input image Image from the interval [Min,Max]</c>
<c>* to the interval [0,255] (default).</c>
<c>* Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.</c>
<c>* </c>
<c>* If the image shall be scaled to an interval different from [0,255],</c>
<c>* this can be achieved by passing tuples with 2 values [From, To]</c>
<c>* as Min and Max.</c>
<c>* Example:</c>
<c>* scale_image_range(Image:ImageScaled:[100,50],[200,250])</c>
<c>* maps the gray values of Image from the interval [100,200] to [50,250].</c>
<c>* All other gray values will be clipped.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Image: the input image</c>
<c>* Min: the minimum gray value which will be mapped to 0</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* Max: The maximum gray value which will be mapped to 255</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageScale: the resulting scaled image.</c>
<c>* </c>
<l>if (|Min| == 2)</l>
<l>    LowerLimit := Min[1]</l>
<l>    Min := Min[0]</l>
<l>else</l>
<l>    LowerLimit := 0.0</l>
<l>endif</l>
<l>if (|Max| == 2)</l>
<l>    UpperLimit := Max[1]</l>
<l>    Max := Max[0]</l>
<l>else</l>
<l>    UpperLimit := 255.0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate scaling parameters.</c>
<l>Mult := real(UpperLimit - LowerLimit) / (Max - Min)</l>
<l>Add := -Mult * Min + LowerLimit</l>
<c>* </c>
<c>* Scale image.</c>
<l>scale_image (Image, Image, Mult, Add)</l>
<c>* </c>
<c>* Clip gray values if necessary.</c>
<c>* This must be done for each image and channel separately.</c>
<l>gen_empty_obj (ImageScaled)</l>
<l>count_obj (Image, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Image, ImageSelected, ImageIndex)</l>
<l>    count_channels (ImageSelected, Channels)</l>
<l>    for ChannelIndex := 1 to Channels by 1</l>
<l>        access_channel (ImageSelected, SelectedChannel, ChannelIndex)</l>
<l>        min_max_gray (SelectedChannel, SelectedChannel, 0, MinGray, MaxGray, Range)</l>
<l>        threshold (SelectedChannel, LowerRegion, min([MinGray,LowerLimit]), LowerLimit)</l>
<l>        threshold (SelectedChannel, UpperRegion, UpperLimit, max([UpperLimit,MaxGray]))</l>
<l>        paint_region (LowerRegion, SelectedChannel, SelectedChannel, LowerLimit, 'fill')</l>
<l>        paint_region (UpperRegion, SelectedChannel, SelectedChannel, UpperLimit, 'fill')</l>
<l>        if (ChannelIndex == 1)</l>
<l>            copy_obj (SelectedChannel, ImageSelectedScaled, 1, 1)</l>
<l>        else</l>
<l>            append_channel (ImageSelectedScaled, SelectedChannel, ImageSelectedScaled)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    concat_obj (ImageScaled, ImageSelectedScaled, ImageScaled)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="scale_image_range">
<abstract lang="en_US">Convenience procedure to scale the gray values of the input image Image from the interval [Min,Max] to the interval [0,255] (default).
Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.
If the image shall be scaled to an interval different from [0,255], this can be achieved by passing tuples with 2 values [From, To] as Min and Max.
Example:
scale_image_range (Image, ImageScaled, [100,50], [200,250])
maps the gray values of Image from the interval [100,200] to [50,250].
All other gray values will be clipped.
</abstract>
<alternatives>
<item>scale_image</item>
<item>scale_image_max</item>
</alternatives>
<chapters>
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<chapters lang="de_DE">
<item>Filter</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<example lang="en_US">read_image (Image, 'fabrik')
scale_image_range (Image, ImageScaled, [100,50], [200,250])</example>
<keywords lang="de_DE">
<item>Grauwerte skalieren</item>
</keywords>
<keywords lang="en_US">
<item>scale gray values</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>scale_image</item>
<item>scale_image_max</item>
</see_also>
<short>Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="de_DE">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="en_US">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<parameters>
<parameter id="Image">
<description lang="en_US">The input image to be scaled</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="ImageScaled">
<description lang="en_US">The scaled output image</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="Max">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The maximum gray value which will be mapped to 255. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Min">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The minimum gray value which will be mapped to 0. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_mask_obj">
<interface>
<io>
<par name="Objects" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedObjects" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Mask" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* select_mask_obj selects one or more single elements of the object array</c>
<c>* Objects and returns them in SelectedObjects.</c>
<c>* The elements of Mask determine if the corresponding elements of Objects are selected.</c>
<c>* If the value is greater than 0, the corresponding element is selected.</c>
<c>* </c>
<c>* Check number of elements</c>
<l>count_obj (Objects, Number)</l>
<l>if (Number != |Mask|)</l>
<l>    throw ('Number of elements in Objects and Mask do not match.')</l>
<l>endif</l>
<c>* </c>
<c>* Check type of mask elements</c>
<l>AllNumbers := sum(is_real_elem(Mask)) + sum(is_int_elem(Mask)) == |Mask|</l>
<l>if (not AllNumbers and Mask != [])</l>
<l>    throw ('Invalid type: Elements of Mask must be integer or real numbers.')</l>
<l>endif</l>
<c>* </c>
<c>* Use select_mask for tuples to generate a list of object indices.</c>
<l>Indices := select_mask([1:|Mask|],Mask)</l>
<l>select_obj (Objects, SelectedObjects, Indices)</l>
<l>return ()</l>
</body>
<docu id="select_mask_obj">
<abstract lang="en_US">select_mask_obj selects elements of the object array Objects based on the elements in Mask and returns them in SelectedObjects. For all elements of Mask that are greater than 0, the corresponding element of Objects is returned in SelectedObjects. Objects and Mask must have the same number of elements. Mask may only contain integer or float values.</abstract>
<alternatives>
<item>tuple_select_mask</item>
<item>select_obj</item>
<item>select_shape</item>
<item>select_shape_xld</item>
<item>select_contours_xld</item>
<item>select_region_point</item>
<item>select_xld_point</item>
</alternatives>
<chapters lang="de_DE">
<item>Objekt</item>
<item>Manipulation</item>
</chapters>
<chapters lang="en_US">
<item>Object</item>
<item>Manipulation</item>
</chapters>
<example lang="en_US">read_image (Image, 'tooth_rim')
edges_sub_pix (Image, Edges, 'canny', 1, 20, 40)
test_closed_xld (Edges, IsClosed)
* Select closed contours.
select_mask_obj (Edges, ClosedContours, IsClosed)
* Select open contours.
select_mask_obj (Edges, OpenContours, not IsClosed)
</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>test_closed_xld</item>
<item>test_equal_obj</item>
<item>test_equal_region</item>
<item>test_region_point</item>
<item>test_self_intersection_xld</item>
<item>test_subset_region</item>
<item>test_xld_point</item>
<item>tuple_greater_elem</item>
<item>tuple_greater_equal_elem</item>
<item>tuple_equal_elem</item>
<item>tuple_is_int_elem</item>
<item>tuple_is_real_elem</item>
<item>tuple_is_string_elem</item>
<item>tuple_less_elem</item>
<item>tuple_less_equal_elem</item>
<item>tuple_not_equal_elem</item>
</predecessor>
<short lang="en_US">Select elements from object arrays using a mask.</short>
<parameters>
<parameter id="Mask">
<default_type>integer</default_type>
<description lang="en_US">&gt; 0 specifies the elements to select.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Objects">
<description lang="en_US">Input object array.</description>
<multivalue>optional</multivalue>
<sem_type>object</sem_type>
</parameter>
<parameter id="SelectedObjects">
<description lang="en_US">Selected objects.</description>
<multivalue>optional</multivalue>
<sem_type>object</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_cam_par_data">
<interface>
<ic>
<par name="CameraParamIn" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParamOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* set_cam_par_data sets the value of the parameter that</c>
<c>* is given in ParamName in the tuple of camera parameters</c>
<c>* given in CameraParamIn. The modified camera parameters</c>
<c>* are returned in CameraParamOut.</c>
<c>* </c>
<c>* Check for consistent length of input parameters</c>
<l>if (|ParamName| != |ParamValue|)</l>
<l>    throw ('Different number of values in ParamName and ParamValue')</l>
<l>endif</l>
<c>* First, get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParamIn, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>CameraParamOut := CameraParamIn</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        CameraParamOut[I] := ParamValue[Index]</l>
<l>    else</l>
<l>        throw ('Wrong ParamName ' + ParamNameInd)</l>
<l>    endif</l>
<c>    * Check the consistency of focus and telecentricity</c>
<l>    if (ParamNameInd == 'focus')</l>
<l>        IsTelecentric := strstr(CameraType,'telecentric') != -1 and strstr(CameraType,'image_side_telecentric') == -1</l>
<l>        if (IsTelecentric)</l>
<l>            throw ('Focus for telecentric lenses is always 0, and hence, cannot be changed.')</l>
<l>        endif</l>
<l>        if (not IsTelecentric and ParamValue[Index] == 0.0)</l>
<l>            throw ('Focus for non-telecentric lenses must not be 0.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="set_cam_par_data">
<abstract lang="en_US">set_cam_par_data sets the value of ParamName in the camera parameter tuple CameraParamIn. The modified camera parameters  are returned in CameraParamOut. The following parameter names can be set: 'focus', 'magnification', 'kappa', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx' ,'sy', 'cx', 'cy', 'vx', 'vy', 'vz', 'image_width', 'image_height'. If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'sx', Sx) 
get_cam_par_data (CameraParam, 'sy', Sy)
get_cam_par_data (CameraParam, 'cx', Cx) 
get_cam_par_data (CameraParam, 'cy', Cy) 
get_cam_par_data (CameraParam, 'image_width', ImageWidth) 
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
*
set_cam_par_data (CameraParam, 'sx', 2.0*Sx, CameraParam)
set_cam_par_data (CameraParam, 'sy', 2.0*Sy, CameraParam)
set_cam_par_data (CameraParam, 'cx', 0.5*Cx, CameraParam)
set_cam_par_data (CameraParam, 'cy', 0.5*Cy, CameraParam)
set_cam_par_data (CameraParam, 'image_width', 0.5*ImageWidth, CameraParam)
set_cam_par_data (CameraParam, 'image_height', 0.5*ImageHeight, CameraParam)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Set the value of a specified camera parameter in the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParamIn">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CameraParamOut">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be set.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_display_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="Bold" base_type="ctrl" dimension="0"/>
<par name="Slant" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure sets the text font of the current window with</c>
<c>* the specified attributes.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The graphics window for which the font will be set</c>
<c>* Size: The font size. If Size=-1, the default of 16 is used.</c>
<c>* Bold: If set to 'true', a bold font is used</c>
<c>* Slant: If set to 'true', a slanted font is used</c>
<c>* </c>
<l>get_system ('operating_system', OS)</l>
<l>if (Size == [] or Size == -1)</l>
<l>    Size := 16</l>
<l>endif</l>
<l>if (OS{0:2} == 'Win')</l>
<c>    * Restore previous behaviour</c>
<l>    Size := int(1.13677 * Size)</l>
<l>else</l>
<l>    Size := int(Size)</l>
<l>endif</l>
<l>if (Font == 'Courier')</l>
<l>    Fonts := ['Courier','Courier 10 Pitch','Courier New','CourierNew','Liberation Mono']</l>
<l>elseif (Font == 'mono')</l>
<l>    Fonts := ['Consolas','Menlo','Courier','Courier 10 Pitch','FreeMono','Liberation Mono']</l>
<l>elseif (Font == 'sans')</l>
<l>    Fonts := ['Luxi Sans','DejaVu Sans','FreeSans','Arial','Liberation Sans']</l>
<l>elseif (Font == 'serif')</l>
<l>    Fonts := ['Times New Roman','Luxi Serif','DejaVu Serif','FreeSerif','Utopia','Liberation Serif']</l>
<l>else</l>
<l>    Fonts := Font</l>
<l>endif</l>
<l>Style := ''</l>
<l>if (Bold == 'true')</l>
<l>    Style := Style + 'Bold'</l>
<l>elseif (Bold != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Bold'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Slant == 'true')</l>
<l>    Style := Style + 'Italic'</l>
<l>elseif (Slant != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Slant'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Style == '')</l>
<l>    Style := 'Normal'</l>
<l>endif</l>
<l>query_font (WindowHandle, AvailableFonts)</l>
<l>Font := ''</l>
<l>for Fdx := 0 to |Fonts| - 1 by 1</l>
<l>    Indices := find(AvailableFonts,Fonts[Fdx])</l>
<l>    if (|Indices| &gt; 0)</l>
<l>        if (Indices[0] &gt;= 0)</l>
<l>            Font := Fonts[Fdx]</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if (Font == '')</l>
<l>    throw ('Wrong value of control parameter Font')</l>
<l>endif</l>
<l>Font := Font + '-' + Style + '-' + Size</l>
<l>set_font (WindowHandle, Font)</l>
<l>return ()</l>
</body>
<docu id="set_display_font">
<abstract lang="en_US">This procedure sets the text font of the current window with the specified attributes Size, Bold and Slant. 
As font, the font name or one of the strings 'mono', 'sans', 'serif' can be used.</abstract>
<alternatives>
<item>set_font</item>
</alternatives>
<attention lang="en_US">For 'mono', 'sans', and 'serif', it is assumed that at least one of the following fonts is installed on the system:
'mono': 'Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono'
'sans': 'Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial'
'serif': 'Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia'</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window_fit_image(Image,0 , 0, 400, 400, WindowHandle)
set_display_font(WindowHandle, 16, 'mono', 'true', 'false')
disp_text (WindowHandle,'Hello World!', 'window', 10, 10, 'black', [], [])
</example>
<keywords lang="de_DE">
<item>Schriftart (Font) setzen</item>
</keywords>
<keywords lang="en_US">
<item>set font</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>open_window</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</predecessor>
<see_also>
<item>set_font</item>
</see_also>
<short>Set font independent of OS</short>
<short lang="de_DE">Set font independent of OS</short>
<short lang="en_US">Set font independent of OS</short>
<successor>
<item>disp_text</item>
<item>disp_continue_message</item>
<item>set_tposition</item>
<item>write_string</item>
</successor>
<parameters>
<parameter id="Bold">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', a bold font is used</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<default_value>'mono'</default_value>
<description lang="en_US">The font name. Either 'mono', 'sans',  'serif' or a specific font name can be used. 'mono' will be mapped to 'Courier New' on Windows, to 'courier' on Linux, and to 'Menlo' on OS X. 'sans' will be mapped to 'Arial' on Windows and OS X, and to 'helvetica' on Linux. 'serif' will be mapped to 'Times New Roman' on Windows and OS X, and to 'times' on Linux.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mono'</item>
<item>'sans'</item>
<item>'serif'</item>
</values>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>16</default_value>
<description lang="en_US">The font size on Windows systems. If Size=-1, the default of 16 is used.
On Linux systems, ALL values are multiplied with 1.25 and then mapped to [11, 14, 17, 20, 25, 34].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>[9, 11, 14, 16, 20, 27]</item>
</values>
</parameter>
<parameter id="Slant">
<default_type>string</default_type>
<default_value>'false'</default_value>
<description lang="en_US">If set to 'true', a slanted font is used</description>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the window, where the font will be set</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="sort_pairs">
<interface>
<ic>
<par name="T1" base_type="ctrl" dimension="0"/>
<par name="T2" base_type="ctrl" dimension="0"/>
<par name="SortMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sorted1" base_type="ctrl" dimension="0"/>
<par name="Sorted2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Sort tuple pairs.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* T1: first tuple</c>
<c>* T2: second tuple</c>
<c>* SortMode: if set to '1', sort by the first tuple,</c>
<c>*    if set to '2', sort by the second tuple</c>
<c>* </c>
<l>if (SortMode == '1' or SortMode == 1)</l>
<l>    tuple_sort_index (T1, Indices1)</l>
<l>    Sorted1 := subset(T1,Indices1)</l>
<l>    Sorted2 := subset(T2,Indices1)</l>
<l>elseif (SortMode == 'column' or SortMode == '2' or SortMode == 2)</l>
<l>    tuple_sort_index (T2, Indices2)</l>
<l>    Sorted1 := subset(T1,Indices2)</l>
<l>    Sorted2 := subset(T2,Indices2)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="sort_pairs">
<abstract lang="en_US">Sort tuple pairs.
This procedure first sorts one of the tuples (which one is specified by the parameter SortMode) in ascending order. The second tuple is then ordered such, that their position in the output tuple is the same as the new position of the value of the first tuple, which had the same index before sorting.
Example:
Tuple1 := [5,4,3,2,1]
Tuple2 := [105,204,303,402,501]
sort_pairs (Tuple1, Tuple2, '1', Sorted1, Sorted2)

returns:
Sorted1 := [1,2,3,4,5]
Sorted2 := [501,402,303,204,105]</abstract>
<alternatives>
<item>tuple_sort</item>
<item>tuple_sort_index</item>
</alternatives>
<attention lang="en_US">Both tuples must have the same length.
If the sorted tuple (T1, if SortMode='1' or T2, if SortMode='2') has more elements than the other, an error will occur. 
If the sorted tuple (T1, if SortMode='1' or T2, if SortMode='2') has less elements than the other, the output tuples will have as many elements as the shorter one of the input tuples.</attention>
<chapters>
<item>Tools</item>
<item>Geometry</item>
</chapters>
<chapters lang="de_DE">
<item>Tools</item>
<item>Geometrie</item>
</chapters>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<example lang="en_US">Tuple1 := [5,4,3,2,1]
Tuple2 := [105,204,303,402,501]
sort_pairs (Tuple1, Tuple2, '1', Sorted1, Sorted2)</example>
<keywords lang="de_DE">
<item>Tupelpaare sortieren</item>
</keywords>
<keywords lang="en_US">
<item>sort tuple pairs</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>tuple_sort</item>
<item>tuple_sort_index</item>
</see_also>
<short>Sort tuple pairs.</short>
<short lang="de_DE">Sort tuple pairs.</short>
<short lang="en_US">Sort tuple pairs.</short>
<parameters>
<parameter id="SortMode">
<default_type>string</default_type>
<default_value>'1'</default_value>
<description lang="en_US">If set to '1', sort by the first tuple, if set to '2', sort by the second tuple.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>'1'</item>
<item>'2'</item>
</values>
</parameter>
<parameter id="Sorted1">
<default_type>integer</default_type>
<description lang="en_US">The first sorted output tuple (corresponding to the input tuple T1)</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Sorted2">
<default_type>integer</default_type>
<description lang="en_US">The second sorted output tuple (corresponding to the input tuple T2)</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="T1">
<default_type>integer</default_type>
<description lang="en_US">First input tuple of the pair, which shall be sorted.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="T2">
<default_type>integer</default_type>
<description lang="en_US">Second input tuple of the pair, which shall be sorted.</description>
<mixed_type>optional</mixed_type>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="test_features">
<interface>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Test procedure for custom features</c>
<c>* </c>
<c>* This procedure can be used to test, if custom features</c>
<c>* implemented in get_custom_features comply with the</c>
<c>* specifications of the calculate_feature_set library.</c>
<c>* </c>
<c>* In particular, the feature vector Feature, that is</c>
<c>* calculated with calculate_feature must fulfil</c>
<c>* following conditions:</c>
<c>* </c>
<c>* - For a single input region the result of</c>
<c>*   get_feature_length has to be equal to the length</c>
<c>*   of the featue vector: |Feature| == Length</c>
<c>* </c>
<c>* - For an empty input region array, the feature</c>
<c>*   vector has to be empty:</c>
<c>*   Feature == []</c>
<c>* </c>
<c>* - For input region arrays with multiple regions, the</c>
<c>*   following condition must be met:</c>
<c>*   |Feature| == NumRegions * Length</c>
<c>* </c>
<c>* - Additionally, the feature vector has to be sorted</c>
<c>*   according to the 'feature_column' order of</c>
<c>*   add_sample_class_train_data.</c>
<c>* </c>
<l>TestSuccessful := false</l>
<l>read_image (Image, 'patras')</l>
<l>threshold (Image, Region, 128, 255)</l>
<l>get_feature_lengths (FeatureNames, Lengths)</l>
<c>* </c>
<l>TestString[0] := 'Empty region array test (no region)'</l>
<l>TestString[1] := 'Empty region test'</l>
<l>TestString[2] := 'Single region test'</l>
<l>for Test := 0 to 2 by 1</l>
<l>    switch (Test)</l>
<l>    case 0:</l>
<l>        select_shape (Region, TestRegion, 'area', 'and', 0, 0)</l>
<l>        break</l>
<l>    case 1:</l>
<l>        gen_empty_region (TestRegion)</l>
<l>        break</l>
<l>    case 2:</l>
<l>        copy_obj (Region, TestRegion, 1, 1)</l>
<l>        break</l>
<l>    default:</l>
<l>    endswitch</l>
<l>    count_obj (TestRegion, NumRegions)</l>
<l>    AllFeatures := []</l>
<l>    for Index := 0 to |FeatureNames| - 1 by 1</l>
<l>        CurName := FeatureNames[Index]</l>
<l>        CurLength := Lengths[Index]</l>
<l>        calculate_features (TestRegion, Image, CurName, Features)</l>
<l>        if (NumRegions * CurLength != |Features|)</l>
<l>            throw (TestString[Test] + ' failed for feature \'' + CurName + '\'')</l>
<l>        endif</l>
<l>        AllFeatures := [AllFeatures,Features]</l>
<l>    endfor</l>
<l>    SumLengths := sum(Lengths)</l>
<l>    Total := SumLengths * NumRegions</l>
<l>    if (Total != |AllFeatures|)</l>
<l>        throw (['Test ' + Test + ' failed',TestString[Test]])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Test multiple input regions</c>
<l>connection (Region, TestRegion)</l>
<l>select_obj (TestRegion, TestRegionSelected, [1:3])</l>
<l>for I := 0 to |FeatureNames| - 1 by 1</l>
<l>    CurName := FeatureNames[I]</l>
<l>    calculate_features (TestRegionSelected, Image, CurName, Features1)</l>
<l>    Features2 := []</l>
<l>    count_obj (TestRegionSelected, NumRegions)</l>
<l>    for J := 1 to NumRegions by 1</l>
<l>        select_obj (TestRegionSelected, ObjectSelected, J)</l>
<l>        calculate_features (ObjectSelected, Image, CurName, Features)</l>
<l>        Features2 := [Features2,Features]</l>
<l>    endfor</l>
<l>    CorrectOrder := Features1 == Features2</l>
<l>    if (not CorrectOrder)</l>
<l>        throw ('Multiple region test failed for feature \'' + CurName + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<l>TestSuccessful := true</l>
<l>return ()</l>
</body>
<docu id="test_features">
<abstract lang="en_US">This procedure can be used to test, if custom features implemented in get_custom_features comply with the specifications of the calculate_feature_set library.

In particular, the feature vector Feature, that is calculated with calculate_feature must fulfil following conditions:

- For a single input region the result of get_feature_length has to be equal to the length of the featue vector: |Feature| == Length

- For an empty input region array, the feature vector has to be empty:   Feature == []

- For input region arrays with multiple regions, the following condition must be met: |Feature| == NumRegions * Length
 
- Additionally, the feature vector has to be sorted according to the 'feature_column' order of  add_sample_class_train_data.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Test procedure for custom features.</short>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="trackball">
<interface>
<ic>
<par name="MX1" base_type="ctrl" dimension="0"/>
<par name="MY1" base_type="ctrl" dimension="0"/>
<par name="MX2" base_type="ctrl" dimension="0"/>
<par name="MY2" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SensFactor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="QuatRotation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Compute the 3D rotation from the mouse movement</c>
<c>* </c>
<l>if (MX1 == MX2 and MY1 == MY2)</l>
<l>    QuatRotation := [1,0,0,0]</l>
<l>    return ()</l>
<l>endif</l>
<c>* Project the image point onto the trackball</c>
<l>project_point_on_trackball (MX1, MY1, VirtualTrackball, TrackballSize, P1)</l>
<l>project_point_on_trackball (MX2, MY2, VirtualTrackball, TrackballSize, P2)</l>
<c>* The cross product of the projected points defines the rotation axis</c>
<l>tuple_vector_cross_product (P1, P2, RotAxis)</l>
<c>* Compute the rotation angle</c>
<l>D := P2 - P1</l>
<l>T := sqrt(sum(D * D)) / (2.0 * TrackballSize)</l>
<l>if (T &gt; 1.0)</l>
<l>    T := 1.0</l>
<l>endif</l>
<l>if (T &lt; -1.0)</l>
<l>    T := -1.0</l>
<l>endif</l>
<l>RotAngle := 2.0 * asin(T) * SensFactor</l>
<l>Len := sqrt(sum(RotAxis * RotAxis))</l>
<l>if (Len &gt; 0.0)</l>
<l>    RotAxis := RotAxis / Len</l>
<l>endif</l>
<l>axis_angle_to_quat (RotAxis[0], RotAxis[1], RotAxis[2], RotAngle, QuatRotation)</l>
<l>return ()</l>
</body>
<docu id="trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute the 3D rotation from the mouse movement</short>
<parameters>
<parameter id="MX1"/>
<parameter id="MX2"/>
<parameter id="MY1"/>
<parameter id="MY2"/>
<parameter id="QuatRotation"/>
<parameter id="SensFactor"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
</parameters>
</docu>
</procedure>
<procedure name="tuple_vector_cross_product">
<interface>
<ic>
<par name="V1" base_type="ctrl" dimension="0"/>
<par name="V2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The caller must ensure that the length of both input vectors is 3</c>
<l>VC := V1[1] * V2[2] - V1[2] * V2[1]</l>
<l>VC := [VC,V1[2] * V2[0] - V1[0] * V2[2]]</l>
<l>VC := [VC,V1[0] * V2[1] - V1[1] * V2[0]]</l>
<l>return ()</l>
</body>
<docu id="tuple_vector_cross_product">
<abstract lang="en_US">Calculates the cross product of two vectors of length 3.</abstract>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculates the cross product of two vectors of length 3.</short>
<parameters>
<parameter id="V1">
<default_type>real</default_type>
<description lang="en_US">First Vector</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="V2">
<default_type>real</default_type>
<description lang="en_US">Second vector.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="VC">
<default_type>real</default_type>
<description lang="en_US">Resulting vector.</description>
<mixed_type>optional</mixed_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_calibrated_touching_point">
<interface>
<ic>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Create 3D object models.</c>
<l>gen_tool_to_touching_point_object_model_3d (ToolInBasePosesTouchingPoint, RobotTouchingPointInToolCoordinates, OM3DToolTouchingPoint)</l>
<c>* </c>
<c>* Prepare parameters for visualize_object_model_3d.</c>
<c>* Instructions.</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* 3D visualization pose.</c>
<l>create_pose (0.326, 0.016, 3.137, 83.33, 341.96, 99.32, 'Rp+T', 'gba', 'point', PoseIn)</l>
<c>* </c>
<l>GenParamName := ['color_0','color_1','color_2','color_3','color_4','color_5','color_6','color_7','color_8','color_9','color_10','color_11']</l>
<l>GenParamValue := ['red','green','blue','magenta','red','green','blue','magenta','red','green','blue','magenta']</l>
<c>* </c>
<l>Title := 'Visualization of the read poses. The magenta lines connect the'</l>
<l>Title[1] := 'tool coordinate system with the touching point. They intersect'</l>
<l>Title[2] := 'in the approached point in the plane. Calculated touching point'</l>
<l>Title[3] := 'coordinates with respect to the robot\'s tool: '</l>
<l>Title[4] := 'X: ' + (RobotTouchingPointInToolCoordinates[0] * 1000)$'.2f' + ' mm, Y: ' + (RobotTouchingPointInToolCoordinates[1] * 1000)$'.2f' + ' mm, Z: ' + (RobotTouchingPointInToolCoordinates[2] * 1000)$'.2f' + ' mm'</l>
<c>* Labels for the visualized 3D object models.</c>
<l>NumOM3D := |OM3DToolTouchingPoint|</l>
<l>tuple_gen_const (NumOM3D, '', Label)</l>
<l>Label[2] := 'ToolInBasePosesTouchingPoint 1'</l>
<l>Label[6] := 'ToolInBasePosesTouchingPoint 2'</l>
<l>Label[10] := 'ToolInBasePosesTouchingPoint 3'</l>
<c>* </c>
<l>visualize_object_model_3d (WindowHandle, OM3DToolTouchingPoint, [], PoseIn, GenParamName, GenParamValue, Title, Label, Instructions, PoseOut)</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_object_model_3d (OM3DToolTouchingPoint)</l>
<l>return ()</l>
</body>
<docu id="visualize_calibrated_touching_point">
<chapters lang="de_DE">
<item>Graphik</item>
<item>3D-Szene</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>3D Scene</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_robot_touching_point_in_tool_coordinates</item>
</predecessor>
<see_also>
<item>calibrate_robot_touching_point</item>
</see_also>
<short lang="en_US">Visualize the poses that were used to calculate the touching point, and the result.</short>
<parameters>
<parameter id="RobotTouchingPointInToolCoordinates"/>
<parameter id="ToolInBasePosesTouchingPoint">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_object_model_3d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The procedure visualize_object_model_3d can be used to display</c>
<c>* one or more 3d object models and to interactively modify</c>
<c>* the object poses by using the mouse.</c>
<c>* </c>
<c>* The pose can be modified by moving the mouse while</c>
<c>* pressing a mouse button. The default settings are:</c>
<c>* </c>
<c>*  Rotate: Left mouse button</c>
<c>*  Zoom: Shift + Left mouse button (or Center mouse button)</c>
<c>*  Pan: Ctrl + Left mouse button</c>
<c>* </c>
<c>* Furthermore, it is possible to select and deselect objects,</c>
<c>* to decrease the mouse sensitivity, and to toggle the</c>
<c>* inspection mode (see the description of the generic parameter</c>
<c>* 'inspection_mode' below):</c>
<c>* </c>
<c>*  (De-)select object(s): Right mouse button</c>
<c>*  Low mouse sensitivity: Alt + Mouse button</c>
<c>*  Toggle inspection mode: Ctrl + Alt + Left mouse button</c>
<c>* </c>
<c>* In GenParamName and GenParamValue all generic Parameters</c>
<c>* of disp_object_model_3d are supported.</c>
<c>* </c>
<c>* **********************************************************</c>
<c>* Define global variables</c>
<c>* **********************************************************</c>
<c>* </c>
<l>global def tuple gDispObjOffset</l>
<l>global def tuple gLabelsDecor</l>
<l>global def tuple gInfoDecor</l>
<l>global def tuple gInfoPos</l>
<l>global def tuple gTitlePos</l>
<l>global def tuple gTitleDecor</l>
<l>global def tuple gTerminationButtonLabel</l>
<l>global def tuple gAlphaDeselected</l>
<l>global def tuple gIsSinglePose</l>
<l>global def tuple gUsesOpenGL</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* Initialize Handles to enable correct handling in error case</c>
<c>* **********************************************************</c>
<l>Scene3DTest := []</l>
<l>Scene3D := []</l>
<l>WindowHandleBuffer := []</l>
<c></c>
<c>* **********************************************************</c>
<c>* Some user defines that may be adapted if desired</c>
<c>* **********************************************************</c>
<c>* </c>
<c>* TrackballSize defines the diameter of the trackball in</c>
<c>* the image with respect to the smaller image dimension.</c>
<l>TrackballSize := 0.8</l>
<c>* </c>
<c>* VirtualTrackball defines the type of virtual trackball that</c>
<c>* shall be used ('shoemake' or 'bell').</c>
<l>VirtualTrackball := 'shoemake'</l>
<l>* VirtualTrackball := 'bell'</l>
<c>* </c>
<c>* Functionality of mouse buttons</c>
<c>*     1: Left Button</c>
<c>*     2: Middle Button</c>
<c>*     4: Right Button</c>
<c>*     5: Left+Right Mousebutton</c>
<c>*   8+x: Shift + Mousebutton</c>
<c>*  16+x: Ctrl + Mousebutton</c>
<c>*  48+x: Ctrl + Alt + Mousebutton</c>
<c>* in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]</c>
<l>MouseMapping := [17,1,2,5,9,4,49]</l>
<c>* </c>
<c>* The labels of the objects appear next to their projected</c>
<c>* center. With gDispObjOffset a fixed offset is added</c>
<c>*                   R,  C</c>
<l>gDispObjOffset := [-30,0]</l>
<c>* </c>
<c>* Customize the decoration of the different text elements</c>
<c>*               Color,   Box</c>
<l>gInfoDecor := ['white','false']</l>
<l>gLabelsDecor := ['white','false']</l>
<l>gTitleDecor := ['black','true']</l>
<c>* </c>
<c>* Customize the position of some text elements</c>
<c>*   gInfoPos has one of the values</c>
<c>*   {'UpperLeft', 'LowerLeft', 'UpperRight'}</c>
<l>gInfoPos := 'LowerLeft'</l>
<c>*   gTitlePos has one of the values</c>
<c>*   {'UpperLeft', 'UpperCenter', 'UpperRight'}</c>
<l>gTitlePos := 'UpperLeft'</l>
<c>* Alpha value (=1-transparency) that is used for visualizing</c>
<c>* the objects that are not selected</c>
<l>gAlphaDeselected := 0.3</l>
<c>* Customize the label of the continue button</c>
<l>gTerminationButtonLabel := ' Continue '</l>
<c>* Define if the continue button responds to a single click event or</c>
<c>* if it responds only if the mouse button is released while being placed</c>
<c>* over the continue button.</c>
<c>* 'true':  Wait until the continue button has been released.</c>
<c>*          This should be used to avoid unwanted continuations of</c>
<c>*          subsequent calls of visualize_object_model_3d, which can</c>
<c>*          otherwise occur if the mouse button remains pressed while the</c>
<c>*          next visualization is active.</c>
<c>* 'false': Continue the execution already if the continue button is</c>
<c>*          pressed. This option allows a fast forwarding through</c>
<c>*          subsequent calls of visualize_object_model_3d.</c>
<l>WaitForButtonRelease := 'true'</l>
<c>* Number of 3D Object models that can be selected and handled individually.</c>
<c>* If there are more models passed then this number, some calculations</c>
<c>* are performed differently and the individual selection and handling</c>
<c>* of models is not supported anymore. Note that the value of MaxNumModels</c>
<c>* can be overwritten with the generic parameter max_num_selectable_models.</c>
<l>MaxNumModels := 1000</l>
<c>* Defines the default for the initial state of the rotation center:</c>
<c>* (1) The rotation center is fixed in the center of the image and lies</c>
<c>*     on the surface of the object.</c>
<c>* (2) The rotation center lies in the center of the object.</c>
<l>WindowCenteredRotation := 2</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* </c>
<c>* Initialize some values</c>
<l>NumModels := |ObjectModel3D|</l>
<l>SelectedObject := gen_tuple_const(NumModels,1)</l>
<c>* </c>
<c>* Apply some system settings</c>
<l>dev_set_preferences ('graphics_window_context_menu', 'false')</l>
<l>dev_get_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>dev_set_preferences ('graphics_window_mouse_wheel', 'false')</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Check if GenParamName matches GenParamValue</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<c>    * </c>
<c>    * Refactor camera parameters to fit to window size</c>
<c>    * </c>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    get_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    set_part (WindowHandle, 0, 0, Height - 1, Width - 1)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for max_num_selectable_models</c>
<c>    * (Note that the default is set above to MaxNumModels := 1000)</c>
<l>    Indices := find(GenParamName,'max_num_selectable_models')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (is_number(GenParamValue[Indices[0]]))</l>
<l>            if (int(number(GenParamValue[Indices[0]])) &lt; 1)</l>
<c>                * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>                throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>            endif</l>
<l>        else</l>
<c>            * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>            throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>        endif</l>
<l>        MaxNumModels := int(number(GenParamValue[Indices[0]]))</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for window_centered_rotation</c>
<c>    * (Note that the default is set above to WindowCenteredRotation := 2)</c>
<l>    Indices := find(GenParamName,'inspection_mode')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[0]] == 'surface')</l>
<l>            WindowCenteredRotation := 1</l>
<l>        elseif (GenParamValue[Indices[0]] == 'standard')</l>
<l>            WindowCenteredRotation := 2</l>
<l>        else</l>
<c>            * Wrong parameter value, use default value</c>
<l>        endif</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for disp_background</c>
<c>    * (The former parameter name 'use_background' is still supported</c>
<c>    *  for compatibility reasons)</c>
<l>    DispBackground := 'false'</l>
<l>    if (|GenParamName| &gt; 0)</l>
<l>        Mask := GenParamName [==] 'disp_background' or GenParamName [==] 'use_background'</l>
<l>        Indices := find(Mask,1)</l>
<l>    else</l>
<l>        Indices := -1</l>
<l>    endif</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        DispBackground := GenParamValue[Indices[0]]</l>
<l>        if (DispBackground != 'true' and DispBackground != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'disp_background\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<c>        * Note the the background is handled explicitly in this procedure</c>
<c>        * and therefore, the parameter is removed from the list of</c>
<c>        * parameters and disp_background is always set to true (see below)</c>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter Label for each object</c>
<l>    if (|Label| == 0)</l>
<l>        Label := 0</l>
<l>    elseif (|Label| == 1)</l>
<l>        Label := gen_tuple_const(NumModels,Label)</l>
<l>    else</l>
<l>        if (|Label| != NumModels)</l>
<c>            * Error: Number of elements in Label does not match the</c>
<c>            * number of object models</c>
<l>            stop ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    if (|PoseIn| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    elseif (|PoseIn| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseIn[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    else</l>
<l>        if (|PoseIn| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := PoseIn</l>
<l>        endif</l>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<c></c>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<l>    get_font (WindowHandle, Font)</l>
<l>    try</l>
<l>        set_font (WindowHandleBuffer, Font)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    * </c>
<c>    *  Is OpenGL available and should it be used?</c>
<l>    gUsesOpenGL := 'true'</l>
<l>    Indices := find(GenParamName,'opengl')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        gUsesOpenGL := GenParamValue[Indices[0]]</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>        if (gUsesOpenGL != 'true' and gUsesOpenGL != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'opengl\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        get_system ('opengl_info', OpenGLInfo)</l>
<l>        if (OpenGLInfo == 'No OpenGL support included.')</l>
<l>            gUsesOpenGL := 'false'</l>
<l>        else</l>
<l>            gen_object_model_3d_from_points (0, 0, 0, DummyObjectModel3D)</l>
<l>            create_scene_3d (Scene3DTest)</l>
<l>            add_scene_3d_camera (Scene3DTest, CamParam, CameraIndexTest)</l>
<l>            determine_optimum_pose_distance (DummyObjectModel3D, CamParam, 0.9, [0,0,0,0,0,0,0], PoseTest)</l>
<l>            add_scene_3d_instance (Scene3DTest, DummyObjectModel3D, PoseTest, InstanceIndexTest)</l>
<l>            try</l>
<l>                display_scene_3d (WindowHandleBuffer, Scene3DTest, InstanceIndexTest)</l>
<l>            catch (Exception)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            endtry</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>            clear_object_model_3d (DummyObjectModel3D)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the trackball</c>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * </c>
<c>    * Measure the text extents for the continue button in the</c>
<c>    * graphics window</c>
<l>    get_string_extents (WindowHandleBuffer, gTerminationButtonLabel + '  ', Ascent, Descent, TextWidth, TextHeight)</l>
<c>    * </c>
<c>    * Store background image</c>
<l>    if (DispBackground == 'false')</l>
<l>        clear_window (WindowHandle)</l>
<l>    endif</l>
<l>    dump_window_image (Image, WindowHandle)</l>
<c>    * Special treatment for color background images necessary</c>
<l>    count_channels (Image, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * </c>
<l>    create_scene_3d (Scene3D)</l>
<l>    add_scene_3d_camera (Scene3D, CamParam, CameraIndex)</l>
<l>    add_scene_3d_instance (Scene3D, ObjectModel3D, Poses, AllInstances)</l>
<c>    * Always set 'disp_background' to true,  because it is handled explicitly</c>
<c>    * in this procedure (see above)</c>
<l>    set_scene_3d_param (Scene3D, 'disp_background', 'true')</l>
<c>    * Check if we have to set light specific parameters</c>
<l>    SetLight := regexp_test(GenParamName,'light_')</l>
<l>    if (SetLight)</l>
<c>        * set position of light source</c>
<l>        Indices := find(GenParamName,'light_position')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If multiple light positions are given, use the last one</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| != 4)</l>
<l>                throw ('light_position must be given as a string that contains four space separated floating point numbers')</l>
<l>            endif</l>
<l>            LightPosition := LightParam[0:2]</l>
<l>            LightKind := 'point_light'</l>
<l>            if (LightParam[3] == 0)</l>
<l>                LightKind := 'directional_light'</l>
<l>            endif</l>
<c>            * Currently, only one light source is supported</c>
<l>            remove_scene_3d_light (Scene3D, 0)</l>
<l>            add_scene_3d_light (Scene3D, LightPosition, LightKind, LightIndex)</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * set ambient part of light source</c>
<l>        Indices := find(GenParamName,'light_ambient')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the ambient part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_ambient must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'ambient', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * Set diffuse part of light source</c>
<l>        Indices := find(GenParamName,'light_diffuse')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the diffuse part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_diffuse must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'diffuse', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Handle persistence parameters separately because persistence will</c>
<c>    * only be activated immediately before leaving the visualization</c>
<c>    * procedure</c>
<l>    PersistenceParamName := []</l>
<l>    PersistenceParamValue := []</l>
<c>    * Set position of light source</c>
<l>    Indices := find(GenParamName,'object_index_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'object_index_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'object_index_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<l>    Indices := find(GenParamName,'depth_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'depth_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'depth_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Parse the generic parameters</c>
<c>    * - First, all parameters that are understood by set_scene_3d_instance_param</c>
<l>    AlphaOrig := gen_tuple_const(NumModels,1)</l>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<l>        ParamName := GenParamName[I]</l>
<l>        ParamValue := GenParamValue[I]</l>
<c>        * Check if this parameter is understood by set_scene_3d_param</c>
<l>        if (ParamName == 'alpha')</l>
<l>            AlphaOrig := gen_tuple_const(NumModels,ParamValue)</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_param (Scene3D, ParamName, ParamValue)</l>
<l>            continue</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            endif</l>
<l>        endtry</l>
<c>        * Check if it is a parameter that is valid for only one instance</c>
<c>        * and therefore can be set only with set_scene_3d_instance_param</c>
<l>        ParamNameTrunk := regexp_replace(ParamName,'_\\d+$','')</l>
<l>        if (ParamName == ParamNameTrunk)</l>
<l>            Instance := [0:NumModels - 1]</l>
<l>        else</l>
<l>            Instance := number(regexp_replace(ParamName,'^' + ParamNameTrunk + '_(\\d+)$','$1'))</l>
<l>            if (Instance &lt; 0 or Instance &gt; NumModels - 1)</l>
<l>                throw ('Parameter ' + ParamName + ' refers to a non existing 3D object model')</l>
<l>            endif</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_instance_param (Scene3D, Instance, ParamNameTrunk, ParamValue)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1204 or Exception[0] == 1304)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            elseif (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong parameter name ' + ParamName)</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>        if (ParamNameTrunk == 'alpha')</l>
<l>            AlphaOrig[Instance] := ParamValue</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Start the visualization loop</c>
<l>    pose_to_hom_mat3d (Poses[0:6], HomMat3D)</l>
<l>    affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>    TBCenter := [Qx,Qy,Qz]</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>    ButtonHold := false</l>
<l>    while (1)</l>
<l>        VisualizeTB := max(SelectedObject) != 0</l>
<l>        MaxIndex := min([|ObjectModel3D|,MaxNumModels]) - 1</l>
<c>        * Set trackball fixed in the center of the window</c>
<l>        TrackballCenterRow := Height / 2</l>
<l>        TrackballCenterCol := Width / 2</l>
<l>        if (WindowCenteredRotation == 1)</l>
<l>            try</l>
<l>                get_trackball_center_fixed (SelectedObject[0:MaxIndex], TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>            catch (Exception)</l>
<l>                disp_message (WindowHandle, 'Surface inspection mode is not available.', 'image', 5, 20, 'red', 'true')</l>
<l>                WindowCenteredRotation := 2</l>
<l>                get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>                wait_seconds (1)</l>
<l>            endtry</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>        endif</l>
<l>        dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, Information, Label, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>        dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_display (ImageDump)</l>
<c>        * </c>
<c>        * Check for mouse events</c>
<l>        GraphEvent := false</l>
<l>        Exit := false</l>
<l>        while (1)</l>
<c>            * </c>
<c>            * Check graphic event</c>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                if (GraphButton != 0)</l>
<l>                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<c>                        * Wait until the continue button has been released</c>
<l>                        if (WaitForButtonRelease == 'true')</l>
<l>                            while (1)</l>
<l>                                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                                if (GraphButton == 0 or GraphButton == [])</l>
<l>                                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<l>                                        ButtonReleased := true</l>
<l>                                    else</l>
<l>                                        ButtonReleased := false</l>
<l>                                    endif</l>
<c>                                    * </c>
<l>                                    break</l>
<l>                                endif</l>
<c>                                * Keep waiting until mouse button is released or moved out of the window</c>
<l>                            endwhile</l>
<l>                        else</l>
<l>                            ButtonReleased := true</l>
<l>                        endif</l>
<c>                        * Exit the visualization loop</c>
<l>                        if (ButtonReleased)</l>
<l>                            Exit := true</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    GraphEvent := true</l>
<l>                    break</l>
<l>                else</l>
<l>                    ButtonHold := false</l>
<l>                endif</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>        if (GraphEvent)</l>
<l>            analyze_graph_event (Image, MouseMapping, GraphButton, GraphButtonRow, GraphButtonColumn, WindowHandle, WindowHandleBuffer, VirtualTrackball, TrackballSize, SelectedObject, Scene3D, AlphaOrig, ObjectModel3D, CamParam, Label, Title, Information, GenParamName, GenParamValue, Poses, ButtonHold, TBCenter, TBSize, WindowCenteredRotation, MaxNumModels, Poses, SelectedObject, ButtonHold, WindowCenteredRotation)</l>
<l>        endif</l>
<l>        if (Exit)</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<c>    * Display final state with persistence, if requested</c>
<c>    * Note that disp_object_model_3d must be used instead of the 3D scene</c>
<l>    if (|PersistenceParamName| &gt; 0)</l>
<l>        try</l>
<l>            disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Poses, ['disp_background','alpha',PersistenceParamName], ['true',0.0,PersistenceParamValue])</l>
<l>        catch (Exception)</l>
<l>            stop ()</l>
<l>        endtry</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the output pose</c>
<l>    if (gIsSinglePose)</l>
<l>        PoseOut := Poses[0:6]</l>
<l>    else</l>
<l>        PoseOut := Poses</l>
<l>    endif</l>
<c>    * </c>
<c>    * Clean up</c>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    dev_set_preferences ('graphics_window_context_menu', 'true')</l>
<l>    dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, [], Label, 0, 'false', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>    dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_display (ImageDump)</l>
<l>    close_window (WindowHandleBuffer)</l>
<l>    set_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    clear_scene_3d (Scene3D)</l>
<l>    Scene3D := []</l>
<l>catch (Exception)</l>
<l>    try</l>
<l>        if (0 &lt; |Scene3DTest|)</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>        endif</l>
<l>        if (0 &lt; |Scene3D|)</l>
<l>            clear_scene_3d (Scene3D)</l>
<l>            Scene3D := []</l>
<l>        endif</l>
<l>        if (0 &lt; |WindowHandleBuffer|)</l>
<l>            close_window (WindowHandleBuffer)</l>
<l>            WindowHandleBuffer := []</l>
<l>        endif</l>
<l>    catch (e)</l>
<c>        * suppress all further exceptions to return the original exception</c>
<l>    endtry</l>
<c></c>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="visualize_object_model_3d">
<abstract lang="en_US">The procedure visualize_object_model_3d displays the 3D object models of ObjectModel3D in the window with the handle WindowHandle and allows to interactively modify the object poses with the mouse. The current content of the window will be kept as background.

The pose can be modified by moving the mouse while pressing a mouse button. The default settings are:

- Rotate: Left mouse button
- Zoom: Shift + Left mouse button (or Center mouse button)
- Pan: Ctrl + Left mouse button

Furthermore, it is possible to select and deselect objects, to decrease the mouse sensitivity, and to toggle the inspection mode (see the description of the generic parameter 'inspection_mode' below):

- (De-)select object(s): Right mouse button
- Low mouse sensitivity: Alt + Mouse button
- Toggle inspection mode: Ctrl + Alt + Left mouse button

Note that the selection of individual 3D object models is only available, if the number of models is not greater than 1000 (or the value passed with the generic parameter 'max_num_selectable_models', see below).

Set CamParam and the individual poses (in PoseIn) of the 3D object models to setup the displayed scene. 
If an empty tuple is given for CamParam, visualize_object_model_3d uses default camera parameters that correspond to the window size.
PoseIn can contain either multiple poses (one for each 3D object model) or one pose for all 3D object models.
If an empty tuple is given for PoseIn, visualize_object_model_3d estimates a pose, such that all 3D object models are visible.

The parameter Title can be used to specify text that will be displayed in a box at the top of the window.

The parameter Label can be used to specify a list of labels, which are displayed aligned with the corresponding 3D object model. It must either contain one entry per 3D object model or it must be empty.

The parameter Information can be used to specify text that is displayed without a box at the bottom left of the window.

The output parameter PoseOut contains the possibly modified poses used for the visualization of the 3D object models. These poses can be used directly in disp_object_model_3d and render_object_model_3d or in visualize_object_model_3d to start the visualization with exactly the poses that have been chosen interactively.

The visualization can be configured with a set of parameters, which are given in GenParamName and GenParamValue. The detailed description  of these parameters can be found in the reference documentation of disp_object_model_3d.

The following values influence the whole scene: 

'disp_background':
Flag, if the current window content should be used as background.
Values: 'true' or 'false'
Default: 'false' 

'opengl':
Decides if  OpenGL is used to display the 3D object models. Otherwise the CPU based fallback solution is used.
Values: 'true' or 'false'
Default: 'true' 

'light_position':
Position of the light source. Must be given as a string containing four space separated floating point numbers. If the fourth number is 0.0, a directional light source is used (the first three components represent the direction), otherwise a point light source is used (with the first three components representing the position). 
Default: '-100.0 -100.0 0.0 1.0'

'light_ambient':
Ambient part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.2 0.2 0.2'

'light_diffuse':
Diffuse part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.8 0.8 0.8' 

'colored':
Display object models in different colors. The value of this parameter defines the number of colors that are used.
Values: 3, 6, or 12
Default: all objects are white 

'object_index_persistence':
Must be set to 'true' to enable the object index query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

'depth_persistence':
Must be set to 'true' to enable the depth query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

The following parameters can be set for all objects in the scene or for a specific object by appending the index of the object to the parameter name (e.g., 'color_0' to set the color of the first object).

'attribute'
Explicitly select in which way a 3D object model is visualized.
Values: 'auto', 'faces', 'primitive', 'points', 'lines'
Default Value: 'auto'

'color':
Color of the 3D object model. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers between '00' and 'ff', respectively.
Values: 'red', 'green', ...
Default value: 'white'

'alpha':
Transparency of the 3D object models. Displaying 3D object models with transparency set to less than 1.0 may significantly increase the runtime ofdisplay_scene_3d and render_scene_3d.
Values: floating point value between 0.0 (fully transparent) and 1.0 (fully opaque).
Default value: 1.0

'disp_pose':
Flag, if the pose of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'disp_lines':
Flag, if the contours of the 3D object models' polygons should be displayed.
Values: 'true' or 'false'
Default value: 'false'

'disp_normals':
Flag, if the surface normals of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'line_color':
Color of the lines if 'disp_lines' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'line_width':
Sets the width of lines in pixel.
Default value: 1.0

'normal_color':
Color of the visualized normals if 'disp_normals' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'point_size':
Sets the diameter of the points in pixel.
Default value: 3.5

'lut':
Sets the LUT that transforms the values of the attribute set with 'color_attrib' into a color.
See set_lut for available LUTs. If 'lut' is set to anything but 'default', 'color' is ignored.
Default value: 'default'

'color_attrib':
Name of a point attribute that is used for false color visualization.
If an attribute is set, the color of the displayed 3D points is determined by the point's attribute value and the currently set LUT (see 'lut'). This way, it is possible to visualize attributes in false colors.
Example: If 'color_attrib' is set to 'coord_z', and 'lut' is set to 'color1', the z-coordinates will be color coded from red to blue.
If 'lut' is set to 'default', the attribute values are used to scale the color that was set by the parameter 'color'.
If 'lut' is set to a different value, the attribute values of all points are internally scaled to the interval [0,255] and used as input value for the LUT function.
The mapping is also controlled by the parameters 'color_attrib_start' and 'color_attrib_end' (see below).
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;distance', 'coord_x', 'coord_y', 'coord_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'color_attrib_start','color_attrib_end':
The range of interest of the values of the attribute set with 'color_attrib'.
The attribute values between 'color_attrib_start' and 'color_attrib_end' are scaled to the start and end of the selected LUT. Attribute values outside the selected range are clipped. This allows to use a fixed color mapping which will not be distorted by outliers.
If set to 'auto', the minimum attribute value is mapped to the start of the LUT, the maximum is mapped to the end of the LUT, except if 'color_attrib' is 'normal_x','normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect flip the used LUT.
Values: 0, 0.1, 1, 100, 255, ...
Default value: 'auto'

'red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib':
Name of a point attribute that is used for the red, green, or blue color channel.
This is most useful when used with a group of three connected attributes, like RGB colors or normal vectors. This way it is possible to display points in colored texture, e.g., display the object model with overlayed RGB-sensor data, or display point normals in false colors.
To display only a single attribute in false colors, please use 'color_attrib' (see above).
By default, the attribute values are assumed to lie between 0 and 255. If the attributes have a different range, you additionally have to set the parameters'rgb_channel_attrib_start' and 'rgb_channel_attrib_end' (see below).
If only 1 or 2 channels are set, the remaining channels use the RGB value of the color set with 'color'.
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;red','&amp;green','&amp;blue', 'normal_x', 'normal_y', 'normal_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'rgb_channel_attrib_start', 'rgb_channel_attrib_end':
The range of interest of the values of attributes set with 'red_channel_attrib', 'green_channel_attrib', and 'blue_channel_attrib'.
These parameters define the value range that is scaled to the full RGB channels. This is useful, if the input attribute values are not in the interval [0,255].
If set to 'auto', the minimum attribute value is mapped to 0, the maximum is mapped to 255, except if the attribute is 'normal_x', 'normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect invert the displayed RGB colors.
The range can be set for the channels individually by replacing 'rgb' in the parameter name with the channel name, e.g., 'green_channel_attrib_start'.
Values: 'auto', 0, 0.1, 1, 100, 255, ...
Default values: 0, 255

The following value defines the maximum number of models, for which the selection of individual models is available:

'max_num_selectable_models':
Number of 3D Object models that can be selected and handled individually. If there are more models passed then this number, some calculations are performed differently and for reasons of efficiency, the individual selection and handling of models is not supported anymore.
Values: 1, 2, ...
Default: 1000

The following value influences the handling how the pose can be modified interactively: 

'inspection_mode':
Flag that controls the initial state of the inspection mode.
If 'inspection_mode' is set to 'standard', the rotation center is fixed in the center of the displayed object. In this mode, the rotation center is indicated by a vertical cross (+). This mode is  particularly well suited for getting an impression of the whole object.
If 'inspection_mode' is set to 'surface', the rotation center is fixed in the center of the window and it lies on the surface of the displayed object. In this mode, the rotation center is indicated by a diagonal cross (x). This mode is particularly well suited for a detailed inspection of the object's surface. It is less suitable for the inspection of point clouds, because they do not provide surface information.
Note that the trackball itself is kept in the center of the image, regardless of the selected inspection mode. Note also that the inspection mode can be toggled interactively during the visualization with Ctrl + Alt + Left mouse button (see above).
Values: 'standard' or 'surface'
Default: 'standard''
  </abstract>
<alternatives>
<item>disp_object_model_3d</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D1, Status)
read_object_model_3d ('clamp_sloped', 'mm', [], [], ObjectModel3D2, Status)
gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
get_cam_par_data (CamParam, 'image_width', Width)
get_cam_par_data (CamParam, 'image_height', Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)
create_pose (0.01, 0.03, .6, 130, 315, 340, 'Rp+T', 'gba', 'point', Pose2)
visualize_object_model_3d (WindowHandle, [ObjectModel3D1, ObjectModel3D2], \ 
                           CamParam, [Pose1, Pose2], \
                           ['alpha', 'color_0', 'color_1', 'disp_pose'], \
                           [0.5,     'orange',  'yellow',  'true'], \
                           ['3D visualization demo'], ['pipe joint', 'clamp'], \
                           ['Use mouse to change view'], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<see_also>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Interactively display 3D object models</short>
<successor>
<item>clear_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_normals'</item>
<item>'disp_pose'</item>
<item>'inspection_mode'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'light_position'</item>
<item>'light_ambient'</item>
<item>'light_diffuse'</item>
<item>'line_color'</item>
<item>'line_width'</item>
<item>'lut'</item>
<item>'max_num_selectable_models'</item>
<item>'normal_color'</item>
<item>'point_size'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
<item>'normal_x'</item>
<item>'normal_y,'normal_z'</item>
<item>'standard'</item>
<item>'surface'</item>
</values>
</parameter>
<parameter id="Information">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the lower left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Label">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed at the position of each displayed object model.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">3D poses of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Poses of all object models that were possibly interactively changed by the user.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the upper left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window identifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="xyz_attrib_to_object_model_3d">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="AttribImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="AttribName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency checks:</c>
<l>count_obj (AttribImage, Number)</l>
<l>if (Number != 1)</l>
<l>    throw ('The attribute image must be an image array with exactly one object. If you want to set multiple attributes, use a multichannel image.')</l>
<l>endif</l>
<c>* </c>
<l>count_channels (AttribImage, Channels)</l>
<l>if (Channels != |AttribName|)</l>
<l>    throw ('The number of channels of the attribute image (' + Channels + ') must be equal to the number of attribute names (' + |AttribName| + ').')</l>
<l>endif</l>
<c>* </c>
<l>get_image_size (X, WidthX, HeightX)</l>
<l>get_image_size (Y, WidthY, HeightY)</l>
<l>get_image_size (Z, WidthZ, HeightZ)</l>
<l>get_image_size (AttribImage, WidthA, HeightA)</l>
<l>if (WidthX != WidthY or HeightX != HeightY or WidthX != WidthZ or HeightX != HeightZ or WidthX != WidthA or HeightX != HeightA)</l>
<l>    throw ('Image sizes do not match. The size of all input images must be equal.')</l>
<l>endif</l>
<c>* </c>
<l>get_param_info ('set_object_model_3d_attrib_mod', 'AttribName', 'value_list', AvailableAttributes)</l>
<l>tuple_regexp_select (AvailableAttributes, 'point_.*', Selection)</l>
<l>tuple_difference (AttribName, Selection, Difference)</l>
<l>tuple_regexp_select (Difference, '^[^&amp;]', InvalidParameters)</l>
<l>if (|InvalidParameters| &gt; 0)</l>
<l>    Exception := 'The following attribute names are invalid: ' + sum(InvalidParameters + ', ') + 'please use a \'&amp;\' prefix for extended attributes, e.g., \'&amp;' + InvalidParameters[0] + '\', or a standard point attribute.'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<c>* </c>
<c>* Get the domain of the images containing the 3D points and get the region all</c>
<c>* three of them share. This is because xyz_to_object_model_3d only uses points</c>
<c>* in the intersecting domains of all three images.</c>
<l>get_domain (X, DomainX)</l>
<l>get_domain (Y, DomainY)</l>
<l>get_domain (Z, DomainZ)</l>
<l>intersection (DomainX, DomainY, RegionIntersectionTmp)</l>
<l>intersection (RegionIntersectionTmp, DomainZ, RegionIntersection)</l>
<c>* </c>
<c>* Transform the images that contain the X, Y, and Z-coordinates to a 3D object model.</c>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel3D)</l>
<c>* </c>
<c>* Loop through all channels and collect the cooresponding attribute values</c>
<l>AttribValues := []</l>
<l>for Index := 1 to Channels by 1</l>
<l>    access_channel (AttribImage, Channel, Index)</l>
<l>    get_region_points (RegionIntersection, Rows, Columns)</l>
<l>    get_grayval (Channel, Rows, Columns, AttribValuesTmp)</l>
<l>    AttribValues := [AttribValues,AttribValuesTmp]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the attributes</c>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, AttribName, 'points', AttribValues)</l>
<l>return ()</l>
</body>
<docu id="xyz_attrib_to_object_model_3d">
<abstract lang="en_US">The procedure xyz_attrib_to_object_model_3d transforms the images X, Y, and Z into a 3D object model ObjectModel3D. Additionally, it sets the point attributes in AttribName to the values in AttribImage.

The procedure can be used, e.g., to create a 3D object model that uses an RGB image to set the extended attributes '&amp;amp;red', '&amp;amp;green', and '&amp;amp;blue'. Then, as seen in the example code below, the procedure visualize_object_model_3d can be used to display the object model with the respective texture.

AttribImage can be a multichannel image. The number of channels of the attribute image must be equal to the size of the tuple AttribName. Additionally, the images X, Y, Z, and AttribImage must be the same size.

Only points in the intersecting domains of the X, Y, and Z-image are used. The domain of AttribImage is ignored. The created 3D object model contains the coordinates of the points, as well as the xyz mapping attribute that contains the original row and column of each 3D point. Points where one of the coordinates is infinity or "Not a Number" (NaN) are ignored and not added to the 3D object model.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<alternatives>
<item>xyz_to_object_model_3d</item>
<item>set_object_model_3d_attrib</item>
</alternatives>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<example lang="en_US">xyz_attrib_to_object_model_3d (X, Y, Z, ImageRGB, ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], ObjectModel3D)
prepare_object_model_3d (ObjectModel3D, 'segmentation', 'true', [], [])
visualize_object_model_3d (WindowHandle, ObjectModel3D, [], [], ['red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib'], ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], [], [], [], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disparity_image_to_xyz</item>
</predecessor>
<short lang="en_US">Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model.</short>
<successor>
<item>prepare_object_model_3d</item>
<item>select_points_object_model_3d</item>
</successor>
<parameters>
<parameter id="AttribImage">
<description lang="en_US">The (multichannel) image with the attributes.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AttribName">
<default_type>string</default_type>
<default_value>'&amp;gray'</default_value>
<description lang="en_US">The names of the attributes.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>['&amp;red', '&amp;green', '&amp;blue']</item>
<item>'&amp;distance'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<description lang="en_US">Image with the X coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<description lang="en_US">Image with the Y coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<description lang="en_US">Image with the Z coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc36">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc36 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn:=0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    skipnext:=0</l>
<l>    xc := PPx[i]</l>
<l>*     if (xc==3066)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     if(i==8)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if (i==1 and v==1)</l>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        *if (vp==0 and (vn ==pnum or vn==1))</l>
<c>    *** 2 points ******         </c>
<l>        if(vp==pnum)</l>
<l>            skipnext:=1</l>
<l>            if(gv&gt;=gvp)</l>
<c>                </c>
<l>            endif</l>
<l>        endif</l>
<c>    *******************         </c>
<l>        if (vp==0 and (vn ==pnum or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif ( (vn==1 and vp==pnum) or (vp==1 and vn==pnum))</l>
<l>            btype := 1</l>
<c>        </c>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and (v==1 or v==pnum) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    vp := v</l>
<l>    gvp:=gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>* elseif (intnum==1)</l>
<l>*     wmax := 1.0</l>
<l>*     wmin := 1.0</l>
<l>*     shift:=0.0</l>
<l>*     return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>*****</c>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>*****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<l>if(intnum &lt;3)</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<c>    </c>
<l>elseif(intnum ==4)</l>
<l>    dif0:=abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1:=abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c></c>
<l>    if(dif0&gt;dif1)</l>
<l>        jMBdn:=PB[0]</l>
<l>        jMBup:=PE[0]</l>
<l>    else</l>
<l>        jMBdn:=PB[1]</l>
<l>        jMBup:=PE[1]</l>
<l>    endif</l>
<l>else</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>endif</l>
<c></c>
<l>if (intnum==1)</l>
<l>    jMBdn:=0</l>
<l>    jMBup:=0</l>
<l>    jSPdn:=0</l>
<l>    jjSPup:=0</l>
<l>endif</l>
<c></c>
<c></c>
<l>gen_region_points(PMB, [PIntY[jMBdn],PIntY[jMBup]],  [PIntX[jMBdn],PIntX[jMBup]]) </l>
<l>gen_region_points(PSP, [PIntY[jSPdn],PIntY[jSPup]],  [PIntX[jSPdn],PIntX[jSPup]]) </l>
<c></c>
<l>* for j := 0 to ii-1 by 1</l>
<l>*     if (PType[j]==1)</l>
<l>*         jSPdn := j</l>
<l>*         clcb := PCLC[j]</l>
<l>*         break</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* for j := jSPdn to ii-1 by 1</l>
<l>*     if (PType[j]==-1)</l>
<l>*         clce := PCLC[j]</l>
<l>*         if (abs(clce-clcb) &gt; clcmax)</l>
<l>*             jSPup := j</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc36">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing3space">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionI2" base_type="iconic" dimension="0"/>
<par name="RegionIS2" base_type="iconic" dimension="0"/>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="RegionInoD2" base_type="iconic" dimension="0"/>
<par name="RegionsInoD2" base_type="iconic" dimension="0"/>
<par name="RegionInoD3" base_type="iconic" dimension="0"/>
<par name="RegionsInoD3" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thr2" base_type="ctrl" dimension="0"/>
<par name="thr3" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>****** Main Image Processing ****</c>
<c>****  condition thr1 &lt; thr3 &lt; thr2 ****</c>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>*     complement(R, RC)</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<c></c>
<c>* </c>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<l>* test_equal_region(RegionIi, RegionI, IsEqual)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI2, RegionIi2, thr2, Width, Height)</l>
<c>*************************************</c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI3, RegionIi3, thr3, Width, Height)</l>
<c>*************************************</c>
<c>*** REMOVING Isl and PH *****</c>
<c>*******  Find Pinholes 1 ****</c>
<l>* fill_up_shape (RegionI, RegionIfu, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu, RegionISfI)</l>
<l>* fill_up_shape (RegionISfI, RegionIfuSfIf, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfuSfIf, RegionIf)</l>
<c>***********</c>
<l>* fill_up_shape (RegionI2, RegionIfu2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu2, RegionISfI2)</l>
<c>*******  Find Islands 2  ***</c>
<l>* fill_up_shape (RegionI2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionIf2)</l>
<l>* stop()</l>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<c>**** for RegionIi2:</c>
<l>DetectPH2 (RegionIi2, Im, RegionsPHfuAll2, RegionI2noPh2, fumax, nPHfu)</l>
<c>**** for RegionIi:</c>
<l>union2(RegionIi, RegionsPHfuAll2, RegionI1noPh2)</l>
<l>difference(Domain, RegionI1noPh2, RegionIS1noPh2)</l>
<c>**** for RegionIi3:</c>
<l>union2(RegionIi3, RegionsPHfuAll2, RegionI3noPh2)</l>
<l>difference(Domain, RegionI3noPh2, RegionIS3noPh2)</l>
<c>*//////// removing too small Pinholes from the list///////</c>
<l>select_shape(RegionsPHfuAll2, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPH, nPH)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>difference(Domain, RegionI2noPh2, RegionIS2noPh2)</l>
<l>* complement(RegionI2noPh2, RegionIS2noPh22)</l>
<l>* symm_difference(RegionIS2noPh2, RegionIS2noPh22, RegionDifference)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS2noPh2, RC, RegionIS2noPh2)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<l>* DetectIsl2n (RegionIS, Im, RegionsIslfuAll, RegionInoIsl, fumax, nIslfu)</l>
<l>* aislmax:=8000</l>
<l>* fumax:=1000</l>
<c>*** RegionInoPHnoIsl - removed PH2 and Isl1</c>
<c>**** for RegionIi1:</c>
<l>DetectIsl5 (RegionIS1noPh2, SkeletonG, RegionI1noPh2, RegionG, Im, RegionsIslfuAll, RegionI1noPh2noIsl1, fumax, aislmax, nIslfu)</l>
<l>difference(RegionI2noPh2, RegionsIslfuAll,RegionI2noPh2noIsl1)</l>
<l>difference(RegionI3noPh2, RegionsIslfuAll,RegionI3noPh2noIsl1)</l>
<c></c>
<l>difference(Domain, RegionI1noPh2noIsl1, RegionIS1noPh2noIsl1)</l>
<l>difference(Domain, RegionI2noPh2noIsl1, RegionIS2noPh2noIsl1)</l>
<c>*/////// removing too small Islandss from the list ////////*</c>
<l>select_shape (RegionsIslfuAll, RegionsIsl, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIsl, RegionsIsl, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIsl, nIsl)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>* union1(RegionsIslfu2, RegionIslfu2)</l>
<l>* difference(RegionI, RegionIslfu2, RegionI)</l>
<c></c>
<c></c>
<l>* fill_up_shape (RegionI1noPh2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionI1noPh2noIsl1)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH2 and Isl1)</c>
<c>************************************</c>
<l>* RegionInoD:=RegionInoPHnoIsl</l>
<c>*************************************</c>
<l>* difference(RegionIi, RegionIi2, RegionDifference)</l>
<l>* symm_difference(RegionIi, RegionIi2, RegionDifference)</l>
<c>************</c>
<l>* complement(RegionI, RegionIS)</l>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<c>*** zachem SkGR vmesto SkG?</c>
<l>* DetectOpenFU3 (SkeletonGnoR, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegionsOpCon, 3.0, 4, d1, nOp)</l>
<l>* difference(DomainI, RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>DetectOpenN1 (SkeletonGnoR, RegionI2noPh2noIsl1, RegionIS2noPh2noIsl1, WidthImageP, DirImageP, RegionsOp, RegionsOpCon, R2)</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<l>* union2(RegionInoPHnoIsl, RegionsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>* complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<c></c>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c>********** new Short</c>
<c></c>
<l>DetectShortN1 (SkeletonGS, RegionI1noPh2noIsl1, RegionIS1noPh2noIsl1, WidthImageS, DirImageS, RegionsShi, R2)</l>
<l>dev_display(RegionsShi)</l>
<c>*******</c>
<l>* DetectOpenN1 (SkeletonGnoR, RegionIf2, RegionISf2, WidthImageP, DirImageP, RegionsOp2, RegionsOpCon2, R2)</l>
<l>* DetectShortN1 (SkeletonGS, RegionIf2, RegionISf2, WidthImageS, DirImageS, RegionsShi2, R2)</l>
<c></c>
<c></c>
<l>* stop()</l>
<l>* DetectShortFU3 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>* DetectShortFU (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShio, 3.0, 4, nSh)</l>
<l>set_system('neighborhood', 4)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<c>******* fixing Shorts ******</c>
<l>difference(RegionI1noPh2noIsl1, RegionRemoveSh, RegionI1noPh2noIsl1noSh1)</l>
<l>difference(RegionI2noPh2noIsl1, RegionRemoveSh, RegionI2noPh2noIsl1noSh1)</l>
<l>difference(RegionI3noPh2noIsl1, RegionRemoveSh, RegionI3noPh2noIsl1noSh1)</l>
<c></c>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c>***** final RegionInoD 1,2,3 ******</c>
<l>union2(RegionI1noPh2noIsl1noSh1, RegionOpCon, RegionInoDi)</l>
<l>difference(RegionInoDi, R, RegionInoD)</l>
<l>union2(RegionI2noPh2noIsl1noSh1, RegionOpCon, RegionInoD2i)</l>
<l>difference(RegionInoD2i, R, RegionInoD2)</l>
<l>union2(RegionI3noPh2noIsl1noSh1, RegionOpCon, RegionInoD3i)</l>
<l>difference(RegionInoD3i, R, RegionInoD3)</l>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>connection(RegionInoD2, RegionsInoD2)</l>
<l>connection(RegionInoD3, RegionsInoD3)</l>
<c></c>
<l>get_region_points(RegionI1noPh2, Rows, Columns)</l>
<l>tuple_max(Columns, Max1)</l>
<c></c>
<c></c>
<l>get_region_points(RegionInoD2, Rows, Columns)</l>
<l>tuple_max(Columns, Max2)</l>
<l>get_region_points(RegionInoD, Rows, Columns)</l>
<l>tuple_max(Columns, Max)</l>
<c></c>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>* connection(RegionInoD, RegionsInoD)</l>
<l>* difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>* difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>* connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing3space">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionI"/>
<parameter id="RegionI2"/>
<parameter id="RegionIS"/>
<parameter id="RegionIS2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoD2"/>
<parameter id="RegionInoD3"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsInoD2"/>
<parameter id="RegionsInoD3"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPH"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aislmax"/>
<parameter id="d1"/>
<parameter id="fumax"/>
<parameter id="path"/>
<parameter id="thr"/>
<parameter id="thr2"/>
<parameter id="thr3"/>
</parameters>
</docu>
</procedure>
<procedure name="MaesureSmoothing">
<interface>
<io>
<par name="RegionsG" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>difm:=100000000000</l>
<l>for sm:=3 to 21 by 2</l>
<l>    SmoothingRegion (RegionsG, RegionsGsm, sm)</l>
<l>    union1(RegionsGsm, RegionGsm)</l>
<l>    symm_difference(RegionGsm, RegionI, RegionDifsm)</l>
<l>    area_center(RegionDifsm, AreaDifsm, Row2, Column2)</l>
<l>    if(AreaDifsm &lt;= difm)</l>
<l>        difm:=AreaDifsm</l>
<l>    else</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>smoothCADcontours:=sm-2</l>
<l>return ()</l>
</body>
<docu id="MaesureSmoothing">
<parameters>
<parameter id="RegionI"/>
<parameter id="RegionsG"/>
<parameter id="smoothCADcontours"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain114">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain114 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<c></c>
<l>WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa)</l>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP2(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c></c>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain114">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="Plot1">
<interface>
<ic>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="Wmed" base_type="ctrl" dimension="0"/>
<par name="WmedExt" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Plot code generated by function inspect window</c>
<l>dev_open_window (0, 0, 722, 338, 'white', TmpCtrl_Handle)</l>
<l>TmpCtrl_LimitNames := ['start_x','end_x','start_y','end_y']</l>
<l>TmpCtrl_LimitValues := [0, 773, 6.9, 19.1]</l>
<l>TmpCtrl_GenParamNames := ['axes_color','ticks_x','ticks_y','grid_x','grid_y',TmpCtrl_LimitNames]</l>
<l>TmpCtrl_GenParamValues := ['black', 100, 2, 100, 2, TmpCtrl_LimitValues]</l>
<l>dev_clear_window ()</l>
<l>plot_tuple (TmpCtrl_Handle, [], [], 'x', 'y', 'none', TmpCtrl_GenParamNames, TmpCtrl_GenParamValues)</l>
<l>dev_set_line_width (5)</l>
<l>plot_tuple (TmpCtrl_Handle, [], Wfilt, '', '', 'orange', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>plot_tuple (TmpCtrl_Handle, [], Wch, '', '', 'dim gray', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>plot_tuple (TmpCtrl_Handle, [], W, '', '', 'blue', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_line_width (2)</l>
<l>plot_tuple (TmpCtrl_Handle, [], Wmed, '', '', 'magenta', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_line_width (2)</l>
<l>plot_tuple (TmpCtrl_Handle, [], WmedExt, '', '', 'cyan', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>return ()</l>
</body>
<docu id="Plot1">
<parameters>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="Wmed"/>
<parameter id="WmedExt"/>
</parameters>
</docu>
</procedure>
<procedure name="PlotWWmed">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="WmedExt" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Plot code generated by function inspect window</c>
<l>dev_open_window (0, 0, 722, 338, 'white', TmpCtrl_Handle)</l>
<l>TmpCtrl_LimitNames := ['start_x','end_x','start_y','end_y']</l>
<l>TmpCtrl_LimitValues := [0, 1185, 7.2, 18.2]</l>
<l>TmpCtrl_GenParamNames := ['axes_color','ticks_x','ticks_y','grid_x','grid_y',TmpCtrl_LimitNames]</l>
<l>TmpCtrl_GenParamValues := ['black', 100, 2, 100, 2, TmpCtrl_LimitValues]</l>
<l>dev_clear_window ()</l>
<l>plot_tuple (TmpCtrl_Handle, [], [], 'x', 'y', 'none', TmpCtrl_GenParamNames, TmpCtrl_GenParamValues)</l>
<l>dev_set_line_width (2)</l>
<l>plot_tuple (TmpCtrl_Handle, [], W, '', '', 'blue', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>dev_set_line_width (2)</l>
<l>plot_tuple (TmpCtrl_Handle, [], WmedExt, '', '', 'cyan', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>dev_set_line_width (1)</l>
<l>* dev_close_window()</l>
<l>return ()</l>
</body>
<docu id="PlotWWmed">
<parameters>
<parameter id="W"/>
<parameter id="WmedExt"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing4">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionI2" base_type="iconic" dimension="0"/>
<par name="RegionIS2" base_type="iconic" dimension="0"/>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="RegionInoD2" base_type="iconic" dimension="0"/>
<par name="RegionsInoD2" base_type="iconic" dimension="0"/>
<par name="RegionInoD3" base_type="iconic" dimension="0"/>
<par name="RegionsInoD3" base_type="iconic" dimension="0"/>
<par name="RegionInoD4" base_type="iconic" dimension="0"/>
<par name="RegionsInoD4" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thr2" base_type="ctrl" dimension="0"/>
<par name="thr3" base_type="ctrl" dimension="0"/>
<par name="thr4" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>****** Main Image Processing ****</c>
<c>****  condition thr1 &lt; thr2,thr3 &lt; thr4 ****</c>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>*     complement(R, RC)</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<c></c>
<c>* </c>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<l>* test_equal_region(RegionIi, RegionI, IsEqual)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI2, RegionIi2, thr2, Width, Height)</l>
<c>*************************************</c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI3, RegionIi3, thr3, Width, Height)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI4, RegionIi4, thr4, Width, Height)</l>
<c>*************************************</c>
<c>*** REMOVING Isl and PH *****</c>
<c>*******  Find Pinholes 1 ****</c>
<l>* fill_up_shape (RegionI, RegionIfu, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu, RegionISfI)</l>
<l>* fill_up_shape (RegionISfI, RegionIfuSfIf, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfuSfIf, RegionIf)</l>
<c>***********</c>
<l>* fill_up_shape (RegionI2, RegionIfu2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu2, RegionISfI2)</l>
<c>*******  Find Islands 2  ***</c>
<l>* fill_up_shape (RegionI2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionIf2)</l>
<l>* stop()</l>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<c>**** for RegionIi2:</c>
<l>DetectPH2 (RegionIi4, Im, RegionsPHfuAll4, RegionI4noPh4, fumax, nPHfu)</l>
<c>**** for RegionIi:</c>
<l>union2(RegionIi, RegionsPHfuAll4, RegionI1noPh4)</l>
<l>difference(Domain, RegionI1noPh4, RegionIS1noPh4)</l>
<c>**** for RegionIi2:</c>
<l>union2(RegionIi2, RegionsPHfuAll4, RegionI2noPh4)</l>
<l>difference(Domain, RegionI2noPh4, RegionIS2noPh4)</l>
<c>**** for RegionIi3:</c>
<l>union2(RegionIi3, RegionsPHfuAll4, RegionI3noPh4)</l>
<l>difference(Domain, RegionI3noPh4, RegionIS3noPh4)</l>
<c></c>
<c>*//////// removing too small Pinholes from the list///////</c>
<l>select_shape(RegionsPHfuAll4, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPH, nPH)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>difference(Domain, RegionI2noPh4, RegionIS2noPh4)</l>
<l>* complement(RegionI2noPh2, RegionIS2noPh22)</l>
<l>* symm_difference(RegionIS2noPh2, RegionIS2noPh22, RegionDifference)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS2noPh4, RC, RegionIS2noPh4)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<l>* DetectIsl2n (RegionIS, Im, RegionsIslfuAll, RegionInoIsl, fumax, nIslfu)</l>
<l>* aislmax:=8000</l>
<l>* fumax:=1000</l>
<c>*** RegionInoPHnoIsl - removed PH4 and Isl1</c>
<c>**** for RegionIi1:</c>
<l>DetectIsl5 (RegionIS1noPh4, SkeletonG, RegionI1noPh4, RegionG, Im, RegionsIslfuAll, RegionI1noPh4noIsl1, fumax, aislmax, nIslfu)</l>
<c>**** for RegionIi2:</c>
<l>difference(RegionI2noPh4, RegionsIslfuAll,RegionI2noPh4noIsl1)</l>
<c>**** for RegionIi3:</c>
<l>difference(RegionI3noPh4, RegionsIslfuAll,RegionI3noPh4noIsl1)</l>
<c>**** for RegionIi43:</c>
<l>difference(RegionI4noPh4, RegionsIslfuAll,RegionI4noPh4noIsl1)</l>
<c></c>
<l>difference(Domain, RegionI1noPh4noIsl1, RegionIS1noPh4noIsl1)</l>
<l>difference(Domain, RegionI2noPh4noIsl1, RegionIS2noPh4noIsl1)</l>
<l>difference(Domain, RegionI3noPh4noIsl1, RegionIS3noPh4noIsl1)</l>
<l>difference(Domain, RegionI4noPh4noIsl1, RegionIS4noPh4noIsl1)</l>
<c>*/////// removing too small Islandss from the list ////////*</c>
<l>select_shape (RegionsIslfuAll, RegionsIsl, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIsl, RegionsIsl, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIsl, nIsl)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>* union1(RegionsIslfu2, RegionIslfu2)</l>
<l>* difference(RegionI, RegionIslfu2, RegionI)</l>
<c></c>
<c></c>
<l>* fill_up_shape (RegionI1noPh2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionI1noPh2noIsl1)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH2 and Isl1)</c>
<c>************************************</c>
<l>* RegionInoD:=RegionInoPHnoIsl</l>
<c>*************************************</c>
<l>* difference(RegionIi, RegionIi2, RegionDifference)</l>
<l>* symm_difference(RegionIi, RegionIi2, RegionDifference)</l>
<c>************</c>
<l>* complement(RegionI, RegionIS)</l>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<c>*** zachem SkGR vmesto SkG?</c>
<l>* DetectOpenFU3 (SkeletonGnoR, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegionsOpCon, 3.0, 4, d1, nOp)</l>
<l>* difference(DomainI, RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>DetectOpenN1 (SkeletonGnoR, RegionI2noPh4noIsl1, RegionIS2noPh4noIsl1, WidthImageP, DirImageP, RegionsOp, RegionsOpCon, R2)</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<l>* union2(RegionInoPHnoIsl, RegionsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>* complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<c></c>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c>********** new Short</c>
<c></c>
<l>DetectShortN2 (SkeletonGS, RegionI1noPh4noIsl1, RegionIS1noPh4noIsl1, WidthImageS, DirImageS, RegionG, RegionsShi, R2)</l>
<l>dev_display(RegionsShi)</l>
<c>*******</c>
<l>* DetectOpenN1 (SkeletonGnoR, RegionIf2, RegionISf2, WidthImageP, DirImageP, RegionsOp2, RegionsOpCon2, R2)</l>
<l>* DetectShortN1 (SkeletonGS, RegionIf2, RegionISf2, WidthImageS, DirImageS, RegionsShi2, R2)</l>
<c></c>
<c></c>
<l>* stop()</l>
<l>* DetectShortFU3 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>* DetectShortFU (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShio, 3.0, 4, nSh)</l>
<l>set_system('neighborhood', 4)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<c>******* fixing Shorts ******</c>
<l>difference(RegionI1noPh4noIsl1, RegionRemoveSh, RegionI1noPh4noIsl1noSh1)</l>
<l>difference(RegionI2noPh4noIsl1, RegionRemoveSh, RegionI2noPh4noIsl1noSh1)</l>
<l>difference(RegionI3noPh4noIsl1, RegionRemoveSh, RegionI3noPh4noIsl1noSh1)</l>
<l>difference(RegionI4noPh4noIsl1, RegionRemoveSh, RegionI4noPh4noIsl1noSh1)</l>
<c></c>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c>***** final RegionInoD 1,2,3,4 ******</c>
<l>union2(RegionI1noPh4noIsl1noSh1, RegionOpCon, RegionInoDi)</l>
<l>difference(RegionInoDi, R, RegionInoD)</l>
<l>union2(RegionI2noPh4noIsl1noSh1, RegionOpCon, RegionInoD2i)</l>
<l>difference(RegionInoD2i, R, RegionInoD2)</l>
<l>union2(RegionI3noPh4noIsl1noSh1, RegionOpCon, RegionInoD3i)</l>
<l>difference(RegionInoD3i, R, RegionInoD3)</l>
<l>union2(RegionI4noPh4noIsl1noSh1, RegionOpCon, RegionInoD4i)</l>
<l>difference(RegionInoD4i, R, RegionInoD4)</l>
<l>connection(RegionInoD, RegionsInoD)</l>
<l>connection(RegionInoD2, RegionsInoD2)</l>
<l>connection(RegionInoD3, RegionsInoD3)</l>
<c></c>
<l>connection(RegionInoD4, RegionsInoD4)</l>
<l>count_seconds(s1)</l>
<l>* fill_up_shape(RegionsInoDn, RegionsInoDnp,'area', 1, 30)</l>
<l>* select_shape(RegionsInoDnp, RegionsInoD, 'area', 'and', 30, 9999999)</l>
<l>* difference( RegionsInoD,Domain, RegionDifference)</l>
<l>* fill_up_shape(RegionsInoD2n, RegionsInoD2np,'area', 1, 30)</l>
<l>* select_shape(RegionsInoD2np, RegionsInoD2, 'area', 'and', 30, 9999999)</l>
<l>* fill_up_shape(RegionsInoD3n, RegionsInoD3,'area', 1, 30)</l>
<l>* fill_up_shape(RegionsInoD4n, RegionsInoD4np,'area', 1, 30)</l>
<l>* select_shape(RegionsInoD4np, RegionsInoD4, 'area', 'and', 30, 9999999)</l>
<l>* count_seconds(s2)</l>
<l>* s:=s2-s1</l>
<l>* stop()</l>
<l>* get_region_points(RegionI1noPh4, Rows, Columns)</l>
<l>* tuple_max(Columns, Max1)</l>
<c></c>
<c></c>
<l>* get_region_points(RegionInoD2, Rows, Columns)</l>
<l>* tuple_max(Columns, Max2)</l>
<l>* get_region_points(RegionInoD, Rows, Columns)</l>
<l>* tuple_max(Columns, Max)</l>
<c></c>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>* connection(RegionInoD, RegionsInoD)</l>
<l>* difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>* difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>* connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing4">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionI"/>
<parameter id="RegionI2"/>
<parameter id="RegionIS"/>
<parameter id="RegionIS2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoD2"/>
<parameter id="RegionInoD3"/>
<parameter id="RegionInoD4"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsInoD2"/>
<parameter id="RegionsInoD3"/>
<parameter id="RegionsInoD4"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPH"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aislmax"/>
<parameter id="d1"/>
<parameter id="fumax"/>
<parameter id="path"/>
<parameter id="thr"/>
<parameter id="thr2"/>
<parameter id="thr3"/>
<parameter id="thr4"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc36">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSSpProc36 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>** 2022.09.15 MSSpProc34() modified very narrow space</c>
<c>** 2022.12.28 MSSpProc36() modified from MSPtProc36()</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [0,0,0,0,0,0]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>merr:=0</l>
<l>err:=0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>** finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if (i==1 and v==1)</l>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        if (vp==0 and (vn ==pnum or vn==1))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and v==0 and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    vp := v</l>
<c>   </c>
<l>*     if (v==pnum)</l>
<l>*         PIntY[ii]:=yc</l>
<l>*         PIntX[ii]:=xc</l>
<l>*         PInti[ii]:=i</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>endfor</l>
<c></c>
<l>intnum:=ii</l>
<l>jSPdn:=0</l>
<l>jSPup:=ii-1</l>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<l>jSPdn := PB[0]</l>
<l>jSPup := PE[ie-1]</l>
<c></c>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>***</c>
<l>* if(intnum==0)</l>
<l>*     w:=0.5</l>
<l>*     wmin:=0.5</l>
<l>*     return()</l>
<l>* elseif(intnum==1)</l>
<l>*     wmax:=1.0</l>
<l>*     wmin:=1.0</l>
<l>*     i:=PInti[0]</l>
<l>*     return()</l>
<l>*     intnum:=2</l>
<l>*     PInti[0]:=i-1</l>
<l>*     PInti[1]:=i+1</l>
<l>*     jSPup:=1</l>
<l>* endif</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    i:=PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i],  g)</l>
<l>*     typ:=j%2</l>
<l>*     if(g&lt;thr)</l>
<l>*         if(typ==0)</l>
<l>*             i:=i-1</l>
<l>*         else</l>
<l>*             i:=i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i],  g)    </l>
<l>*     endif</l>
<l>    PIntcor[j]:=i</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[i+1], PPx[i+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax:=max(g0)</l>
<l>*     gmin:=min(g0)</l>
<l>*     gmax:=max2(g0[0], g0[1])</l>
<l>    if(i&lt;pind-1 and i&gt;0)</l>
<l>        SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX:=PIntX[j]</l>
<l>        fIntY:=PIntY[j]</l>
<l>    endif</l>
<l>*     SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    if(err==1)</l>
<l>        merr:=1</l>
<l>    endif</l>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*         SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>* stop()</l>
<l>* gen_region_points(PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi:=PInti[i]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* previous clc </c>
<l>*         pclc:=-2</l>
<l>*         fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>* if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii]:=PPy[0]</l>
<l>*     PIntX[ii]:=PPx[0]</l>
<l>*     PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>*     get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if(Pval[0]==pnum)</l>
<l>*         PCLC[ii]:=clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii]:=-2</l>
<l>*     endif</l>
<l>*     ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>*     if(Pval[0]==1)</l>
<l>*         fi1:=1</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>*             PIntY[ii]:=PPy[0]</l>
<l>*             PIntX[ii]:=PPx[0]</l>
<l>*             PInti[ii]:=0</l>
<l>*             PCLC[ii]:=clc</l>
<l>*             PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>*             ii:=ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1:=0</l>
<l>* endif</l>
<c>***********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>*     if(fi1==1)</l>
<l>*         if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii:=ii-1</l>
<l>*             fi1:=0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1:=0</l>
<c>        * previous and next values</c>
<l>*         vp:=Pval[i-1]</l>
<l>*         vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>*         dev_set_color('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj(PC, Pc, PC)</l>
<l>*         dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>*             get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval(ImageIRBS, yc, xc, irbs)</l>
<c>*            </c>
<l>*                 PIntY[ii]:=yc</l>
<l>*                 PIntX[ii]:=xc</l>
<l>*                 PInti[ii]:=i</l>
<l>*                 Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>*                 if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>*                     ii:=ii+1</l>
<l>*                     PIntY[ii-1]:=yc-0.35*signY</l>
<l>*                     PIntX[ii-1]:=xc-0.35*signX</l>
<l>*                     Psubpix[ii-1]:=0</l>
<l>*                     PIntY[ii]:=yc+0.35*signY</l>
<l>*                     PIntX[ii]:=xc+0.35*signX</l>
<l>*                     PInti[ii]:=i</l>
<l>*                     Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<c>                </c>
<l>*                 PCLC[ii]:=clc</l>
<l>*                 PIRBS[ii]:=irbs</l>
<l>*                 ii:=ii+1</l>
<l>*                 pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>*         endif</l>
<l>*       endif</l>
<l>*     vp:=v</l>
<l>*     gp:=g</l>
<l>* endfor</l>
<c></c>
<c>*checking last MS pixel</c>
<l>* if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if(Pval[pind-1]==pnum)</l>
<l>*         get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc:=PCLC[ii-1]</l>
<l>*         irbs:=PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii]:=PPy[pind-1]</l>
<l>*     PIntX[ii]:=PPx[pind-1]</l>
<l>*     PInti[ii]:=pind-1</l>
<l>*     PCLC[ii]:=clc</l>
<l>*     ii:=ii+1</l>
<l>*     if(Pval[pind-2]==1)</l>
<l>*         PIntY[ii]:=PPy[pind-1]</l>
<l>*         PIntX[ii]:=PPx[pind-1]</l>
<l>*         PInti[ii]:=pind-1</l>
<l>*         PCLC[ii]:=clc</l>
<l>*         PIRBS[ii]:=irbs</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii]:=0</l>
<l>* endif</l>
<c>**************************</c>
<l>* gen_region_points(PInt, PIntY, PIntX) </l>
<l>* intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>* if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>*     wmin := 0.</l>
<l>*     wmax := 0.</l>
<l>*     shift:=0.</l>
<l>*     return()</l>
<l>* endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>* pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>*     g0[1] := g</l>
<l>*     if(PInti[j]&gt;0)</l>
<l>*         get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*         g0[0] := g</l>
<l>*     else</l>
<l>*         g0[0] := g0[1]</l>
<l>*     endif</l>
<l>*     if(PInti[j]&lt;pind-1)</l>
<l>*        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>*        g0[2] := g</l>
<l>*     else</l>
<l>*         g0[2] := g0[1]</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*             SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*         FIntX[j]:=fIntX</l>
<l>*         FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>*     if(g0[2]-g0[0]&gt;0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     elseif(g0[0]-g0[2]&gt;0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     if(pdir &gt; 0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     elseif(pdir &lt; 0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     pdir:=Pdir[j]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>* nmwc:=0</l>
<c>* MW segment</c>
<l>* mw:=-1</l>
<l>* dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*     get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*     if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*         clc:=0</l>
<l>*         for dx:=-3 to 3 by 1</l>
<l>*             for dy:=-3 to 3 by 1</l>
<l>*                 get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                 if(vclc!=0)</l>
<l>*                     clc:=vclc</l>
<l>*                     break</l>
<l>*                 endif</l>
<l>*             endfor</l>
<l>*         endfor</l>
<l>*         PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>*     else</l>
<l>*         PCLC[j]:=vclc</l>
<l>*     endif</l>
<l>*     Pnums[j]:=vpnums</l>
<l>* endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     pclc:=PCLC[j]</l>
<l>*     clc:=PCLC[j+1]</l>
<c>    </c>
<l>*     dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*     if(dclc&gt;clcmax)</l>
<l>*         if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*             continue</l>
<l>*         endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*         d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*         d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*         d:=sqrt( min2(d1,d2) )</l>
<l>*         if(d&lt;dmin)</l>
<l>*             mw:=j</l>
<l>*             nmwc:=nmwc+1</l>
<l>*             dmin:=d</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* if(mw==-1)</l>
<l>*     mw:=0</l>
<l>*     stop()</l>
<l>* endif</l>
<l>* dev_set_color('red')</l>
<l>* gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>* jSPdn:=mw</l>
<l>* jSPup:=mw+1</l>
<c></c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     if(j==mw)</l>
<l>*         continue</l>
<l>*     else</l>
<l>*         clc:=PCLC[j]</l>
<l>*         clc1:=PCLC[mw]</l>
<l>*         clc2:=PCLC[mw+1]</l>
<l>*         dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*         dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>*             if(j&lt;mw)</l>
<l>*                 dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPdn:=j</l>
<l>*                 endif</l>
<l>*             else</l>
<l>*                 dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPup:=j+1</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>* if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>*     stop()</l>
<l>* endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>* wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>wmin:=wmax</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc36">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN2">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN2 : new detect short proc. 19.01.2023</c>
<c>*** remowed last SkeletonGS contour</c>
<c></c>
<l>* get_domain(WidthImageS, Domain)</l>
<l>* boundary(Domain, DomainB, 'inner')</l>
<l>* get_image_size(WidthImageS,Width, Height)</l>
<l>* gen_rectangle1(RB, bdist,bdist,Height- bdist, Width-bdist)</l>
<c>** for rectengular outer shape</c>
<l>region_features(RegionG, 'row1', r1)</l>
<l>region_features(RegionG, 'column1', c1)</l>
<l>region_features(RegionG, 'row2', r2)</l>
<l>region_features(RegionG, 'column2', c2)</l>
<l>gen_rectangle1(RB, r1,c1,r2,c2)</l>
<c></c>
<l>* fill_up(RegionG, RegionFillUpG)</l>
<c>** for arbitrary outer shape</c>
<l>* closing_circle(RegionG, RB, 101)</l>
<c></c>
<l>intersection(SkeletonGS, RB, SkeletonGSnoB)</l>
<l>intersection(SkeletonGSnoB, RegionInoPHnoIsl, ShCandAll)</l>
<l>connection(ShCandAll, ShCands)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>for j:=1 to nShCands by 1</l>
<l>*     intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*     connection(RInt, RInts)</l>
<l>*     if(j==5085)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(ShCands, ShCand, j)</l>
<l>    area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>    get_region_points(ShCand, Rows, Columns)</l>
<l>    get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>    tuple_median(SpW, spw)</l>
<l>    get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>    tuple_median(SpD, spd)</l>
<l>    sa:=spd*3.14159/256</l>
<l>    if(spw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+10, Length2+spw+10)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    endif</l>
<c>    </c>
<l>*     gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>    connection(RegionISR2, RegionsISR2)</l>
<l>    intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>    connection(RegionGSR2, RegionsGSR2)</l>
<l>    count_obj(RegionsGSR2, nGSR2)</l>
<l>    for jj:=1 to nGSR2 by 1</l>
<l>        select_obj(RegionsGSR2, Rsel, jj)</l>
<l>        test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGSR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGSR2, Rskel, jj)</l>
<l>    intersection( RegionsISR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<l>        concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortN2">
<parameters>
<parameter id="DirImageS"/>
<parameter id="R2"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="Preprocessing41">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="RegionI2" base_type="iconic" dimension="0"/>
<par name="RegionIS2" base_type="iconic" dimension="0"/>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPh" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
<par name="RegionsIslfuAll" base_type="iconic" dimension="0"/>
<par name="RegionsPHfuAll" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegonsOpCon" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoOP" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIslnoSh" base_type="iconic" dimension="0"/>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="RegionInoD2" base_type="iconic" dimension="0"/>
<par name="RegionsInoD2" base_type="iconic" dimension="0"/>
<par name="RegionInoD3" base_type="iconic" dimension="0"/>
<par name="RegionsInoD3" base_type="iconic" dimension="0"/>
<par name="RegionInoD4" base_type="iconic" dimension="0"/>
<par name="RegionsInoD4" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="thr2" base_type="ctrl" dimension="0"/>
<par name="thr3" base_type="ctrl" dimension="0"/>
<par name="thr4" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="d1" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>****** Main Image Processing ****</c>
<c>****  condition thr1 &lt; thr2,thr3 &lt; thr4 ****</c>
<c>*** removed small islands and pinholes</c>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>*     complement(R, RC)</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<c></c>
<c>* </c>
<c></c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI, RegionIi, thr, Width, Height)</l>
<c></c>
<l>* test_equal_region(RegionIi, RegionI, IsEqual)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI2, RegionIi2, thr2, Width, Height)</l>
<c>*************************************</c>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI3, RegionIi3, thr3, Width, Height)</l>
<l>ImagePrepThr (Im, R, RC, Domain, RegionI4, RegionIi4, thr4, Width, Height)</l>
<c>*************************************</c>
<c>*** REMOVING Isl and PH *****</c>
<c>*******  Find Pinholes 1 ****</c>
<l>* fill_up_shape (RegionI, RegionIfu, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu, RegionISfI)</l>
<l>* fill_up_shape (RegionISfI, RegionIfuSfIf, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfuSfIf, RegionIf)</l>
<c>***********</c>
<l>* fill_up_shape (RegionI2, RegionIfu2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionIfu2, RegionISfI2)</l>
<c>*******  Find Islands 2  ***</c>
<l>* fill_up_shape (RegionI2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionIf2)</l>
<l>* stop()</l>
<c>*** PH detection using fillup</c>
<c>**** Pinhole detection function</c>
<c>**** for RegionIi2:</c>
<l>DetectPH2 (RegionIi4, Im, RegionsPHfuAll4, RegionI4noPh4, fumax, nPHfu)</l>
<c>**** for RegionIi:</c>
<l>union2(RegionIi, RegionsPHfuAll4, RegionI1noPh4)</l>
<l>difference(Domain, RegionI1noPh4, RegionIS1noPh4)</l>
<c>**** for RegionIi2:</c>
<l>union2(RegionIi2, RegionsPHfuAll4, RegionI2noPh4)</l>
<l>difference(Domain, RegionI2noPh4, RegionIS2noPh4)</l>
<c>**** for RegionIi3:</c>
<l>union2(RegionIi3, RegionsPHfuAll4, RegionI3noPh4)</l>
<l>difference(Domain, RegionI3noPh4, RegionIS3noPh4)</l>
<c></c>
<c>*//////// removing too small Pinholes from the list///////</c>
<l>select_shape(RegionsPHfuAll4, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<l>count_obj(RegionsPH, nPH)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>difference(Domain, RegionI2noPh4, RegionIS2noPh4)</l>
<l>* complement(RegionI2noPh2, RegionIS2noPh22)</l>
<l>* symm_difference(RegionIS2noPh2, RegionIS2noPh22, RegionDifference)</l>
<l>* intersection (RegionIS1, DomainImOut, RegionIS2)</l>
<l>intersection(RegionIS2noPh4, RC, RegionIS2noPh4)</l>
<c></c>
<c></c>
<c>*** Isl detection using fillup</c>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection(RegionIS, R, RegionIS)</l>
<l>* DetectIsl2n (RegionIS, Im, RegionsIslfuAll, RegionInoIsl, fumax, nIslfu)</l>
<l>* aislmax:=8000</l>
<l>* fumax:=1000</l>
<c>*** RegionInoPHnoIsl - removed PH4 and Isl1</c>
<c>**** for RegionIi1:</c>
<l>DetectIsl5 (RegionIS1noPh4, SkeletonG, RegionI1noPh4, RegionG, Im, RegionsIslfuAll, RegionI1noPh4noIsl1, fumax, aislmax, nIslfu)</l>
<c>**** for RegionIi2:</c>
<l>difference(RegionI2noPh4, RegionsIslfuAll,RegionI2noPh4noIsl1)</l>
<c>**** for RegionIi3:</c>
<l>difference(RegionI3noPh4, RegionsIslfuAll,RegionI3noPh4noIsl1)</l>
<c>**** for RegionIi43:</c>
<l>difference(RegionI4noPh4, RegionsIslfuAll,RegionI4noPh4noIsl1)</l>
<c></c>
<l>difference(Domain, RegionI1noPh4noIsl1, RegionIS1noPh4noIsl1)</l>
<l>difference(Domain, RegionI2noPh4noIsl1, RegionIS2noPh4noIsl1)</l>
<l>difference(Domain, RegionI3noPh4noIsl1, RegionIS3noPh4noIsl1)</l>
<l>difference(Domain, RegionI4noPh4noIsl1, RegionIS4noPh4noIsl1)</l>
<c>*/////// removing too small Islandss from the list ////////*</c>
<l>select_shape (RegionsIslfuAll, RegionsIsl, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIsl, RegionsIsl, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIsl, nIsl)</l>
<c>*/////////////////////////////////////////////////////////*</c>
<l>* union1(RegionsIslfu2, RegionIslfu2)</l>
<l>* difference(RegionI, RegionIslfu2, RegionI)</l>
<c></c>
<c></c>
<l>* fill_up_shape (RegionI1noPh2, RegionISf2, 'area', 1, fumax)</l>
<l>* difference(Domain, RegionISf2, RegionI1noPh2noIsl1)</l>
<l>* write_object(RegionInoPHnoIsl, path+'RegionInoPHnoIsl.hobj')</l>
<c>****** region with removed defects (PH2 and Isl1)</c>
<c>************************************</c>
<l>* RegionInoD:=RegionInoPHnoIsl</l>
<c>*************************************</c>
<l>* difference(RegionIi, RegionIi2, RegionDifference)</l>
<l>* symm_difference(RegionIi, RegionIi2, RegionDifference)</l>
<c>************</c>
<l>* complement(RegionI, RegionIS)</l>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<c>*** zachem SkGR vmesto SkG?</c>
<l>* DetectOpenFU3 (SkeletonGnoR, RegionInoPHnoIsl, DirImageP, WidthImageP, RegionsOp, RegionsOpCon, 3.0, 4, d1, nOp)</l>
<l>* difference(DomainI, RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<l>DetectOpenN1 (SkeletonGnoR, RegionI4noPh4noIsl1, RegionIS4noPh4noIsl1, WidthImageP, DirImageP, RegionsOp, RegionsOpCon, R2)</l>
<l>set_system('neighborhood', 4)</l>
<c>*********</c>
<l>union1(RegionsOpCon, RegionOpCon)</l>
<l>* union2(RegionInoPHnoIsl, RegionsOpCon, RegionInoPHnoIslnoOP)</l>
<l>* stop()</l>
<l>* complement(RegionInoPHnoIsl, RegionISnoPHnoIsl)</l>
<c></c>
<l>* stop()</l>
<c>**** SHORT FillUp-based*****</c>
<l>set_system('neighborhood', 8)</l>
<c>********** new Short</c>
<c></c>
<l>DetectShortN2 (SkeletonGS, RegionI1noPh4noIsl1, RegionIS1noPh4noIsl1, WidthImageS, DirImageS, RegionG, RegionsShi, R2)</l>
<l>dev_display(RegionsShi)</l>
<c>*******</c>
<l>* DetectOpenN1 (SkeletonGnoR, RegionIf2, RegionISf2, WidthImageP, DirImageP, RegionsOp2, RegionsOpCon2, R2)</l>
<l>* DetectShortN1 (SkeletonGS, RegionIf2, RegionISf2, WidthImageS, DirImageS, RegionsShi2, R2)</l>
<c></c>
<c></c>
<l>* stop()</l>
<l>* DetectShortFU3 (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShi, 3.0, 4, nSh)</l>
<l>* DetectShortFU (SkeletonGS, RegionISnoPHnoIsl, DirImageS, WidthImageS, RegionsShio, 3.0, 4, nSh)</l>
<l>set_system('neighborhood', 4)</l>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<c>******* fixing Shorts ******</c>
<l>difference(RegionI1noPh4noIsl1, RegionRemoveSh, RegionI1noPh4noIsl1noSh1)</l>
<l>difference(RegionI2noPh4noIsl1, RegionRemoveSh, RegionI2noPh4noIsl1noSh1)</l>
<l>difference(RegionI3noPh4noIsl1, RegionRemoveSh, RegionI3noPh4noIsl1noSh1)</l>
<l>difference(RegionI4noPh4noIsl1, RegionRemoveSh, RegionI4noPh4noIsl1noSh1)</l>
<c></c>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c>***** final RegionInoD 1,2,3,4 ******</c>
<l>union2(RegionI1noPh4noIsl1noSh1, RegionOpCon, RegionInoDi)</l>
<l>difference(RegionInoDi, R, RegionInoD)</l>
<l>union2(RegionI2noPh4noIsl1noSh1, RegionOpCon, RegionInoD2i)</l>
<l>difference(RegionInoD2i, R, RegionInoD2)</l>
<l>union2(RegionI3noPh4noIsl1noSh1, RegionOpCon, RegionInoD3i)</l>
<l>difference(RegionInoD3i, R, RegionInoD3)</l>
<l>union2(RegionI4noPh4noIsl1noSh1, RegionOpCon, RegionInoD4i)</l>
<l>difference(RegionInoD4i, R, RegionInoD4)</l>
<l>connection(RegionInoD, RegionsInoDn)</l>
<l>connection(RegionInoD2, RegionsInoD2n)</l>
<l>connection(RegionInoD3, RegionsInoD3n)</l>
<l>connection(RegionInoD2, RegionsInoD2n)</l>
<l>connection(RegionInoD4, RegionsInoD4n)</l>
<l>count_seconds(s1)</l>
<l>fill_up_shape(RegionsInoDn, RegionsInoDnp,'area', 1, 30)</l>
<l>select_shape(RegionsInoDnp, RegionsInoD, 'area', 'and', 30, 99999999)</l>
<l>* difference( RegionsInoD,Domain, RegionDifference)</l>
<c>*** removing small islands and pinholes</c>
<l>fill_up_shape(RegionsInoD2n, RegionsInoD2np,'area', 1, 30)</l>
<l>select_shape(RegionsInoD2np, RegionsInoD2, 'area', 'and', 30, 99999999)</l>
<l>fill_up_shape(RegionsInoD3n, RegionsInoD3np,'area', 1, 30)</l>
<l>select_shape(RegionsInoD3np, RegionsInoD3, 'area', 'and', 30, 99999999)</l>
<l>fill_up_shape(RegionsInoD4n, RegionsInoD4np,'area', 1, 30)</l>
<l>select_shape(RegionsInoD4np, RegionsInoD4, 'area', 'and', 30, 99999999)</l>
<l>count_seconds(s2)</l>
<l>s:=s2-s1</l>
<l>* stop()</l>
<l>* get_region_points(RegionI1noPh4, Rows, Columns)</l>
<l>* tuple_max(Columns, Max1)</l>
<c></c>
<c></c>
<l>* get_region_points(RegionInoD2, Rows, Columns)</l>
<l>* tuple_max(Columns, Max2)</l>
<l>* get_region_points(RegionInoD, Rows, Columns)</l>
<l>* tuple_max(Columns, Max)</l>
<c></c>
<l>* stop()</l>
<l>intersection(RegionsShi, RegionI, RegionsSh)</l>
<l>intersection (RegionsSh, RegionGS, RegionsShm)</l>
<c></c>
<l>* connection(RegionInoD, RegionsInoD)</l>
<l>* difference (RegionsInoD, RegionsShm, RegionsInoDm)</l>
<l>* difference (RegionInoD, RegionsShm, RegionInoDm)</l>
<l>* connection(RegionInoDm, RegionsInoDmm)</l>
<l>* stop()</l>
<l>* difference(RegionIi, R, RegionI)</l>
<l>* get_domain (Im, DomainIm)</l>
<l>* complement(RegionI, RegionIS)</l>
<l>* intersection (RegionIS, DomainIm, RegionIS)</l>
<l>return ()</l>
</body>
<docu id="Preprocessing41">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImageIRB"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RC"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionI"/>
<parameter id="RegionI2"/>
<parameter id="RegionIS"/>
<parameter id="RegionIS2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoD2"/>
<parameter id="RegionInoD3"/>
<parameter id="RegionInoD4"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionInoPHnoIslnoOP"/>
<parameter id="RegionInoPHnoIslnoSh"/>
<parameter id="RegionInoPh"/>
<parameter id="RegionsInoD"/>
<parameter id="RegionsInoD2"/>
<parameter id="RegionsInoD3"/>
<parameter id="RegionsInoD4"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsIslfuAll"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsPH"/>
<parameter id="RegionsPHfuAll"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsSh"/>
<parameter id="RegonsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="aislmax"/>
<parameter id="d1"/>
<parameter id="fumax"/>
<parameter id="path"/>
<parameter id="thr"/>
<parameter id="thr2"/>
<parameter id="thr3"/>
<parameter id="thr4"/>
</parameters>
</docu>
</procedure>
<procedure name="WSelbyHist">
<interface>
<ic>
<par name="PrcWGi" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="prcmin" base_type="ctrl" dimension="0"/>
<par name="numP" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WminPa" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>create_funct_1d_array (PrcWGi, FunctionWGi)</l>
<l>smooth_funct_1d_mean (FunctionWGi, 1, 3, SmoothedFunctionWGi)</l>
<l>local_min_max_funct_1d (SmoothedFunctionWGi, 'plateaus_center', 'true', Min, Max)</l>
<l>Imax1 := int(Max)</l>
<l>Imax2 := int(Max)+1</l>
<l>get_y_value_funct_1d (FunctionWGi, Imax1, 'constant', Ymax1)</l>
<l>get_y_value_funct_1d (FunctionWGi, Imax2, 'constant', Ymax2)</l>
<l>Ymax := max2(Ymax1, Ymax2)</l>
<c></c>
<l>tuple_length (Ymax, nm)</l>
<l>WminPa := []</l>
<l>i := 0</l>
<l>for j := 0 to nm-1 by 1</l>
<l>    w := Max[j]</l>
<l>    if (w&gt;wmax)</l>
<l>        break</l>
<l>    endif</l>
<l>    y := Ymax[j]</l>
<l>    if (y &lt; prcmin)</l>
<l>        continue</l>
<l>    endif</l>
<l>    WminPa[i] := round(Max[j])</l>
<l>    i := i+1</l>
<l>    if (i&gt;=numP)</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="WSelbyHist">
<parameters>
<parameter id="PrcWGi"/>
<parameter id="WminPa"/>
<parameter id="numP"/>
<parameter id="prcmin"/>
<parameter id="wmax"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP2">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP2 v1.0, 09.02.2023</c>
<l>junctions_skeleton(SkeletonG, EndPoints, JuncPoints)</l>
<l>* gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 1, 'filter')</l>
<l>area_center(SkeletonsFWM, A,Row, Column)</l>
<l>tuple_sort_index(Row, Indices)</l>
<l>tuple_sort(A, Sorted)</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>* count_obj (SkContoursG, nSkCG)</l>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nFWM by 1</l>
<l>*     if(k==184)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>    area_center(SelectedSkeletonG, a, r, c)</l>
<l>    if(a&lt;1)</l>
<l>        continue</l>
<l>    endif</l>
<l>*     select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    gen_contours_skeleton_xld (SelectedSkeletonG, SelectedContourG, 1, 'filter')</l>
<c>    </c>
<l>*     if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c></c>
<l>    gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>    gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>    if(a&gt;0)</l>
<l>        test_subset_region(ER1, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>            col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>            gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>            intersection(Rectangle21, Domain, Rectangle21)</l>
<l>            union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle21, R21, C21)</l>
<l>            tuple_length(R21, n21)</l>
<l>            ang:=AnglesG[1]</l>
<l>            dir21:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n21, dir21, Dir21)</l>
<l>            tuple_max(R21, rm)</l>
<l>            tuple_max(C21, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<c>        </c>
<l>        test_subset_region(ER2, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<c>            </c>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>            col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>            gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.25)</l>
<l>*             gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>            intersection(Rectangle22, Domain, Rectangle22)</l>
<l>            union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle22, R22, C22)</l>
<l>            tuple_length(R22, n22)</l>
<l>            ang:=AnglesG[nA-2]</l>
<l>            dir22:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n22, dir22, Dir22)</l>
<l>            tuple_max(R22, rm)</l>
<l>            tuple_max(C22, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<l>    endif</l>
<l>    concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<l>*      get_region_points(SelectedSkeletonG, Rows, Columns)</l>
<l>*     get_grayval(WidthImageP,Rows, Columns, WR)</l>
<l>*     tuple_median(WR, wrm)</l>
<l>*     tuple_min(WR, wrm)</l>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP2">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc37">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSSpProc36 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>** 2022.09.15 MSSpProc34() modified very narrow space</c>
<c>** 2022.12.28 MSSpProc36() modified from MSPtProc36()</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [0,0,0,0,0,0]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>merr:=0</l>
<l>err:=0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>** finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>* no0:=1</l>
<l>vp := Pval[0]</l>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if (i==1 and v==1)</l>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        if (vp==0 and (vn ==pnum or vn==1))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and v==0 and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>*     if(vn==0)</l>
<l>*         no0:=0</l>
<l>*     endif</l>
<c>    </c>
<l>    vp := v</l>
<c>   </c>
<l>*     if (v==pnum)</l>
<l>*         PIntY[ii]:=yc</l>
<l>*         PIntX[ii]:=xc</l>
<l>*         PInti[ii]:=i</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>endfor</l>
<c></c>
<l>intnum:=ii</l>
<l>jSPdn:=0</l>
<l>jSPup:=ii-1</l>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>if (intnum==0 )</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<l>jSPdn := PB[0]</l>
<l>jSPup := PE[ie-1]</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<c>****Hong ****</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<c>		</c>
<l>				jSPdn := jSPdn</l>
<c></c>
<l>			else</l>
<c></c>
<l>				jSPdn := intnum - 2</l>
<l>   endif</l>
<c>   *******</c>
<l>* if(intnum==0)</l>
<l>*     w:=0.5</l>
<l>*     wmin:=0.5</l>
<l>*     return()</l>
<l>* elseif(intnum==1)</l>
<l>*     wmax:=1.0</l>
<l>*     wmin:=1.0</l>
<l>*     i:=PInti[0]</l>
<l>*     return()</l>
<l>*     intnum:=2</l>
<l>*     PInti[0]:=i-1</l>
<l>*     PInti[1]:=i+1</l>
<l>*     jSPup:=1</l>
<l>* endif</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    i:=PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i],  g)</l>
<l>*     typ:=j%2</l>
<l>*     if(g&lt;thr)</l>
<l>*         if(typ==0)</l>
<l>*             i:=i-1</l>
<l>*         else</l>
<l>*             i:=i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i],  g)    </l>
<l>*     endif</l>
<l>    PIntcor[j]:=i</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[i+1], PPx[i+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax:=max(g0)</l>
<l>*     gmin:=min(g0)</l>
<l>*     gmax:=max2(g0[0], g0[1])</l>
<l>    if(i&lt;pind-1 and i&gt;0)</l>
<l>        SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX:=PIntX[j]</l>
<l>        fIntY:=PIntY[j]</l>
<l>    endif</l>
<l>*     SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    if(err==1)</l>
<l>        merr:=1</l>
<l>    endif</l>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*         SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>* stop()</l>
<l>* gen_region_points(PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi:=PInti[i]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* previous clc </c>
<l>*         pclc:=-2</l>
<l>*         fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>* if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii]:=PPy[0]</l>
<l>*     PIntX[ii]:=PPx[0]</l>
<l>*     PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>*     get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if(Pval[0]==pnum)</l>
<l>*         PCLC[ii]:=clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii]:=-2</l>
<l>*     endif</l>
<l>*     ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>*     if(Pval[0]==1)</l>
<l>*         fi1:=1</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>*             PIntY[ii]:=PPy[0]</l>
<l>*             PIntX[ii]:=PPx[0]</l>
<l>*             PInti[ii]:=0</l>
<l>*             PCLC[ii]:=clc</l>
<l>*             PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>*             ii:=ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1:=0</l>
<l>* endif</l>
<c>***********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>*     if(fi1==1)</l>
<l>*         if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii:=ii-1</l>
<l>*             fi1:=0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1:=0</l>
<c>        * previous and next values</c>
<l>*         vp:=Pval[i-1]</l>
<l>*         vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>*         dev_set_color('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj(PC, Pc, PC)</l>
<l>*         dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>*             get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval(ImageIRBS, yc, xc, irbs)</l>
<c>*            </c>
<l>*                 PIntY[ii]:=yc</l>
<l>*                 PIntX[ii]:=xc</l>
<l>*                 PInti[ii]:=i</l>
<l>*                 Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>*                 if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>*                     ii:=ii+1</l>
<l>*                     PIntY[ii-1]:=yc-0.35*signY</l>
<l>*                     PIntX[ii-1]:=xc-0.35*signX</l>
<l>*                     Psubpix[ii-1]:=0</l>
<l>*                     PIntY[ii]:=yc+0.35*signY</l>
<l>*                     PIntX[ii]:=xc+0.35*signX</l>
<l>*                     PInti[ii]:=i</l>
<l>*                     Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<c>                </c>
<l>*                 PCLC[ii]:=clc</l>
<l>*                 PIRBS[ii]:=irbs</l>
<l>*                 ii:=ii+1</l>
<l>*                 pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>*         endif</l>
<l>*       endif</l>
<l>*     vp:=v</l>
<l>*     gp:=g</l>
<l>* endfor</l>
<c></c>
<c>*checking last MS pixel</c>
<l>* if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if(Pval[pind-1]==pnum)</l>
<l>*         get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc:=PCLC[ii-1]</l>
<l>*         irbs:=PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii]:=PPy[pind-1]</l>
<l>*     PIntX[ii]:=PPx[pind-1]</l>
<l>*     PInti[ii]:=pind-1</l>
<l>*     PCLC[ii]:=clc</l>
<l>*     ii:=ii+1</l>
<l>*     if(Pval[pind-2]==1)</l>
<l>*         PIntY[ii]:=PPy[pind-1]</l>
<l>*         PIntX[ii]:=PPx[pind-1]</l>
<l>*         PInti[ii]:=pind-1</l>
<l>*         PCLC[ii]:=clc</l>
<l>*         PIRBS[ii]:=irbs</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii]:=0</l>
<l>* endif</l>
<c>**************************</c>
<l>* gen_region_points(PInt, PIntY, PIntX) </l>
<l>* intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>* if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>*     wmin := 0.</l>
<l>*     wmax := 0.</l>
<l>*     shift:=0.</l>
<l>*     return()</l>
<l>* endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>* pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>*     g0[1] := g</l>
<l>*     if(PInti[j]&gt;0)</l>
<l>*         get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*         g0[0] := g</l>
<l>*     else</l>
<l>*         g0[0] := g0[1]</l>
<l>*     endif</l>
<l>*     if(PInti[j]&lt;pind-1)</l>
<l>*        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>*        g0[2] := g</l>
<l>*     else</l>
<l>*         g0[2] := g0[1]</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*             SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*         FIntX[j]:=fIntX</l>
<l>*         FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>*     if(g0[2]-g0[0]&gt;0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     elseif(g0[0]-g0[2]&gt;0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     if(pdir &gt; 0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     elseif(pdir &lt; 0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     pdir:=Pdir[j]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>* nmwc:=0</l>
<c>* MW segment</c>
<l>* mw:=-1</l>
<l>* dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*     get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*     if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*         clc:=0</l>
<l>*         for dx:=-3 to 3 by 1</l>
<l>*             for dy:=-3 to 3 by 1</l>
<l>*                 get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                 if(vclc!=0)</l>
<l>*                     clc:=vclc</l>
<l>*                     break</l>
<l>*                 endif</l>
<l>*             endfor</l>
<l>*         endfor</l>
<l>*         PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>*     else</l>
<l>*         PCLC[j]:=vclc</l>
<l>*     endif</l>
<l>*     Pnums[j]:=vpnums</l>
<l>* endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     pclc:=PCLC[j]</l>
<l>*     clc:=PCLC[j+1]</l>
<c>    </c>
<l>*     dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*     if(dclc&gt;clcmax)</l>
<l>*         if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*             continue</l>
<l>*         endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*         d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*         d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*         d:=sqrt( min2(d1,d2) )</l>
<l>*         if(d&lt;dmin)</l>
<l>*             mw:=j</l>
<l>*             nmwc:=nmwc+1</l>
<l>*             dmin:=d</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* if(mw==-1)</l>
<l>*     mw:=0</l>
<l>*     stop()</l>
<l>* endif</l>
<l>* dev_set_color('red')</l>
<l>* gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>* jSPdn:=mw</l>
<l>* jSPup:=mw+1</l>
<c></c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     if(j==mw)</l>
<l>*         continue</l>
<l>*     else</l>
<l>*         clc:=PCLC[j]</l>
<l>*         clc1:=PCLC[mw]</l>
<l>*         clc2:=PCLC[mw+1]</l>
<l>*         dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*         dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>*             if(j&lt;mw)</l>
<l>*                 dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPdn:=j</l>
<l>*                 endif</l>
<l>*             else</l>
<l>*                 dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPup:=j+1</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>* if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>*     stop()</l>
<l>* endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>* wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>wmin:=wmax</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc37">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain115">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain114 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<c></c>
<l>WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa)</l>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>set_system('neighborhood', 8)</l>
<l>WminP := wFWM</l>
<l>tuple_length(WminP, nWP)</l>
<c>* wside := 4 - moved to param</c>
<c>***** vector based</c>
<l>* RowsMo := []</l>
<l>* ColsMo := []</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGi-1 by 1</l>
<l>*     w := WGi[j]</l>
<l>*     for k:=0 to nWP-1 by 1</l>
<l>*         if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>*             VectorRM.insert(j, RowsGi[j])</l>
<l>*             VectorCM.insert(j, ColsGi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<c>    </c>
<l>*     if(j%100000==0)</l>
<l>*         dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMo)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMo)</l>
<l>* stop()</l>
<c>***** temp. tuple based Pattern Skel. FWM</c>
<l>* WminP := [16, 24, 68, 126]</l>
<l>* tuple_length(WminP, nWP)</l>
<l>RowsM:=[] </l>
<l>ColsM:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGi-1 by 1</l>
<c>    </c>
<l>    w := WGi[j]</l>
<l>    for k:=0 to nWP-1 by 1</l>
<l>        if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>            tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsM, RowsT, RowsM) </l>
<l>        tuple_concat(ColsM, ColsT, ColsM) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsM, RowsT, RowsM) </l>
<l>tuple_concat(ColsM, ColsT, ColsM) </l>
<c></c>
<l>* tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>* tuple_equal(ColsMo, ColsM, EqualC)</l>
<c></c>
<l>gen_region_points (Rmain, RowsM, ColsM)</l>
<l>* stop()</l>
<l>connection(Rmain, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)</l>
<l>count_obj(Regionsmain, nFWMP)</l>
<l>junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>union1(EndPoints1, EndPoints1u)</l>
<l>difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* area_center(EndPoints2, Area, Rows2, Cols2)</l>
<l>union1(EndPoints2, EndPoints2u)</l>
<l>get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP2(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<l>RegForbid := SkeletonGSi</l>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1) </l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<l>connection (SkeletonGS, SkeletonsGS)</l>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c></c>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain115">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_off_COPY_1">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c></c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off_COPY_1">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'off'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="FindWires">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonsWire" base_type="iconic" dimension="0"/>
<par name="Rnoint" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lTrmin" base_type="ctrl" dimension="0"/>
<par name="nWr" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="sgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nTr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>nWrOut := nWr</l>
<l>dilation_circle(RegionFlash, RegionFlashDl, 2.5) </l>
<l>* skeleton(RegionG, SkeletonG)</l>
<l>set_system('neighborhood',8)</l>
<c></c>
<l>pruning(SkeletonG, SkeletonGP,2)</l>
<c></c>
<l>* symm_difference(SkeletonGP, SkeletonG, RegionDifference2)</l>
<l>intersection(SkeletonGP,RegionTrace, SkeletonTr)</l>
<l>difference(SkeletonTr, RegionFlashDl, SkeletonTrnoFlDl)</l>
<l>connection(SkeletonTrnoFlDl, SkeletonsTrnoFlDl)</l>
<l>count_obj(SkeletonsTrnoFlDl, nTr)</l>
<c></c>
<l>gen_empty_obj(Wires)</l>
<l>gen_empty_obj(WiresC)</l>
<l>for j:=1 to nTr by 1</l>
<l>    select_obj(SkeletonsTrnoFlDl, Tr, j)</l>
<l>    gen_contours_skeleton_xld(Tr, ContourTr, 1, 'filter')</l>
<l>    length_xld(ContourTr, lTr)</l>
<l>    if(lTr &lt; lTrmin)</l>
<l>        continue</l>
<l>    endif</l>
<l>    concat_obj(Wires,Tr, Wires)</l>
<l>    concat_obj(WiresC,ContourTr, WiresC)</l>
<l>    nWrOut := nWrOut+1</l>
<l>endfor</l>
<c></c>
<c></c>
<l>numnz:=0</l>
<l>gen_empty_region(Rnoint)</l>
<l>gen_empty_region(SkeletonsWire)</l>
<l>for j := 1 to nWrOut by 1</l>
<l>*     j:=1692</l>
<l>    select_obj(WiresC, WiC, j)</l>
<l>    get_contour_xld (WiC, Rw, Cw)</l>
<l>    tuple_length (Rw, pN)</l>
<l>    get_grayval(DirImageP, Rw, Cw, Dirs)</l>
<l>    get_grayval(WidthImageP, Rw, Cw, Widths)</l>
<l>    Dirsi:=Dirs</l>
<l>    tuple_length(Dirs, nD)</l>
<l>    for jjj:=0 to nD-2 by 1</l>
<l>*         if(jjj==641)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>        d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>        if(d &gt; 128)</l>
<l>            d:= d-255</l>
<l>        elseif(d &lt; -128)</l>
<l>            d:= d+255</l>
<l>        endif</l>
<l>        Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>    endfor</l>
<l>    get_grayval (WidthImageP, Rw, Cw, WG)</l>
<l>    get_grayval (DirImageP, Rw, Cw, Dir)</l>
<l>    Ang := Dir*1.0*3.1415926/256.0</l>
<l>    Y1 := Rw-sin(Ang)*(WG/2+wpl-sgap)</l>
<l>    X1 := Cw+cos(Ang)*(WG/2+wpl-sgap)</l>
<l>    Y2 := Rw+sin(Ang)*(WG/2+wpl-sgap)</l>
<l>    X2 := Cw-cos(Ang)*(WG/2+wpl-sgap)</l>
<l>    YC := Rw</l>
<l>    XC := Cw</l>
<l>    gen_region_line(RegionsLines, Y1, X1, Y2, X2)</l>
<l>    gen_region_points(RegionP1, Y1, X1)</l>
<l>    gen_region_points(RegionP2, Y2, X2)</l>
<l>    gen_region_points(RegionPC, YC, XC)</l>
<l>    union2(RegionP1,RegionP2,RegionP)</l>
<c>**** finding corresponding RegionPNi ****</c>
<c>   </c>
<l>    select_region_point(RegionsPNi, RegionPNi, YC[nD/2], XC[nD/2])</l>
<l>    intersection(RegionG, RegionPNi, RegionGiPNi)</l>
<l>    intersection(RegionP, RegionGiPNi, RegionIntersection)</l>
<c>    </c>
<l>    area_center(RegionIntersection,a, r3, c3)</l>
<l>    if(a&gt;0)</l>
<c>        </c>
<c>    </c>
<l>        intersection(RegionsLines, RegionIntersection, RegionIntersection1)</l>
<l>        area_center(RegionIntersection1, Area, Row3, Column3)</l>
<l>        tuple_not(Area, Not)</l>
<l>        tuple_select_mask(X1, Not, X1s)</l>
<l>        tuple_select_mask(Y1, Not, Y1s)</l>
<l>        tuple_select_mask(X2, Not, X2s)</l>
<l>        tuple_select_mask(Y2, Not, Y2s)</l>
<l>        tuple_select_mask(XC, Not, XCs)</l>
<l>        tuple_select_mask(YC, Not, YCs)</l>
<c>        </c>
<l>        gen_region_points(RegionPCs, YCs, XCs)</l>
<l>        connection(RegionPCs, RegionPsCs)</l>
<l>        select_shape(RegionPsCs, SelectedRegions, 'area', 'and', 15, 99999999)</l>
<l>        union1(SelectedRegions, SelectedRegion)</l>
<l>        concat_obj(SkeletonsWire,SelectedRegion, SkeletonsWire)</l>
<c>        </c>
<l>        numnz:=numnz+1</l>
<c>        </c>
<l>    else</l>
<l>        concat_obj(SkeletonsWire,RegionPC, SkeletonsWire)</l>
<l>    endif</l>
<l>*     connection(RegionIntersection, RegionsIntersection)</l>
<l>*     count_obj(RegionsIntersection, nInt)</l>
<l>*     for jj:=1 to nInt by 1</l>
<l>*         select_obj(RegionsIntersection, ObjectSelected1, jj)</l>
<l>*         get_region_points(ObjectSelected1, Rows1, Columns1)</l>
<l>*         tuple_length(Rows1, l)</l>
<l>*         select_region_point(RegionsLines, Reg, Rows1[l/2], Columns1[l/2])</l>
<l>*         stop()</l>
<l>*     endfor</l>
<l>*     concat_obj(Rnoint,RegionIntersection, Rnoint)</l>
<l>*     area_center(RegionIntersection, a, Row2, Column2)</l>
<l>*     if(a&gt;0)</l>
<l>*         numnz:=numnz+1</l>
<l>*     endif</l>
<l>*     union1(RegionsLines, RegionLines)</l>
<l>*     stop()</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FindWires">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsPNi"/>
<parameter id="Rnoint"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonsWire"/>
<parameter id="WidthImageP"/>
<parameter id="lTrmin"/>
<parameter id="nTr"/>
<parameter id="nWr"/>
<parameter id="sgap"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain116">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain116 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>RegForbid := SkeletonGSi</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB==1)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    Regionsmain:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<l>count_obj(Regionsmain, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP3(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<c></c>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c></c>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain116">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP3">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP3 v1.0, 09.02.2023</c>
<c>*  230223 - fixed possible non-equal numbers of SkeletonsFWM and SkContoursG</c>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>junctions_skeleton(SkeletonFWM, EndPoints, JuncPoints)</l>
<l>* gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 1, 'filter')</l>
<l>area_center(SkeletonsFWM, A,Row, Column)</l>
<l>tuple_sort_index(Row, Indices)</l>
<l>tuple_sort(A, Sorted)</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>* count_obj (SkContoursG, nSkCG)</l>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nFWM by 1</l>
<l>    if(k==178)</l>
<l>        stop()</l>
<l>    endif</l>
<c>    </c>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>    area_center(SelectedSkeletonG, a, r, c)</l>
<l>    if(a&lt;1)</l>
<l>        continue</l>
<l>    endif</l>
<l>*     select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    gen_contours_skeleton_xld (SelectedSkeletonG, SelectedContourG, 1, 'filter')</l>
<c>    </c>
<l>*     if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c></c>
<l>    gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>    gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>    if(a&gt;0)</l>
<l>        test_subset_region(ER1, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>            col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>            gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>            intersection(Rectangle21, Domain, Rectangle21)</l>
<l>            union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle21, R21, C21)</l>
<l>            tuple_length(R21, n21)</l>
<l>            ang:=AnglesG[1]</l>
<l>            dir21:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n21, dir21, Dir21)</l>
<l>            tuple_max(R21, rm)</l>
<l>            tuple_max(C21, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<c>        </c>
<l>        test_subset_region(ER2, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<c>            </c>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>            col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>            gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.25)</l>
<l>*             gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>            intersection(Rectangle22, Domain, Rectangle22)</l>
<l>            union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle22, R22, C22)</l>
<l>            tuple_length(R22, n22)</l>
<l>            ang:=AnglesG[nA-2]</l>
<l>            dir22:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n22, dir22, Dir22)</l>
<l>            tuple_max(R22, rm)</l>
<l>            tuple_max(C22, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<l>    endif</l>
<l>    concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<l>*      get_region_points(SelectedSkeletonG, Rows, Columns)</l>
<l>*     get_grayval(WidthImageP,Rows, Columns, WR)</l>
<l>*     tuple_median(WR, wrm)</l>
<l>*     tuple_min(WR, wrm)</l>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP3">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain117">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain117 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<l>* read_object (Regionspni, 'E:/PATTERN/NS13/RegionsPNi.hobj')</l>
<l>* read_object (Skeletonsfwm, 'E:/PATTERN/NS13/SkeletonsFWM.hobj')</l>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>* difference (RegionGii, RecOvl, RegionGi)</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>RegForbid := SkeletonGSi</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires2 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    Regionsmain:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<l>count_obj(Regionsmain, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<l>ExtendedSkeletonWFMP4(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>union1(SkeletonPartsPi, SkeletonPartPi)</l>
<l>pruning(SkeletonPartPi, RegionPrune, 1)</l>
<l>connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPip</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(SkeletonsFWMp, SkeletonFWM)</l>
<c></c>
<l>difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, SkeletonFWM, SkeletonsFWM)</l>
<l>count_obj(SkeletonsFWM, nFWM)</l>
<l>union1(SkeletonsFWMSp, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<c></c>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain117">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="FindWires2">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonsWire" base_type="iconic" dimension="0"/>
<par name="Rnoint" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lTrmin" base_type="ctrl" dimension="0"/>
<par name="nWr" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="sgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nTr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>nWrOut := nWr</l>
<l>dilation_circle(RegionFlash, RegionFlashDl, 2.5) </l>
<l>* skeleton(RegionG, SkeletonG)</l>
<l>set_system('neighborhood',8)</l>
<c></c>
<l>pruning(SkeletonG, SkeletonGP,2)</l>
<c></c>
<l>* symm_difference(SkeletonGP, SkeletonG, RegionDifference2)</l>
<l>intersection(SkeletonGP,RegionTrace, SkeletonTr)</l>
<l>difference(SkeletonTr, RegionFlashDl, SkeletonTrnoFlDl)</l>
<l>connection(SkeletonTrnoFlDl, SkeletonsTrnoFlDl)</l>
<l>count_obj(SkeletonsTrnoFlDl, nTr)</l>
<c></c>
<l>gen_empty_obj(Wires)</l>
<l>gen_empty_obj(WiresC)</l>
<l>for j:=1 to nTr by 1</l>
<l>    select_obj(SkeletonsTrnoFlDl, Tr, j)</l>
<l>    gen_contours_skeleton_xld(Tr, ContourTr, 1, 'filter')</l>
<l>    length_xld(ContourTr, lTr)</l>
<l>    if(lTr &lt; lTrmin)</l>
<l>        continue</l>
<l>    endif</l>
<l>    concat_obj(Wires,Tr, Wires)</l>
<l>    concat_obj(WiresC,ContourTr, WiresC)</l>
<l>    nWrOut := nWrOut+1</l>
<l>endfor</l>
<l>dev_disp_text('Traces examined', 'window', 'top', 'left', 'black', [], [])</l>
<c></c>
<l>numnz:=0</l>
<l>gen_empty_obj(Rnoint)</l>
<l>gen_empty_obj(SkeletonsWire)</l>
<l>for j := 1 to nWrOut by 1</l>
<l>*     j:=1896</l>
<l>    if(j==613)</l>
<l>        stop()</l>
<l>    endif</l>
<l>    select_obj(WiresC, WiC, j)</l>
<l>    get_contour_xld (WiC, Rw, Cw)</l>
<l>    tuple_length (Rw, pN)</l>
<l>    if(pN &lt; 50)</l>
<l>        continue</l>
<l>    endif</l>
<l>    get_grayval(DirImageP, Rw, Cw, Dirs)</l>
<l>    get_grayval(WidthImageP, Rw, Cw, Widths)</l>
<l>    Dirsi:=Dirs</l>
<l>    tuple_length(Dirs, nD)</l>
<l>    for jjj:=0 to nD-2 by 1</l>
<l>*         if(jjj==641)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         jjj:=nD-6</l>
<l>        d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>        if(d &gt; 128)</l>
<l>            d:= d-255</l>
<l>        elseif(d &lt; -128)</l>
<l>            d:= d+255</l>
<l>        endif</l>
<l>        Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>    endfor</l>
<l>    get_grayval (WidthImageP, Rw, Cw, WG)</l>
<l>    get_grayval (DirImageP, Rw, Cw, Dir)</l>
<l>    Ang := Dir*1.0*3.1415926/256.0</l>
<l>    Y1 := Rw-sin(Ang)*(WG/2+wpl-sgap)</l>
<l>    X1 := Cw+cos(Ang)*(WG/2+wpl-sgap)</l>
<l>    Y2 := Rw+sin(Ang)*(WG/2+wpl-sgap)</l>
<l>    X2 := Cw-cos(Ang)*(WG/2+wpl-sgap)</l>
<l>    YC := Rw</l>
<l>    XC := Cw</l>
<c>        </c>
<l>    k:=nD-1</l>
<l>    gen_region_line(RegionsLines, Y1[k], X1[k], Y2[k], X2[k])</l>
<c>    </c>
<l>    select_region_point(RegionsPNi, RegionPNi, YC[nD/2], XC[nD/2])</l>
<l>    intersection(RegionG, RegionPNi, RegionGiPNi)</l>
<l>    boundary(RegionGiPNi, RegionGiPNiB, 'inner')</l>
<l>* dev_disp_text('MS built', 'window', 'top', 'left', 'black', [], []) </l>
<l>    D:=[]</l>
<l>    for k:=0 to nD-1 by 1</l>
<l>        gen_region_line(RegionLine, Y1[k], X1[k], Y2[k], X2[k])</l>
<l>        intersection(RegionGiPNiB, RegionLine, RegionIntersection2)</l>
<l>        connection(RegionIntersection2, P2s)</l>
<l>        count_obj(P2s, n2s)</l>
<l>        if(n2s!=2)</l>
<l>*             stop()</l>
<l>            d:=100</l>
<l>        else</l>
<l>            area_center(P2s, A2, Row2, Column2)</l>
<l>            distance_pp(Row2[0], Column2[0], Row2[1], Column2[1], d)</l>
<c>            </c>
<l>        endif</l>
<l>        tuple_concat(D, d, D)</l>
<l>    endfor</l>
<l>* dev_disp_text('Dist. measured', 'window', 'top', 'left', 'black', [], [])   </l>
<l>    k:=0</l>
<l>    tuple_median(D, dmed)</l>
<l>    repeat</l>
<l>     tuple_select_range(D, k, k+5, DS)</l>
<l>     tuple_max(DS, dmax)</l>
<l>     tuple_min(DS, dmin)</l>
<l>     dd:=dmax-dmin</l>
<l>     ddmed := max2( abs(dmed-dmax), abs(dmed-dmin) )</l>
<l>     k:=k+1</l>
<l>    until (dd&lt;3 and ddmed &lt; 5 and dmax!=100) </l>
<l>    k1:=k</l>
<c>    </c>
<l>    k:=0</l>
<l>    repeat</l>
<l>     tuple_select_range(D,  nD-(k+6), nD-k-1, DS)</l>
<l>     tuple_max(DS, dmax)</l>
<l>     tuple_min(DS, dmin)</l>
<l>     dd:=dmax-dmin</l>
<l>     ddmed := max2( abs(dmed-dmax), abs(dmed-dmin) )</l>
<l>     k:=k+1</l>
<l>    until (dd&lt;3 and ddmed &lt; 5 and dmax!=100)</l>
<l>    k2:=nD-k</l>
<l>    tuple_select_range(D, k1, k2, Dm)</l>
<l>    tuple_select_range(X1, k1, k2, X1m)</l>
<l>    tuple_select_range(Y1, k1, k2, Y1m)</l>
<l>    tuple_select_range(X2, k1, k2, X2m)</l>
<l>    tuple_select_range(Y2, k1, k2, Y2m)</l>
<l>    tuple_select_range(XC, k1, k2, XCm)</l>
<l>    tuple_select_range(YC, k1, k2, YCm)</l>
<l>*    stop()</l>
<l>    gen_region_points(RegionP1, Y1m, X1m)</l>
<l>    gen_region_points(RegionP2, Y2m, X2m)</l>
<l>    gen_region_points(RegionPC, YCm, XCm)</l>
<l>    union2(RegionP1,RegionP2,RegionP)</l>
<l>    dev_display(RegionPC)</l>
<c>**** finding corresponding RegionPNi ****</c>
<c>   </c>
<c></c>
<l>*     intersection(RegionP, RegionGiPNi, RegionIntersection)</l>
<c>    </c>
<l>*     area_center(RegionIntersection,a, r3, c3)</l>
<l>*     if(a&gt;1)</l>
<c>        </c>
<c>    </c>
<l>*         intersection(RegionsLines, RegionIntersection, RegionIntersection1)</l>
<l>*         area_center(RegionIntersection1, Area, Row3, Column3)</l>
<l>*         tuple_not(Area, Not)</l>
<l>*         tuple_select_mask(X1, Not, X1s)</l>
<l>*         tuple_select_mask(Y1, Not, Y1s)</l>
<l>*         tuple_select_mask(X2, Not, X2s)</l>
<l>*         tuple_select_mask(Y2, Not, Y2s)</l>
<l>*         tuple_select_mask(XC, Not, XCs)</l>
<l>*         tuple_select_mask(YC, Not, YCs)</l>
<c>        </c>
<l>*         gen_region_points(RegionPCs, YCs, XCs)</l>
<l>*         connection(RegionPCs, RegionPsCs)</l>
<l>*         select_shape(RegionPsCs, SelectedRegions, 'area', 'and', 15, 99999999)</l>
<l>*         union1(SelectedRegions, SelectedRegion)</l>
<l>*         concat_obj(SkeletonsWire,SelectedRegion, SkeletonsWire)</l>
<c>        </c>
<l>*         numnz:=numnz+1</l>
<c>        </c>
<l>*     else</l>
<l>        concat_obj(SkeletonsWire,RegionPC, SkeletonsWire)</l>
<l>*     endif</l>
<l>*     connection(RegionIntersection, RegionsIntersection)</l>
<l>*     count_obj(RegionsIntersection, nInt)</l>
<l>*     for jj:=1 to nInt by 1</l>
<l>*         select_obj(RegionsIntersection, ObjectSelected1, jj)</l>
<l>*         get_region_points(ObjectSelected1, Rows1, Columns1)</l>
<l>*         tuple_length(Rows1, l)</l>
<l>*         select_region_point(RegionsLines, Reg, Rows1[l/2], Columns1[l/2])</l>
<l>*         stop()</l>
<l>*     endfor</l>
<l>*     concat_obj(Rnoint,RegionIntersection, Rnoint)</l>
<l>*     area_center(RegionIntersection, a, Row2, Column2)</l>
<l>*     if(a&gt;0)</l>
<l>*         numnz:=numnz+1</l>
<l>*     endif</l>
<l>*     union1(RegionsLines, RegionLines)</l>
<l>*     stop()</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FindWires2">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsPNi"/>
<parameter id="Rnoint"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonsWire"/>
<parameter id="WidthImageP"/>
<parameter id="lTrmin"/>
<parameter id="nTr"/>
<parameter id="nWr"/>
<parameter id="sgap"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP4">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP4 v1.0, 11.03.2023</c>
<c>*  230223 - fixed possible non-equal numbers of SkeletonsFWM and SkContoursG</c>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>junctions_skeleton(SkeletonFWM, EndPoints, JuncPoints)</l>
<l>* gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 1, 'filter')</l>
<l>area_center(SkeletonsFWM, A,Row, Column)</l>
<l>tuple_sort_index(Row, Indices)</l>
<l>tuple_sort(A, Sorted)</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>* count_obj (SkContoursG, nSkCG)</l>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nFWM by 1</l>
<l>*     if(k==178)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>    area_center(SelectedSkeletonG, a, r, c)</l>
<l>    if(a&lt;1)</l>
<l>        continue</l>
<l>    endif</l>
<l>*     select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    gen_contours_skeleton_xld (SelectedSkeletonG, SelectedContourG, 1, 'filter')</l>
<c>    </c>
<l>*     if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<c>    </c>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length(AnglesG, nA)</l>
<c></c>
<l>    gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>    gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>    if(a&gt;0)</l>
<l>        test_subset_region(ER1, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>            col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>            gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>            intersection(Rectangle21, Domain, Rectangle21)</l>
<l>            union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle21, R21, C21)</l>
<l>            tuple_length(R21, n21)</l>
<l>            ang:=AnglesG[1]</l>
<l>            dir21:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n21, dir21, Dir21)</l>
<l>            tuple_max(R21, rm)</l>
<l>            tuple_max(C21, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<c>        </c>
<l>        test_subset_region(ER2, EndPoints, IsSubset)</l>
<l>        if(IsSubset==0)</l>
<l>            gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>            intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>            if(elengthnoend &gt; 0)</l>
<l>                union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            else</l>
<l>                difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>            endif</l>
<c>            </c>
<l>            nsk:=nsk+1</l>
<l>        else</l>
<l>            row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>            col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>            gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.25)</l>
<l>*             gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>            intersection(Rectangle22, Domain, Rectangle22)</l>
<l>            union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>            get_region_points(Rectangle22, R22, C22)</l>
<l>            tuple_length(R22, n22)</l>
<l>            ang:=AnglesG[nA-2]</l>
<l>            dir22:= (ang-1.57)*256/3.14159</l>
<l>            tuple_gen_const(n22, dir22, Dir22)</l>
<l>            tuple_max(R22, rm)</l>
<l>            tuple_max(C22, cm)</l>
<l>            if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>            nrec:=nrec+1</l>
<l>        endif</l>
<l>    endif</l>
<l>    concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<l>*      get_region_points(SelectedSkeletonG, Rows, Columns)</l>
<l>*     get_grayval(WidthImageP,Rows, Columns, WR)</l>
<l>*     tuple_median(WR, wrm)</l>
<l>*     tuple_min(WR, wrm)</l>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP4">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain118">
<interface>
<io>
<par name="R" base_type="iconic" dimension="0"/>
<par name="RecOvl" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="Cr" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain118 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>difference (RegionGii, RecOvl, RegionGi)</l>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<l>closing_circle (RegionGi, RegionGi, 1)</l>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference(R, RegionGid, RmnoG)</l>
<l>* R:=RmnoG</l>
<l>ROut := R</l>
<l>union2 (ROut, RecOvl, ROut)</l>
<l>difference (DomainG, R, RC)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGi, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<c></c>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGS)</l>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>RegForbid := SkeletonGSi</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle(R, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    Regionsmain:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<l>count_obj(Regionsmain, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(Regionsmain, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>count_obj(RegionsmainPNi, nRMPNI)</l>
<c></c>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference(SkeletonPartsPi, R, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPip</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference(Regionsmain, R, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>SkeletonsFWM:=SkeletonPartsP</l>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>ncut:=1000000</l>
<l>tuple_length(X1, nMS)</l>
<l>n:=nMS/ncut</l>
<l>gen_empty_obj(RegionMSLines)</l>
<l>for j:=0 to n-1 by 1</l>
<l>    tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>    tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>    tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>    tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>    gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>    union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>endfor</l>
<l>tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain118">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="Cr"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="DomainG"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="R"/>
<parameter id="ROut"/>
<parameter id="RecOvl"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP5">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP5 v1.0, 11.03.2023</c>
<c>*  230313 - added skel. parts having multiple regions</c>
<c>*  230223 - fixed possible non-equal numbers of SkeletonsFWM and SkContoursG</c>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>* junctions_skeleton(SkeletonFWM, EndPoints, JuncPoints)</l>
<l>junctions_skeleton(SkeletonG, EndPoints, JuncPoints)</l>
<l>* dilation_circle(EndPoints, EndPointsd, 1.5)</l>
<l>dilation_rectangle1(EndPoints, EndPointsd, 2.5,2.5)</l>
<l>union1(EndPointsd, EndPointd)</l>
<l>* gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 1, 'filter')</l>
<l>area_center(SkeletonsFWM, A,Row, Column)</l>
<l>tuple_sort_index(Row, Indices)</l>
<l>tuple_sort(A, Sorted)</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>* count_obj (SkContoursG, nSkCG)</l>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>get_domain(WidthImageP,Domain)</l>
<l>dilation_circle(SkeletonG, SkeletonGd, 1)</l>
<l>difference(Domain, SkeletonGd, NoSkeletonG)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nFWM by 1</l>
<l>*     if(k==65)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>    connection(SelectedSkeletonG, SelectedSkeletonsG)</l>
<l>    count_obj(SelectedSkeletonsG, nSSG)</l>
<l>    for kk := 1 to nSSG by 1</l>
<l>        select_obj(SelectedSkeletonsG, SSG, kk)</l>
<l>        area_center(SSG, a, r, c)</l>
<l>        if(a&lt;10)</l>
<l>            continue</l>
<l>        endif</l>
<l>*         select_obj (SkContoursG, SelectedContourG, k)</l>
<l>        gen_contours_skeleton_xld (SSG, SelectedContourG, 1, 'filter')</l>
<c>        </c>
<l>*         if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>        contour_point_num_xld (SelectedContourG, np)</l>
<l>        get_contour_xld (SelectedContourG, RowG, ColG)</l>
<c>        </c>
<l>        gen_region_points (RegionSCG, RowG, ColG)</l>
<l>        if (np &lt; 21)</l>
<l>            lookaround := 1</l>
<l>        else</l>
<l>            lookaround := 3</l>
<l>        endif</l>
<c>        </c>
<l>        get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>        tuple_length(AnglesG, nA)</l>
<c>    </c>
<l>        gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>        gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>        if(a&gt;0)</l>
<l>            test_subset_region(ER1, EndPointd, IsSubset)</l>
<l>            *if(IsSubset==1)</l>
<l>            if(IsSubset&lt;=1)</l>
<l>                gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>                intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>*                 get_system('neighborhood', nb)</l>
<l>*                 set_system('neighborhood', 8)</l>
<l>                gen_region_points(P, RowG[0], ColG[0])</l>
<l>                expand_region(P, NoSkeletonG, Pe, abs(elengthnoend),'image')</l>
<c>                </c>
<l>*                 set_system('neighborhood', nb)</l>
<l>                if(elengthnoend &gt; 0)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                else</l>
<l>*                     difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                    difference(SelectedSkeletonG, Pe, SelectedSkeletonG)</l>
<l>                endif</l>
<l>                nsk:=nsk+1</l>
<l>            else</l>
<l>                row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>                col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>                gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>                intersection(Rectangle21, Domain, Rectangle21)</l>
<l>                union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>                get_region_points(Rectangle21, R21, C21)</l>
<l>                tuple_length(R21, n21)</l>
<l>                ang:=AnglesG[1]</l>
<l>                dir21:= (ang-1.57)*256/3.14159</l>
<l>                tuple_gen_const(n21, dir21, Dir21)</l>
<l>                tuple_max(R21, rm)</l>
<l>                tuple_max(C21, cm)</l>
<l>                if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                    stop()</l>
<l>                endif</l>
<l>                set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>                nrec:=nrec+1</l>
<l>            endif</l>
<c>            </c>
<l>            test_subset_region(ER2, EndPointd, IsSubset)</l>
<l>            if(IsSubset&lt;=1)</l>
<l>                gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>                intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>                gen_region_points(P, RowG[nA-1], ColG[nA-1])</l>
<l>                expand_region(P, NoSkeletonG, Pe, abs(elengthnoend),'image')</l>
<l>                if(elengthnoend &gt; 0)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                else</l>
<l>*                     difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                    difference(SelectedSkeletonG, Pe, SelectedSkeletonG)</l>
<l>                endif</l>
<c>                </c>
<l>                nsk:=nsk+1</l>
<l>            else</l>
<l>                row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>                col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>                gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.01)</l>
<l>*                 gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>                intersection(Rectangle22, Domain, Rectangle22)</l>
<l>                union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>                get_region_points(Rectangle22, R22, C22)</l>
<l>                tuple_length(R22, n22)</l>
<l>                ang:=AnglesG[nA-2]</l>
<l>                dir22:= (ang-1.57)*256/3.14159</l>
<l>                tuple_gen_const(n22, dir22, Dir22)</l>
<l>                tuple_max(R22, rm)</l>
<l>                tuple_max(C22, cm)</l>
<l>                if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                    stop()</l>
<l>                endif</l>
<l>                set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>                nrec:=nrec+1</l>
<l>            endif</l>
<l>        endif</l>
<l>        concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<l>*      get_region_points(SelectedSkeletonG, Rows, Columns)</l>
<l>*     get_grayval(WidthImageP,Rows, Columns, WR)</l>
<l>*     tuple_median(WR, wrm)</l>
<l>*     tuple_min(WR, wrm)</l>
<l>    endfor</l>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP5">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="FindWires3">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonsWire" base_type="iconic" dimension="0"/>
<par name="Rnoint" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lTrmin" base_type="ctrl" dimension="0"/>
<par name="nWr" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="sgap" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nTr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>nWrOut := nWr</l>
<l>dilation_circle(RegionFlash, RegionFlashDl, 2.5) </l>
<l>* skeleton(RegionG, SkeletonG)</l>
<l>set_system('neighborhood',8)</l>
<c></c>
<l>pruning(SkeletonG, SkeletonGP,2)</l>
<c></c>
<l>* symm_difference(SkeletonGP, SkeletonG, RegionDifference2)</l>
<l>intersection(SkeletonGP,RegionTrace, SkeletonTr)</l>
<l>difference(SkeletonTr, RegionFlashDl, SkeletonTrnoFlDl)</l>
<l>connection(SkeletonTrnoFlDl, SkeletonsTrnoFlDl)</l>
<l>count_obj(SkeletonsTrnoFlDl, nTr)</l>
<c></c>
<l>gen_empty_obj(Wires)</l>
<l>gen_empty_obj(WiresC)</l>
<l>for j:=1 to nTr by 1</l>
<l>    select_obj(SkeletonsTrnoFlDl, Tr, j)</l>
<l>    gen_contours_skeleton_xld(Tr, ContourTr, 1, 'filter')</l>
<l>    length_xld(ContourTr, lTr)</l>
<l>    if(lTr &lt; lTrmin)</l>
<l>        continue</l>
<l>    endif</l>
<l>    concat_obj(Wires,Tr, Wires)</l>
<l>    concat_obj(WiresC,ContourTr, WiresC)</l>
<l>    nWrOut := nWrOut+1</l>
<l>endfor</l>
<l>dev_disp_text('Traces examined', 'window', 'top', 'left', 'black', [], [])</l>
<c></c>
<l>numnz:=0</l>
<l>gen_empty_obj(Rnoint)</l>
<l>gen_empty_obj(SkeletonsWire)</l>
<l>for j := 1 to nWrOut by 1</l>
<l>*     j:=1896</l>
<l>*     if(j==1386)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(WiresC, WiC, j)</l>
<l>    get_contour_xld (WiC, Rw, Cw)</l>
<l>    tuple_length (Rw, pN)</l>
<l>    if(pN &lt; 50)</l>
<l>        continue</l>
<l>    endif</l>
<l>    get_grayval(DirImageP, Rw, Cw, Dirs)</l>
<l>    get_grayval(WidthImageP, Rw, Cw, Widths)</l>
<l>    Dirsi:=Dirs</l>
<l>    tuple_length(Dirs, nD)</l>
<l>    for jjj:=0 to nD-2 by 1</l>
<l>*         if(jjj==641)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         jjj:=nD-6</l>
<l>        d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>        if(d &gt; 128)</l>
<l>            d:= d-255</l>
<l>        elseif(d &lt; -128)</l>
<l>            d:= d+255</l>
<l>        endif</l>
<l>        Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>    endfor</l>
<l>    get_grayval (WidthImageP, Rw, Cw, WG)</l>
<l>    get_grayval (DirImageP, Rw, Cw, Dir)</l>
<l>    Ang := Dir*1.0*3.1415926/256.0</l>
<l>    Y1 := Rw-sin(Ang)*(WG/2+wpl-sgap)</l>
<l>    X1 := Cw+cos(Ang)*(WG/2+wpl-sgap)</l>
<l>    Y2 := Rw+sin(Ang)*(WG/2+wpl-sgap)</l>
<l>    X2 := Cw-cos(Ang)*(WG/2+wpl-sgap)</l>
<l>    YC := Rw</l>
<l>    XC := Cw</l>
<c>        </c>
<l>    k:=nD-1</l>
<l>    gen_region_line(RegionsLines, Y1[k], X1[k], Y2[k], X2[k])</l>
<c>    </c>
<l>    select_region_point(RegionsPNi, RegionPNi, YC[nD/2], XC[nD/2])</l>
<l>    intersection(RegionG, RegionPNi, RegionGiPNi)</l>
<l>    boundary(RegionGiPNi, RegionGiPNiB, 'inner')</l>
<l>* dev_disp_text('MS built', 'window', 'top', 'left', 'black', [], []) </l>
<l>    D:=[]</l>
<l>    for k:=0 to nD-1 by 1</l>
<l>        gen_region_line(RegionLine, Y1[k], X1[k], Y2[k], X2[k])</l>
<l>        intersection(RegionGiPNiB, RegionLine, RegionIntersection2)</l>
<l>        connection(RegionIntersection2, P2s)</l>
<l>        count_obj(P2s, n2s)</l>
<l>        if(n2s!=2)</l>
<l>*             stop()</l>
<l>            d:=100</l>
<l>        else</l>
<l>            area_center(P2s, A2, Row2, Column2)</l>
<l>            distance_pp(Row2[0], Column2[0], Row2[1], Column2[1], d)</l>
<c>            </c>
<l>        endif</l>
<l>        tuple_concat(D, d, D)</l>
<l>    endfor</l>
<l>* dev_disp_text('Dist. measured', 'window', 'top', 'left', 'black', [], [])   </l>
<l>    k:=0</l>
<l>    tuple_select_range(D, 0, nD/2-1, Db) </l>
<l>    tuple_histo_range(Db,0, 100, 50, Histo, BinSize)</l>
<l>    tuple_sort_index(Histo, Indices)</l>
<l>    tuple_inverse(Indices, Inverted)</l>
<l>    dmedb:=Inverted[0]*2</l>
<l>    repeat</l>
<l>     tuple_select_range(D, k, k+5, DS)</l>
<l>     tuple_max(DS, dmax)</l>
<l>     tuple_min(DS, dmin)</l>
<l>     dd:=dmax-dmin</l>
<l>     ddmed := max2( abs(dmedb-dmax), abs(dmedb-dmin) )</l>
<l>     k:=k+1</l>
<l>    until (dd&lt;3 and ddmed &lt; 5 and dmax!=100) </l>
<l>    *until (dd&lt;3 and ddmed &lt; 5 and dmax!=100 or k&gt;nD-6) </l>
<l>    k1:=k</l>
<l>*   stop()  </l>
<l>    k:=0</l>
<l>*     tuple_select_range(D, nD-db-1, nD-db, De) </l>
<l>*     tuple_median(De, dmede)</l>
<l>     tuple_select_range(D, nD/2, nD-1, De) </l>
<l>    tuple_histo_range(De,0, 100, 50, Histo, BinSize)</l>
<l>    tuple_sort_index(Histo, Indices)</l>
<l>    tuple_inverse(Indices, Inverted)</l>
<l>    dmede:=Inverted[0]*2</l>
<l>    repeat</l>
<c>    </c>
<l>     tuple_select_range(D,  nD-(k+6), nD-k-1, DS)</l>
<l>     tuple_max(DS, dmax)</l>
<l>     tuple_min(DS, dmin)</l>
<l>     dd:=dmax-dmin</l>
<c>     </c>
<l>     ddmed := max2( abs(dmede-dmax), abs(dmede-dmin) )</l>
<l>     k:=k+1</l>
<l>    until (dd&lt;3 and ddmed &lt; 5 and dmax!=100)</l>
<l>    k2:=nD-k</l>
<l>*     stop()</l>
<l>    tuple_select_range(D, k1, k2, Dm)</l>
<l>    tuple_select_range(X1, k1, k2, X1m)</l>
<l>    tuple_select_range(Y1, k1, k2, Y1m)</l>
<l>    tuple_select_range(X2, k1, k2, X2m)</l>
<l>    tuple_select_range(Y2, k1, k2, Y2m)</l>
<l>    tuple_select_range(XC, k1, k2, XCm)</l>
<l>    tuple_select_range(YC, k1, k2, YCm)</l>
<l>*    stop()</l>
<l>    gen_region_points(RegionP1, Y1m, X1m)</l>
<l>    gen_region_points(RegionP2, Y2m, X2m)</l>
<l>    gen_region_points(RegionPC, YCm, XCm)</l>
<l>    union2(RegionP1,RegionP2,RegionP)</l>
<l>    dev_display(RegionPC)</l>
<c>**** finding corresponding RegionPNi ****</c>
<c>   </c>
<c></c>
<l>*     intersection(RegionP, RegionGiPNi, RegionIntersection)</l>
<c>    </c>
<l>*     area_center(RegionIntersection,a, r3, c3)</l>
<l>*     if(a&gt;1)</l>
<c>        </c>
<c>    </c>
<l>*         intersection(RegionsLines, RegionIntersection, RegionIntersection1)</l>
<l>*         area_center(RegionIntersection1, Area, Row3, Column3)</l>
<l>*         tuple_not(Area, Not)</l>
<l>*         tuple_select_mask(X1, Not, X1s)</l>
<l>*         tuple_select_mask(Y1, Not, Y1s)</l>
<l>*         tuple_select_mask(X2, Not, X2s)</l>
<l>*         tuple_select_mask(Y2, Not, Y2s)</l>
<l>*         tuple_select_mask(XC, Not, XCs)</l>
<l>*         tuple_select_mask(YC, Not, YCs)</l>
<c>        </c>
<l>*         gen_region_points(RegionPCs, YCs, XCs)</l>
<l>*         connection(RegionPCs, RegionPsCs)</l>
<l>*         select_shape(RegionPsCs, SelectedRegions, 'area', 'and', 15, 99999999)</l>
<l>*         union1(SelectedRegions, SelectedRegion)</l>
<l>*         concat_obj(SkeletonsWire,SelectedRegion, SkeletonsWire)</l>
<c>        </c>
<l>*         numnz:=numnz+1</l>
<c>        </c>
<l>*     else</l>
<l>        concat_obj(SkeletonsWire,RegionPC, SkeletonsWire)</l>
<l>*     endif</l>
<l>*     connection(RegionIntersection, RegionsIntersection)</l>
<l>*     count_obj(RegionsIntersection, nInt)</l>
<l>*     for jj:=1 to nInt by 1</l>
<l>*         select_obj(RegionsIntersection, ObjectSelected1, jj)</l>
<l>*         get_region_points(ObjectSelected1, Rows1, Columns1)</l>
<l>*         tuple_length(Rows1, l)</l>
<l>*         select_region_point(RegionsLines, Reg, Rows1[l/2], Columns1[l/2])</l>
<l>*         stop()</l>
<l>*     endfor</l>
<l>*     concat_obj(Rnoint,RegionIntersection, Rnoint)</l>
<l>*     area_center(RegionIntersection, a, Row2, Column2)</l>
<l>*     if(a&gt;0)</l>
<l>*         numnz:=numnz+1</l>
<l>*     endif</l>
<l>*     union1(RegionsLines, RegionLines)</l>
<l>*     stop()</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="FindWires3">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsPNi"/>
<parameter id="Rnoint"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonsWire"/>
<parameter id="WidthImageP"/>
<parameter id="lTrmin"/>
<parameter id="nTr"/>
<parameter id="nWr"/>
<parameter id="sgap"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="FindMissing">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="missz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length (W, nW)</l>
<l>* Def := []</l>
<l>im1 := 0</l>
<l>for j := 0 to nW-1 by 1</l>
<c></c>
<l>    if(W[j]==0)</l>
<l>        im1:=im1+1</l>
<l>    else</l>
<l>        break</l>
<l>    endif</l>
<l>*     tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<l>if(im1&gt;=missz)</l>
<l>    tuple_gen_const(im1, 1, Def1)</l>
<l>else </l>
<l>    Def1:=[]</l>
<l>endif</l>
<c></c>
<l>im2 := 0</l>
<l>for j := nW-1 to 0 by -1</l>
<c></c>
<l>    if(W[j]==0)</l>
<l>        im2:=im2+1</l>
<l>    else</l>
<l>        break</l>
<l>    endif</l>
<l>*     tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<l>if(im2&gt;=missz)</l>
<l>    tuple_gen_const(im2, 1, Def2)</l>
<l>else </l>
<l>    Def2:=[]</l>
<l>endif</l>
<c></c>
<l>tuple_gen_const(nW-1-im1-im2, 0, Zer)</l>
<l>tuple_concat(Def1, Zer, Def)</l>
<l>tuple_concat(Def, Def2, Def)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="FindMissing">
<parameters>
<parameter id="Def"/>
<parameter id="W"/>
<parameter id="missz"/>
</parameters>
</docu>
</procedure>
<procedure name="RemoveSmallCorners">
<interface>
<io>
<par name="ConnectedRegionsG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ConnectedRegionsGnC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="amin" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="n" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>select_region_point(ConnectedRegionsG, DestRegions11, Row1, Column1)</l>
<l>select_region_point(ConnectedRegionsG, DestRegions12, Row1, Column2)</l>
<l>select_region_point(ConnectedRegionsG, DestRegions21, Row2, Column1)</l>
<l>select_region_point(ConnectedRegionsG, DestRegions22, Row2, Column2)</l>
<l>area_center(DestRegions11, a11, r11, c11)</l>
<l>area_center(DestRegions12, a12, r12, c12)</l>
<l>area_center(DestRegions21, a21, r21, c21)</l>
<l>area_center(DestRegions22, a22, r22, c22)</l>
<l>* amin:=20</l>
<l>gen_empty_obj(RegionCorner)</l>
<l>if(a11&lt;amin)</l>
<l>    union2(RegionCorner, DestRegions11, RegionCorner)</l>
<l>endif</l>
<l>if(a12&lt;amin)</l>
<l>    union2(RegionCorner, DestRegions12, RegionCorner)</l>
<l>endif</l>
<l>if(a21&lt;amin)</l>
<l>    union2(RegionCorner, DestRegions21, RegionCorner)</l>
<l>endif</l>
<l>if(a22&lt;amin)</l>
<l>    union2(RegionCorner, DestRegions22, RegionCorner)</l>
<l>endif</l>
<l>* union2(DestRegions11, DestRegions12, RegionCorner)</l>
<l>* union2(RegionCorner, DestRegions21, RegionCorner)</l>
<l>* union2(RegionCorner, DestRegions22, RegionCorner)</l>
<l>union1(ConnectedRegionsG, ConnectedRegionG)</l>
<l>difference(ConnectedRegionG, RegionCorner, ConnectedRegionGnC)</l>
<l>connection(ConnectedRegionGnC, ConnectedRegionsGnCi)</l>
<l>select_shape(ConnectedRegionsGnCi, ConnectedRegionsGnC, 'area', 'and', amin, 9999999)</l>
<l>count_obj(ConnectedRegionsGnC, n)</l>
<l>return ()</l>
</body>
<docu id="RemoveSmallCorners">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="ConnectedRegionsG"/>
<parameter id="ConnectedRegionsGnC"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="amin"/>
<parameter id="n"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN3">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN3 : new detect short proc. 19.01.2023</c>
<c>*** remowed last SkeletonGS contour</c>
<c></c>
<l>* get_domain(WidthImageS, Domain)</l>
<l>* boundary(Domain, DomainB, 'inner')</l>
<l>* get_image_size(WidthImageS,Width, Height)</l>
<l>* gen_rectangle1(RB, bdist,bdist,Height- bdist, Width-bdist)</l>
<c>** for rectengular outer shape</c>
<l>region_features(RegionG, 'row1', r1)</l>
<l>region_features(RegionG, 'column1', c1)</l>
<l>region_features(RegionG, 'row2', r2)</l>
<l>region_features(RegionG, 'column2', c2)</l>
<l>gen_rectangle1(RB, r1,c1,r2,c2)</l>
<c></c>
<l>* fill_up(RegionG, RegionFillUpG)</l>
<c>** for arbitrary outer shape</c>
<l>* closing_circle(RegionG, RB, 101)</l>
<c></c>
<l>intersection(SkeletonGS, RB, SkeletonGSnoB)</l>
<l>intersection(SkeletonGSnoB, RegionInoPHnoIsl, ShCandAll)</l>
<c></c>
<l>* intersection(ShCandAlli, RegionCheck, ShCandAll)</l>
<l>* set_system('neighborhood', 8)</l>
<l>connection(ShCandAll, ShCands)</l>
<l>* set_system('neighborhood', 8)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>for j:=1 to nShCands by 1</l>
<l>*     intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*     connection(RInt, RInts)</l>
<l>*     if(j==56)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(j==1237)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*      if(j==1008)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(ShCands, ShCand, j)</l>
<l>    area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>    get_region_points(ShCand, Rows, Columns)</l>
<l>    get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>    tuple_median(SpW, spw)</l>
<l>    get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>    tuple_median(SpD, spd)</l>
<l>    sa:=spd*3.14159/256</l>
<l>    if(spw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+10, Length2+spw+10)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    endif</l>
<c>    </c>
<l>*     gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>    connection(RegionISR2, RegionsISR2)</l>
<l>    intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>    connection(RegionGSR2, RegionsGSR2)</l>
<l>    count_obj(RegionsGSR2, nGSR2)</l>
<l>    for jj:=1 to nGSR2 by 1</l>
<l>        select_obj(RegionsGSR2, Rsel, jj)</l>
<l>        test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGSR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGSR2, Rskel, jj)</l>
<l>    get_region_points(Rskel, Rowsrs, Columnsrs)</l>
<l>    tuple_length(Rowsrs, l)</l>
<l>    skcrow:=Rowsrs[l/2]</l>
<l>    skccol:=Columnsrs[l/2]</l>
<c>    </c>
<l>    distance_pp(Rowsrs[0], Columnsrs[0], Rowsrs[l-1], Columnsrs[l-1],lr)</l>
<c>    </c>
<l>    dilation_circle(Rskel, Rskeld, 1)</l>
<l>    intersection( RegionsISR2,Rskeld, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Rowi, Columni)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_sum(Area, asum)</l>
<l>    tuple_select_mask(Rowi, int(Rowi), Rowrnonz)</l>
<l>    tuple_select_mask(Columni, int(Columni), Columnrnonz)</l>
<c> </c>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    tuple_gen_const(nArnonz, skcrow, Skcrow)</l>
<l>    tuple_gen_const(nArnonz, skccol, Skccol)</l>
<l>    distance_pp(Rowrnonz, Columnrnonz, Skcrow, Skccol, Dr)</l>
<c>    </c>
<l>    if(nArnonz&gt;0)</l>
<l>        Mr:=min(Dr)</l>
<l>    else </l>
<l>        Mr:=10</l>
<l>    endif</l>
<c>    ***</c>
<l>*     intersection(RegionG, R2, RegionGR2)</l>
<c>    </c>
<c>    ***</c>
<l>    if(nArnonz &gt; 1 and Mr &lt; lr/2 and asum&gt;15)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<l>        concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortN3">
<parameters>
<parameter id="DirImageS"/>
<parameter id="R2"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN3">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN3 : new detect open proc. 11.08.2022</c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==1233)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+ppw, Length2+ppw+ppw)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskeli, jj)</l>
<l>    dilation_circle(Rskeli,Rskel, 3) </l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>        concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>         dilation_circle(Rskel, RskelSd, 1)</l>
<l>         concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*        stop()</l>
<l>*     elseif(AreaC &gt; 10)</l>
<l>*         dilation_circle(OpCand, OpCandd, 3) </l>
<l>*         intersection(OpCandd, RegionIR2, RegionIntCandI)</l>
<l>*         connection(RegionIntCandI, RegionsIntCandI)</l>
<l>*         count_obj(RegionsIntCandI, n)</l>
<l>*         if(n==2)</l>
<l>*             intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>*             concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>*             dilation_circle(Rskel, RskelSd, 1)</l>
<l>*             concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*         endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN3">
<parameters>
<parameter id="DirImageP"/>
<parameter id="R2"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="ShortOpenPreps">
<interface>
<io>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoPhnoIsl" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonI" base_type="iconic" dimension="0"/>
<par name="EndPointsI" base_type="iconic" dimension="0"/>
<par name="JuncPointsI" base_type="iconic" dimension="0"/>
<par name="SkelPointsI" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
<par name="RegionFWMdil" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dilFWM" base_type="ctrl" dimension="0"/>
<par name="dilS" base_type="ctrl" dimension="0"/>
<par name="ClS" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dilation_circle(RegionFWM, RegionFWMdil, dilFWM)</l>
<l>intersection (RegionInoPhnoIsl, RegionFWMdil, RegSkel)</l>
<l>skeleton(RegSkel, SkeletonI)</l>
<l>* pruning(SkeletonI, SkeletonIPrune, 2)</l>
<l>junctions_skeleton(SkeletonI, EndPointsI, JuncPointsI)</l>
<l>union2(EndPointsI, JuncPointsI, SkelPointsIi)</l>
<l>dilation_circle(SkelPointsIi, SkelPointsI, dilS)</l>
<c></c>
<l>RegionCheck:=SkelPointsI</l>
<l>difference(RegionI,RegionFWM,  RDif)</l>
<l>opening_circle(RDif, RegionClosing, ClS)</l>
<l>union2(RegionCheck, RegionClosing, RegionCheck)</l>
<l>return ()</l>
</body>
<docu id="ShortOpenPreps">
<parameters>
<parameter id="ClS"/>
<parameter id="EndPointsI"/>
<parameter id="JuncPointsI"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionFWMdil"/>
<parameter id="RegionI"/>
<parameter id="RegionInoPhnoIsl"/>
<parameter id="SkelPointsI"/>
<parameter id="SkeletonI"/>
<parameter id="dilFWM"/>
<parameter id="dilS"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN31">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN3 : new detect short proc. 19.01.2023</c>
<c>*** remowed last SkeletonGS contour</c>
<c></c>
<l>* get_domain(WidthImageS, Domain)</l>
<l>* boundary(Domain, DomainB, 'inner')</l>
<l>* get_image_size(WidthImageS,Width, Height)</l>
<l>* gen_rectangle1(RB, bdist,bdist,Height- bdist, Width-bdist)</l>
<c>** for rectengular outer shape</c>
<l>region_features(RegionG, 'row1', r1)</l>
<l>region_features(RegionG, 'column1', c1)</l>
<l>region_features(RegionG, 'row2', r2)</l>
<l>region_features(RegionG, 'column2', c2)</l>
<l>gen_rectangle1(RB, r1,c1,r2,c2)</l>
<c></c>
<l>* fill_up(RegionG, RegionFillUpG)</l>
<c>** for arbitrary outer shape</c>
<l>* closing_circle(RegionG, RB, 101)</l>
<c></c>
<l>intersection(SkeletonGS, RB, SkeletonGSnoB)</l>
<l>intersection(SkeletonGSnoB, RegionInoPHnoIsl, ShCandAlli)</l>
<c></c>
<l>intersection(ShCandAlli, RegionCheck, ShCandAll)</l>
<c></c>
<l>connection(ShCandAll, ShCands)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>for j:=1 to nShCands by 1</l>
<l>*     intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*     connection(RInt, RInts)</l>
<l>*     if(j==544)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(ShCands, ShCand, j)</l>
<l>    area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>    get_region_points(ShCand, Rows, Columns)</l>
<l>    get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>    tuple_median(SpW, spw)</l>
<l>    get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>    tuple_median(SpD, spd)</l>
<l>    sa:=spd*3.14159/256</l>
<l>    if(spw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+12, Length2+spw+12)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    endif</l>
<c>    </c>
<l>*     gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>    connection(RegionISR2, RegionsISR2)</l>
<l>    count_obj(RegionsISR2, nI)</l>
<l>    intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>    connection(RegionGSR2, RegionsGSR2)</l>
<l>    count_obj(RegionsGSR2, nGSR2)</l>
<l>    for jj:=1 to nGSR2 by 1</l>
<l>        select_obj(RegionsGSR2, Rsel, jj)</l>
<l>        test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGSR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGSR2, Rskel, jj)</l>
<l>    intersection( RegionsISR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<c>    ***</c>
<l>    intersection(RegionGS, R2, RegionGSR2r)</l>
<l>    count_obj(RegionGSR2r, nGS)</l>
<c>    ***</c>
<l>    if(nArnonz &gt; 1 or nI&gt;nGS)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<l>        concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortN31">
<parameters>
<parameter id="DirImageS"/>
<parameter id="R2"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc38">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc38 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.04.01 dual int point</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn:=0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>skipnext:=0</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    if(skipnext==1)</l>
<l>        skipnext:=0</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    xc := PPx[i]</l>
<l>*     if (xc==3066)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<c>    </c>
<l>    if (i==1 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<c>        *** reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<c>        *** met wrong region, so reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        *if (vp==0 and (vn ==pnum or vn==1))</l>
<c>    *** 2 points ******</c>
<c>    * changed index ip</c>
<l>    ip:=ii</l>
<l>*     skipnext:=0</l>
<l>        if(vp==pnum)</l>
<l>            skipnext:=1</l>
<l>            if(vn==0)</l>
<l>                btype := -1</l>
<l>            elseif(vn==1)</l>
<l>                btype := 1</l>
<l>            elseif(vn==pnum)</l>
<l>                btype := 1</l>
<l>            endif</l>
<l>            if(gv&gt;gvp)</l>
<l>                ip:=ii-1</l>
<l>            endif</l>
<l>        *endif</l>
<c>    *******************         </c>
<l>        elseif (vp==0 and (vn ==pnum or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif ( (vn==1 and vp==pnum) or (vp==1 and vn==pnum))</l>
<l>            btype := 1</l>
<c>        </c>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ip+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and (v==1 or v==pnum) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>*         ii := ip+1</l>
<l>    endif</l>
<c>    </c>
<l>    vp := v</l>
<l>    gvp:=gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>*****</c>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>*****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<l>if(intnum &lt;3)</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>elseif(intnum ==4)</l>
<l>    dif0:=abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1:=abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c></c>
<l>    if(dif0&gt;dif1)</l>
<l>        jMBdn:=PB[0]</l>
<l>        jMBup:=PE[0]</l>
<l>    else</l>
<l>        jMBdn:=PB[1]</l>
<l>        jMBup:=PE[1]</l>
<l>    endif</l>
<l>else</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>endif</l>
<c></c>
<l>gen_region_points(PMB, [PIntY[jMBdn],PIntY[jMBup]],  [PIntX[jMBdn],PIntX[jMBup]]) </l>
<l>gen_region_points(PSP, [PIntY[jSPdn],PIntY[jSPup]],  [PIntX[jSPdn],PIntX[jSPup]]) </l>
<c></c>
<l>* for j := 0 to ii-1 by 1</l>
<l>*     if (PType[j]==1)</l>
<l>*         jSPdn := j</l>
<l>*         clcb := PCLC[j]</l>
<l>*         break</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* for j := jSPdn to ii-1 by 1</l>
<l>*     if (PType[j]==-1)</l>
<l>*         clce := PCLC[j]</l>
<l>*         if (abs(clce-clcb) &gt; clcmax)</l>
<l>*             jSPup := j</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc38">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc38d">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc36 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.04.01 dual int point</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn:=0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    skipnext:=0</l>
<l>    xc := PPx[i]</l>
<l>*     if (xc==3066)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if (i==1 and v==1)</l>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        *if (vp==0 and (vn ==pnum or vn==1))</l>
<c>    *** 2 points ******</c>
<c>    * changed index ip</c>
<l>    ip:=ii</l>
<l>*     skipnext:=0</l>
<l>        if(vp==pnum)</l>
<l>            skipnext:=1</l>
<l>            if(vn==0)</l>
<l>                btype := -1</l>
<l>            else</l>
<l>                btype := 1</l>
<l>            endif</l>
<l>            if(gv&gt;gvp)</l>
<l>                ip:=ii-1</l>
<l>            endif</l>
<l>        *endif</l>
<c>    *******************         </c>
<l>        elseif (vp==0 and (vn ==pnum or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif ( (vn==1 and vp==pnum) or (vp==1 and vn==pnum))</l>
<l>            btype := 1</l>
<c>        </c>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>*         ii := ip+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and (v==1 or v==pnum) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>*         ii := ip+1</l>
<l>    endif</l>
<l>    ii := ip+1</l>
<l>    vp := v</l>
<l>    gvp:=gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>*****</c>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>*****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<l>if(intnum &lt;3)</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>elseif(intnum ==4)</l>
<l>    dif0:=abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1:=abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c></c>
<l>    if(dif0&gt;dif1)</l>
<l>        jMBdn:=PB[0]</l>
<l>        jMBup:=PE[0]</l>
<l>    else</l>
<l>        jMBdn:=PB[1]</l>
<l>        jMBup:=PE[1]</l>
<l>    endif</l>
<l>else</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>endif</l>
<c></c>
<l>gen_region_points(PMB, [PIntY[jMBdn],PIntY[jMBup]],  [PIntX[jMBdn],PIntX[jMBup]]) </l>
<l>gen_region_points(PSP, [PIntY[jSPdn],PIntY[jSPup]],  [PIntX[jSPdn],PIntX[jSPup]]) </l>
<c></c>
<l>* for j := 0 to ii-1 by 1</l>
<l>*     if (PType[j]==1)</l>
<l>*         jSPdn := j</l>
<l>*         clcb := PCLC[j]</l>
<l>*         break</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* for j := jSPdn to ii-1 by 1</l>
<l>*     if (PType[j]==-1)</l>
<l>*         clce := PCLC[j]</l>
<l>*         if (abs(clce-clcb) &gt; clcmax)</l>
<l>*             jSPup := j</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc38d">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectIsl6">
<interface>
<io>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nIslfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>* fill_up_shape (RegionIS, RegionISfu, 'area', 1, fumax)</l>
<l>smallest_rectangle1(RegionIS, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1(R0, Row1, Column1, Row2/2-1, Column2/2-1)</l>
<l>gen_rectangle1(R1, Row1, Column2/2, Row2/2, Column2)</l>
<l>gen_rectangle1(R2, Row2/2, Column1, Row2, Column2/2-1)</l>
<l>gen_rectangle1(R3, Row2/2, Column2/2, Row2, Column2)</l>
<c></c>
<l>intersection(RegionIS, R0, RegionIS0)</l>
<l>fill_up_shape (RegionIS0, RegionISfu0, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R1, RegionIS1)</l>
<l>fill_up_shape (RegionIS1, RegionISfu1, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R2, RegionIS2)</l>
<l>fill_up_shape (RegionIS2, RegionISfu2, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R3, RegionIS3)</l>
<l>fill_up_shape (RegionIS3, RegionISfu3, 'area', 1, 8000)</l>
<l>union2(RegionISfu0, RegionISfu1, RegionISfu)</l>
<l>union2(RegionISfu, RegionISfu2, RegionISfu)</l>
<l>union2(RegionISfu, RegionISfu3, RegionISfu)</l>
<l>* fill_up_shape (RegionIS, RegionISfu, 'area', 1, 8000)</l>
<l>* fill_up (RegionIS, RegionISfuns)</l>
<l>difference (RegionISfu, RegionIS, RegionIslfu)</l>
<l>* difference (RegionIslfu, RegionG, RegionIslfunG)</l>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<l>select_shape(RegionsIslfu, RegionsBig, 'area', 'and', fumax, aislmax)</l>
<l>union1(RegionsBig, RegionsBigu)</l>
<l>difference(RegionIslfu, RegionsBigu, RegionIslfu)</l>
<c></c>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<c></c>
<l>count_obj(RegionsBig, nBig)</l>
<l>for j := 1 to nBig by 1</l>
<l>    select_obj(RegionsBig, RBig, j)</l>
<l>    intersection(RBig, RegionG, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    if(Area==0)</l>
<l>        concat_obj(RegionsIslfu, RBig, RegionsIslfu)</l>
<l>    endif</l>
<l>endfor</l>
<l>* gen_empty_obj (RegionsIslfu)</l>
<l>* nIslfu := 0</l>
<l>* for j := 1 to nIslfum by 1</l>
<l>*     select_obj (RegionsIslfu, ObjectSelected, j)</l>
<l>*     intersection (ObjectSelected, SkeletonG, RegionInt)</l>
<l>*     area_center (RegionInt, a, r, c)</l>
<l>*     if (a==0)</l>
<l>*         concat_obj (RegionsIslfu, ObjectSelected, RegionsIslfu)</l>
<l>*         nIslfu := nIslfu+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>difference (RegionIfu, RegionsIslfu, RegionIi)</l>
<l>connection (RegionIi, RegionsIi)</l>
<l>select_shape (RegionsIi, RegionsI, 'area', 'and', 10, 99999999)</l>
<l>union1 (RegionsI, RegionI)</l>
<l>return ()</l>
</body>
<docu id="DetectIsl6">
<parameters>
<parameter id="Im"/>
<parameter id="RegionG"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionIfu"/>
<parameter id="RegionsIslfu"/>
<parameter id="SkeletonG"/>
<parameter id="aislmax"/>
<parameter id="fumax"/>
<parameter id="nIslfu"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectIsl61">
<interface>
<io>
<par name="RegionIS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsIslfu" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nIslfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>* fill_up_shape (RegionIS, RegionISfu, 'area', 1, fumax)</l>
<l>smallest_rectangle1(RegionIS, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1(R0, Row1, Column1, Row2/10-1, Column2)</l>
<l>gen_rectangle1(R1, Row2/10, Column1, Row2*2/10-1, Column2)</l>
<l>gen_rectangle1(R2, Row2*2/10, Column1, Row2*3/10-1, Column2)</l>
<l>gen_rectangle1(R3, Row2*3/10, Column1, Row2*4/10-1, Column2)</l>
<l>gen_rectangle1(R4, Row2*4/10, Column1, Row2*5/10-1, Column2)</l>
<l>gen_rectangle1(R5, Row2*5/10, Column1, Row2*6/10-1, Column2)</l>
<l>gen_rectangle1(R6, Row2*6/10, Column1, Row2*7/10-1, Column2)</l>
<l>gen_rectangle1(R7, Row2*7/10, Column1, Row2*8/10-1, Column2)</l>
<l>gen_rectangle1(R8, Row2*8/10, Column1, Row2*9/10-1, Column2)</l>
<l>gen_rectangle1(R9, Row2*9/10, Column1, Row2, Column2)</l>
<c></c>
<l>intersection(RegionIS, R0, RegionIS0)</l>
<l>fill_up_shape (RegionIS0, RegionISfu0, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R1, RegionIS1)</l>
<l>fill_up_shape (RegionIS1, RegionISfu1, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R2, RegionIS2)</l>
<l>fill_up_shape (RegionIS2, RegionISfu2, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R3, RegionIS3)</l>
<l>fill_up_shape (RegionIS3, RegionISfu3, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R4, RegionIS4)</l>
<l>fill_up_shape (RegionIS4, RegionISfu4, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R5, RegionIS5)</l>
<l>fill_up_shape (RegionIS5, RegionISfu5, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R6, RegionIS6)</l>
<l>fill_up_shape (RegionIS6, RegionISfu6, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R7, RegionIS7)</l>
<l>fill_up_shape (RegionIS7, RegionISfu7, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R8, RegionIS8)</l>
<l>fill_up_shape (RegionIS8, RegionISfu8, 'area', 1, 8000)</l>
<l>intersection(RegionIS, R9, RegionIS9)</l>
<l>fill_up_shape (RegionIS9, RegionISfu9, 'area', 1, 8000)</l>
<l>concat_obj(RegionISfu0, RegionISfu1, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu2, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu3, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu4, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu5, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu6, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu7, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu8, RegionISfu)</l>
<l>concat_obj(RegionISfu, RegionISfu9, RegionISfu)</l>
<l>union1(RegionISfu, RegionISfu)</l>
<c></c>
<l>* union2(RegionISfu0, RegionISfu1, RegionISfu)</l>
<l>* union2(RegionISfu, RegionISfu2, RegionISfu)</l>
<l>* union2(RegionISfu, RegionISfu3, RegionISfu)</l>
<l>* fill_up_shape (RegionIS, RegionISfu, 'area', 1, 8000)</l>
<l>* fill_up (RegionIS, RegionISfuns)</l>
<l>difference (RegionISfu, RegionIS, RegionIslfu)</l>
<l>* difference (RegionIslfu, RegionG, RegionIslfunG)</l>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<l>select_shape(RegionsIslfu, RegionsBig, 'area', 'and',  aislmax,fumax)</l>
<l>union1(RegionsBig, RegionsBigu)</l>
<l>difference(RegionIslfu, RegionsBigu, RegionIslfu)</l>
<c></c>
<l>connection (RegionIslfu, RegionsIslfu)</l>
<l>count_obj (RegionsIslfu, nIslfu)</l>
<c></c>
<l>count_obj(RegionsBig, nBig)</l>
<l>for j := 1 to nBig by 1</l>
<l>    select_obj(RegionsBig, RBig, j)</l>
<l>    intersection(RBig, RegionG, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    if(Area==0)</l>
<l>        concat_obj(RegionsIslfu, RBig, RegionsIslfu)</l>
<l>    endif</l>
<l>endfor</l>
<l>* gen_empty_obj (RegionsIslfu)</l>
<l>* nIslfu := 0</l>
<l>* for j := 1 to nIslfum by 1</l>
<l>*     select_obj (RegionsIslfu, ObjectSelected, j)</l>
<l>*     intersection (ObjectSelected, SkeletonG, RegionInt)</l>
<l>*     area_center (RegionInt, a, r, c)</l>
<l>*     if (a==0)</l>
<l>*         concat_obj (RegionsIslfu, ObjectSelected, RegionsIslfu)</l>
<l>*         nIslfu := nIslfu+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>difference (RegionIfu, RegionsIslfu, RegionIi)</l>
<l>connection (RegionIi, RegionsIi)</l>
<l>select_shape (RegionsIi, RegionsI, 'area', 'and', 10, 99999999)</l>
<l>union1 (RegionsI, RegionI)</l>
<l>return ()</l>
</body>
<docu id="DetectIsl61">
<parameters>
<parameter id="Im"/>
<parameter id="RegionG"/>
<parameter id="RegionI"/>
<parameter id="RegionIS"/>
<parameter id="RegionIfu"/>
<parameter id="RegionsIslfu"/>
<parameter id="SkeletonG"/>
<parameter id="aislmax"/>
<parameter id="fumax"/>
<parameter id="nIslfu"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectPH3">
<interface>
<io>
<par name="RegionIi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsPHfu" base_type="iconic" dimension="0"/>
<par name="RegionIfu" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="fumax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nPHfu" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>smallest_rectangle1(RegionIi, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1(R0, Row1, Column1, Row2/10-1, Column2)</l>
<l>gen_rectangle1(R1, Row2/10, Column1, Row2*2/10-1, Column2)</l>
<l>gen_rectangle1(R2, Row2*2/10, Column1, Row2*3/10-1, Column2)</l>
<l>gen_rectangle1(R3, Row2*3/10, Column1, Row2*4/10-1, Column2)</l>
<l>gen_rectangle1(R4, Row2*4/10, Column1, Row2, Column2)</l>
<c></c>
<l>intersection(RegionIi, R0, RegionI0)</l>
<l>fill_up_shape (RegionI0, RegionIfu0, 'area', 1, 8000)</l>
<l>intersection(RegionIi, R1, RegionI1)</l>
<l>fill_up_shape (RegionI1, RegionIfu1, 'area', 1, 8000)</l>
<l>intersection(RegionIi, R2, RegionI2)</l>
<l>fill_up_shape (RegionI2, RegionIfu2, 'area', 1, 8000)</l>
<l>intersection(RegionIi, R3, RegionI3)</l>
<l>fill_up_shape (RegionI3, RegionIfu3, 'area', 1, 8000)</l>
<l>intersection(RegionIi, R4, RegionI4)</l>
<l>fill_up_shape (RegionI4, RegionIfu4, 'area', 1, 8000)</l>
<c></c>
<l>concat_obj(RegionIfu0, RegionIfu1, RegionIfu)</l>
<l>concat_obj(RegionIfu, RegionIfu2, RegionIfu)</l>
<l>concat_obj(RegionIfu, RegionIfu3, RegionIfu)</l>
<l>concat_obj(RegionIfu, RegionIfu4, RegionIfu)</l>
<l>union1(RegionIfu, RegionIfu)</l>
<c></c>
<l>* fill_up_shape (RegionIi, RegionIfu, 'area', 1, fumax)</l>
<l>* fill_up (RegionIi, RegionIfu2)</l>
<c></c>
<l>difference (RegionIfu, RegionIi, RegionPHfui)</l>
<l>fill_up (RegionPHfui, RegionsPHfu)</l>
<l>connection (RegionsPHfu, RegionsPHfu)</l>
<l>count_obj (RegionsPHfu, nPHfu)</l>
<l>* difference (RegionIi, RegionsPHfu, RegionIfu)</l>
<l>union2 (RegionIi, RegionsPHfu, RegionIfu)</l>
<l>return ()</l>
</body>
<docu id="DetectPH3">
<parameters>
<parameter id="Im"/>
<parameter id="RegionIfu"/>
<parameter id="RegionIi"/>
<parameter id="RegionsPHfu"/>
<parameter id="fumax"/>
<parameter id="nPHfu"/>
</parameters>
</docu>
</procedure>
<procedure name="PinholeIsland">
<interface>
<io>
<par name="RegionIi5" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="Domain" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SmallPs" base_type="iconic" dimension="0"/>
<par name="SmallSs" base_type="iconic" dimension="0"/>
<par name="RegionISnoIslnoPh" base_type="iconic" dimension="0"/>
<par name="RegionInoIslnoPh" base_type="iconic" dimension="0"/>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="aislmax" base_type="ctrl" dimension="0"/>
<par name="aphmax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>set_system('neighborhood', 8)</l>
<l>difference(RegionIi5, R, RegionIi5r)</l>
<l>connection(RegionIi5r, RegionsIi5r)</l>
<l>difference(Domain, RegionIi5r, RegionISi5r)</l>
<l>connection(RegionISi5r, RegionsISi5r)</l>
<l>select_shape(RegionsIi5r, SmallPs, 'area', 'and', 1, aislmax)</l>
<l>select_shape(RegionsISi5r, SmallSs, 'area', 'and', 1, aphmax)</l>
<c></c>
<l>union1(SmallPs, SmallP)</l>
<l>union1(SmallSs, SmallS)</l>
<l>difference(RegionIi5r, SmallP, RegionInoIsl)</l>
<l>difference(Domain, RegionInoIsl, RegionISnoIsl)</l>
<l>difference(RegionISnoIsl, SmallS, RegionISnoIslnoPh)</l>
<l>difference(Domain, RegionISnoIslnoPh, RegionInoIslnoPh)</l>
<c></c>
<l>select_shape(RegionInoIslnoPh, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<c></c>
<l>select_shape (SmallPs, RegionsIsl, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIsl, RegionsIsl, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>return ()</l>
</body>
<docu id="PinholeIsland">
<parameters>
<parameter id="Domain"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RegionISnoIslnoPh"/>
<parameter id="RegionIi5"/>
<parameter id="RegionInoIslnoPh"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsPH"/>
<parameter id="SmallPs"/>
<parameter id="SmallSs"/>
<parameter id="aislmax"/>
<parameter id="aphmax"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN4">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN3 : new detect open proc. 11.08.2022</c>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j:=1 to nOpCands by 1</l>
<l>    if(j==1284)</l>
<l>        stop()</l>
<l>    endif</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+ppw, Length2+ppw+ppw)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskel, jj)</l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>        concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>         dilation_circle(Rskel, RskelSd, 1)</l>
<l>         concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN4">
<parameters>
<parameter id="DirImageP"/>
<parameter id="R2"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN4_COPY_1">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN4 : new detect open proc. 11.08.2022</c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==1233)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     j:=999</l>
<l>*     j:=893</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+ppw, Length2+ppw+ppw)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<c>    </c>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    intersection (RegionG, R2, RegionGR)</l>
<l>    connection(RegionGR, RegionsGR)</l>
<c>    </c>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskeli, jj)</l>
<l>    dilation_circle(Rskeli,Rskel, 3) </l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<c>    </c>
<l>    if(nArnonz &gt; 1)</l>
<l>*         Index:=[]</l>
<l>        IndexGAll:=[]</l>
<l>        SmallIs:=RegionIntersection</l>
<l>        union1(SmallIs, SmallI)</l>
<l>        connection(SmallI, SmallIs)</l>
<c>        </c>
<l>*         BigIs:=RegionsIR2</l>
<l>        gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>        intersection(RegionInoPHnoIsl, R3, BigI)</l>
<l>        connection(BigI, BigIs)</l>
<l>        difference(BigIs, SmallI, BigInoSs)</l>
<c>        </c>
<l>        intersection (RegionG, R3, RegionGR3)</l>
<l>        connection(RegionGR3, RegionsGR3)</l>
<l>        for jj:=1 to nArnonz by 1</l>
<l>            select_obj(SmallIs, Obj, jj)</l>
<l>            get_region_points(Obj, RowsO, ColumnsO)</l>
<l>            tuple_length(RowsO, nOp)</l>
<l>            get_region_index(BigIs, int(RowsO[nOp/2]), int(ColumnsO[nOp/2]), Index)</l>
<l>            select_obj(BigInoSs, CurBigInoS, Index)</l>
<l>            intersection(CurBigInoS, RegionG, CurBigInoSG)</l>
<l>            get_region_points(CurBigInoSG, RowsB, ColumnsB)</l>
<l>            tuple_length(RowsB, nB)</l>
<l>            get_region_index(RegionsGR3, int(RowsB[nB/2]), int(ColumnsB[nB/2]), IndexG)</l>
<l>            IndexGAll[jj-1]:=IndexG</l>
<l>        endfor</l>
<l>        if(IndexGAll[0]==IndexGAll[1])</l>
<l>            intersection(RegionG, R2, RegionG2)</l>
<l>*         dev_display(R2)</l>
<l>          intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>          concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>         dilation_circle(Rskel, RskelSd, 1)</l>
<l>         concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>        endif</l>
<c>        </c>
<l>*        stop()</l>
<l>*     elseif(AreaC &gt; 10)</l>
<l>*         dilation_circle(OpCand, OpCandd, 3) </l>
<l>*         intersection(OpCandd, RegionIR2, RegionIntCandI)</l>
<l>*         connection(RegionIntCandI, RegionsIntCandI)</l>
<l>*         count_obj(RegionsIntCandI, n)</l>
<l>*         if(n==2)</l>
<l>*             intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>*             concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>*             dilation_circle(Rskel, RskelSd, 1)</l>
<l>*             concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*         endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN4_COPY_1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="R2"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpen1v2">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN1v2 : new detect open proc. 11.08.2022</c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<c></c>
<l>* intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAll)</l>
<l>* connection(OpCandAll, OpCands)</l>
<l>* count_obj(OpCands, nOpCands)</l>
<l>* gen_empty_obj (RegionsOp)</l>
<l>* gen_empty_obj (RegionsOpCon)</l>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==139)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+3, Length2+ppw+3)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskel, jj)</l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>        concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>         dilation_circle(Rskel, RskelSd, 1)</l>
<l>         concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpen1v2">
<parameters>
<parameter id="DirImageP"/>
<parameter id="R2"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN1v1">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
<par name="R2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN1v1 : new detect open proc. 10.09.2023</c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==139)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+3, Length2+ppw+3)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskel, jj)</l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    if(nArnonz &gt; 1)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>        concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>         dilation_circle(Rskel, RskelSd, 1)</l>
<l>         concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN1v1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="R2"/>
<parameter id="RegionCheck"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenFU3_COPY_1">
<interface>
<io>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="coef" base_type="ctrl" dimension="0"/>
<par name="wgap" base_type="ctrl" dimension="0"/>
<par name="d" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nOp" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** OPEN  FillUp******</c>
<c>* 202290317 fixed very big open problem</c>
<c>* 202290317 added RegionsOpCon - connection line for 2 parts of Open defect</c>
<l>if (d&gt;1)</l>
<l>    dilation_circle (RegionI, RegionId, d)</l>
<l>else</l>
<l>    RegionId := RegionI</l>
<l>endif</l>
<c></c>
<l>difference (SkeletonG, RegionId, RegionSkGI)</l>
<l>connection (RegionSkGI, RegionsSkGI)</l>
<l>area_center (RegionsSkGI, Area, RowOpC, ColOpC)</l>
<l>gen_region_points (RC, RowOpC, ColOpC)</l>
<l>tuple_length (RowOpC, nOpC)</l>
<c></c>
<l>nOp := 0</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>for j := 1 to nOpC by 1</l>
<l>    select_obj (RegionsSkGI, RegionsSkGISel, j)</l>
<l>    get_region_points (RegionsSkGISel, Rows, Cols)</l>
<l>    tuple_length (Rows, np)</l>
<l>    row := Rows[np/2]</l>
<l>    col := Cols[np/2]</l>
<l>*     if (j==225)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     gen_region_points (R, row, col)</l>
<l>*     if (row&gt;5415 and row&lt;5423)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     gen_region_points (P, Rows[np/2], Cols[np/2])</l>
<l>*     get_grayval (DirImageP, row, col, dirOpC)</l>
<l>    get_grayval (WidthImageP, row, col, widthOpC)</l>
<c></c>
<l>*     angsOpC := dirOpC*3.1415926/256.0</l>
<l>*     angsOpC := dirOpC*0.012271846</l>
<c></c>
<l>*     region_features (RegionsSkGISel, 'rect2_len1', l1)</l>
<l>*     tuple_max2 (widthOpC*coef/2, l1+wgap*2, recw)</l>
<l>*     gen_rectangle2 (Rect, row, col, angsOpC, widthOpC*coef/2, recw)</l>
<c></c>
<l>    dilation_circle (RegionsSkGISel, RegA, widthOpC*coef/2)</l>
<c></c>
<l>*     intersection (Rect, RegionI, RegionIR)</l>
<l>    intersection (RegA, RegionI, RegionIR)</l>
<c></c>
<l>    connection (RegionIR, RegionsIRCon)</l>
<l>    count_obj (RegionsIRCon, nR)</l>
<l>    intersection (RegA, SkeletonG, SkelGR)</l>
<l>    connection (SkelGR, SkelGRCon)</l>
<l>    count_obj (SkelGRCon, nS)</l>
<c></c>
<l>*     intersection (RegionsIRCon, SkeletonG, RegionsIRConSkeli)</l>
<l>*     select_shape (RegionsIRConSkeli, RegionsIRConSkel, 'area', 'and', 1, 99999)</l>
<l>*     count_obj (RegionsIRConSkel, nIRcons)</l>
<l>    for n := 1 to nS by 1</l>
<l>        select_obj (SkelGRCon, SkelS, n)</l>
<l>        numint := 0</l>
<l>        gen_empty_obj (Reg)</l>
<l>        for nn := 1 to nR by 1</l>
<l>            select_obj (RegionsIRCon, RegR, nn)</l>
<l>            intersection (SkelS, RegR, RInt)</l>
<l>            area_center (RInt, a, r, c)</l>
<l>            if (a&gt;0)</l>
<l>                numint := numint+1</l>
<l>                concat_obj (Reg, RegR, Reg)</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (numint &gt; 1)</l>
<l>            nOp := nOp+1</l>
<l>            union1 (Reg, Regu)</l>
<l>            concat_obj (RegionsOp, Regu, RegionsOp)</l>
<l>*             union1 (RegionsOp, RegionOp)</l>
<l>*             complement (RegA, RegAC)</l>
<l>*             expand_region (SkelS, RegAC, RegOpCon, 'maximal', 'image')</l>
<l>            dilation_circle (SkelS, SkelSd, 1)</l>
<l>            concat_obj (RegionsOpCon, SkelSd, RegionsOpCon)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenFU3_COPY_1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionI"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
<parameter id="coef"/>
<parameter id="d"/>
<parameter id="nOp"/>
<parameter id="wgap"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN5">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN5 : new detect open proc. 11.08.2022</c>
<c>*** modified 12.09.2023, overkills removed</c>
<c> </c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<c></c>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==1233)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     j:=999</l>
<l>*     j:=18</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>    if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>    endif</l>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+ppw, Length2+ppw+ppw/2)</l>
<l>        gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>        gen_rectangle2(R3, RowC, ColumnC ,pa, ppw*2.5+5, ppw*2.5+5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<c>    </c>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    intersection (RegionG, R2, RegionGR)</l>
<l>    connection(RegionGR, RegionsGR)</l>
<c>    </c>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskeli, jj)</l>
<l>    dilation_circle(Rskeli,Rskel, 3) </l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<c>    </c>
<l>    if(nArnonz &gt; 1)</l>
<l>*         Index:=[]</l>
<l>        IndexGAll:=[]</l>
<l>        SmallIs:=RegionIntersection</l>
<l>        union1(SmallIs, SmallI)</l>
<l>        connection(SmallI, SmallIs)</l>
<c>        </c>
<l>*         BigIs:=RegionsIR2</l>
<l>* gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>        intersection(RegionInoPHnoIsl, R3, BigI)</l>
<l>        connection(BigI, BigIs)</l>
<l>        difference(BigIs, SmallI, BigInoSs)</l>
<c>        </c>
<l>        intersection (RegionG, R3, RegionGR3)</l>
<l>        connection(RegionGR3, RegionsGR3)        </l>
<l>        for jj:=1 to nArnonz by 1</l>
<l>            select_obj(SmallIs, Obj, jj)</l>
<l>            get_region_points(Obj, RowsO, ColumnsO)</l>
<l>            tuple_length(RowsO, nOp)</l>
<l>            get_region_index(BigIs, int(RowsO[nOp/2]), int(ColumnsO[nOp/2]), Index)</l>
<l>            select_obj(BigInoSs, CurBigInoS, Index)</l>
<l>            intersection(CurBigInoS, RegionG, CurBigInoSG)</l>
<l>            get_region_points(CurBigInoSG, RowsB, ColumnsB)</l>
<l>            tuple_length(RowsB, nB)</l>
<l>            if(nB==0)</l>
<l>                continue</l>
<l>            endif</l>
<l>            get_region_index(RegionsGR3, int(RowsB[nB/2]), int(ColumnsB[nB/2]), IndexG)</l>
<l>            IndexGAll[jj-1]:=IndexG</l>
<l>        endfor</l>
<l>        tuple_length(IndexGAll, nGAll)</l>
<l>*         if(IndexGAll[0]==IndexGAll[1])</l>
<l>*             intersection(RegionG, R2, RegionG2)</l>
<l>*         dev_display(R2)</l>
<l>            select_obj(RegionsGR3, RGR3, IndexG)</l>
<l>          intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>          intersection(Rop, RGR3, Ropf)</l>
<l>          concat_obj (RegionsOp, Ropf, RegionsOp)</l>
<l>*          dilation_circle(Rskel, RskelSd, 1)</l>
<l>*          concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>         concat_obj (RegionsOpCon, Rskel, RegionsOpCon)</l>
<l>*         endif</l>
<c>        </c>
<l>*        stop()</l>
<l>*     elseif(AreaC &gt; 10)</l>
<l>*         dilation_circle(OpCand, OpCandd, 3) </l>
<l>*         intersection(OpCandd, RegionIR2, RegionIntCandI)</l>
<l>*         connection(RegionIntCandI, RegionsIntCandI)</l>
<l>*         count_obj(RegionsIntCandI, n)</l>
<l>*         if(n==2)</l>
<l>*             intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>*             concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>*             dilation_circle(Rskel, RskelSd, 1)</l>
<l>*             concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*         endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN5">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN4">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN4 : new detect short proc. 19.01.2023</c>
<c>*** remowed last SkeletonGS contour</c>
<c>*** 12.09.2023</c>
<c></c>
<l>* get_domain(WidthImageS, Domain)</l>
<l>* boundary(Domain, DomainB, 'inner')</l>
<l>* get_image_size(WidthImageS,Width, Height)</l>
<l>* gen_rectangle1(RB, bdist,bdist,Height- bdist, Width-bdist)</l>
<c>** for rectengular outer shape</c>
<l>region_features(RegionG, 'row1', r1)</l>
<l>region_features(RegionG, 'column1', c1)</l>
<l>region_features(RegionG, 'row2', r2)</l>
<l>region_features(RegionG, 'column2', c2)</l>
<l>gen_rectangle1(RB, r1,c1,r2,c2)</l>
<c></c>
<l>* fill_up(RegionG, RegionFillUpG)</l>
<c>** for arbitrary outer shape</c>
<l>* closing_circle(RegionG, RB, 101)</l>
<c></c>
<l>intersection(SkeletonGS, RB, SkeletonGSnoB)</l>
<l>intersection(SkeletonGSnoB, RegionInoPHnoIsl, ShCandAll)</l>
<c></c>
<l>* intersection(ShCandAlli, RegionCheck, ShCandAll)</l>
<l>* set_system('neighborhood', 8)</l>
<l>connection(ShCandAll, ShCands)</l>
<l>* set_system('neighborhood', 8)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>for j:=1 to nShCands by 1</l>
<l>*     intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*     connection(RInt, RInts)</l>
<l>*     if(j==56)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(j==1237)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*      if(j==1008)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     j:=442</l>
<l>    select_obj(ShCands, ShCand, j)</l>
<l>    area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>    get_region_points(ShCand, Rows, Columns)</l>
<l>    get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>    tuple_median(SpW, spw)</l>
<l>    get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>    tuple_median(SpD, spd)</l>
<l>    sa:=spd*3.14159/256</l>
<l>    if(spw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+10, Length2+spw+10)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    endif</l>
<c>    </c>
<l>*     gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>    connection(RegionISR2, RegionsISR2)</l>
<l>    intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>    connection(RegionGSR2, RegionsGSR2)</l>
<l>    count_obj(RegionsGSR2, nGSR2)</l>
<l>    for jj:=1 to nGSR2 by 1</l>
<l>        select_obj(RegionsGSR2, Rsel, jj)</l>
<l>        test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGSR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGSR2, Rskel, jj)</l>
<l>    get_region_points(Rskel, Rowsrs, Columnsrs)</l>
<l>    tuple_length(Rowsrs, l)</l>
<l>    skcrow:=Rowsrs[l/2]</l>
<l>    skccol:=Columnsrs[l/2]</l>
<c>    </c>
<l>    distance_pp(Rowsrs[0], Columnsrs[0], Rowsrs[l-1], Columnsrs[l-1],lr)</l>
<c>    </c>
<l>    dilation_circle(Rskel, Rskeld, 1)</l>
<l>    intersection( RegionsISR2,Rskeld, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Rowi, Columni)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_sum(Area, asum)</l>
<l>    tuple_select_mask(Rowi, int(Rowi), Rowrnonz)</l>
<l>    tuple_select_mask(Columni, int(Columni), Columnrnonz)</l>
<c> </c>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    tuple_gen_const(nArnonz, skcrow, Skcrow)</l>
<l>    tuple_gen_const(nArnonz, skccol, Skccol)</l>
<l>    distance_pp(Rowrnonz, Columnrnonz, Skcrow, Skccol, Dr)</l>
<c>    </c>
<l>    if(nArnonz&gt;0)</l>
<l>        Mr:=min(Dr)</l>
<l>    else </l>
<l>        Mr:=10</l>
<l>    endif</l>
<c>    ***</c>
<l>*     intersection(RegionG, R2, RegionGR2)</l>
<c>    </c>
<c>    ***</c>
<l>    if(nArnonz &gt; 1 and Mr &lt; lr/2 and asum&gt;15)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<c>        *** only biggeast region should remain</c>
<l>        connection(Rsh, Rshs)</l>
<l>        area_center(Rshs, AreaRshs, RowRshs, ColumnRshs)</l>
<l>        tuple_length(AreaRshs, no)</l>
<l>        if(no&gt;1)</l>
<l>            tuple_sort_index(AreaRshs, Ind)</l>
<l>            tuple_inverse(Ind, Inverted)</l>
<l>            select_obj(Rshs, Rshf,Inverted[0]+1)</l>
<l>            concat_obj(RegionsSh, Rshf, RegionsSh)</l>
<l>        else</l>
<l>            concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>        endif</l>
<c>        </c>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortN4">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain119">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="ROut" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain118 - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<c>* RegDontCare - non-processing region</c>
<c>* RegMargin   - includes margins on Lt/Rt/Top/Bot</c>
<c>* RegSM       - solder mask region, its boundary shouldn't be processed</c>
<c></c>
<c>*** R  - region for processing</c>
<c>*** Rd - dilated R for skeletons generation</c>
<l>get_domain(Gi, DomainG)</l>
<l>* union2 (RegMargin, RegNoProc, R)</l>
<l>* boundary(RegSM, RegionBorder, 'inner')</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<c></c>
<l>difference (RegionGii, RegNoProc, RegionGi)</l>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c>*** fixing artefacts</c>
<l>closing_circle (RegionGi, RegionGi, 1)</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<l>* RegNoProc := RmnoG</l>
<l>ROut := RegNoProc</l>
<l>union2 (ROut, RegMargin, ROut)</l>
<l>difference (DomainG, RegNoProc, RC)</l>
<c>*** correcting RC right side (temp.)</c>
<l>smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>Column2:=Column2-5</l>
<l>gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>intersection (RegionGsm, RC, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c></c>
<l>difference (RegionsGND, ROut, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGsm, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, ROut, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<c></c>
<l>intersection (RegionGSi, RC, RegionGSii)</l>
<l>difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    Regionsmain:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<l>count_obj(Regionsmain, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(Regionsmain, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>count_obj(RegionsmainPNi, nRMPNI)</l>
<c></c>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPi, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPip</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>SkeletonsFWMii:=SkeletonPartsP</l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>SkeletonsFWM:=SkeletonPartsP</l>
<l>intersection(SkeletonsFWM, RC, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSBuildFWM5 (SkeletonsFWMrc, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain119">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="ROut"/>
<parameter id="RegNoProc"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="PrepRC">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Domain" base_type="iconic" dimension="0"/>
<par name="RC" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>get_domain (Im, Domain)</l>
<l>area_center(R, aR, r, c)</l>
<l>tuple_length(aR, l)</l>
<l>if(aR==0 or l==0)</l>
<l>    RC:=Domain</l>
<l>else</l>
<l>    difference(Domain, R, RC)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="PrepRC">
<parameters>
<parameter id="Domain"/>
<parameter id="Im"/>
<parameter id="R"/>
<parameter id="RC"/>
</parameters>
</docu>
</procedure>
<procedure name="SkeletonsCheckPrep">
<interface>
<io>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoIslnoPh" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionFWMdil" base_type="iconic" dimension="0"/>
<par name="RegSkel" base_type="iconic" dimension="0"/>
<par name="RegSkeld" base_type="iconic" dimension="0"/>
<par name="SkeletonI" base_type="iconic" dimension="0"/>
<par name="EndPointsI" base_type="iconic" dimension="0"/>
<par name="JuncPointsI" base_type="iconic" dimension="0"/>
<par name="SkelPointsI" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dilFWM" base_type="ctrl" dimension="0"/>
<par name="s1" base_type="ctrl" dimension="0"/>
<par name="dilS" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dilation_circle(RegionFWM, RegionFWMdil, dilFWM)</l>
<l>intersection(RegionInoIslnoPh, RegionFWMdil, RegSkel)</l>
<l>set_system('neighborhood', 8)</l>
<l>dilation_circle(RegSkel, RegSkeld, 2)</l>
<l>opening_circle(RegSkeld, RegSkelo, 2)</l>
<l>skeleton(RegSkelo, SkeletonI)</l>
<l>* split_skeleton_region(SkeletonI, RegionLines, 30)</l>
<l>* pruning(SkeletonI, SkeletonIPrune, 10)</l>
<l>* count_seconds(s2)</l>
<l>* sprep:=s2-s1</l>
<c></c>
<l>junctions_skeleton(SkeletonI, EndPointsI, JuncPointsI)</l>
<l>set_system('neighborhood', 8)</l>
<l>union2(EndPointsI, JuncPointsI, SkelPointsIi)</l>
<l>dilation_circle(SkelPointsIi, SkelPointsI, dilS)</l>
<c>************************</c>
<l>RegionChecki:=SkelPointsI</l>
<l>closing_circle(RegionChecki, RegionCheck, 13.5)</l>
<l>return ()</l>
</body>
<docu id="SkeletonsCheckPrep">
<parameters>
<parameter id="EndPointsI"/>
<parameter id="JuncPointsI"/>
<parameter id="RegSkel"/>
<parameter id="RegSkeld"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionFWMdil"/>
<parameter id="RegionInoIslnoPh"/>
<parameter id="SkelPointsI"/>
<parameter id="SkeletonI"/>
<parameter id="dilFWM"/>
<parameter id="dilS"/>
<parameter id="s1"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildRegionInoD">
<interface>
<io>
<par name="RegionsShi" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoIslnoPh" base_type="iconic" dimension="0"/>
<par name="RegionOpCon" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>union1(RegionsShi, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<c>******* fixing Shorts ******</c>
<l>difference(RegionInoIslnoPh, RegionRemoveSh, RegionI1noPh5noIsl1noSh1)</l>
<l>* difference(RegionI1noPh5noIsl1, RegionRemoveSh, RegionI1noPh5noIsl1noSh1)</l>
<l>* difference(RegionI2noPh5noIsl1, RegionRemoveSh, RegionI2noPh5noIsl1noSh1)</l>
<l>* difference(RegionI3noPh5noIsl1, RegionRemoveSh, RegionI3noPh5noIsl1noSh1)</l>
<l>* difference(RegionI4noPh5noIsl1, RegionRemoveSh, RegionI4noPh5noIsl1noSh1)</l>
<l>* difference(RegionI5noPh5noIsl1, RegionRemoveSh, RegionI5noPh5noIsl1noSh1)</l>
<c></c>
<l>count_obj(RegionsShi, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c>***** final RegionInoD 1,2,3,4,5 ******</c>
<l>union2(RegionI1noPh5noIsl1noSh1, RegionOpCon, RegionInoDi)</l>
<l>difference(RegionInoDi, R, RegionInoD)</l>
<l>return ()</l>
</body>
<docu id="BuildRegionInoD">
<parameters>
<parameter id="R"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoIslnoPh"/>
<parameter id="RegionOpCon"/>
<parameter id="RegionsShi"/>
<parameter id="SkeletonGS"/>
</parameters>
</docu>
</procedure>
<procedure name="MakeSkeletonGnoR">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonGnoR" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>get_domain(Im, DomainI)</l>
<l>difference(DomainI, RegionI, RegionIS) </l>
<l>difference(R, RegionI, RS) </l>
<l>intersection(SkeletonG,RS, SkeletonGR)</l>
<c>****</c>
<l>set_system('neighborhood', 8)</l>
<l>difference(SkeletonG, R, SkeletonGnoR)</l>
<l>return ()</l>
</body>
<docu id="MakeSkeletonGnoR">
<parameters>
<parameter id="Im"/>
<parameter id="R"/>
<parameter id="RegionI"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGnoR"/>
</parameters>
</docu>
</procedure>
<procedure name="PinholeIsland2">
<interface>
<io>
<par name="RegionIi5" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
<par name="Domain" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SmallPs" base_type="iconic" dimension="0"/>
<par name="SmallSs" base_type="iconic" dimension="0"/>
<par name="RegionISnoIslnoPh" base_type="iconic" dimension="0"/>
<par name="RegionInoIslnoPh" base_type="iconic" dimension="0"/>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="aislmax" base_type="ctrl" dimension="0"/>
<par name="aphmax" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*** PinholeIsland2</c>
<c>* 2023.09.23 using CAD</c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>difference(RegionIi5, R, RegionIi5r)</l>
<l>connection(RegionIi5r, RegionsIi5r)</l>
<l>difference(Domain, RegionIi5r, RegionISi5r)</l>
<l>connection(RegionISi5r, RegionsISi5r)</l>
<l>select_shape(RegionsIi5r, SmallPs, 'area', 'and', 1, aislmax)</l>
<l>select_shape(RegionsISi5r, SmallSs, 'area', 'and', 1, aphmax)</l>
<c></c>
<l>union1(SmallPs, SmallP)</l>
<l>union1(SmallSs, SmallS)</l>
<l>difference(RegionIi5r, SmallP, RegionInoIsl)</l>
<l>difference(Domain, RegionInoIsl, RegionISnoIsl)</l>
<l>difference(RegionISnoIsl, SmallS, RegionISnoIslnoPh)</l>
<l>difference(Domain, RegionISnoIslnoPh, RegionInoIslnoPh)</l>
<c></c>
<l>select_shape(RegionInoIslnoPh, RegionsPHfu1, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHfu1, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<c></c>
<l>select_shape (SmallPs, RegionsIsli, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIsli, RegionsIslii, 'inner_radius', 'and', Islrmin, 999999)</l>
<l>count_obj(RegionsIslii, nIsl)</l>
<c></c>
<l>gen_empty_obj(RegionsIsl)</l>
<l>for j:=1 to nIsl by 1</l>
<l>*     j:=25</l>
<l>    select_obj(RegionsIslii, Isl, j)</l>
<l>    intersection(Isl, RegionG, IslG)</l>
<l>    difference(Isl, RegionG, IslnoG)</l>
<l>    area_center(IslG, aIslG,Row, Column)</l>
<l>    area_center(IslnoG, aIslnoG,Row, Column)</l>
<l>    if( aIslnoG &gt; aIslG)</l>
<l>        concat_obj(RegionsIsl, Isl, RegionsIsl)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="PinholeIsland2">
<parameters>
<parameter id="Domain"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="R"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoIslnoPh"/>
<parameter id="RegionIi5"/>
<parameter id="RegionInoIslnoPh"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsPH"/>
<parameter id="SmallPs"/>
<parameter id="SmallSs"/>
<parameter id="aislmax"/>
<parameter id="aphmax"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN5">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN5 : new detect short proc. 19.01.2023</c>
<c>*** 25.09.2023 small pieces removed</c>
<c>*** remowed last SkeletonGS contour</c>
<c>*** 12.09.2023</c>
<c></c>
<l>* get_domain(WidthImageS, Domain)</l>
<l>* boundary(Domain, DomainB, 'inner')</l>
<l>* get_image_size(WidthImageS,Width, Height)</l>
<l>* gen_rectangle1(RB, bdist,bdist,Height- bdist, Width-bdist)</l>
<c>** for rectengular outer shape</c>
<l>region_features(RegionG, 'row1', r1)</l>
<l>region_features(RegionG, 'column1', c1)</l>
<l>region_features(RegionG, 'row2', r2)</l>
<l>region_features(RegionG, 'column2', c2)</l>
<l>gen_rectangle1(RB, r1,c1,r2,c2)</l>
<c></c>
<l>* fill_up(RegionG, RegionFillUpG)</l>
<c>** for arbitrary outer shape</c>
<l>* closing_circle(RegionG, RB, 101)</l>
<c></c>
<l>intersection(SkeletonGS, RB, SkeletonGSnoB)</l>
<l>intersection(SkeletonGSnoB, RegionInoPHnoIsl, ShCandAll)</l>
<c></c>
<l>* intersection(ShCandAlli, RegionCheck, ShCandAll)</l>
<l>* set_system('neighborhood', 8)</l>
<l>connection(ShCandAll, ShCands)</l>
<l>set_system('neighborhood', 8)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>for j:=1 to nShCands by 1</l>
<l>*     intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*     connection(RInt, RInts)</l>
<l>*     if(j==56)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(j==1237)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*      if(j==1008)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    j:=299</l>
<l>    select_obj(ShCands, ShCand, j)</l>
<l>    area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>    get_region_points(ShCand, Rows, Columns)</l>
<l>    get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>    tuple_median(SpW, spw)</l>
<l>    get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>    tuple_median(SpD, spd)</l>
<l>    sa:=spd*3.14159/256</l>
<l>    if(spw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+10, Length2+spw+10)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    endif</l>
<c>    </c>
<l>*     gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>    intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>    connection(RegionISR2, RegionsISR2)</l>
<l>    intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>    connection(RegionGSR2, RegionsGSR2)</l>
<l>    count_obj(RegionsGSR2, nGSR2)</l>
<l>    for jj:=1 to nGSR2 by 1</l>
<l>        select_obj(RegionsGSR2, Rsel, jj)</l>
<l>        test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGSR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>*     get_system('neighborhood', nb)</l>
<l>    select_obj(RegionsGSR2, Rskel, jj)</l>
<l>    get_region_points(Rskel, Rowsrs, Columnsrs)</l>
<l>    tuple_length(Rowsrs, l)</l>
<l>    skcrow:=Rowsrs[l/2]</l>
<l>    skccol:=Columnsrs[l/2]</l>
<c>    </c>
<l>    distance_pp(Rowsrs[0], Columnsrs[0], Rowsrs[l-1], Columnsrs[l-1],lr)</l>
<c>    </c>
<l>    dilation_circle(Rskel, Rskeld, 1)</l>
<l>    intersection( RegionsISR2,Rskeld, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Rowi, Columni)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_sum(Area, asum)</l>
<l>    tuple_select_mask(Rowi, int(Rowi), Rowrnonz)</l>
<l>    tuple_select_mask(Columni, int(Columni), Columnrnonz)</l>
<c> </c>
<l>    tuple_length(Arnonz, nArnonz)</l>
<l>    tuple_gen_const(nArnonz, skcrow, Skcrow)</l>
<l>    tuple_gen_const(nArnonz, skccol, Skccol)</l>
<l>    distance_pp(Rowrnonz, Columnrnonz, Skcrow, Skccol, Dr)</l>
<c>    </c>
<l>    if(nArnonz&gt;0)</l>
<l>        Mr:=min(Dr)</l>
<l>    else </l>
<l>        Mr:=10</l>
<l>    endif</l>
<c>    ***</c>
<l>*     intersection(RegionG, R2, RegionGR2)</l>
<c>    </c>
<c>    ***</c>
<l>    if(nArnonz &gt; 1 and Mr &lt; lr/1.5 and asum&gt;15)</l>
<l>*         dev_display(R2)</l>
<l>        intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<c>        *** only biggeast region should remain</c>
<l>        connection(Rsh, Rshs)</l>
<l>        area_center(Rshs, AreaRshs, RowRshs, ColumnRshs)</l>
<l>        tuple_length(AreaRshs, no)</l>
<l>        if(no&gt;1)</l>
<l>            tuple_sort_index(AreaRshs, Ind)</l>
<l>            tuple_inverse(Ind, Inverted)</l>
<l>            select_obj(Rshs, Rshf,Inverted[0]+1)</l>
<l>            concat_obj(RegionsSh, Rshf, RegionsSh)</l>
<l>        else</l>
<l>            concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>        endif</l>
<c>        </c>
<l>*        stop() </l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectShortN5">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterFloadMedn_COPY_1">
<interface>
<ic>
<par name="W" base_type="ctrl" dimension="0"/>
<par name="sz" base_type="ctrl" dimension="0"/>
<par name="prcmb" base_type="ctrl" dimension="0"/>
<par name="prcsp" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Def" base_type="ctrl" dimension="0"/>
<par name="Wfilt" base_type="ctrl" dimension="0"/>
<par name="Wch" base_type="ctrl" dimension="0"/>
<par name="Prc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* FilterFloadMedn</c>
<l>tuple_length (W, nW)</l>
<l>tuple_gen_const (nW, -prcmb, ThrMB)</l>
<l>tuple_gen_const (nW, prcsp, ThrSp)</l>
<l>tuple_gen_const (sz, W[0], Wbeg)</l>
<l>tuple_gen_const (sz, W[nW-1], Wend)</l>
<l>tuple_insert (W, 0, Wbeg, Wext)</l>
<l>tuple_concat (Wext, Wend, Wext)</l>
<l>Wfilt := []</l>
<l>i := 0</l>
<l>for j := sz to nW+sz-1 by 1</l>
<l>    beg := j-sz</l>
<l>    end := nW-1</l>
<l>    tuple_select_range (Wext, j-sz, j+sz, Sel)</l>
<l>    tuple_median (Sel, medSel)</l>
<l>    tuple_concat (Wfilt, medSel, Wfilt)</l>
<l>endfor</l>
<c></c>
<l>Wch := W-Wfilt</l>
<l>Prc := Wch*100.0/(Wfilt+0.001)</l>
<l>tuple_greater_equal_elem (Prc, ThrSp, DefSp)</l>
<l>tuple_less_equal_elem (Prc, ThrMB, DefMB)</l>
<l>Def := -DefMB+DefSp</l>
<l>return ()</l>
</body>
<docu id="FilterFloadMedn_COPY_1">
<parameters>
<parameter id="Def"/>
<parameter id="Prc"/>
<parameter id="W"/>
<parameter id="Wch"/>
<parameter id="Wfilt"/>
<parameter id="prcmb"/>
<parameter id="prcsp"/>
<parameter id="sz"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain120C">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain120C - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231002 * new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<l>tuple_max(wFWM, maxwfwm)</l>
<c></c>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>connection (RegionGid, RegionsGid)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGsm, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<c></c>
<l>intersection (RegionGSi, RC, RegionGSii)</l>
<l>difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    Regionsmain:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<l>count_obj(Regionsmain, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(Regionsmain, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>count_obj(RegionsmainPNi, nRMPNI)</l>
<c></c>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPi, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPip</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<l>connection(RmainS, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseq := nGND+1</l>
<l>overf := 255-stseq</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<c></c>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=SkeletonPartsP</l>
<l>SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq</l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>MSBuildFWM5 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain120C">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="PatternWidthDirImages_COPY_1">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="AngleImageP" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** Width image for Pattern</c>
<l>distance_transform (RegionG, DistanceImageGi, 'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>* reduce_domain (DistanceImageG, SkeletonG, ImageReduced)</l>
<l>scale_image (DistanceImageGi, WidthImageP4, 2, -1)</l>
<l>mean_image (WidthImageP4, DistanceImageG, 3, 3)</l>
<c></c>
<l>convert_image_type (DistanceImageG, WidthImageP, 'byte')</l>
<l>convol_image (WidthImageP, ImageResult, 'lowpas_3_3', 'mirrored')</l>
<c>* **</c>
<c>* ------- Dir image for Pattern</c>
<l>copy_image (WidthImageP, DirImageP)</l>
<l>gen_contours_skeleton_xld (SkeletonG, SkContoursG, 10, 'filter')</l>
<l>* dev_update_off ()</l>
<l>gen_image_const (AngleImageP, 'real', WidthG, HeightG)</l>
<l>count_obj (SkContoursG, nSkCG)</l>
<l>for k := 1 to nSkCG by 1</l>
<l>*     if (k==1452)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    select_obj (SkContoursG, SelectedContourG, k)</l>
<l>    contour_point_num_xld (SelectedContourG, np)</l>
<l>    get_contour_xld (SelectedContourG, RowG, ColG)</l>
<l>    gen_region_points (RegionSCG, RowG, ColG)</l>
<l>    if (np &lt; 21)</l>
<l>        lookaround := 1</l>
<l>    else</l>
<l>        lookaround := 3</l>
<l>    endif</l>
<l>    get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>    tuple_length (AnglesG, nA)</l>
<c></c>
<l>    set_grayval (AngleImageP, RowG[0], ColG[0], AnglesG[0]-3.14159)</l>
<l>    set_grayval (AngleImageP, RowG[1], ColG[1], AnglesG[1]-3.14159)</l>
<l>    set_grayval (AngleImageP, RowG[2], ColG[2], AnglesG[2]-3.14159)</l>
<l>    set_grayval (AngleImageP, RowG[nA-1], ColG[nA-1], AnglesG[nA-1])</l>
<l>    set_grayval (AngleImageP, RowG[nA-2], ColG[nA-2], AnglesG[nA-2])</l>
<l>    set_grayval (AngleImageP, RowG[nA-3], ColG[nA-3], AnglesG[nA-3])</l>
<c></c>
<c></c>
<l>    tuple_add (AnglesG, rad(90), AnglesG1)</l>
<l>    tuple_fmod (AnglesG1, rad(180), AnglesG2)</l>
<l>    tuple_mult (AnglesG2, 256.0/rad(180), AnglesG3)</l>
<l>    set_grayval (DirImageP, RowG, ColG, AnglesG3)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PatternWidthDirImages_COPY_1">
<parameters>
<parameter id="AngleImageP"/>
<parameter id="DirImageP"/>
<parameter id="HeightG"/>
<parameter id="RegionG"/>
<parameter id="SkeletonG"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRB16andCLC41">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN16" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB16" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC41 -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB16 := ImagePN16</l>
<l>ImageCLC:=ImageChainLength</l>
<l>get_domain(Im, Domain)</l>
<l>addr:=0</l>
<l>nmax:=0</l>
<l>tuple_gen_sequence(0, 1000000, lstep, SeqM)</l>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>area_center(RegionsInoD, Area, Row, Column)</l>
<l>tuple_max(Area, amax)</l>
<c></c>
<l>tuple_sort_index(Area, Indices)</l>
<l>tuple_inverse(Indices, Inverted)</l>
<l>amax2:=Area[Inverted[0]]</l>
<l>select_obj(RegionsInoD, ObjectSelected, Inverted[0]+1)</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=1272</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>*     erosion_circle(RInoD, RegionErosion, 1)</l>
<l>*     get_region_polygon(RegionErosion, 1, RowsP, ColumnsP)</l>
<l>*     get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<l>*     get_region_polygon(RInoD, 0.5, RowsP, ColumnsP)</l>
<l>*     tuple_length(RowsInoD, nId)</l>
<l>*     Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/8]] </l>
<l>*     Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/8]]</l>
<c>    </c>
<l>    tuple_length(RowsC, nIc)</l>
<l>    RselC:=[RowsC[nIc/2], RowsC[nIc/4], RowsC[nIc*3/8]] </l>
<l>    CselC:=[ColsC[nIc/2], ColsC[nIc/4], ColsC[nIc*3/8]]</l>
<l>*     Rsel:=RowsInoD</l>
<l>*     Csel:=ColsInoD</l>
<l>* get_grayval (ImageIR16, Rsel, Csel, Grayval)</l>
<l>*     tuple_median(Grayval, pn)</l>
<c>    </c>
<l>get_grayval (ImageIR16, RselC, CselC, GrayvalC)</l>
<l>    tuple_median(GrayvalC, pnC)</l>
<l>    if(GrayvalC[0]!=GrayvalC[1] or GrayvalC[2]!=GrayvalC[1])</l>
<l>        RselC:=[RowsC[nIc/8], RowsC[nIc/4], RowsC[nIc*3/8], RowsC[nIc/2], RowsC[nIc*5/8], RowsC[nIc*6/8], RowsC[nIc*7/8], RowsC[nIc*2/3], RowsC[nIc/3]] </l>
<l>        CselC:=[ColsC[nIc/8], ColsC[nIc/4], ColsC[nIc*3/8], ColsC[nIc/2], ColsC[nIc*5/8], ColsC[nIc*7/8], ColsC[nIc*7/8], ColsC[nIc*2/3], ColsC[nIc/3]]</l>
<l>get_grayval (ImageIR16, RselC, CselC, GrayvalC2)</l>
<l>        tuple_median(GrayvalC2, pnC)</l>
<l>    endif</l>
<l>*     tuple_max(GrayvalC, ma)</l>
<l>*     tuple_min(GrayvalC, mi)</l>
<l>*     if(ma!=mi)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     tuple_equal(GrayvalC,Grayval,Equal)</l>
<l>*     if(Equal==0)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(pn!=pnC)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    tuple_length(RowsC, n1)</l>
<l>*     if(n1&gt;nmax)</l>
<l>*         nmax:=n1</l>
<l>*     endif</l>
<l>     addr:= addr+n1</l>
<l>*     tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<c>     </c>
<l>    tuple_select_range(SeqM, 0, n1*lstep-lstep, Seq)</l>
<c>    </c>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<l>*     gen_region_points(Region, RowsC, ColsC)</l>
<c>*     overpaint_region</c>
<c></c>
<l>    tuple_gen_const(n1, pnC, Pn)</l>
<l>set_grayval (ImageIRB16, RowsC, ColsC, Pn)</l>
<l>*     gen_region_points(RR, RowsC, ColsC)</l>
<l>* overpaint_region (ImageIRB16, RR, pn, 'fill')</l>
<c></c>
<c>    </c>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        count_obj(RHoles, nHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>*             if(jj==3)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>*             complement(Hole, HoleComp)</l>
<l>            difference(Domain, Hole,  HoleComp)</l>
<l>            boundary(HoleComp, HoleB, 'inner')</l>
<c>            </c>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<l>*             get_region_polygon(HoleComp, 1, Rows, Columns)</l>
<c>            </c>
<l>            gen_region_points(HoleP, RowsC, ColsC)</l>
<l>            boundary(HoleP, HolePB, 'outer')</l>
<c>            </c>
<c>            </c>
<l>*             boundary(Hole, HoleB, 'outer')</l>
<c>* *            fill_up(HoleB, HoleBFU)</c>
<l>*             set_system('neighborhood',4)</l>
<l>*             get_region_contour(HoleB, RowsC, ColsC)</l>
<l>*             gen_region_points(HoleP, RowsC, ColsC)</l>
<c>            ****</c>
<l>            tuple_length(RowsC, n)</l>
<l>*             if(n&gt;nmax)</l>
<l>*                 nmax:=1</l>
<l>*             endif</l>
<c></c>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>            tuple_select_range(SeqM, 0, n*lstep-lstep, Seq)</l>
<l>            tuple_max(ColsC, cm)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>            tuple_gen_const(n, pnC, Pn)</l>
<l>set_grayval (ImageIRB16, RowsC, ColsC, Pn)</l>
<l>*             gen_region_points(RR, RowsC, ColsC)</l>
<l>* overpaint_region (ImageIRB16, RR, pn, 'fill')</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>*     stop()</l>
<l>endfor</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRB16andCLC41">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRB16"/>
<parameter id="ImagePN16"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain121C">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain121C - new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<l>tuple_max(wFWM, maxwfwm)</l>
<c></c>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>connection (RegionGid, RegionsGid)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGsm, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<c></c>
<l>intersection (RegionGSi, RC, RegionGSii)</l>
<l>difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, Regionsmain, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    Regionsmain:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<l>count_obj(Regionsmain, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>union1(Regionsmain, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<c>***</c>
<c>***</c>
<l>intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>count_obj(RegionsmainPNi, nRMPNI)</l>
<c></c>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPi, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPip</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>union1(CirclesSJ, CirclesSJu)</l>
<l>difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>**********</c>
<l>connection(RmainSnoJ, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>union1(RegionsmainSs, RegionsmainSu)</l>
<l>difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>union1(EndPointsMSS, EndPointsMSSu)</l>
<l>connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>RegionsmainSn:=RegionsmainSs</l>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<c></c>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=SkeletonPartsP</l>
<l>SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>MSBuildFWM5 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain121C">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS4">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*****BuildIRBS3_16b - 14.09.2022</c>
<l>ImIRBSOut := ImIRBS</l>
<c>** dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<l>dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<l>union1(SkeletonsFWMSd, SkeletonsFWMSdu)</l>
<l>* difference(SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<l>difference(SkeletonsFWMSdu, RegionInoD, SkeletonsFWMSmu)</l>
<l>connection(SkeletonsFWMSmu, SkeletonsFWMSm)</l>
<l>* intersection(SkeletonsFWMS, RegionInoD,RegionIntersection)</l>
<l>* union2(SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region(RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region(SkeletonsFWMSm, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>* SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS4">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS3_16b">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*****BuildIRBS3_16b - 14.09.2022</c>
<l>ImIRBSOut := ImIRBS</l>
<c>** dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<l>dilation_circle(SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<l>union1(SkeletonsFWMSd, SkeletonsFWMSdu)</l>
<l>* difference(SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<l>difference(SkeletonsFWMSdu, RegionInoD, SkeletonsFWMSmu)</l>
<l>connection(SkeletonsFWMSmu, SkeletonsFWMSm)</l>
<l>* intersection(SkeletonsFWMS, RegionInoD,RegionIntersection)</l>
<l>* union2(SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region(RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region(SkeletonsFWMSm, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>count_obj(RegionsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWMS, 1, SequenceINBSi)</l>
<l>* SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS3_16b">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS4B2">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBS41B2 - 18.04.2023 - removed difference for regions tuple</c>
<l>ImIRBSOut := ImIRBS</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 3</l>
<l>dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<l>count_obj (SkeletonsFWMSd, no)</l>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWMS, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoD, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMSd, RegionInoDC, SkeletonsFWMSm)</l>
<l>union1(SkeletonsFWMSd, SkeletonsFWMSdu)</l>
<l>intersection (SkeletonsFWMSdu, RegionInoDC, SkeletonsFWMSmu)</l>
<l>connection(SkeletonsFWMSmu, SkeletonsFWMSm2)</l>
<c>* 3</c>
<l>* difference (SkeletonsFWMSm, SkeletonsFWMSm2, RegionDifference1)</l>
<c></c>
<c></c>
<l>* area_center (SkeletonsFWMSm, Area, Row, Column)</l>
<l>* tuple_min (Area, amin)</l>
<l>* count_obj (SkeletonsFWMSm, nm)</l>
<c></c>
<l>* symm_difference (SkeletonsFWMSm, SkeletonsFWMSc, RegionDifference)</l>
<c></c>
<l>* intersection (SkeletonsFWMS, RegionInoD, RegionIntersection)</l>
<l>* union2 (SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region (RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>expand_region (SkeletonsFWMSm, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMS, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>count_obj (SkeletonsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (2, nRFWMS+1, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS2, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS2, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS4B2">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS16">
<interface>
<io>
<par name="RegionsInoD" base_type="iconic" dimension="0"/>
<par name="ImageChainLength" base_type="iconic" dimension="0"/>
<par name="ImagePN16" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRB16" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lstep" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>***BuildIRBandCLC41 -without vectors and tuples 2022.08.25</c>
<l>set_system('neighborhood', 4)</l>
<c></c>
<l>ImageIRB16 := ImagePN16</l>
<l>ImageCLC:=ImageChainLength</l>
<l>get_domain(Im, Domain)</l>
<l>addr:=0</l>
<l>nmax:=0</l>
<l>tuple_gen_sequence(0, 400000, lstep, SeqM)</l>
<c>* vector insertion index</c>
<l>* i:=1</l>
<l>count_obj(RegionsInoD, nInoD)</l>
<l>for j:=1 to nInoD by 1</l>
<l>*     j:=104</l>
<l>    select_obj(RegionsInoD, RInoD, j)</l>
<l>*     erosion_circle(RInoD, RegionErosion, 1)</l>
<l>*     get_region_polygon(RegionErosion, 1, RowsP, ColumnsP)</l>
<l>*     get_region_points(RInoD, RowsInoD, ColsInoD)</l>
<l>    get_region_contour(RInoD, RowsC, ColsC)</l>
<l>*     get_region_polygon(RInoD, 0.5, RowsP, ColumnsP)</l>
<l>*     tuple_length(RowsInoD, nId)</l>
<l>*     Rsel:=[RowsInoD[nId/2], RowsInoD[nId/4], RowsInoD[nId*3/8]] </l>
<l>*     Csel:=[ColsInoD[nId/2], ColsInoD[nId/4], ColsInoD[nId*3/8]]</l>
<c>    </c>
<l>    tuple_length(RowsC, nIc)</l>
<l>    RselC:=[RowsC[nIc/2], RowsC[nIc/4], RowsC[nIc*3/8]] </l>
<l>    CselC:=[ColsC[nIc/2], ColsC[nIc/4], ColsC[nIc*3/8]]</l>
<l>*     Rsel:=RowsInoD</l>
<l>*     Csel:=ColsInoD</l>
<l>* get_grayval (ImageIR16, Rsel, Csel, Grayval)</l>
<l>*     tuple_median(Grayval, pn)</l>
<c>    </c>
<l>get_grayval (ImageIR16, RselC, CselC, GrayvalC)</l>
<l>    tuple_median(GrayvalC, pnC)</l>
<l>    if(GrayvalC[0]!=GrayvalC[1] or GrayvalC[2]!=GrayvalC[1])</l>
<l>        RselC:=[RowsC[nIc/8], RowsC[nIc/4], RowsC[nIc*3/8], RowsC[nIc/2], RowsC[nIc*5/8], RowsC[nIc*6/8], RowsC[nIc*7/8], RowsC[nIc*2/3], RowsC[nIc/3]] </l>
<l>        CselC:=[ColsC[nIc/8], ColsC[nIc/4], ColsC[nIc*3/8], ColsC[nIc/2], ColsC[nIc*5/8], ColsC[nIc*7/8], ColsC[nIc*7/8], ColsC[nIc*2/3], ColsC[nIc/3]]</l>
<l>get_grayval (ImageIR16, RselC, CselC, GrayvalC2)</l>
<l>        tuple_median(GrayvalC2, pnC)</l>
<l>    endif</l>
<l>*     tuple_max(GrayvalC, ma)</l>
<l>*     tuple_min(GrayvalC, mi)</l>
<l>*     if(ma!=mi)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     tuple_equal(GrayvalC,Grayval,Equal)</l>
<l>*     if(Equal==0)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     if(pn!=pnC)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<c>    ****</c>
<l>*     gen_region_points(RCont,RowsC, ColsC)</l>
<c></c>
<l>    tuple_length(RowsC, n1)</l>
<l>*     if(n1&gt;nmax)</l>
<l>*         nmax:=n1</l>
<l>*     endif</l>
<l>     addr:= addr+n1</l>
<l>*     tuple_gen_sequence(0, n1*lstep-lstep, lstep, Seq)</l>
<c>     </c>
<l>    tuple_select_range(SeqM, 0, n1*lstep-lstep, Seq)</l>
<l>    set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<l>*     gen_region_points(Region, RowsC, ColsC)</l>
<c>*     overpaint_region</c>
<c></c>
<l>    tuple_gen_const(n1, pnC, Pn)</l>
<l>set_grayval (ImageIRB16, RowsC, ColsC, Pn)</l>
<l>*     gen_region_points(RR, RowsC, ColsC)</l>
<l>* overpaint_region (ImageIRB16, RR, pn, 'fill')</l>
<c></c>
<c>    </c>
<l>*     i:=i+1</l>
<l>    connect_and_holes(RInoD, nConnected, nHoles)</l>
<l>    if(nHoles&gt;0)</l>
<l>        fill_up(RInoD, RInodFillUp)</l>
<l>        difference(RInodFillUp, RInoD, RHole)</l>
<l>        connection(RHole, RHoles)</l>
<l>        count_obj(RHoles, nHoles)</l>
<l>        for jj:=1 to nHoles by 1</l>
<l>*             if(jj==3)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c>            **</c>
<l>            select_obj(RHoles, Hole, jj)</l>
<l>*             complement(Hole, HoleComp)</l>
<l>            difference(Domain, Hole,  HoleComp)</l>
<l>            boundary(HoleComp, HoleB, 'inner')</l>
<c>            </c>
<l>            get_region_contour(HoleB, RowsC, ColsC)</l>
<l>*             get_region_polygon(HoleComp, 1, Rows, Columns)</l>
<c>            </c>
<l>            gen_region_points(HoleP, RowsC, ColsC)</l>
<l>            boundary(HoleP, HolePB, 'outer')</l>
<c>            </c>
<c>            </c>
<l>*             boundary(Hole, HoleB, 'outer')</l>
<c>* *            fill_up(HoleB, HoleBFU)</c>
<l>*             set_system('neighborhood',4)</l>
<l>*             get_region_contour(HoleB, RowsC, ColsC)</l>
<l>*             gen_region_points(HoleP, RowsC, ColsC)</l>
<c>            ****</c>
<l>            tuple_length(RowsC, n)</l>
<l>*             if(n&gt;nmax)</l>
<l>*                 nmax:=1</l>
<l>*             endif</l>
<c></c>
<l>            addr:= addr+n</l>
<l>*             tuple_gen_sequence(0, n*lstep-lstep, lstep, Seq)</l>
<l>            tuple_select_range(SeqM, 0, n*lstep-lstep, Seq)</l>
<l>            tuple_max(ColsC, cm)</l>
<l>            set_grayval(ImageCLC, RowsC, ColsC, Seq)</l>
<c></c>
<l>            tuple_gen_const(n, pnC, Pn)</l>
<l>set_grayval (ImageIRB16, RowsC, ColsC, Pn)</l>
<l>*             gen_region_points(RR, RowsC, ColsC)</l>
<l>* overpaint_region (ImageIRB16, RR, pn, 'fill')</l>
<l>        endfor</l>
<l>    else</l>
<c>    ***** Contour ****</c>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS16">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageChainLength"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRB16"/>
<parameter id="ImagePN16"/>
<parameter id="RegionsInoD"/>
<parameter id="lstep"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevAbsP">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegsMB" base_type="iconic" dimension="0"/>
<par name="RegsSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
<par name="gMB" base_type="ctrl" dimension="0"/>
<par name="gSpur" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*   ProcDevAbsP</c>
<c>*** 20231017- output gegs and gray check</c>
<c>*** 20220429-complement shouldn't be used because of wrong outer boundaries</c>
<l>* complement(RegionInoD, RegionInoDC)</l>
<l>erosion_circle(RegionInoD, RegionInoDe, 2)</l>
<l>get_region_contour(RegionInoDe, RowsCP, ColsCP)</l>
<l>tuple_max(ColsCP, MaxCPC)</l>
<l>tuple_max(RowsCP, MaxCPR)</l>
<l>gen_rectangle1(Rectangle, 0, 0, MaxCPR, MaxCPC)</l>
<l>* gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<l>difference(Rectangle, RegionInoDe, RegionInoDC)</l>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<l>* tuple_max(ColsCC, MaxCC)</l>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<c></c>
<l>gen_region_points(TInoDC, RowsC, ColsC)</l>
<l>* tuple_max(ColsC, MaxC)</l>
<l>*tuple_min(ColsC, MinC)</l>
<l>* tuple_max(RowsC, MaxR)</l>
<l>*tuple_min(RowsC, MinR)</l>
<l>* get_grayval(ImDeviation, MaxR/2, MaxC/2, Deviation1)</l>
<l>* get_image_size(ImDeviation,Width, Height)</l>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>tuple_max(ColsC, Max)</l>
<c></c>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nPs)</l>
<l>gen_empty_obj(RegsSpur)</l>
<l>area_center(Ps, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPs by 1</l>
<l>*     j:=33</l>
<l>        select_obj(Pss, OPs, j)</l>
<l>        get_region_points(OPs, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &gt; gSpur)</l>
<l>            concat_obj(RegsSpur, OPs, RegsSpur)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nPsl)</l>
<c></c>
<l>gen_empty_obj(RegsMB)</l>
<l>area_center(Psl, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPsl by 1</l>
<l>*     j:=75</l>
<l>        select_obj(Psls, OPls, j)</l>
<l>        get_region_points(OPls, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &lt; gMB)</l>
<l>            concat_obj(RegsMB, OPs, RegsMB)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<c></c>
<l>* area_center(Psls, Area, Row, Col)</l>
<l>* rc:=30.5</l>
<l>* tuple_gen_const( nMin, rc, Rc)</l>
<l>* gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>* union1(CirclesMin1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsMB)</l>
<l>* count_obj (RegsMB, nMin)</l>
<c></c>
<l>* connection(Ps, Pss)</l>
<l>* count_obj(Pss, nMax)</l>
<c></c>
<l>* area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>* tuple_gen_const( nMax, rc, Rc)</l>
<l>* gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>* union1(CirclesMax1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsSpur)</l>
<l>* count_obj (RegsSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevAbsP">
<parameters>
<parameter id="Im"/>
<parameter id="ImDeviation"/>
<parameter id="RegionInoD"/>
<parameter id="RegsMB"/>
<parameter id="RegsSpur"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
<parameter id="gMB"/>
<parameter id="gSpur"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevAbsP2">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegsMB" base_type="iconic" dimension="0"/>
<par name="RegsSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
<par name="gMB" base_type="ctrl" dimension="0"/>
<par name="gSpur" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*   ProcDevAbsP2</c>
<c>*** 20231017- output gegs and gray check</c>
<c>*** 20220429-complement shouldn't be used because of wrong outer boundaries</c>
<l>* complement (RegionInoD, RegionInoDC)</l>
<l>* union1 (RegionInoD, RegionInoD)</l>
<l>connection(RegionInoD, RegionsInoD2)</l>
<l>erosion_circle (RegionInoD, RegionInoDe, 2)</l>
<l>get_region_contour(RegionInoDe, RowsCP, ColsCP)</l>
<l>tuple_max(ColsCP, MaxCPC)</l>
<l>tuple_max(RowsCP, MaxCPR)</l>
<l>gen_rectangle1(Rectangle, 0, 0, MaxCPR, MaxCPC)</l>
<l>* gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<l>difference(Rectangle, RegionInoDe, RegionInoDC)</l>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<l>* tuple_max(ColsCC, MaxCC)</l>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<c></c>
<l>gen_region_points(TInoDC, RowsC, ColsC)</l>
<l>* tuple_max(ColsC, MaxC)</l>
<l>*tuple_min(ColsC, MinC)</l>
<l>* tuple_max(RowsC, MaxR)</l>
<l>*tuple_min(RowsC, MinR)</l>
<l>* get_grayval(ImDeviation, MaxR/2, MaxC/2, Deviation1)</l>
<l>* get_image_size(ImDeviation,Width, Height)</l>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>tuple_max(ColsC, Max)</l>
<c></c>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nPs)</l>
<l>gen_empty_obj(RegsSpur)</l>
<l>area_center(Ps, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPs by 1</l>
<l>*     j:=9</l>
<l>        select_obj(Pss, OPs, j)</l>
<l>        skeleton(OPs, SkeletonPs)</l>
<l>        gen_contours_skeleton_xld(SkeletonPs, Contours, 1, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours, UnionContours, 10, 1, 'attr_keep')</l>
<l>        select_contours_xld(UnionContours, SelectedContours, 'contour_length', 2.5, 200, -0.5, 0.5)</l>
<l>        close_contours_xld(SelectedContours, ClosedContours)</l>
<l>        count_obj(ClosedContours, nC)</l>
<l>        if(nC==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        gen_region_contour_xld(ClosedContours, RegionsOP, 'filled')</l>
<l>        union1(RegionsOP, RegionOP)</l>
<l>        get_region_points(RegionOP, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<c>        </c>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &gt; gSpur)</l>
<l>*             area_center(RegionOP, a, rowOp, columnOp)</l>
<l>*             select_region_point(RegionsInoD2, Reg, rowOp, columnOp)</l>
<l>*             difference(RegionsInoD2, Reg, RegionsInoD2noReg)</l>
<l>*             union1(RegionsInoD2noReg, RegionInoD2noReg)</l>
<l>*             distance_rr_min(RegionOP, RegionInoD2noReg, minDistance, Row1, Column1, Row2, Column2)</l>
<l>            concat_obj(RegsSpur, RegionOP, RegsSpur)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nPsl)</l>
<c></c>
<l>gen_empty_obj(RegsMB)</l>
<l>area_center(Psl, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPsl by 1</l>
<l>*     j:=75</l>
<l>        select_obj(Psls, OPls, j)</l>
<l>        get_region_points(OPls, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &lt; gMB)</l>
<l>            concat_obj(RegsMB, OPs, RegsMB)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<c></c>
<l>* area_center(Psls, Area, Row, Col)</l>
<l>* rc:=30.5</l>
<l>* tuple_gen_const( nMin, rc, Rc)</l>
<l>* gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>* union1(CirclesMin1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsMB)</l>
<l>* count_obj (RegsMB, nMin)</l>
<c></c>
<l>* connection(Ps, Pss)</l>
<l>* count_obj(Pss, nMax)</l>
<c></c>
<l>* area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>* tuple_gen_const( nMax, rc, Rc)</l>
<l>* gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>* union1(CirclesMax1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsSpur)</l>
<l>* count_obj (RegsSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevAbsP2">
<parameters>
<parameter id="Im"/>
<parameter id="ImDeviation"/>
<parameter id="RegionInoD"/>
<parameter id="RegsMB"/>
<parameter id="RegsSpur"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
<parameter id="gMB"/>
<parameter id="gSpur"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevAbsP3">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="Region" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegsMB" base_type="iconic" dimension="0"/>
<par name="RegsSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
<par name="gMB" base_type="ctrl" dimension="0"/>
<par name="gSpur" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*   ProcDevAbsP3 - not working</c>
<c>*** 20231018- check distance to other regions</c>
<c>*** 20231017- output gegs and gray check</c>
<c>*** 20220429-complement shouldn't be used because of wrong outer boundaries</c>
<l>* complement (RegionInoD, RegionInoDC)</l>
<l>* union1 (RegionInoD, RegionInoD)</l>
<l>connection(RegionInoD, RegionsInoD2)</l>
<l>erosion_circle (RegionInoD, RegionInoDe, 2)</l>
<l>get_region_contour(RegionInoDe, RowsCP, ColsCP)</l>
<l>tuple_max(ColsCP, MaxCPC)</l>
<l>tuple_max(RowsCP, MaxCPR)</l>
<l>gen_rectangle1(Rectangle, 0, 0, MaxCPR, MaxCPC)</l>
<l>* gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<l>difference(Rectangle, RegionInoDe, RegionInoDC)</l>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<l>* tuple_max(ColsCC, MaxCC)</l>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<c></c>
<l>gen_region_points(TInoDC, RowsC, ColsC)</l>
<l>* tuple_max(ColsC, MaxC)</l>
<l>*tuple_min(ColsC, MinC)</l>
<l>* tuple_max(RowsC, MaxR)</l>
<l>*tuple_min(RowsC, MinR)</l>
<l>* get_grayval(ImDeviation, MaxR/2, MaxC/2, Deviation1)</l>
<l>* get_image_size(ImDeviation,Width, Height)</l>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>tuple_max(ColsC, Max)</l>
<c></c>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nPs)</l>
<l>gen_empty_obj(RegsSpur)</l>
<l>area_center(Ps, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPs by 1</l>
<l>*     j:=9</l>
<l>        select_obj(Pss, OPs, j)</l>
<l>        skeleton(OPs, SkeletonPs)</l>
<l>        gen_contours_skeleton_xld(SkeletonPs, Contours, 1, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours, UnionContours, 10, 1, 'attr_keep')</l>
<l>        select_contours_xld(UnionContours, SelectedContours, 'contour_length', 2.5, 200, -0.5, 0.5)</l>
<l>        close_contours_xld(SelectedContours, ClosedContours)</l>
<l>        count_obj(ClosedContours, nC)</l>
<l>        if(nC==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        gen_region_contour_xld(ClosedContours, RegionsOP, 'filled')</l>
<l>        union1(RegionsOP, RegionOP)</l>
<l>        get_region_points(RegionOP, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<c>        </c>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &gt; gSpur)</l>
<l>*             area_center(RegionOP, a, rowOp, columnOp)</l>
<l>*             select_region_point(RegionsInoD2, Reg, rowOp, columnOp)</l>
<l>*             difference(RegionsInoD2, Reg, RegionsInoD2noReg)</l>
<l>*             union1(RegionsInoD2noReg, RegionInoD2noReg)</l>
<l>*             distance_rr_min(RegionOP, RegionInoD2noReg, minDistance, Row1, Column1, Row2, Column2)</l>
<l>            concat_obj(RegsSpur, RegionOP, RegsSpur)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nPsl)</l>
<c></c>
<l>gen_empty_obj(RegsMB)</l>
<l>area_center(Psl, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPsl by 1</l>
<l>*     j:=75</l>
<l>        select_obj(Psls, OPls, j)</l>
<l>        get_region_points(OPls, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &lt; gMB)</l>
<l>            concat_obj(RegsMB, OPs, RegsMB)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<c></c>
<l>* area_center(Psls, Area, Row, Col)</l>
<l>* rc:=30.5</l>
<l>* tuple_gen_const( nMin, rc, Rc)</l>
<l>* gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>* union1(CirclesMin1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsMB)</l>
<l>* count_obj (RegsMB, nMin)</l>
<c></c>
<l>* connection(Ps, Pss)</l>
<l>* count_obj(Pss, nMax)</l>
<c></c>
<l>* area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>* tuple_gen_const( nMax, rc, Rc)</l>
<l>* gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>* union1(CirclesMax1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsSpur)</l>
<l>* count_obj (RegsSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevAbsP3">
<parameters>
<parameter id="Im"/>
<parameter id="ImDeviation"/>
<parameter id="Region"/>
<parameter id="RegionInoD"/>
<parameter id="RegsMB"/>
<parameter id="RegsSpur"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
<parameter id="gMB"/>
<parameter id="gSpur"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevAbsP21">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionInoDnoFWM" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegsMB" base_type="iconic" dimension="0"/>
<par name="RegsSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
<par name="gMB" base_type="ctrl" dimension="0"/>
<par name="gSpur" base_type="ctrl" dimension="0"/>
<par name="dist" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*   ProcDevAbsP21</c>
<c>*** 20231018- check distance to other regions</c>
<c>*** 20231017- output gegs and gray check</c>
<c>*** 20220429-complement shouldn't be used because of wrong outer boundaries</c>
<l>* complement (RegionInoD, RegionInoDC)</l>
<l>* union1 (RegionInoD, RegionInoD)</l>
<l>connection(RegionInoD, RegionsInoD2)</l>
<l>erosion_circle (RegionInoDnoFWM, RegionInoDe, 2)</l>
<l>get_region_contour(RegionInoDe, RowsCP, ColsCP)</l>
<l>tuple_max(ColsCP, MaxCPC)</l>
<l>tuple_max(RowsCP, MaxCPR)</l>
<l>gen_rectangle1(Rectangle, 0, 0, MaxCPR, MaxCPC)</l>
<l>* gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<l>difference(Rectangle, RegionInoDe, RegionInoDC)</l>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<l>* tuple_max(ColsCC, MaxCC)</l>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<c></c>
<l>gen_region_points(TInoDC, RowsC, ColsC)</l>
<l>* tuple_max(ColsC, MaxC)</l>
<l>*tuple_min(ColsC, MinC)</l>
<l>* tuple_max(RowsC, MaxR)</l>
<l>*tuple_min(RowsC, MinR)</l>
<l>* get_grayval(ImDeviation, MaxR/2, MaxC/2, Deviation1)</l>
<l>* get_image_size(ImDeviation,Width, Height)</l>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>tuple_max(ColsC, Max)</l>
<c></c>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nPs)</l>
<l>gen_empty_obj(RegsSpur)</l>
<l>area_center(Ps, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPs by 1</l>
<l>*     j:=9</l>
<l>        select_obj(Pss, OPs, j)</l>
<l>        skeleton(OPs, SkeletonPs)</l>
<l>        gen_contours_skeleton_xld(SkeletonPs, Contours, 1, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours, UnionContours, 10, 1, 'attr_keep')</l>
<l>        select_contours_xld(UnionContours, SelectedContours, 'contour_length', 2.5, 200, -0.5, 0.5)</l>
<l>        close_contours_xld(SelectedContours, ClosedContours)</l>
<l>        count_obj(ClosedContours, nC)</l>
<l>        if(nC==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        gen_region_contour_xld(ClosedContours, RegionsOP, 'filled')</l>
<l>        union1(RegionsOP, RegionOP)</l>
<l>        get_region_points(RegionOP, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<c>        </c>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &gt; gSpur)</l>
<l>            area_center(RegionOP, a, rowOp, columnOp)</l>
<l>            difference(RegionInoD, RegionOP, RegionInoD2noReg)</l>
<c>            </c>
<l>            select_region_point(RegionsInoD2, Reg, rowOp, columnOp)</l>
<l>            difference(RegionInoD, Reg, RegionInoDnoReg)</l>
<l>*             union1(RegionsInoD2noReg, RegionInoD2noReg)</l>
<l>            gen_circle(COp, rowOp, columnOp, 80.5)</l>
<l>            intersection(RegionInoDnoReg, COp, RegionInoDCop)</l>
<l>            area_center(RegionInoDCop, a1, Row3, Column3)</l>
<l>            if(a1&gt;0)</l>
<l>                distance_rr_min(RegionOP, RegionInoDCop, minDistance, Row1, Column1, Row2, Column2)</l>
<l>                if(minDistance &lt; dist)</l>
<l>                    concat_obj(RegsSpur, RegionOP, RegsSpur)</l>
<l>                endif</l>
<l>            endif</l>
<c>                        </c>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nPsl)</l>
<c></c>
<l>gen_empty_obj(RegsMB)</l>
<l>area_center(Psl, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPsl by 1</l>
<l>*     j:=75</l>
<l>        select_obj(Psls, OPls, j)</l>
<l>        get_region_points(OPls, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &lt; gMB)</l>
<l>            concat_obj(RegsMB, OPs, RegsMB)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<c></c>
<l>* area_center(Psls, Area, Row, Col)</l>
<l>* rc:=30.5</l>
<l>* tuple_gen_const( nMin, rc, Rc)</l>
<l>* gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>* union1(CirclesMin1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsMB)</l>
<l>* count_obj (RegsMB, nMin)</l>
<c></c>
<l>* connection(Ps, Pss)</l>
<l>* count_obj(Pss, nMax)</l>
<c></c>
<l>* area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>* tuple_gen_const( nMax, rc, Rc)</l>
<l>* gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>* union1(CirclesMax1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsSpur)</l>
<l>* count_obj (RegsSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevAbsP21">
<parameters>
<parameter id="Im"/>
<parameter id="ImDeviation"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoDnoFWM"/>
<parameter id="RegsMB"/>
<parameter id="RegsSpur"/>
<parameter id="dist"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
<parameter id="gMB"/>
<parameter id="gSpur"/>
</parameters>
</docu>
</procedure>
<procedure name="ProcDevAbsP22">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="RegionInoDnoFWM" base_type="iconic" dimension="0"/>
<par name="ImDeviation" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegsMB" base_type="iconic" dimension="0"/>
<par name="RegsSpur" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="dmax" base_type="ctrl" dimension="0"/>
<par name="dmin" base_type="ctrl" dimension="0"/>
<par name="gMB" base_type="ctrl" dimension="0"/>
<par name="gSpur" base_type="ctrl" dimension="0"/>
<par name="dist" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*   ProcDevAbsP22</c>
<c>*** 20231019- catches only if protr &gt; distCAD/3.</c>
<c>*** 20231017- output gegs and gray check</c>
<c>*** 20220429-complement shouldn't be used because of wrong outer boundaries</c>
<l>* complement (RegionInoD, RegionInoDC)</l>
<l>* union1 (RegionInoD, RegionInoD)</l>
<l>connection(RegionInoD, RegionsInoD2)</l>
<l>erosion_circle (RegionInoDnoFWM, RegionInoDe, 2)</l>
<l>get_region_contour(RegionInoDe, RowsCP, ColsCP)</l>
<l>tuple_max(ColsCP, MaxCPC)</l>
<l>tuple_max(RowsCP, MaxCPR)</l>
<l>gen_rectangle1(Rectangle, 0, 0, MaxCPR, MaxCPC)</l>
<l>* gen_region_points(PRInoD, RowsCP, ColsCP)</l>
<l>* connection(PRInoD, ConnectedRegions)</l>
<l>difference(Rectangle, RegionInoDe, RegionInoDC)</l>
<l>get_region_contour(RegionInoDC, RowsCC, ColsCC)</l>
<l>gen_region_points(PRInoDC, RowsCC, ColsCC)</l>
<l>* tuple_max(ColsCC, MaxCC)</l>
<l>tuple_concat(RowsCP, RowsCC, RowsC)</l>
<l>tuple_concat(ColsCP, ColsCC, ColsC)</l>
<c></c>
<c></c>
<l>gen_region_points(TInoDC, RowsC, ColsC)</l>
<l>* tuple_max(ColsC, MaxC)</l>
<l>*tuple_min(ColsC, MinC)</l>
<l>* tuple_max(RowsC, MaxR)</l>
<l>*tuple_min(RowsC, MinR)</l>
<l>* get_grayval(ImDeviation, MaxR/2, MaxC/2, Deviation1)</l>
<l>* get_image_size(ImDeviation,Width, Height)</l>
<l>get_grayval(ImDeviation, RowsC, ColsC, Deviation1)</l>
<l>tuple_max(ColsC, Max)</l>
<c></c>
<l>Deviation:=Deviation1-127</l>
<c></c>
<c></c>
<l>tuple_length(Deviation, nPDev)</l>
<l>tuple_gen_const(nPDev, dmax, LPlus)</l>
<l>tuple_greater_elem(Deviation, LPlus, Greater)</l>
<l>tuple_select_mask(Deviation, Greater, Sel)</l>
<l>tuple_select_mask(RowsC, Greater, Cys)</l>
<l>tuple_select_mask(ColsC, Greater, Cxs)</l>
<l>gen_region_points(Ps, Cys,Cxs)</l>
<l>connection(Ps, Pss)</l>
<l>count_obj(Pss, nPs)</l>
<l>gen_empty_obj(RegsSpur)</l>
<l>area_center(Ps, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPs by 1</l>
<l>*     j:=11</l>
<l>        select_obj(Pss, OPs, j)</l>
<l>        skeleton(OPs, SkeletonPs)</l>
<l>        gen_contours_skeleton_xld(SkeletonPs, Contours, 1, 'filter')</l>
<l>        union_adjacent_contours_xld(Contours, UnionContours, 10, 1, 'attr_keep')</l>
<l>        select_contours_xld(UnionContours, SelectedContours, 'contour_length', 2.5, 200, -0.5, 0.5)</l>
<l>        close_contours_xld(SelectedContours, ClosedContours)</l>
<l>        count_obj(ClosedContours, nC)</l>
<l>        if(nC==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        gen_region_contour_xld(ClosedContours, RegionsOP, 'filled')</l>
<l>        union1(RegionsOP, RegionOP)</l>
<l>        get_region_points(RegionOP, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<c>        </c>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &gt; gSpur)</l>
<l>            area_center(RegionOP, a, rowOp, columnOp)</l>
<c>          </c>
<c>            </c>
<l>*             difference(RegionInoD, RegionOP, RegionInoD2noReg)</l>
<c>            </c>
<l>            select_region_point(RegionsInoD2, Reg, rowOp, columnOp)</l>
<l>            difference(RegionInoD, Reg, RegionInoDnoReg)</l>
<l>            gen_circle(COp, rowOp, columnOp, 80.5)</l>
<l>            intersection(RegionInoDnoReg, COp, RegionInoDCop)</l>
<l>            area_center(RegionInoDCop, a1, Row3, Column3)</l>
<l>            if(a1&gt;0)</l>
<l>                distance_rr_min(RegionOP, RegionInoDCop, distReal, Row1, Column1, Row2, Column2)</l>
<l>                gen_region_points(R1, Row1, Column1)</l>
<l>                gen_region_points(R2, Row2, Column2)</l>
<l>                gen_region_line(L, Row1, Column1, Row2, Column2)</l>
<l>                get_region_points(L, RowsL, ColumnsL)</l>
<l>                get_grayval(ImDeviation, RowsL, ColumnsL, LDval)</l>
<l>                tuple_max(LDval, maxLD)</l>
<l>                distCAD:=(maxLD-127)*2.</l>
<l>                protr:=distCAD-distReal</l>
<l>                if( protr &gt; distCAD/3.)</l>
<l>                    concat_obj(RegsSpur, RegionOP, RegsSpur)</l>
<l>                endif</l>
<l>            endif</l>
<c>                        </c>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>* stop()</l>
<c></c>
<l>tuple_gen_const(nPDev, dmin, LMin)</l>
<l>tuple_less_elem(Deviation, LMin, Less)</l>
<l>tuple_select_mask(Deviation, Less, Sel)</l>
<l>tuple_select_mask(RowsC, Less, Cysl)</l>
<l>tuple_select_mask(ColsC, Less, Cxsl)</l>
<l>gen_region_points(Psl, Cysl,Cxsl)</l>
<l>connection(Psl, Psls)</l>
<l>count_obj(Psls, nPsl)</l>
<c></c>
<l>gen_empty_obj(RegsMB)</l>
<l>area_center(Psl, a, Row, Column)</l>
<l>if(a&gt;0)</l>
<l>    for j:=1 to nPsl by 1</l>
<l>*     j:=75</l>
<l>        select_obj(Psls, OPls, j)</l>
<l>        get_region_points(OPls, Rows, Columns)</l>
<l>        get_grayval(Im, Rows, Columns, Grayval)</l>
<l>        tuple_mean(Grayval, g)</l>
<l>        if(g &lt; gMB)</l>
<l>            concat_obj(RegsMB, OPs, RegsMB)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<c></c>
<l>* area_center(Psls, Area, Row, Col)</l>
<l>* rc:=30.5</l>
<l>* tuple_gen_const( nMin, rc, Rc)</l>
<l>* gen_circle(CirclesMin1, Row, Col, Rc)</l>
<l>* union1(CirclesMin1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsMB)</l>
<l>* count_obj (RegsMB, nMin)</l>
<c></c>
<l>* connection(Ps, Pss)</l>
<l>* count_obj(Pss, nMax)</l>
<c></c>
<l>* area_center(Pss, Area, Row, Col)</l>
<c></c>
<l>* tuple_gen_const( nMax, rc, Rc)</l>
<l>* gen_circle(CirclesMax1, Row, Col, Rc)</l>
<l>* union1(CirclesMax1, RegionUnion)</l>
<l>* connection (RegionUnion, RegsSpur)</l>
<l>* count_obj (RegsSpur, nMax)</l>
<l>return ()</l>
</body>
<docu id="ProcDevAbsP22">
<parameters>
<parameter id="Im"/>
<parameter id="ImDeviation"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoDnoFWM"/>
<parameter id="RegsMB"/>
<parameter id="RegsSpur"/>
<parameter id="dist"/>
<parameter id="dmax"/>
<parameter id="dmin"/>
<parameter id="gMB"/>
<parameter id="gSpur"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN6">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN6 : new detect open proc. 11.08.2022</c>
<c>*** modified 21.10.2023, checking big opens</c>
<c>*** modified 12.09.2023, overkills removed</c>
<c></c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>connection(OpCandAlli, OpCandsAlli)</l>
<l>IndexesList:=[]</l>
<l>for j:=1 to nOpCands by 1</l>
<l>*     if(j==1233)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     j:=999</l>
<l>*     j:=15</l>
<l>    select_obj(OpCands, OpCand, j)</l>
<l>    area_center(OpCand, AreaC, RowC, ColumnC)</l>
<c>    </c>
<l>    get_region_index(OpCandsAlli, int(RowC), int(ColumnC), IndexAlli)</l>
<l>    select_obj(OpCandsAlli, ObjectSelected, IndexAlli)</l>
<l>    tuple_find(IndexesList, IndexAlli, Indices)</l>
<l>    tuple_length(Indices, n)</l>
<l>    if(n&gt;0)</l>
<c>        </c>
<l>    endif</l>
<l>*     if(AreaC &gt; 250)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>    get_region_points(OpCand, Rows, Columns)</l>
<l>    get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>    tuple_median(PpW, ppw)</l>
<l>    get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>    tuple_median(PpD, ppd)</l>
<l>    pa:=ppd*3.14159/256</l>
<l>    if(ppw&gt;100)</l>
<l>        continue</l>
<l>    endif</l>
<l>    if(AreaC&gt;1)</l>
<l>        smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+ppw, Length2+ppw+ppw)</l>
<l>        gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>    else</l>
<l>        gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>        gen_rectangle2(R3, RowC, ColumnC ,pa, ppw*2.5+5, ppw*2.5+5)</l>
<l>    endif</l>
<l>    intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>    connection(RegionIR2, RegionsIR2)</l>
<l>    intersection (SkeletonG, R2, RegionGR2)</l>
<c>    </c>
<l>    connection(RegionGR2, RegionsGR2)</l>
<l>    intersection (RegionG, R2, RegionGR)</l>
<l>    connection(RegionGR, RegionsGR)</l>
<c>    </c>
<l>    count_obj(RegionsGR2, nGR2)</l>
<l>    for jj:=1 to nGR2 by 1</l>
<l>        select_obj(RegionsGR2, Rsel, jj)</l>
<l>        test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>        if(IsSubset)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(jj==nGR2+1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    select_obj(RegionsGR2, Rskeli, jj)</l>
<l>    dilation_circle(Rskeli,Rskel, 3) </l>
<l>    intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_select_mask(Area, Area, Arnonz)</l>
<l>    tuple_length(Arnonz, nArnonz)</l>
<c>    </c>
<l>    if(nArnonz &gt; 1)</l>
<l>*         Index:=[]</l>
<l>        IndexGAll:=[]</l>
<l>        SmallIs:=RegionIntersection</l>
<l>        union1(SmallIs, SmallI)</l>
<l>        connection(SmallI, SmallIs)</l>
<c>        </c>
<l>*         BigIs:=RegionsIR2</l>
<l>* gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>        intersection(RegionInoPHnoIsl, R3, BigI)</l>
<l>        connection(BigI, BigIs)</l>
<l>        difference(BigIs, SmallI, BigInoSs)</l>
<c>        </c>
<l>        intersection (RegionG, R3, RegionGR3)</l>
<l>        connection(RegionGR3, RegionsGR3)        </l>
<l>        for jj:=1 to nArnonz by 1</l>
<l>            select_obj(SmallIs, Obj, jj)</l>
<l>            get_region_points(Obj, RowsO, ColumnsO)</l>
<l>            tuple_length(RowsO, nOp)</l>
<l>            get_region_index(BigIs, int(RowsO[nOp/2]), int(ColumnsO[nOp/2]), Index)</l>
<l>            select_obj(BigInoSs, CurBigInoS, Index)</l>
<l>            intersection(CurBigInoS, RegionG, CurBigInoSG)</l>
<l>            get_region_points(CurBigInoSG, RowsB, ColumnsB)</l>
<l>            tuple_length(RowsB, nB)</l>
<l>            get_region_index(RegionsGR3, int(RowsB[nB/2]), int(ColumnsB[nB/2]), IndexG)</l>
<l>            IndexGAll[jj-1]:=IndexG</l>
<l>        endfor</l>
<c>        </c>
<l>        if(IndexGAll[0]==IndexGAll[1])</l>
<l>            intersection(RegionG, R2, RegionG2)</l>
<l>*         dev_display(R2)</l>
<l>            select_obj(RegionsGR3, RGR3, IndexG)</l>
<l>          intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>          intersection(Rop, RGR3, Ropf)</l>
<l>          concat_obj (RegionsOp, Ropf, RegionsOp)</l>
<l>*          dilation_circle(Rskel, RskelSd, 1)</l>
<l>*          concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>         concat_obj (RegionsOpCon, Rskel, RegionsOpCon)</l>
<l>        endif</l>
<c>        </c>
<l>*        stop()</l>
<l>*     elseif(AreaC &gt; 10)</l>
<l>*         dilation_circle(OpCand, OpCandd, 3) </l>
<l>*         intersection(OpCandd, RegionIR2, RegionIntCandI)</l>
<l>*         connection(RegionIntCandI, RegionsIntCandI)</l>
<l>*         count_obj(RegionsIntCandI, n)</l>
<l>*         if(n==2)</l>
<l>*             intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>*             concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>*             dilation_circle(Rskel, RskelSd, 1)</l>
<l>*             concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*         endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN6">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc39">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc39 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* * 2023.10.23 skipnext modified </c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.04.01 dual int point</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn:=0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>skipnext:=0</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    if(skipnext==1)</l>
<l>        skipnext:=0</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    xc := PPx[i]</l>
<l>*     if (xc==3066)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<c>    </c>
<l>    if (i==1 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := -1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>*         begtype := 1</l>
<l>*         ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<c>        *** reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<c>        *** met wrong region, so reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        *if (vp==0 and (vn ==pnum or vn==1))</l>
<c>    *** 2 points ******</c>
<c>    * changed index ip</c>
<l>    ip:=ii</l>
<l>*     skipnext:=0</l>
<l>        if(vp==pnum and vn==pnum)</l>
<l>            continue</l>
<l>*             skipnext:=1</l>
<l>*             if(vn==0)</l>
<l>*                 btype := -1</l>
<l>*             elseif(vn==1)</l>
<l>*                 btype := 1</l>
<l>*             elseif(vn==pnum)</l>
<l>*                 btype := 1</l>
<l>*             endif</l>
<l>*             if(gv&gt;gvp)</l>
<l>*                 ip:=ii-1</l>
<l>*             endif</l>
<l>        *endif</l>
<c>    *******************         </c>
<l>        elseif (vp==0 and (vn ==pnum or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif ( (vn==1 and vp==pnum) or (vp==1 and vn==pnum))</l>
<l>            btype := 1</l>
<c>        </c>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ip+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and (v==1 or v==pnum) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<c>    </c>
<l>    vp := v</l>
<l>    gvp:=gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>*****</c>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>*****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<l>if(intnum &lt;3)</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>elseif(intnum ==4)</l>
<l>    dif0:=abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1:=abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c></c>
<l>    if(dif0&gt;dif1)</l>
<l>        jMBdn:=PB[0]</l>
<l>        jMBup:=PE[0]</l>
<l>    else</l>
<l>        jMBdn:=PB[1]</l>
<l>        jMBup:=PE[1]</l>
<l>    endif</l>
<l>else</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>endif</l>
<c></c>
<l>gen_region_points(PMB, [PIntY[jMBdn],PIntY[jMBup]],  [PIntX[jMBdn],PIntX[jMBup]]) </l>
<l>gen_region_points(PSP, [PIntY[jSPdn],PIntY[jSPup]],  [PIntX[jSPdn],PIntX[jSPup]]) </l>
<c></c>
<l>* for j := 0 to ii-1 by 1</l>
<l>*     if (PType[j]==1)</l>
<l>*         jSPdn := j</l>
<l>*         clcb := PCLC[j]</l>
<l>*         break</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* for j := jSPdn to ii-1 by 1</l>
<l>*     if (PType[j]==-1)</l>
<l>*         clce := PCLC[j]</l>
<l>*         if (abs(clce-clcb) &gt; clcmax)</l>
<l>*             jSPup := j</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc39">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc39B">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc39B (MeasIntBresenham), single Bres. P1-P2</c>
<c>* * 2023.10.25 skipnext modified </c>
<c>* * 2023.10.23 skipnext modified </c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.04.01 dual int point</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn:=0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<l>* read_object (Reg0001, 'C:/Defect/OFFLINE/Reg_0001.hobj')</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<c></c>
<c>*Going forward from PS1</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>skipnext:=0</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    if(skipnext==1)</l>
<l>        skipnext:=0</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<c>    </c>
<l>    if (i==1 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := -1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>*         begtype := 1</l>
<l>*         ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<c>        *** reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and begtype==1)</l>
<c>        *** met wrong region, so reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum)</l>
<l>        *if (vp==0 and (vn ==pnum or vn==1))</l>
<c>    *** 2 points ******</c>
<c>    * changed index ip</c>
<l>*     ip:=ii</l>
<l>*     skipnext:=0</l>
<l>        if(vp==pnum and vn==pnum)</l>
<l>            continue</l>
<l>*             skipnext:=1</l>
<l>*             if(vn==0)</l>
<l>*                 btype := -1</l>
<l>*             elseif(vn==1)</l>
<l>*                 btype := 1</l>
<l>*             elseif(vn==pnum)</l>
<l>*                 btype := 1</l>
<l>*             endif</l>
<l>*             if(gv&gt;gvp)</l>
<l>*                 ip:=ii-1</l>
<l>*             endif</l>
<l>        *endif</l>
<c>    *******************         </c>
<l>        elseif (vp==0 and (vn ==pnum or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif ( (vn==1 and vp==pnum) or (vp==1 and vn==pnum))</l>
<l>            btype := 1</l>
<c>        </c>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and (v==1 or v==pnum) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<c>    </c>
<l>    vp := v</l>
<l>    gvp:=gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>*****</c>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>*****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<c></c>
<l>* threshold(ImageIRB, RegionIRB, 3, 255)</l>
<l>tuple_length(PB, nPB)</l>
<l>tuple_length(PE, nPE)</l>
<l>if(intnum &lt;3 or PB!=PE)</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>elseif(intnum ==4)</l>
<l>    dif0:=abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1:=abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c>    </c>
<c></c>
<l>    if(dif0&gt;dif1)</l>
<l>        jMBdn:=PB[0]</l>
<l>        jMBup:=PE[0]</l>
<l>    else</l>
<l>        jMBdn:=PB[1]</l>
<l>        jMBup:=PE[1]</l>
<l>    endif</l>
<l>else</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>endif</l>
<c></c>
<l>gen_region_points(PMB, [PIntY[jMBdn],PIntY[jMBup]],  [PIntX[jMBdn],PIntX[jMBup]]) </l>
<l>gen_region_points(PSP, [PIntY[jSPdn],PIntY[jSPup]],  [PIntX[jSPdn],PIntX[jSPup]]) </l>
<c></c>
<l>* for j := 0 to ii-1 by 1</l>
<l>*     if (PType[j]==1)</l>
<l>*         jSPdn := j</l>
<l>*         clcb := PCLC[j]</l>
<l>*         break</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* for j := jSPdn to ii-1 by 1</l>
<l>*     if (PType[j]==-1)</l>
<l>*         clce := PCLC[j]</l>
<l>*         if (abs(clce-clcb) &gt; clcmax)</l>
<l>*             jSPup := j</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc39B">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectShortN6">
<interface>
<io>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsSh" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectShortN6 : new detect short proc. 19.01.2023</c>
<c>*** 01.11.2023 added sheck in on RegNoProc boundary</c>
<c>*** 25.09.2023 small pieces removed</c>
<c>*** remowed last SkeletonGS contour</c>
<c>*** 12.09.2023</c>
<l>boundary(RegNoProc, RegNoProcB, 'outer')</l>
<l>* get_domain(WidthImageS, Domain)</l>
<l>* boundary(Domain, DomainB, 'inner')</l>
<l>* get_image_size(WidthImageS,Width, Height)</l>
<l>* gen_rectangle1(RB, bdist,bdist,Height- bdist, Width-bdist)</l>
<c>** for rectengular outer shape</c>
<l>region_features(RegionG, 'row1', r1)</l>
<l>region_features(RegionG, 'column1', c1)</l>
<l>region_features(RegionG, 'row2', r2)</l>
<l>region_features(RegionG, 'column2', c2)</l>
<l>gen_rectangle1(RB, r1,c1,r2,c2)</l>
<c></c>
<l>* fill_up(RegionG, RegionFillUpG)</l>
<c>** for arbitrary outer shape</c>
<l>* closing_circle(RegionG, RB, 101)</l>
<c></c>
<l>intersection(SkeletonGS, RB, SkeletonGSnoB)</l>
<l>intersection(SkeletonGSnoB, RegionInoPHnoIsl, ShCandAll)</l>
<c></c>
<l>* intersection(ShCandAlli, RegionCheck, ShCandAll)</l>
<l>* set_system('neighborhood', 8)</l>
<l>connection(ShCandAll, ShCands)</l>
<l>set_system('neighborhood', 8)</l>
<l>count_obj(ShCands, nShCands)</l>
<l>area_center(ShCands, Area1, Row1, Column1)</l>
<l>gen_empty_obj(RegionsSh)</l>
<l>if(Area1 &gt; 0)</l>
<c>    </c>
<c></c>
<c>    </c>
<l>    for j:=1 to nShCands by 1</l>
<l>*         intersection(RegionInoPHnoIsl, SkeletonGS, RInt)</l>
<l>*         connection(RInt, RInts)</l>
<l>*         if(j==247)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         if(j==1237)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*          if(j==1008)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         j:=299</l>
<l>        select_obj(ShCands, ShCand, j)</l>
<l>        intersection(ShCand, RegNoProcB, RegionIntersection1)</l>
<l>        area_center(RegionIntersection1, a, Row, Column)</l>
<l>        if(a&gt;0)</l>
<l>            concat_obj(RegionsSh, ShCand, RegionsSh)</l>
<l>            continue</l>
<l>        endif</l>
<l>        area_center(ShCand, AreaC, RowC, ColumnC)</l>
<l>        get_region_points(ShCand, Rows, Columns)</l>
<l>        get_grayval(WidthImageS, Rows, Columns, SpW)</l>
<l>        tuple_median(SpW, spw)</l>
<l>        get_grayval(DirImageS, Rows, Columns, SpD)</l>
<l>        tuple_median(SpD, spd)</l>
<l>        sa:=spd*3.14159/256</l>
<c>        </c>
<l>        if(spw&gt;200)</l>
<l>            continue</l>
<l>        endif</l>
<l>        if(AreaC&gt;1)</l>
<l>            smallest_rectangle2(ShCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>            gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+10, Length2+spw+10)</l>
<l>        else</l>
<l>            gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>        endif</l>
<c>        </c>
<l>*         gen_rectangle2(R2, RowC, ColumnC ,sa, spw*2.5, spw*2.5)</l>
<l>        intersection(RegionISnoPHnoIsl, R2, RegionISR2)</l>
<l>        connection(RegionISR2, RegionsISR2)</l>
<l>        intersection(SkeletonGS, R2, RegionGSR2)</l>
<l>        connection(RegionGSR2, RegionsGSR2)</l>
<l>        count_obj(RegionsGSR2, nGSR2)</l>
<l>        for jj:=1 to nGSR2 by 1</l>
<l>            select_obj(RegionsGSR2, Rsel, jj)</l>
<l>            test_subset_region(ShCand, Rsel, IsSubset)</l>
<l>            if(IsSubset)</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(jj==nGSR2+1)</l>
<l>            continue</l>
<l>        endif</l>
<l>*         get_system('neighborhood', nb)</l>
<l>        select_obj(RegionsGSR2, Rskel, jj)</l>
<l>        get_region_points(Rskel, Rowsrs, Columnsrs)</l>
<l>        tuple_length(Rowsrs, l)</l>
<l>        skcrow:=Rowsrs[l/2]</l>
<l>        skccol:=Columnsrs[l/2]</l>
<c>        </c>
<l>        distance_pp(Rowsrs[0], Columnsrs[0], Rowsrs[l-1], Columnsrs[l-1],lr)</l>
<c>        </c>
<l>        dilation_circle(Rskel, Rskeld, 1)</l>
<l>        intersection( RegionsISR2,Rskeld, RegionIntersection)</l>
<l>        area_center(RegionIntersection, Area, Rowi, Columni)</l>
<l>        tuple_select_mask(Area, Area, Arnonz)</l>
<l>        tuple_sum(Area, asum)</l>
<l>        tuple_select_mask(Rowi, int(Rowi), Rowrnonz)</l>
<l>        tuple_select_mask(Columni, int(Columni), Columnrnonz)</l>
<c>     </c>
<l>        tuple_length(Arnonz, nArnonz)</l>
<l>        tuple_gen_const(nArnonz, skcrow, Skcrow)</l>
<l>        tuple_gen_const(nArnonz, skccol, Skccol)</l>
<l>        distance_pp(Rowrnonz, Columnrnonz, Skcrow, Skccol, Dr)</l>
<c>        </c>
<l>        if(nArnonz&gt;0)</l>
<l>            Mr:=min(Dr)</l>
<l>        else </l>
<l>            Mr:=10</l>
<l>        endif</l>
<c>        ***</c>
<l>*         intersection(RegionG, R2, RegionGR2)</l>
<c>        </c>
<c>        ***</c>
<l>        if(nArnonz &gt; 1 and Mr &lt; lr/1.5 and asum&gt;15)</l>
<l>*             dev_display(R2)</l>
<l>            intersection(R2, RegionInoPHnoIsl, Rsh)</l>
<c>            *** only biggeast region should remain</c>
<l>            connection(Rsh, Rshs)</l>
<l>            area_center(Rshs, AreaRshs, RowRshs, ColumnRshs)</l>
<l>            tuple_length(AreaRshs, no)</l>
<l>            if(no&gt;1)</l>
<l>                tuple_sort_index(AreaRshs, Ind)</l>
<l>                tuple_inverse(Ind, Inverted)</l>
<l>                select_obj(Rshs, Rshf,Inverted[0]+1)</l>
<l>                concat_obj(RegionsSh, Rshf, RegionsSh)</l>
<l>            else</l>
<l>                concat_obj(RegionsSh, Rsh, RegionsSh)</l>
<l>            endif</l>
<c>            </c>
<l>*            stop() </l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="DetectShortN6">
<parameters>
<parameter id="DirImageS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsSh"/>
<parameter id="SkeletonGS"/>
<parameter id="WidthImageS"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBP4">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoDS" base_type="iconic" dimension="0"/>
<par name="ImIRBP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBPOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBP4 - 07.12.2023 - same as S but for P</c>
<l>ImIRBPOut := ImIRBP</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 3</l>
<l>dilation_circle (SkeletonsFWM, SkeletonsFWMd, dil)</l>
<l>count_obj (SkeletonsFWMd, no)</l>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWM, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoDS, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoDS, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoDS, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoDS, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoDS, RegionInoDS, RegionInoDSC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMd, RegionInoDSC, SkeletonsFWMm)</l>
<l>union1(SkeletonsFWMd, SkeletonsFWMdu)</l>
<l>intersection (SkeletonsFWMdu, RegionInoDSC, SkeletonsFWMmu)</l>
<l>connection(SkeletonsFWMmu, SkeletonsFWMm2)</l>
<c>* 3</c>
<l>* difference (SkeletonsFWMSm, SkeletonsFWMSm2, RegionDifference1)</l>
<c></c>
<c></c>
<l>* area_center (SkeletonsFWMSm, Area, Row, Column)</l>
<l>* tuple_min (Area, amin)</l>
<l>* count_obj (SkeletonsFWMSm, nm)</l>
<c></c>
<l>* symm_difference (SkeletonsFWMSm, SkeletonsFWMSc, RegionDifference)</l>
<c></c>
<l>* intersection (SkeletonsFWM, RegionInoDS, RegionIntersection)</l>
<l>* union2 (SkeletonsFWM, RegionIntersection, RegionUnion)</l>
<l>* expand_region (RegionUnion, RegionInoDS, RegionsFWMS, expsize, 'image')</l>
<l>expsize:=25</l>
<l>expand_region (SkeletonsFWMm, RegionInoDS, RegionsFWM2, expsize, 'image')</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionInoDS, RegionsFWMS2, expsize, 'image')</l>
<l>count_obj (SkeletonsFWM, nRFWM)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWM, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary (RegionsFWM2, RegionsFWMB, 'inner')</l>
<l>count_obj (RegionsFWMB, nFWMP)</l>
<l>paint_region (RegionsFWM2, ImIRBPOut, ImIRBPOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMB, ImIRBPOut, ImIRBPOut, SequenceINBi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBP4">
<parameters>
<parameter id="ImIRBP"/>
<parameter id="ImIRBPOut"/>
<parameter id="RegionInoDS"/>
<parameter id="SkeletonsFWM"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMP"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBP5">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoDS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBPOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBP5 - 07.12.2023 - same as S but for P</c>
<l>ImIRBPOut := ImIRBP</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 3</l>
<l>dilation_circle (SkeletonsFWM, SkeletonsFWMd, dil)</l>
<l>count_obj (SkeletonsFWMd, no)</l>
<c></c>
<l>union1(SkeletonsFWMd, SkeletonFWMd)</l>
<l>dilation_circle (SkeletonFWMd, RegionFWM, 20)</l>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWM, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoDS, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoDS, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoDS, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoDS, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoDS, RegionInoDS, RegionInoDSC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMd, RegionInoDSC, SkeletonsFWMm)</l>
<l>union1(SkeletonsFWMd, SkeletonsFWMdu)</l>
<l>intersection (SkeletonsFWMdu, RegionInoDSC, SkeletonsFWMmu)</l>
<l>connection(SkeletonsFWMmu, SkeletonsFWMm2)</l>
<c>* 3</c>
<l>* difference (SkeletonsFWMSm, SkeletonsFWMSm2, RegionDifference1)</l>
<c></c>
<c></c>
<l>* area_center (SkeletonsFWMSm, Area, Row, Column)</l>
<l>* tuple_min (Area, amin)</l>
<l>* count_obj (SkeletonsFWMSm, nm)</l>
<c></c>
<l>* symm_difference (SkeletonsFWMSm, SkeletonsFWMSc, RegionDifference)</l>
<c></c>
<l>* intersection (SkeletonsFWM, RegionInoDS, RegionIntersection)</l>
<l>* union2 (SkeletonsFWM, RegionIntersection, RegionUnion)</l>
<l>* expand_region (RegionUnion, RegionInoDS, RegionsFWMS, expsize, 'image')</l>
<l>* expsize:=31</l>
<l>* expand_region (SkeletonsFWMm, RegionInoDS, RegionsFWM2, expsize, 'image')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>dilation_circle(SkeletonsFWMm, SkeletonsFWMmd, expsize)</l>
<l>intersection(RegionsPNi, SkeletonsFWMmd, RegionsPNiSkd)</l>
<l>intersection( RegionsPNiSkd,RegionInoD,RegionsFWM3)</l>
<l>* union1(RegionsFWM2, RegionFWM2)</l>
<l>* union1(RegionsFWM3, RegionFWM3)</l>
<l>* symm_difference(RegionFWM2, RegionFWM3, RegionDifference)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionInoDS, RegionsFWMS2, expsize, 'image')</l>
<l>count_obj (SkeletonsFWM, nRFWM)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (1, nRFWM, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary (RegionsFWM3, RegionsFWMB, 'inner')</l>
<l>count_obj (RegionsFWMB, nFWMP)</l>
<l>paint_region (RegionsFWM3, ImIRBPOut, ImIRBPOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMB, ImIRBPOut, ImIRBPOut, SequenceINBi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBP5">
<parameters>
<parameter id="ImIRBP"/>
<parameter id="ImIRBPOut"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoDS"/>
<parameter id="RegionsPNi"/>
<parameter id="SkeletonsFWM"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMP"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain122C">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsGbr" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain122C smaller pattern skels </c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<l>tuple_max(wFWM, maxwfwm)</l>
<c></c>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>connection (RegionGid, RegionsGid)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGsm, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<c></c>
<l>intersection (RegionGSi, RC, RegionGSii)</l>
<l>difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>difference(SkeletonG, CJ, Skeletonii)</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c></c>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<c></c>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, \
                      SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPi, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPip</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<c></c>
<l>RegionsmainS:=RegionsmainSn</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPii, nINB)</l>
<l>tuple_gen_sequence (1, nINB, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<l>union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<l>SkeletonsGbr:=Regionsmain</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>MSBuildFWM5 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, wpl, useint, Pnum, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16, wpl, useint, PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain122C">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsGbr"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld_COPY_1">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c></c>
<c>* input parameteres:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c></c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c></c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c></c>
<c></c>
<c>* Init</c>
<l>gen_empty_obj (Arrow)</l>
<c></c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c></c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c></c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c></c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c></c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld_COPY_1">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Coordinates2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.
</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])
</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="de_DE">Creates an arrow shaped XLD contour.</short>
<short lang="en_US">Creates an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_tuple_COPY_1">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="XValues" base_type="ctrl" dimension="0"/>
<par name="YValues" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots tuples representing functions</c>
<c>* or curves in a coordinate system.</c>
<c></c>
<c>* Input parameters:</c>
<c></c>
<c>* XValues: X values of the function to be plotted</c>
<c>*          If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.</c>
<c>*          If XValues is a tuple of strings, the values are taken as categories.</c>
<c></c>
<c>* YValues: Y values of the function(s) to be plotted</c>
<c>*          If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.</c>
<c>*          The number of y values must be equal to the number of x values</c>
<c>*          or an integral multiple. In the latter case,</c>
<c>*          multiple functions are plotted, that share the same x values.</c>
<c></c>
<c>* XLabel: X axis label</c>
<c></c>
<c>* XLabel: Y axis label</c>
<c></c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>*        If more than one color is given, multiple functions</c>
<c>*        can be displayed in different colors.</c>
<c></c>
<c>* GenParamNames: Generic parameters to control the presentation</c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possibile values: 'yes', 'no' (default)</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the x axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the x axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'origin_x': X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: same as start_x</c>
<c>*    'origin_y': Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: same as start_y</c>
<c></c>
<c>* GenParamValues: Values of the generic parameters of GenericParamNames</c>
<c></c>
<c></c>
<c>* Store current display settings</c>
<l>dev_get_window (PreviousWindowHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_part (WindowHandle, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>get_line_style (WindowHandle, OriginStyle)</l>
<c></c>
<c>* Set display parameters</c>
<l>set_line_style (WindowHandle, [])</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<c></c>
<c>* Check input coordinates</c>
<c></c>
<l>if (XValues == [] and YValues == [])</l>
<c>    * Neither XValues nor YValues are given:</c>
<c>    * Set axes to interval [0,1]</c>
<l>    XAxisEndValue := 1</l>
<l>    YAxisEndValue := 1</l>
<l>    XAxisStartValue := 0</l>
<l>    YAxisStartValue := 0</l>
<l>    XValuesAreStrings := false</l>
<l>else</l>
<l>    if (XValues == [])</l>
<c>        * XValues are omitted:</c>
<c>        * Set equidistant XValues</c>
<l>        XValues := [0:|YValues| - 1]</l>
<l>        XValuesAreStrings := false</l>
<l>    elseif (YValues == [])</l>
<c>        * YValues are omitted:</c>
<c>        * Set equidistant YValues</c>
<l>        YValues := [0:|XValues| - 1]</l>
<l>    endif</l>
<l>    if (|YValues| % |XValues| != 0)</l>
<c>        * Number of YValues does not match number of XValues</c>
<l>        throw ('Number of YValues is no multiple of the number of XValues!')</l>
<l>        return ()</l>
<l>    endif</l>
<l>    XValuesAreStrings := is_string_elem(XValues)</l>
<l>    XValuesAreStrings := sum(XValuesAreStrings) == |XValuesAreStrings|</l>
<l>    if (XValuesAreStrings)</l>
<c>        * XValues are given as strings:</c>
<c>        * Show XValues as ticks</c>
<l>        XTickValues := XValues</l>
<l>        XTicks := 1</l>
<c>        * Set x-axis dimensions</c>
<l>        XValues := [1:|XValues|]</l>
<l>    endif</l>
<c>    * Set default x-axis dimensions</c>
<l>    if (|XValues| &gt; 1)</l>
<l>        XAxisStartValue := min(XValues)</l>
<l>        XAxisEndValue := max(XValues)</l>
<l>    else</l>
<l>        XAxisEndValue := XValues[0] + 0.5</l>
<l>        XAxisStartValue := XValues[0] - 0.5</l>
<l>    endif</l>
<l>endif</l>
<c>* Set default y-axis dimensions</c>
<l>if (|YValues| &gt; 1)</l>
<l>    YAxisStartValue := min(YValues)</l>
<l>    YAxisEndValue := max(YValues)</l>
<l>elseif (|YValues| == 1)</l>
<l>    YAxisStartValue := YValues[0] - 0.5</l>
<l>    YAxisEndValue := YValues[0] + 0.5</l>
<l>else</l>
<l>    YAxisStartValue := 0</l>
<l>    YAxisEndValue := 1</l>
<l>endif</l>
<c>* Set default interception point of x- and y- axis</c>
<l>OriginX := XAxisStartValue</l>
<l>OriginY := YAxisStartValue</l>
<c></c>
<c>* Set more defaults</c>
<l>LeftBorder := Width * 0.1</l>
<l>RightBorder := Width * 0.1</l>
<l>UpperBorder := Height * 0.1</l>
<l>LowerBorder := Height * 0.1</l>
<l>AxesColor := 'white'</l>
<l>Style := 'line'</l>
<l>Clip := 'no'</l>
<l>XTicks := 'min_max_origin'</l>
<l>YTicks := 'min_max_origin'</l>
<l>XGrid := 'none'</l>
<l>YGrid := 'none'</l>
<l>GridColor := 'dim gray'</l>
<c></c>
<c>* Parse generic parameters</c>
<c></c>
<l>NumGenParamNames := |GenParamNames|</l>
<l>NumGenParamValues := |GenParamValues|</l>
<l>if (NumGenParamNames != NumGenParamValues)</l>
<l>    throw ('Number of generic parameter names does not match generic parameter values!')</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>SetOriginXToDefault := true</l>
<l>SetOriginYToDefault := true</l>
<l>for GenParamIndex := 0 to |GenParamNames| - 1 by 1</l>
<c></c>
<c>    * Set 'axes_color'</c>
<l>    if (GenParamNames[GenParamIndex] == 'axes_color')</l>
<l>        AxesColor := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'style'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'style')</l>
<l>        Style := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'clip'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'clip')</l>
<l>        Clip := GenParamValues[GenParamIndex]</l>
<l>        if (Clip != 'yes' and Clip != 'no')</l>
<l>            throw ('Unsupported clipping option: \'' + Clip + '\'')</l>
<l>        endif</l>
<c></c>
<c>        * Set 'ticks'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'ticks')</l>
<l>        XTicks := GenParamValues[GenParamIndex]</l>
<l>        YTicks := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'ticks_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'ticks_x')</l>
<l>        XTicks := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'ticks_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'ticks_y')</l>
<l>        YTicks := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'grid'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid')</l>
<l>        XGrid := GenParamValues[GenParamIndex]</l>
<l>        YGrid := GenParamValues[GenParamIndex]</l>
<l>        XGridTicks := XTicks</l>
<c></c>
<c>        * Set 'grid_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid_x')</l>
<l>        XGrid := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'grid_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid_y')</l>
<l>        YGrid := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'grid_color'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'grid_color')</l>
<l>        GridColor := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'start_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'start_x')</l>
<l>        XAxisStartValue := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'end_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'end_x')</l>
<l>        XAxisEndValue := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'start_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'start_y')</l>
<l>        YAxisStartValue := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'end_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'end_y')</l>
<l>        YAxisEndValue := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'origin_x'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'origin_x')</l>
<l>        OriginX := GenParamValues[GenParamIndex]</l>
<l>        SetOriginXToDefault := false</l>
<c></c>
<c>        * Set 'origin_y'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'origin_y')</l>
<l>        OriginY := GenParamValues[GenParamIndex]</l>
<l>        SetOriginYToDefault := false</l>
<c></c>
<c>        * Set 'margin'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin')</l>
<l>        LeftBorder := GenParamValues[GenParamIndex]</l>
<l>        RightBorder := GenParamValues[GenParamIndex]</l>
<l>        UpperBorder := GenParamValues[GenParamIndex]</l>
<l>        LowerBorder := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'margin_left'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_left')</l>
<l>        LeftBorder := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'margin_right'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_right')</l>
<l>        RightBorder := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'margin_top'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_top')</l>
<l>        UpperBorder := GenParamValues[GenParamIndex]</l>
<c></c>
<c>        * Set 'margin_bottom'</c>
<l>    elseif (GenParamNames[GenParamIndex] == 'margin_bottom')</l>
<l>        LowerBorder := GenParamValues[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamNames[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<c>* Check consistency of start and end values</c>
<c>* of the axes.</c>
<l>if (XAxisStartValue &gt; XAxisEndValue)</l>
<l>    throw ('Value for \'start_x\' is greater than value for \'end_x\'')</l>
<l>endif</l>
<l>if (YAxisStartValue &gt; YAxisEndValue)</l>
<l>    throw ('Value for \'start_y\' is greater than value for \'end_y\'')</l>
<l>endif</l>
<c></c>
<c>* Set default origin to lower left corner</c>
<l>if (SetOriginXToDefault)</l>
<l>    OriginX := XAxisStartValue</l>
<l>endif</l>
<l>if (SetOriginYToDefault)</l>
<l>    OriginY := YAxisStartValue</l>
<l>endif</l>
<c></c>
<c></c>
<c>* Calculate basic pixel coordinates and scale factors</c>
<c></c>
<l>XAxisWidthPx := Width - LeftBorder - RightBorder</l>
<l>XAxisWidth := XAxisEndValue - XAxisStartValue</l>
<l>if (XAxisWidth == 0)</l>
<l>    XAxisStartValue := XAxisStartValue - 0.5</l>
<l>    XAxisEndValue := XAxisEndValue + 0.5</l>
<l>    XAxisWidth := 1</l>
<l>endif</l>
<l>XScaleFactor := XAxisWidthPx / real(XAxisWidth)</l>
<l>YAxisHeightPx := Height - LowerBorder - UpperBorder</l>
<l>YAxisHeight := YAxisEndValue - YAxisStartValue</l>
<l>if (YAxisHeight == 0)</l>
<l>    YAxisStartValue := YAxisStartValue - 0.5</l>
<l>    YAxisEndValue := YAxisEndValue + 0.5</l>
<l>    YAxisHeight := 1</l>
<l>endif</l>
<l>YScaleFactor := YAxisHeightPx / real(YAxisHeight)</l>
<l>YAxisOffsetPx := (OriginX - XAxisStartValue) * XScaleFactor</l>
<l>XAxisOffsetPx := (OriginY - YAxisStartValue) * YScaleFactor</l>
<c></c>
<c>* Display grid lines</c>
<c></c>
<l>if (GridColor != 'none')</l>
<l>    DotStyle := [5,7]</l>
<l>    set_line_style (WindowHandle, DotStyle)</l>
<l>    dev_set_color (GridColor)</l>
<c></c>
<c>    * Display x grid lines</c>
<l>    if (XGrid != 'none')</l>
<l>        if (XGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (OriginX == XAxisStartValue)</l>
<l>                XGridValues := [XAxisStartValue,XAxisEndValue]</l>
<l>            else</l>
<l>                XGridValues := [XAxisStartValue,OriginX,XAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            XGridStart := ceil(XAxisStartValue / XGrid) * XGrid</l>
<l>            XGridValues := [XGridStart:XGrid:XAxisEndValue]</l>
<l>        endif</l>
<l>        XPosition := (XGridValues - XAxisStartValue) * XScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |XGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXGrid, [Height - LowerBorder,UpperBorder], [LeftBorder + XPosition[IndexGrid],LeftBorder + XPosition[IndexGrid]])</l>
<l>            dev_display (ContourXGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<c></c>
<c>    * Display y grid lines</c>
<l>    if (YGrid != 'none')</l>
<l>        if (YGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (OriginY == YAxisStartValue)</l>
<l>                YGridValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YGridValues := [YAxisStartValue,OriginY,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            YGridStart := ceil(YAxisStartValue / YGrid) * YGrid</l>
<l>            YGridValues := [YGridStart:YGrid:YAxisEndValue]</l>
<l>        endif</l>
<l>        YPosition := (YGridValues - YAxisStartValue) * YScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |YGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYGrid, [Height - LowerBorder - YPosition[IndexGrid],Height - LowerBorder - YPosition[IndexGrid]], [LeftBorder,Width - RightBorder])</l>
<l>            dev_display (ContourYGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<l>set_line_style (WindowHandle, [])</l>
<c></c>
<c></c>
<c>* Display the coordinate sytem axes</c>
<l>if (AxesColor != 'none')</l>
<c>    * Display axes</c>
<l>    dev_set_color (AxesColor)</l>
<l>gen_arrow_contour_xld (XArrow, Height - LowerBorder - XAxisOffsetPx, LeftBorder, Height - LowerBorder - XAxisOffsetPx, Width - RightBorder, 0, 0)</l>
<l>    dev_display (XArrow)</l>
<l>gen_arrow_contour_xld (YArrow, Height - LowerBorder, LeftBorder + YAxisOffsetPx, UpperBorder, LeftBorder + YAxisOffsetPx, 0, 0)</l>
<l>    dev_display (YArrow)</l>
<c>    * Display labels</c>
<l>    get_string_extents (WindowHandle, XLabel, Ascent, Descent, TextWidthXLabel, TextHeightXLabel)</l>
<l>    dev_disp_text (XLabel, 'image', Height - LowerBorder - TextHeightXLabel - XAxisOffsetPx, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>    dev_disp_text (' ' + YLabel, 'image', UpperBorder, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>endif</l>
<c></c>
<c>* Display ticks</c>
<c></c>
<l>if (AxesColor != 'none')</l>
<l>    dev_set_color (AxesColor)</l>
<l>    if (XTicks != 'none')</l>
<c></c>
<c>        * Display x ticks</c>
<l>        if (XValuesAreStrings)</l>
<c>            * Display string XValues as categories</c>
<l>            XTicks := |XValues| / |XTickValues|</l>
<l>            XPosition := (XValues - XAxisStartValue) * XScaleFactor</l>
<l>        else</l>
<c>            * Display tick values</c>
<l>            if (XTicks == 'min_max_origin')</l>
<c>                * Calculate 'min_max_origin' tick coordinates</c>
<l>                if (OriginX == XAxisStartValue)</l>
<l>                    XTickValues := [XAxisStartValue,XAxisEndValue]</l>
<l>                else</l>
<l>                    XTickValues := [XAxisStartValue,OriginX,XAxisEndValue]</l>
<l>                endif</l>
<l>            else</l>
<c>                * Calculate equidistant tick coordinates</c>
<l>                XTickStart := ceil(XAxisStartValue / XTicks) * XTicks</l>
<l>                XTickValues := [XTickStart:XTicks:XAxisEndValue]</l>
<l>            endif</l>
<l>            XPosition := (XTickValues - XAxisStartValue) * XScaleFactor</l>
<l>            TypeTicks := type(XTicks)</l>
<l>            if (TypeTicks == H_TYPE_STRING)</l>
<c>                * String ('min_max_origin')</c>
<c>                * Format depends on actual values</c>
<l>                TypeTicks := type(XTickValues)</l>
<l>            endif</l>
<l>            if (TypeTicks == H_TYPE_INT)</l>
<c>                * Round to integer</c>
<l>                XTickValues := int(XTickValues)</l>
<l>            else</l>
<c>                * Use floating point numbers</c>
<l>                XTickValues := XTickValues$'.2f'</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |XTickValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx,Height - LowerBorder - XAxisOffsetPx - 5], [LeftBorder + XPosition[IndexTicks],LeftBorder + XPosition[IndexTicks]])</l>
<l>            dev_display (ContourXTick)</l>
<l>            dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder + 2 - XAxisOffsetPx, LeftBorder + XPosition[IndexTicks], AxesColor, 'box', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<c></c>
<l>    if (YTicks != 'none')</l>
<c></c>
<c>        * Display y ticks</c>
<l>        if (YTicks == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' tick coordinates</c>
<l>            if (OriginY == YAxisStartValue)</l>
<l>                YTickValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YTickValues := [YAxisStartValue,OriginY,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant tick coordinates</c>
<l>            YTickStart := ceil(YAxisStartValue / YTicks) * YTicks</l>
<l>            YTickValues := [YTickStart:YTicks:YAxisEndValue]</l>
<l>        endif</l>
<l>        YPosition := (YTickValues - YAxisStartValue) * YScaleFactor</l>
<l>        TypeTicks := type(YTicks)</l>
<l>        if (TypeTicks == H_TYPE_STRING)</l>
<c>            * String ('min_max_origin')</c>
<c>            * Format depends on actual values</c>
<l>            TypeTicks := type(YTickValues)</l>
<l>        endif</l>
<l>        if (TypeTicks == H_TYPE_INT)</l>
<c>            * Round to integer</c>
<l>            YTickValues := int(YTickValues)</l>
<l>        else</l>
<c>            * Use floating point numbers</c>
<l>            YTickValues := YTickValues$'.2f'</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |YTickValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YPosition[IndexTicks],Height - LowerBorder - YPosition[IndexTicks]], [LeftBorder + YAxisOffsetPx,LeftBorder + YAxisOffsetPx + 5])</l>
<l>            dev_display (ContourYTick)</l>
<l>            get_string_extents (WindowHandle, YTickValues[IndexTicks], Ascent1, Descent1, TextWidthYTicks, TextHeightYTicks)</l>
<l>            dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YPosition[IndexTicks], LeftBorder - TextWidthYTicks - 2 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* Display function plot</c>
<c></c>
<l>if (Color != 'none')</l>
<l>    if (XValues != [] and YValues != [])</l>
<l>        Num := |YValues| / |XValues|</l>
<c></c>
<c>        * Iterate over all functions to be displayed</c>
<l>        for I := 0 to Num - 1 by 1</l>
<c>            * Select y values for current function</c>
<l>            YSelected := YValues[I * |XValues|:(I + 1) * |XValues| - 1]</l>
<c>            * Set color</c>
<l>            if (Color == [])</l>
<l>                set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>            else</l>
<l>                dev_set_color (Color[I % |Color|])</l>
<l>            endif</l>
<c></c>
<c>            * Display in different styles</c>
<c></c>
<l>            if (Style == 'line' or Style == [])</l>
<c>                * Line</c>
<l>                gen_contour_polygon_xld (Contour, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Contour, Contour, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Contour)</l>
<l>            elseif (Style == 'cross')</l>
<c>                * Cross</c>
<l>                gen_cross_contour_xld (Cross, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor, 6, 0.785398)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Cross, Cross, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Cross)</l>
<l>            elseif (Style == 'filled')</l>
<c>                * Filled</c>
<l>                Y1Selected := [0 + OriginY,YSelected,0 + OriginY]</l>
<l>                X1Selected := [min(XValues),XValues,max(XValues)]</l>
<l>                dev_set_draw ('fill')</l>
<l>                gen_region_polygon_filled (Filled, Height - LowerBorder - Y1Selected * YScaleFactor + YAxisStartValue * YScaleFactor, X1Selected * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Filled, Filled, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Filled)</l>
<l>            else</l>
<l>                throw ('Unsupported style: ' + Style)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* Reset original display settings</c>
<l>dev_set_part (PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>dev_set_window (PreviousWindowHandle)</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_draw (DrawMode)</l>
<l>set_line_style (WindowHandle, OriginStyle)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<l>return ()</l>
</body>
<docu id="plot_tuple_COPY_1">
<abstract lang="en_US">This procedure plots the functions or curves represented by the coordinates in XValues and YValues into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and Ylabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamNames and GenericParamValues.

In particular, following parameters can be set:

XValues: X values of the function to be plotted.

          If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.
          If XValues is a tuple of strings, the values are taken as categories.

 YValues: Y values of the function(s) to be plotted.

          If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.
          The number of y values must be equal to the number of x values
          or an integral multiple. In the latter case,
          multiple functions are plotted, that share the same x values.

 XLabel: X axis label.

 XLabel: Y axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.
        If more than one color is given, multiple functions 
        can be displayed in different colors.

 GenParamNames: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'filled'

    'clip': Clip graph to coordinate system area.
            Possibile values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x axis.
               Default: min(XValues)

    'end_x': Highest x value of the x axis.
             Default: max(XValues)

    'start_y': Lowest y value of the x axis.
               Default: min(YValues)

    'end_y': Highest y value of the x axis.
             Default: max(YValues)

    'origin_x': X coordinate of the intercept point of x- and y-axis.
                Default: same as start_x

    'origin_y': Y coordinate of the intercept point of x- and y-axis.
                Default: same as start_y

 GenParamValues: Values of the generic parameters of GenericParamNames.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y1 := sin(X)
Y2 := (X * X) * 0.2 - 1
XLabel := 'x'
YLabel := 'y'
Color := ['medium slate blue', 'yellow']
GenParamNames := []
GenParamValues := []
plot_tuple (WindowHandle, X, [Y1, Y2], XLabel, YLabel, Color, GenParamNames, GenParamValues)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>tuple</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>funct_1d_to_pairs</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="GenParamNames">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
</values>
</parameter>
<parameter id="GenParamValues">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x axis.</description>
</parameter>
<parameter id="XValues">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">X values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.x</sem_type>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y axis.</description>
</parameter>
<parameter id="YValues">
<default_type>real</default_type>
<description lang="en_US">Y values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.y</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain123">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="IageIRSum" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain125 for coils</c>
<c>*** 240117 - added Cut with overlap</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<c></c>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>connection (RegionGid, RegionsGid)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<l>difference (DomainG, RegionGsm, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c></c>
<l>intersection (RegionGSi, RC, RegionGSii)</l>
<l>difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>SpaceWidthDirImages (RegionGSi, SkeletonGS, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<c></c>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>tuple_length(WdG, nWdG)</l>
<l>tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>else</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSn,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>    tuple_length(RowMSS, nMSS)</l>
<l>    tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>    gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>    union1(CMSSE, CMSSEu)</l>
<l>    difference(RegionsmainSn, CMSSEu, RegionsmainSn)</l>
<l>endfor</l>
<c></c>
<c></c>
<c></c>
<l>RegionsmainS:=RegionsmainSn</l>
<l>difference(RegionsmainSn, RegionCut, RegionmainSi)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<c></c>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (1, nINBS, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>stseqS := nEMPTY+1</l>
<l>overfS := 255-stseqS</l>
<l>SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBS, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<l>MSBuildFWM52 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, \
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM5 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain123">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="IageIRSum"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP6">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
<par name="ImageOverlap" base_type="iconic" dimension="0"/>
<par name="RegsOverlap" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="elengthover" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP6 v1.0, 11.03.2023</c>
<c>*  240117 - overlaps for Cut</c>
<c>*  230313 - added skel. parts having multiple regions</c>
<c>*  230223 - fixed possible non-equal numbers of SkeletonsFWM and SkContoursG</c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>gen_image_const(ImageOverlap, 'int1', Width, Height)</l>
<l>gen_image_proto(ImageOverlap, ImageOverlap, -1)</l>
<c></c>
<l>gen_empty_obj(RegsOverlap)</l>
<c></c>
<l>smallest_rectangle1(RegionG, Row11g, Column11g, Row2g, Column2g)</l>
<l>gen_rectangle1(RectangleG, Row11g-2, Column11g-2, Row2g+2, Column2g+2)</l>
<l>difference(RectangleG, RegionG, RegFirbid)</l>
<c></c>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>* junctions_skeleton(SkeletonFWM, EndPoints, JuncPoints)</l>
<l>junctions_skeleton(SkeletonG, EndPoints, JuncPoints)</l>
<l>* dilation_circle(EndPoints, EndPointsd, 1.5)</l>
<l>dilation_rectangle1(EndPoints, EndPointsd, 2.5,2.5)</l>
<l>union1(EndPointsd, EndPointd)</l>
<l>* gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 1, 'filter')</l>
<l>area_center(SkeletonsFWM, A,Row, Column)</l>
<l>tuple_sort_index(Row, Indices)</l>
<l>tuple_sort(A, Sorted)</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>* count_obj (SkContoursG, nSkCG)</l>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nFWM by 1</l>
<l>*     if(k==65)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     k:=3</l>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>*     connection(SelectedSkeletonG, ConnectedRegions)</l>
<l>*     count_obj(ConnectedRegions, n)</l>
<l>*     if(n&gt;1)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    connection(SelectedSkeletonG, SelectedSkeletonsG)</l>
<l>    count_obj(SelectedSkeletonsG, nSSG)</l>
<l>    for kk := 1 to nSSG by 1</l>
<l>        select_obj(SelectedSkeletonsG, SSG, kk)</l>
<l>        area_center(SSG, a, r, c)</l>
<l>        if(a&lt;10)</l>
<l>            continue</l>
<l>        endif</l>
<l>*         select_obj (SkContoursG, SelectedContourG, k)</l>
<l>        gen_contours_skeleton_xld (SSG, SelectedContourG, 1, 'filter')</l>
<c>        </c>
<l>*         if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>        contour_point_num_xld (SelectedContourG, np)</l>
<l>        get_contour_xld (SelectedContourG, RowG, ColG)</l>
<c>        </c>
<l>        gen_region_points (RegionSCG, RowG, ColG)</l>
<l>        if (np &lt; 21)</l>
<l>            lookaround := 1</l>
<l>        else</l>
<l>            lookaround := 3</l>
<l>        endif</l>
<c>        </c>
<l>        get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>        tuple_length(AnglesG, nA)</l>
<c>    </c>
<l>        gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>        gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>        dilation_circle(ER1, RegionDilation, 13.5)</l>
<l>        dilation_circle(ER2, RegionDilation2, 13.5)</l>
<l>*         stop()</l>
<l>        if(a&gt;0)</l>
<l>            test_subset_region(ER1, EndPointd, IsSubset)</l>
<l>            if(IsSubset==1)</l>
<l>                gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>                intersection(Circle, SkeletonG, RegionIntersection)</l>
<c>                </c>
<l>                if(elengthnoend &gt; 0)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                else</l>
<l>                    difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                endif</l>
<l>                nsk:=nsk+1</l>
<l>            else</l>
<l>                dilation_circle(RegCut, RegCutd, 3)</l>
<l>                intersection(RegCutd, ER1, RegionIntersection1)</l>
<l>                area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>                if(a==0)</l>
<l>                    row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>                    col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>                    gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>                    intersection(Rectangle21, Domain, Rectangle21)</l>
<l>                    union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>                    get_region_points(Rectangle21, R21, C21)</l>
<l>                    tuple_length(R21, n21)</l>
<l>                    ang:=AnglesG[1]</l>
<l>                    dir21:= (ang-1.57)*256/3.14159</l>
<l>                    tuple_gen_const(n21, dir21, Dir21)</l>
<l>                    tuple_max(R21, rm)</l>
<l>                    tuple_max(C21, cm)</l>
<l>                    if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                        stop()</l>
<l>                    endif</l>
<l>                    set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>                    nrec:=nrec+1</l>
<l>                else</l>
<l>*                     area_center(ER1, aer1, rower1, columner1)</l>
<l>                    expand_region(ER1, RegFirbid, RegionExpanded, elengthover, 'image')</l>
<l>                    intersection(RegionExpanded, SkeletonG, RegionIntersectionExpG)</l>
<l>                    intersection(RegionIntersectionExpG, SelectedSkeletonG, RegionIntersectionExpG1)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersectionExpG, SelectedSkeletonG)</l>
<l>*                     difference(RegionIntersectionExpG, SSG, RegionIntersectionExpGd)</l>
<l>                    difference(RegionIntersectionExpG, SSG, RegionIntersectionExpGd)</l>
<l>*                     RegionIntersectionExpG1</l>
<l>                    get_region_points(RegionIntersectionExpG1, Rows, Columns)</l>
<l>                    tuple_length(Rows, n)</l>
<l>                    row:=Rows[n/2]</l>
<l>                    col:=Columns[n/2]</l>
<l>                    row:=Rows[5]</l>
<l>                    col:=Columns[5]</l>
<l>                    gen_region_points(RegionTst, row, col)</l>
<l>                    get_region_index(SkeletonsFWM,row, col, index)</l>
<l>                    tuple_gen_const(n, index+1, Index)</l>
<c>                    </c>
<l>                    set_grayval(ImageOverlap, Rows, Columns, Index)</l>
<l>                    concat_obj(RegsOverlap, RegionIntersectionExpG, RegsOverlap)</l>
<l>                endif</l>
<l>*                 distance_rr_min(RegCut, ER1, MinDistance, Row1, Column1, Row2, Column2)</l>
<c>                </c>
<l>            endif</l>
<l>*             connection(RegionIntersectionExpG, ConnectedRegions)</l>
<l>*             count_obj(ConnectedRegions, n)</l>
<l>*             if(n&gt;1)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>            test_subset_region(ER2, EndPointd, IsSubset)</l>
<l>            if(IsSubset==1)</l>
<l>                gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>                intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>                if(elengthnoend &gt; 0)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                else</l>
<l>                    difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                endif</l>
<c>                </c>
<l>                nsk:=nsk+1</l>
<l>            else</l>
<l>                dilation_circle(RegCut, RegCutd, 3)</l>
<l>                intersection(RegCutd, ER2, RegionIntersection1)</l>
<l>                area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>                if(a==0)</l>
<l>                    row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>                    col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>                    gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.01)</l>
<l>*                     gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>                    intersection(Rectangle22, Domain, Rectangle22)</l>
<l>                    union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>                    get_region_points(Rectangle22, R22, C22)</l>
<l>                    tuple_length(R22, n22)</l>
<l>                    ang:=AnglesG[nA-2]</l>
<l>                    dir22:= (ang-1.57)*256/3.14159</l>
<l>                    tuple_gen_const(n22, dir22, Dir22)</l>
<l>                    tuple_max(R22, rm)</l>
<l>                    tuple_max(C22, cm)</l>
<l>                    if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                        stop()</l>
<l>                    endif</l>
<l>                    set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>                    nrec:=nrec+1</l>
<l>                else</l>
<l>                    expand_region(ER2, RegFirbid, RegionExpanded, elengthover, 'image')</l>
<l>                    intersection(RegionExpanded, SelectedSkeletonG, RegionIntersectionExpG)</l>
<l>                    intersection(RegionIntersectionExpG, SelectedSkeletonG, RegionIntersectionExpG1)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersectionExpG, SelectedSkeletonG)</l>
<l>                    get_region_points(RegionIntersectionExpG1, Rows, Columns)</l>
<l>                    tuple_length(Rows, n)</l>
<l>                    row:=Rows[n/2]</l>
<l>                    col:=Columns[n/2]</l>
<l>                    get_region_index(SkeletonsFWM,row, col, index)</l>
<l>                    tuple_gen_const(n, index, Index)</l>
<c>                    </c>
<l>                    set_grayval(ImageOverlap, Rows, Columns, Index)</l>
<l>                endif</l>
<c>                </c>
<l>            endif</l>
<l>        endif</l>
<l>        concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<l>*      get_region_points(SelectedSkeletonG, Rows, Columns)</l>
<l>*     get_grayval(WidthImageP,Rows, Columns, WR)</l>
<l>*     tuple_median(WR, wrm)</l>
<l>*     tuple_min(WR, wrm)</l>
<l>    endfor</l>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP6">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="ImageOverlap"/>
<parameter id="RegCut"/>
<parameter id="RegionG"/>
<parameter id="RegsOverlap"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elengthover"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildFWM6">
<interface>
<io>
<par name="SkeletonsGThin" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="ImOverlap" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="notusedint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildFWM6</c>
<c>**** 2024.01.25 - added ImageOverlap</c>
<c>**** 2022.06.17 - added Puseint - used intersection points tuple</c>
<c>****</c>
<l>RowSkTh := []</l>
<l>ColSkTh := []</l>
<c>* * pnum corresponding to current MS</c>
<l>Pnum := []</l>
<c>* * pnum corresponding to current MS overlapped</c>
<l>Pnum2 := []</l>
<c>* * pnum corresponding to region</c>
<l>PnumR := []</l>
<c>* * start address of a contour</c>
<l>PaddrC := []</l>
<c>* * start address for region</c>
<l>PaddrR := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregC := []</l>
<c>* * number of countours per region</c>
<l>PCinRnum := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontR := []</l>
<c>* * saving intersect. points for current MS ==1, not saving ==0</c>
<l>Puseint := []</l>
<l>paddrC := 0</l>
<l>paddrR := 0</l>
<l>pcont := 0</l>
<l>tuple_gen_const (notusedint, 0, Notused)</l>
<l>tuple_gen_sequence (0, notusedint-1, 1, Beg)</l>
<c></c>
<l>count_obj (SkeletonsGThin, nSGThin)</l>
<l>for j := 1 to nSGThin by 1</l>
<l>*     if (j==871)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c></c>
<l>*     j:=871</l>
<l>    select_obj (SkeletonsGThin, ObjectSelected1, j)</l>
<l>    area_center (ObjectSelected1, a, r, c)</l>
<c>    * *** empty regions (no skeleton FWM inside of RegiondPNi[j]</c>
<l>    pnumr := -1</l>
<l>*     RowSkTh := 0</l>
<l>*     ColSkTh := 0</l>
<l>    npreg := 0</l>
<l>    if (a&gt;0)</l>
<c>        * *** non-empty regions</c>
<l>        get_region_points (ObjectSelected1, R, C)</l>
<l>        tuple_length (R, nsp)</l>
<c></c>
<l>        get_grayval (ImageIR, R, C, Val)</l>
<l>        tuple_median (Val, pnumr)</l>
<c>        </c>
<c>        </c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld (ObjectSelected1, Contours, 1, 'filter')</l>
<l>        count_obj (Contours, nC)</l>
<l>        tuple_concat (PCinRnum, nC, PCinRnum)</l>
<c></c>
<l>        tuple_concat (PcontR, pcont, PcontR)</l>
<l>        pcont := pcont+nC</l>
<c></c>
<l>        for jj := 1 to nC by 1</l>
<l>            select_obj (Contours, Contour, jj)</l>
<l>            get_contour_xld (Contour, R, C)</l>
<c>            </c>
<l>            get_grayval (ImOverlap, R, C, Ovl)</l>
<c>            </c>
<l>            tuple_max(Ovl,vmax)</l>
<l>*             if(vmax!=j)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<c></c>
<c>            </c>
<c>            </c>
<l>*             get_grayval (ImageIR, R, C, Val)</l>
<l>*             tuple_median (Val, pnum)</l>
<l>            tuple_length (R, pN)</l>
<c>            </c>
<l>             tuple_gen_const(pN, 1, Pui)</l>
<l>            if(pN &gt;=notusedint*2)</l>
<l>                tuple_gen_sequence (pN-notusedint, pN-1, 1, End)</l>
<l>                tuple_replace(Pui, Beg, Notused, Pui)</l>
<l>                tuple_replace(Pui, End, Notused, Pui)</l>
<l>            endif</l>
<c>            </c>
<c>            **** can't skip any contour, numberings don't match!!!</c>
<l>*             if(pN &lt; 100)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>            tuple_concat (PaddrC, paddrC, PaddrC)</l>
<l>*             pcont := pcont+1</l>
<l>            paddrC := paddrC + pN</l>
<l>            tuple_concat (PregC, j, PregC)</l>
<l>*             if (pN&gt;100)</l>
<l>                tuple_concat (RowSkTh, R, RowSkTh)</l>
<l>                tuple_concat (ColSkTh, C, ColSkTh)</l>
<l>            get_grayval(DirImageP, R, C, Dirs)</l>
<l>            Dirsi:=Dirs</l>
<l>            tuple_length(Dirs, nD)</l>
<l>            for jjj:=0 to nD-2 by 1</l>
<l>*                 if(jjj==641)</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<l>                d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>                if(d &gt; 128)</l>
<l>                    d:= d-255</l>
<l>                elseif(d &lt; -128)</l>
<l>                    d:= d+255</l>
<l>                endif</l>
<l>                Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>            endfor</l>
<l>*             endif</l>
<l>            npreg := npreg+pN</l>
<l>            create_funct_1d_array(Dirs, FDirs)</l>
<l>            create_funct_1d_array(Dirsi, FDirsi)</l>
<l>            derivate_funct_1d(FDirs, 'first', Derivative)</l>
<l>            y_range_funct_1d(Derivative, YMin, YMax)</l>
<l>            if(YMin &lt; -20 or YMax &gt; 20)</l>
<l>*                 stop()</l>
<l>            endif</l>
<l>            dev_display(Contour)</l>
<l>            tuple_concat (Puseint, Pui, Puseint)</l>
<l>        endfor</l>
<l>    else</l>
<l>        tuple_concat (PCinRnum, 0, PCinRnum)</l>
<l>        tuple_concat (PcontR, -1, PcontR)</l>
<l>*         tuple_concat (PaddrC, -1, PaddrC)</l>
<l>    endif</l>
<l>    tuple_gen_const (npreg, pnumr, Pn)</l>
<l>    tuple_concat (Pnum, Pn, Pnum)</l>
<l>    tuple_concat (Pnum2, Ovl, Pnum2)</l>
<l>    tuple_concat (PnumR, pnumr, PnumR)</l>
<l>    tuple_concat (PaddrR, paddrR, PaddrR)</l>
<c>    </c>
<l>    paddrR := paddrR + npreg</l>
<l>endfor</l>
<c>* ** test ***</c>
<c></c>
<c></c>
<l>* sj := 1100</l>
<l>* pnum := PnumR[sj-1]</l>
<l>* a := PaddrR[sj-1]</l>
<l>* pnum1 := Pnum[a]</l>
<c>* **************</c>
<l>get_grayval (WidthImageP, RowSkTh, ColSkTh, WG)</l>
<l>get_grayval (DirImageP, RowSkTh, ColSkTh, Dir)</l>
<l>Ang := Dir*1.0*3.1415926/256.0</l>
<l>K:=1.</l>
<l>Y1 := RowSkTh-sin(Ang)*(WG/K+wpl)</l>
<l>X1 := ColSkTh+cos(Ang)*(WG/K+wpl)</l>
<l>Y2 := RowSkTh+sin(Ang)*(WG/K+wpl)</l>
<l>X2 := ColSkTh-cos(Ang)*(WG/K+wpl)</l>
<l>YC := RowSkTh</l>
<l>XC := ColSkTh</l>
<c></c>
<l>* gen_region_points(P2, Y2, X2)</l>
<l>return ()</l>
</body>
<docu id="MSBuildFWM6">
<parameters>
<parameter id="DirImageP"/>
<parameter id="ImOverlap"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumR"/>
<parameter id="PregC"/>
<parameter id="Puseint"/>
<parameter id="SkeletonsGThin"/>
<parameter id="WG"/>
<parameter id="WidthImageP"/>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YC"/>
<parameter id="notusedint"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBP6B2">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBPOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBP6B2 </c>
<c>***- 19.01.2024 - for SSPI</c>
<c>***- 07.12.2023 - same as S but for P</c>
<l>ImIRBPOut := ImIRBP</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 3</l>
<l>dilation_circle (SkeletonsFWM, SkeletonsFWMd, dil)</l>
<l>count_obj (SkeletonsFWMd, no)</l>
<c></c>
<l>union1(SkeletonsFWMd, SkeletonFWMd)</l>
<l>dilation_circle (SkeletonFWMd, RegionFWM, 40)</l>
<l>intersection(RegionFWM, RegionInoD, RegionInoDfwm)</l>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWM, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoDS, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoDS, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoD, RegionInoDfwm, RegionInoDSfwm)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMd, RegionInoDfwm, SkeletonsFWMm)</l>
<l>union1(SkeletonsFWMd, SkeletonsFWMdu)</l>
<l>intersection (SkeletonsFWMdu, RegionInoDfwm, SkeletonsFWMmu)</l>
<l>connection(SkeletonsFWMmu, SkeletonsFWMm2)</l>
<c>* 3</c>
<l>* difference (SkeletonsFWMSm, SkeletonsFWMSm2, RegionDifference1)</l>
<c></c>
<c></c>
<l>* area_center (SkeletonsFWMSm, Area, Row, Column)</l>
<l>* tuple_min (Area, amin)</l>
<l>* count_obj (SkeletonsFWMSm, nm)</l>
<c></c>
<l>* symm_difference (SkeletonsFWMSm, SkeletonsFWMSc, RegionDifference)</l>
<c></c>
<l>* intersection (SkeletonsFWM, RegionInoDS, RegionIntersection)</l>
<l>* union2 (SkeletonsFWM, RegionIntersection, RegionUnion)</l>
<l>* expand_region (RegionUnion, RegionInoDS, RegionsFWMS, expsize, 'image')</l>
<l>* expsize:=31</l>
<l>* expand_region (SkeletonsFWMm, RegionInoDS, RegionsFWM2, expsize, 'image')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>dilation_circle(SkeletonsFWMm, SkeletonsFWMmd, expsize)</l>
<l>intersection(RegionsPNi, SkeletonsFWMmd, RegionsPNiSkd)</l>
<l>intersection( RegionsPNiSkd,RegionInoD,RegionsFWM3)</l>
<l>count_obj(RegionsFWM3, n)</l>
<l>gen_empty_obj(RegionsFWMf)</l>
<l>for i:=1 to n by 1</l>
<l>    select_obj(RegionsFWM3, ObjectSelected, i)</l>
<l>    connection(ObjectSelected, ConnectedRegions)</l>
<l>    count_obj(ConnectedRegions, nreg)</l>
<l>    if(nreg==1)</l>
<l>        concat_obj(RegionsFWMf, ObjectSelected,RegionsFWMf)</l>
<l>*         continue</l>
<l>    else</l>
<l>        area_center(ConnectedRegions, Area, Row, Column)</l>
<l>        tuple_sort_index(Area, Indices)</l>
<l>        tuple_length(Area, na)</l>
<l>        ind:=Indices[na-1]+1</l>
<l>        select_obj(ConnectedRegions, ObjectSelected1, ind)</l>
<l>        concat_obj(RegionsFWMf, ObjectSelected1,RegionsFWMf)</l>
<l>    endif</l>
<l>endfor</l>
<l>* union1(RegionsFWM2, RegionFWM2)</l>
<l>union1(RegionsFWMf, RegionFWMf)</l>
<l>* symm_difference(RegionFWM2, RegionFWM3, RegionDifference)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionInoDS, RegionsFWMS2, expsize, 'image')</l>
<l>count_obj (SkeletonsFWM, nRFWM)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (stseq, nRFWM+stseq-1, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary (RegionsFWMf, RegionsFWMBi, 'inner')</l>
<l>boundary(RegionFWMf, RegionInoDB, 'inner')</l>
<l>dilation_circle(RegCut, RegCutdi, 2)</l>
<l>intersection(RegionInoDB, RegCutdi, RegionInoDBcut)</l>
<l>difference(RegCutdi, RegionInoDBcut,RegCutd)</l>
<l>difference(RegionsFWMBi, RegCutd, RegionsFWMB)</l>
<l>count_obj (RegionsFWMB, nFWMP)</l>
<c></c>
<l>paint_region (RegionsFWMf, ImIRBPOut, ImIRBPOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMB, ImIRBPOut, ImIRBPOut, SequenceINBi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBP6B2">
<parameters>
<parameter id="ImIRBP"/>
<parameter id="ImIRBPOut"/>
<parameter id="RegCut"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="SkeletonsFWM"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMP"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc39B2m">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="pnum2" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc39B2 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* * 2024.01.19 two pnum</c>
<c>* * 2023.10.25 skipnext modified </c>
<c>* * 2023.10.23 skipnext modified </c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.04.01 dual int point</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn:=0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<l>* read_object (Reg0001, 'C:/Defect/OFFLINE/Reg_0001.hobj')</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<c></c>
<c>*Going forward from PS1</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>skipnext:=0</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    if(skipnext==1)</l>
<l>        skipnext:=0</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('green')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<c>    </c>
<l>    if (i==1 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and v==1)</l>
<c>        **** inside of Spur ***</c>
<l>        ptype := -1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>*         begtype := 1</l>
<l>*         ii := ii+1</l>
<l>    endif</l>
<l>    *if (v==0)</l>
<l>    if (v==0 or v&gt;1 and v!=pnum and v!=pnum2)</l>
<c>        *** reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and v!=pnum2 and begtype==1)</l>
<c>        *** met wrong region, so reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum or  v==pnum2)</l>
<l>        *if (vp==0 and (vn ==pnum or vn==1))</l>
<c>    *** 2 points ******</c>
<c>    * changed index ip</c>
<l>*     ip:=ii</l>
<l>*     skipnext:=0</l>
<l>        if((vp==pnum or vn==pnum) or (vp==pnum2 or vn==pnum2))</l>
<l>            continue</l>
<l>*             skipnext:=1</l>
<l>*             if(vn==0)</l>
<l>*                 btype := -1</l>
<l>*             elseif(vn==1)</l>
<l>*                 btype := 1</l>
<l>*             elseif(vn==pnum)</l>
<l>*                 btype := 1</l>
<l>*             endif</l>
<l>*             if(gv&gt;gvp)</l>
<l>*                 ip:=ii-1</l>
<l>*             endif</l>
<l>        *endif</l>
<c>    *******************         </c>
<l>        elseif (vp==0 and (vn ==pnum or vn ==pnum2 or vn==1 or vn==0))</l>
<c>    *** 31.05.2024</c>
<l>*         elseif ((vp==0 or vp&gt;1 and vp!=pnum and vp!=pnum2) and (vn ==pnum or vn ==pnum2 or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum and vp!=pnum2) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>*         elseif ( (vn==1 and (vp==pnum or vp==pnum2)) or (vp==1 and (vn==pnum or vn==pnum2)))</l>
<l>*             btype := 1</l>
<l>        elseif ( (vn==1 and (vp==pnum or vp==pnum2)) or (vp==1 and vn==pnum ))</l>
<l>            btype := 1</l>
<l>*         elseif ( (vn==1 and (vp&gt;1)) or (vp==1 and vn==pnum))</l>
<l>*             btype := 1</l>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and (v==1 or v==pnum or v==pnum2) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<c>    </c>
<l>    vp := v</l>
<l>    gvp:=gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    shift:=0.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>*****</c>
<c>***Hong</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>*****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<c></c>
<l>* threshold(ImageIRB, RegionIRB, 3, 255)</l>
<l>tuple_length(PB, nPB)</l>
<l>tuple_length(PE, nPE)</l>
<l>if(intnum &lt;3 or nPB!=nPE)</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>elseif(intnum ==4)</l>
<l>    dif0:=abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1:=abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c>    </c>
<l>*     x0:=PIntX[0]</l>
<l>*     x1:=PIntX[1]</l>
<l>*     x2:=PIntX[2]</l>
<l>*     x3:=PIntX[3]</l>
<c>    </c>
<l>    if( (PIntX[0] &lt;= ixc and PIntX[1] &gt;= ixc or PIntX[0] &gt;= ixc and PIntX[1] &lt;= ixc) and \
        (PIntY[0] &gt;= iyc and PIntY[1] &lt;= iyc or PIntY[0] &lt;= iyc and PIntY[1] &gt;= iyc))</l>
<l>        jMBdn:=PB[0]</l>
<l>        jMBup:=PE[0]</l>
<l>    else</l>
<l>        jMBdn:=PB[1]</l>
<l>        jMBup:=PE[1]</l>
<l>    endif</l>
<c></c>
<c></c>
<l>*     if(dif0&gt;dif1)</l>
<l>*         jMBdn:=PB[0]</l>
<l>*         jMBup:=PE[0]</l>
<l>*     else</l>
<l>*         jMBdn:=PB[1]</l>
<l>*         jMBup:=PE[1]</l>
<l>*     endif</l>
<l>else</l>
<l>    jMBdn:=jSPdn</l>
<l>    jMBup:=jSPup</l>
<l>endif</l>
<c></c>
<l>gen_region_points(PMB, [PIntY[jMBdn],PIntY[jMBup]],  [PIntX[jMBdn],PIntX[jMBup]]) </l>
<l>gen_region_points(PSP, [PIntY[jSPdn],PIntY[jSPup]],  [PIntX[jSPdn],PIntX[jSPup]]) </l>
<c></c>
<l>* for j := 0 to ii-1 by 1</l>
<l>*     if (PType[j]==1)</l>
<l>*         jSPdn := j</l>
<l>*         clcb := PCLC[j]</l>
<l>*         break</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* for j := jSPdn to ii-1 by 1</l>
<l>*     if (PType[j]==-1)</l>
<l>*         clce := PCLC[j]</l>
<l>*         if (abs(clce-clcb) &gt; clcmax)</l>
<l>*             jSPup := j</l>
<l>*             break</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax := max(g0)</l>
<l>*     gmin := min(g0)</l>
<l>*     gmax := max2(g0[0], g0[1])</l>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<l>*     if (Psubpix[j]==0)</l>
<l>*         FIntX[j] := PIntX[j]</l>
<l>*         FIntY[j] := PIntY[j]</l>
<l>*     else</l>
<l>* SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop ()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi := PInti[i]</l>
<l>* endfor</l>
<l>* stop ()</l>
<c>* previous clc</c>
<l>* pclc := -2</l>
<l>* fi1 := 0</l>
<c>* checking 1st MS pixel</c>
<l>* if (Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii] := PPy[0]</l>
<l>*     PIntX[ii] := PPx[0]</l>
<l>*     PInti[ii] := 0</l>
<l>*     Psubpix[ii] := 0</l>
<l>*     get_grayval (ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval (ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if (Pval[0]==pnum)</l>
<l>*         PCLC[ii] := clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii] := -2</l>
<l>*     endif</l>
<l>*     ii := ii+1</l>
<c>    * * 1st pix is 1</c>
<l>*     if (Pval[0]==1)</l>
<l>*         fi1 := 1</l>
<l>*     endif</l>
<c></c>
<l>*     if (Pval[1]==0 and Pval[0]==pnum)</l>
<l>*         PIntY[ii] := PPy[0]</l>
<l>*         PIntX[ii] := PPx[0]</l>
<l>*         PInti[ii] := 0</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         Psubpix[ii] := 0</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1 := 0</l>
<l>* endif</l>
<c>* **********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color ('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if (i==9)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_display (Pc)</l>
<l>*     v := Pval[i]</l>
<c>    * * check for 1st pix == 1 case</c>
<l>*     if (fi1==1)</l>
<l>*         if (v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii := ii-1</l>
<l>*             fi1 := 0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1 := 0</l>
<c>        * previous and next values</c>
<l>*         vp := Pval[i-1]</l>
<l>*         vn := Pval[i+1]</l>
<c>        * intersection type detection</c>
<l>*         dev_set_color ('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj (PC, Pc, PC)</l>
<l>*         dev_display (Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if ((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))</l>
<c></c>
<l>*             get_grayval (ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval (ImageIRBS, yc, xc, irbs)</l>
<c></c>
<l>*             PIntY[ii] := yc</l>
<l>*             PIntX[ii] := xc</l>
<l>*             PInti[ii] := i</l>
<l>*             Psubpix[ii] := 1</l>
<l>*             dev_set_color ('red')</l>
<l>*             gen_region_points (Pc, yc, xc)</l>
<l>*             dev_display (Pc)</l>
<l>*             if ((vp==0 )and vn==0)</l>
<c>                * single point special case</c>
<l>*                 ii := ii+1</l>
<l>*                 PIntY[ii-1] := yc-0.35*signY</l>
<l>*                 PIntX[ii-1] := xc-0.35*signX</l>
<l>*                 Psubpix[ii-1] := 0</l>
<l>*                 PIntY[ii] := yc+0.35*signY</l>
<l>*                 PIntX[ii] := xc+0.35*signX</l>
<l>*                 PInti[ii] := i</l>
<l>*                 Psubpix[ii] := 0</l>
<l>*                 stop ()</l>
<l>*             endif</l>
<c></c>
<l>*             PCLC[ii] := clc</l>
<l>*             PIRBS[ii] := irbs</l>
<l>*             ii := ii+1</l>
<l>*             pclc := clc</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     endif</l>
<l>*     vp := v</l>
<l>*     gp := g</l>
<l>* endfor</l>
<c></c>
<c>* checking last MS pixel</c>
<l>* if ((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if (Pval[pind-1]==pnum)</l>
<l>*         get_grayval (ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval (ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc := PCLC[ii-1]</l>
<l>*         irbs := PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii] := PPy[pind-1]</l>
<l>*     PIntX[ii] := PPx[pind-1]</l>
<l>*     PInti[ii] := pind-1</l>
<l>*     PCLC[ii] := clc</l>
<l>*     ii := ii+1</l>
<l>*     if (Pval[pind-2]==1)</l>
<l>*         PIntY[ii] := PPy[pind-1]</l>
<l>*         PIntX[ii] := PPx[pind-1]</l>
<l>*         PInti[ii] := pind-1</l>
<l>*         PCLC[ii] := clc</l>
<l>*         PIRBS[ii] := irbs</l>
<l>*         ii := ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii] := 0</l>
<l>* endif</l>
<c>* *************************</c>
<l>* gen_region_points (PInt, PIntY, PIntX)</l>
<l>* intnum := ii</l>
<l>* if (intnum%2 == 1 or intnum==0)</l>
<c>    * *** error, odd number of intersection points</c>
<l>*     stop ()</l>
<l>* else</l>
<l>*     if (intnum&lt;=1)</l>
<c>        * * no pattern case</c>
<l>*         wmin := 0.</l>
<l>*         wmax := 0.</l>
<l>*         shift := 0.</l>
<l>*         return ()</l>
<l>*     endif</l>
<l>*     stop ()</l>
<l>*     t := thr</l>
<c>    * ** previous dir</c>
<l>*     pdir := -1</l>
<c>    * *************** SUBPIX COORD. ******************************</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0], g)</l>
<l>*         g0[1] := g</l>
<l>*         if (PInti[j]&gt;0)</l>
<l>*             get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*             g0[0] := g</l>
<l>*         else</l>
<l>*             g0[0] := g0[1]</l>
<l>*         endif</l>
<l>*         if (PInti[j]&lt;pind-1)</l>
<l>*             get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g)</l>
<l>*             g0[2] := g</l>
<l>*         else</l>
<l>*             g0[2] := g0[1]</l>
<l>*         endif</l>
<c></c>
<l>*         if (Psubpix[j]==0)</l>
<l>*             FIntX[j] := PIntX[j]</l>
<l>*             FIntY[j] := PIntY[j]</l>
<l>*         else</l>
<l>* SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*             FIntX[j] := fIntX</l>
<l>*             FIntY[j] := fIntY</l>
<l>*         endif</l>
<l>*         if (g0[2]-g0[0]&gt;0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         elseif (g0[0]-g0[2]&gt;0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         if (pdir &gt; 0)</l>
<l>*             Pdir[j] := -1</l>
<l>*         elseif (pdir &lt; 0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*             Pdir[j] := 1</l>
<l>*         endif</l>
<l>*         if (PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*             Pdir[j] := -1</l>
<l>*         endif</l>
<l>*         pdir := Pdir[j]</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * number of MW candidates</c>
<l>*     nmwc := 0</l>
<c>    * MW segment</c>
<l>*     mw := -1</l>
<l>*     dmin := 55555</l>
<c>    * ******************* Check Segments ********</c>
<c>    * ** finding MW (main wire) segment</c>
<c>    * ** fixing PCLC and Pnums</c>
<l>*     for j := 0 to intnum-1 by 1</l>
<l>*         if (j==3)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<l>*         get_grayval (ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*         get_grayval (ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*         if (vclc==0)</l>
<c>            * **** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*             clc := 0</l>
<l>*             for dx := -3 to 3 by 1</l>
<l>*                 for dy := -3 to 3 by 1</l>
<l>*                     get_grayval (ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                     if (vclc!=0)</l>
<l>*                         clc := vclc</l>
<l>*                         break</l>
<l>*                     endif</l>
<l>*                 endfor</l>
<l>*             endfor</l>
<l>*             PCLC[j] := clc</l>
<c>            * ************************************************************</c>
<l>*         else</l>
<l>*             PCLC[j] := vclc</l>
<l>*         endif</l>
<l>*         Pnums[j] := vpnums</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * ******** checking segments for main wire (mw) *****</c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         pclc := PCLC[j]</l>
<l>*         clc := PCLC[j+1]</l>
<c></c>
<l>*         dclc := min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*         if (dclc&gt;clcmax)</l>
<l>*             if (Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*                 continue</l>
<l>*             endif</l>
<c>            * could be MW, so check distance from P1 and P2</c>
<l>*             da := (ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*             d1 := (ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*             d2 := (ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*             d := sqrt( min2(d1,d2) )</l>
<l>*             if (d&lt;dmin)</l>
<l>*                 mw := j</l>
<l>*                 nmwc := nmwc+1</l>
<l>*                 dmin := d</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     if (mw==-1)</l>
<l>*         mw := 0</l>
<l>*         stop ()</l>
<l>*     endif</l>
<l>*     dev_set_color ('red')</l>
<l>*     gen_region_points (PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>*     dev_display (PMW)</l>
<l>*     gen_region_points (PC, iyc, ixc)</l>
<l>*     stop ()</l>
<c>    * ** finding Spur points</c>
<l>*     jSPdn := mw</l>
<l>*     jSPup := mw+1</l>
<c></c>
<l>*     for j := 0 to intnum-1 by 2</l>
<l>*         if (j==mw)</l>
<l>*             continue</l>
<l>*         else</l>
<l>*             clc := PCLC[j]</l>
<l>*             clc1 := PCLC[mw]</l>
<l>*             clc2 := PCLC[mw+1]</l>
<l>*             dclc1 := min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*             dclc2 := min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*             if (dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>                * not SP because of big dCLC</c>
<l>*                 continue</l>
<l>*             else</l>
<l>*                 if (j&lt;mw)</l>
<l>*                     dclc := min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPdn := j</l>
<l>*                     endif</l>
<l>*                 else</l>
<l>*                     dclc := min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                     if (dclc &gt; clcmax)</l>
<c>                        * not SP because of big dCLC from MW point</c>
<l>*                         continue</l>
<l>*                     else</l>
<l>*                         jSPup := j+1</l>
<l>*                     endif</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>*     stop ()</l>
<c>    * *** both sides are rising or falling - error</c>
<l>*     if (Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*         jSPup := jSPdn+1</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc39B2m">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="pnum2"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="AngleUnwrap">
<interface>
<ic>
<par name="AnglesG" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnglesGOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>AnglesGOut[0] := AnglesG[0]</l>
<l>tuple_length (AnglesG, nA)</l>
<l>aadd:=0</l>
<l>for j:=1 to nA-1 by 1</l>
<l>*     if(j==2498)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    ac:=AnglesG[j]</l>
<l>    ap:=AnglesG[j-1]</l>
<l>*     aadd:=0</l>
<l>    if (abs(ac-ap)&gt;3.14)</l>
<l>        if (ac&lt;ap)</l>
<l>            aadd := aadd+6.28318</l>
<l>        else</l>
<l>            aadd := aadd-6.28318</l>
<l>        endif</l>
<l>    endif</l>
<l>    AnglesGOut[j] := ac+aadd</l>
<l>endfor</l>
<l>* AnglesGOut := AnglesG</l>
<l>return ()</l>
</body>
<docu id="AngleUnwrap">
<parameters>
<parameter id="AnglesG"/>
<parameter id="AnglesGOut"/>
</parameters>
</docu>
</procedure>
<procedure name="ExtendedSkeletonWFMP7">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SkeletonParts" base_type="iconic" dimension="0"/>
<par name="WidthImagePout" base_type="iconic" dimension="0"/>
<par name="DirImagePout" base_type="iconic" dimension="0"/>
<par name="ImageOverlap" base_type="iconic" dimension="0"/>
<par name="RegsOverlap" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="elengthover" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ** ExtendedSkeletonWFMP7 v1.0, 11.03.2023</c>
<c>*  240213 - overlaps for Cut (one side)</c>
<c>*  240117 - overlaps for Cut</c>
<c>*  230313 - added skel. parts having multiple regions</c>
<c>*  230223 - fixed possible non-equal numbers of SkeletonsFWM and SkContoursG</c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>gen_image_const(ImageOverlap, 'int1', Width, Height)</l>
<l>gen_image_proto(ImageOverlap, ImageOverlap, -1)</l>
<c></c>
<l>gen_empty_obj(RegsOverlap)</l>
<c></c>
<l>smallest_rectangle1(RegionG, Row11g, Column11g, Row2g, Column2g)</l>
<l>gen_rectangle1(RectangleG, Row11g-2, Column11g-2, Row2g+2, Column2g+2)</l>
<l>difference(RectangleG, RegionG, RegFirbid)</l>
<c></c>
<l>union1(SkeletonsFWM, SkeletonFWM)</l>
<l>* junctions_skeleton(SkeletonFWM, EndPoints, JuncPoints)</l>
<l>junctions_skeleton(SkeletonG, EndPoints, JuncPoints)</l>
<l>* dilation_circle(EndPoints, EndPointsd, 1.5)</l>
<l>dilation_rectangle1(EndPoints, EndPointsd, 2.5,2.5)</l>
<l>union1(EndPointsd, EndPointd)</l>
<l>* gen_contours_skeleton_xld (SkeletonsFWM, SkContoursG, 1, 'filter')</l>
<l>area_center(SkeletonsFWM, A,Row, Column)</l>
<l>tuple_sort_index(Row, Indices)</l>
<l>tuple_sort(A, Sorted)</l>
<l>* dev_update_off ()</l>
<l>* gen_image_const (SkeletonParts, 'real', WidthG, HeightG)</l>
<l>* count_obj (SkContoursG, nSkCG)</l>
<l>count_obj (SkeletonsFWM, nFWM)</l>
<l>gen_empty_obj(SkeletonParts)</l>
<l>get_domain(WidthImageP, Domain)</l>
<l>nrec:=0</l>
<l>nsk:=0</l>
<l>connection(JuncPoints, JuncPointsC)</l>
<l>area_center(JuncPointsC, AJP, RowsJP, ColsJP)</l>
<l>get_image_size(DirImageP, Width, Height)</l>
<l>tuple_max(RowsJP, rm)</l>
<l>tuple_max(ColsJP, cm)</l>
<l>if(rm &gt;= Height or cm &gt;= Width)</l>
<l>         stop()</l>
<l>endif</l>
<l>get_grayval(WidthImageP,RowsJP, ColsJP, WJP)</l>
<l>gen_circle(CircJP, RowsJP, ColsJP, WJP/2+jpadd)</l>
<l>union1(CircJP, CircJPu)</l>
<l>* get_region_points(JuncPoints, RowsJP, ColsJP)</l>
<l>for k := 1 to nFWM by 1</l>
<l>*     if(k==65)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     k:=3</l>
<l>    select_obj (SkeletonsFWM, SelectedSkeletonG, k)</l>
<l>*     connection(SelectedSkeletonG, ConnectedRegions)</l>
<l>*     count_obj(ConnectedRegions, n)</l>
<l>*     if(n&gt;1)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>    connection(SelectedSkeletonG, SelectedSkeletonsG)</l>
<l>    count_obj(SelectedSkeletonsG, nSSG)</l>
<l>    for kk := 1 to nSSG by 1</l>
<l>        select_obj(SelectedSkeletonsG, SSG, kk)</l>
<l>        area_center(SSG, a, r, c)</l>
<l>        if(a&lt;10)</l>
<l>            continue</l>
<l>        endif</l>
<l>*         select_obj (SkContoursG, SelectedContourG, k)</l>
<l>        gen_contours_skeleton_xld (SSG, SelectedContourG, 1, 'filter')</l>
<c>        </c>
<l>*         if( r&gt;600 and r&lt;700 and c&gt;10600 and c&lt;10700)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         if( r&gt;2020 and r&lt;2050 and c&gt;10800 and c&lt;11000)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>        contour_point_num_xld (SelectedContourG, np)</l>
<l>        get_contour_xld (SelectedContourG, RowG, ColG)</l>
<c>        </c>
<l>        gen_region_points (RegionSCG, RowG, ColG)</l>
<l>        if (np &lt; 21)</l>
<l>            lookaround := 1</l>
<l>        else</l>
<l>            lookaround := 3</l>
<l>        endif</l>
<c>        </c>
<l>        get_contour_angle_xld (SelectedContourG, 'abs', 'regress', lookaround, AnglesG)</l>
<l>        tuple_length(AnglesG, nA)</l>
<c>    </c>
<l>        gen_region_points(ER1, RowG[0], ColG[0])</l>
<l>        gen_region_points(ER2, RowG[nA-1], ColG[nA-1])</l>
<l>        dilation_circle(ER1, RegionDilation, 13.5)</l>
<l>        dilation_circle(ER2, RegionDilation2, 13.5)</l>
<l>*         stop()</l>
<l>        if(a&gt;0)</l>
<l>            test_subset_region(ER1, EndPointd, IsSubset)</l>
<l>            if(IsSubset==1)</l>
<l>                gen_circle (Circle, RowG[0], ColG[0], abs(elengthnoend))</l>
<l>                intersection(Circle, SkeletonG, RegionIntersection)</l>
<c>                </c>
<l>                if(elengthnoend &gt; 0)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                else</l>
<l>                    difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                endif</l>
<l>                nsk:=nsk+1</l>
<l>            else</l>
<l>                dilation_circle(RegCut, RegCutd, 3)</l>
<l>                intersection(RegCutd, ER1, RegionIntersection1)</l>
<l>                area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>                if(a==0)</l>
<l>                    row:=round(RowG[1]-elengthend*sin(AnglesG[1]-3.14159))</l>
<l>                    col:=round(ColG[1]+elengthend*cos(AnglesG[1]-3.14159))</l>
<l>                    gen_rectangle2 (Rectangle21, row, col, AnglesG[1]-3.14159, elengthend, 0.25)</l>
<l>                    intersection(Rectangle21, Domain, Rectangle21)</l>
<l>                    union2(SelectedSkeletonG, Rectangle21, SelectedSkeletonG)</l>
<l>                    get_region_points(Rectangle21, R21, C21)</l>
<l>                    tuple_length(R21, n21)</l>
<l>                    ang:=AnglesG[1]</l>
<l>                    dir21:= (ang-1.57)*256/3.14159</l>
<l>                    tuple_gen_const(n21, dir21, Dir21)</l>
<l>                    tuple_max(R21, rm)</l>
<l>                    tuple_max(C21, cm)</l>
<l>                    if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                        stop()</l>
<l>                    endif</l>
<l>                    set_grayval(DirImageP, R21, C21, Dir21)</l>
<l>                    nrec:=nrec+1</l>
<l>                else</l>
<l>*                     expand_region(ER1, RegFirbid, RegionExpanded, elengthover, 'image')</l>
<l>*                     intersection(RegionExpanded, SkeletonG, RegionIntersectionExpG)</l>
<l>*                     intersection(RegionIntersectionExpG, SelectedSkeletonG, RegionIntersectionExpG1)</l>
<l>*                     union2(SelectedSkeletonG, RegionIntersectionExpG, SelectedSkeletonG)</l>
<l>*                     difference(RegionIntersectionExpG, SSG, RegionIntersectionExpGd)</l>
<l>*                     get_region_points(RegionIntersectionExpG1, Rows, Columns)</l>
<l>*                     tuple_length(Rows, n)</l>
<l>*                     row:=Rows[n/2]</l>
<l>*                     col:=Columns[n/2]</l>
<l>*                     row:=Rows[5]</l>
<l>*                     col:=Columns[5]</l>
<l>*                     gen_region_points(RegionTst, row, col)</l>
<l>*                     get_region_index(SkeletonsFWM,row, col, index)</l>
<l>*                     tuple_gen_const(n, index+1, Index)</l>
<c>                    </c>
<l>*                     set_grayval(ImageOverlap, Rows, Columns, Index)</l>
<l>*                     concat_obj(RegsOverlap, RegionIntersectionExpG, RegsOverlap)</l>
<l>                endif</l>
<c>              </c>
<l>            endif</l>
<l>*             connection(RegionIntersectionExpG, ConnectedRegions)</l>
<l>*             count_obj(ConnectedRegions, n)</l>
<l>*             if(n&gt;1)</l>
<l>*                 stop()</l>
<l>*             endif</l>
<l>            test_subset_region(ER2, EndPointd, IsSubset)</l>
<l>            if(IsSubset==1)</l>
<l>                gen_circle (Circle, RowG[nA-1], ColG[nA-1], abs(elengthnoend))</l>
<l>                intersection(Circle, SkeletonG, RegionIntersection)</l>
<l>                if(elengthnoend &gt; 0)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                else</l>
<l>                    difference(SelectedSkeletonG, RegionIntersection, SelectedSkeletonG)</l>
<l>                endif</l>
<c>                </c>
<l>                nsk:=nsk+1</l>
<l>            else</l>
<l>                dilation_circle(RegCut, RegCutd, 3)</l>
<l>                intersection(RegCutd, ER2, RegionIntersection1)</l>
<l>                area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>                if(a==0)</l>
<l>                    row:=round(RowG[nA-2]-elengthend*sin(AnglesG[nA-2]))</l>
<l>                    col:=round(ColG[nA-2]+elengthend*cos(AnglesG[nA-2]))</l>
<l>                    gen_rectangle2 (Rectangle22, row, col, AnglesG[nA-2]-3.14159, elengthend, 0.01)</l>
<l>*                     gen_rectangle2 (Rectangle22, RowG[nA-2]-elengthend*sin(AnglesG[nA-2]), ColG[nA-2]+elengthend*cos(AnglesG[nA-2]), AnglesG[nA-2], elengthend, 0.25)</l>
<l>                    intersection(Rectangle22, Domain, Rectangle22)</l>
<l>                    union2(SelectedSkeletonG, Rectangle22, SelectedSkeletonG)</l>
<l>                    get_region_points(Rectangle22, R22, C22)</l>
<l>                    tuple_length(R22, n22)</l>
<l>                    ang:=AnglesG[nA-2]</l>
<l>                    dir22:= (ang-1.57)*256/3.14159</l>
<l>                    tuple_gen_const(n22, dir22, Dir22)</l>
<l>                    tuple_max(R22, rm)</l>
<l>                    tuple_max(C22, cm)</l>
<l>                    if(rm &gt;= Height or cm &gt;= Width)</l>
<l>                        stop()</l>
<l>                    endif</l>
<l>                    set_grayval(DirImageP, R22, C22, Dir22)</l>
<l>                    nrec:=nrec+1</l>
<l>                else</l>
<l>*                     expand_region(ER2, RegFirbid, RegionExpanded, elengthover, 'image')</l>
<l>*                     intersection(RegionExpanded, SelectedSkeletonG, RegionIntersectionExpG)</l>
<l>*                     intersection(RegionIntersectionExpG, SelectedSkeletonG, RegionIntersectionExpG1)</l>
<l>*                     union2(SelectedSkeletonG, RegionIntersectionExpG, SelectedSkeletonG)</l>
<l>*                     get_region_points(RegionIntersectionExpG1, Rows, Columns)</l>
<l>*                     tuple_length(Rows, n)</l>
<l>*                     row:=Rows[n/2]</l>
<l>*                     col:=Columns[n/2]</l>
<l>*                     get_region_index(SkeletonsFWM,row, col, index)</l>
<l>*                     tuple_gen_const(n, index, Index)</l>
<c>                    </c>
<l>*                     set_grayval(ImageOverlap, Rows, Columns, Index)</l>
<c>                    </c>
<l>                    expand_region(ER2, RegFirbid, RegionExpanded, elengthover, 'image')</l>
<l>                    intersection(RegionExpanded, SkeletonG, RegionIntersectionExpG)</l>
<l>*                     intersection(RegionIntersectionExpG, SelectedSkeletonG, RegionIntersectionExpG1)</l>
<l>                    difference(RegionIntersectionExpG, SelectedSkeletonG, RegionIntersectionExpG1)</l>
<l>                    union2(SelectedSkeletonG, RegionIntersectionExpG, SelectedSkeletonG)</l>
<l>                    difference(RegionIntersectionExpG, SSG, RegionIntersectionExpGd)</l>
<l>                    get_region_points(RegionIntersectionExpG1, Rows, Columns)</l>
<l>                    tuple_length(Rows, n)</l>
<l>                    row:=Rows[n/2]</l>
<l>                    col:=Columns[n/2]</l>
<l>                    row:=Rows[5]</l>
<l>                    col:=Columns[5]</l>
<l>                    gen_region_points(RegionTst, row, col)</l>
<l>                    get_region_index(SkeletonsFWM,row, col, index)</l>
<l>*                     tuple_gen_const(n, index+1, Index)</l>
<c>                    </c>
<l>                    dilation_circle(RegionIntersectionExpG1, RegionIntersectionExpG1d, 3.5)</l>
<l>                    get_region_points(RegionIntersectionExpG1d, Rowsd, Columnsd)</l>
<l>                    tuple_length(Rowsd, nd)</l>
<l>                    tuple_gen_const(nd, index+1, Index)</l>
<c>                    </c>
<l>                    set_grayval(ImageOverlap, Rowsd, Columnsd, Index)</l>
<l>                    concat_obj(RegsOverlap, RegionIntersectionExpG1d, RegsOverlap)</l>
<l>                endif</l>
<c>                </c>
<l>            endif</l>
<l>        endif</l>
<l>        concat_obj(SkeletonParts, SelectedSkeletonG, SkeletonParts)</l>
<l>*      get_region_points(SelectedSkeletonG, Rows, Columns)</l>
<l>*     get_grayval(WidthImageP,Rows, Columns, WR)</l>
<l>*     tuple_median(WR, wrm)</l>
<l>*     tuple_min(WR, wrm)</l>
<l>    endfor</l>
<l>endfor</l>
<l>difference(SkeletonParts, CircJPu, SkeletonParts)</l>
<l>return ()</l>
</body>
<docu id="ExtendedSkeletonWFMP7">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImagePout"/>
<parameter id="ImageOverlap"/>
<parameter id="RegCut"/>
<parameter id="RegionG"/>
<parameter id="RegsOverlap"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonParts"/>
<parameter id="SkeletonsFWM"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImagePout"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elengthover"/>
<parameter id="jpadd"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildFWM52">
<interface>
<io>
<par name="SkeletonsGThin" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="notusedint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildFWM52 </c>
<c>**** 2024.02.19 - Pnum2 near changes of Pnum</c>
<c>**** 2022.06.17 - added Puseint - used intersection points tuple</c>
<c>****</c>
<l>RowSkTh := []</l>
<l>ColSkTh := []</l>
<c>* * pnum corresponding to current MS</c>
<l>Pnum := []</l>
<c>* * pnum corresponding to current MS near cuts</c>
<l>Pnum2 := []</l>
<c>* * pnum corresponding to region</c>
<l>PnumR := []</l>
<c>* * start address of a contour</c>
<l>PaddrC := []</l>
<c>* * start address for region</c>
<l>PaddrR := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregC := []</l>
<c>* * number of countours per region</c>
<l>PCinRnum := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontR := []</l>
<c>* * saving intersect. points for current MS ==1, not saving ==0</c>
<l>Puseint := []</l>
<l>paddrC := 0</l>
<l>paddrR := 0</l>
<l>pcont := 0</l>
<l>tuple_gen_const (notusedint, 0, Notused)</l>
<l>tuple_gen_sequence (0, notusedint-1, 1, Beg)</l>
<c></c>
<l>count_obj (SkeletonsGThin, nSGThin)</l>
<l>for j := 1 to nSGThin by 1</l>
<l>*     if (j==871)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c></c>
<l>*     j:=871</l>
<l>    select_obj (SkeletonsGThin, ObjectSelected1, j)</l>
<l>    area_center (ObjectSelected1, a, r, c)</l>
<c>    * *** empty regions (no skeleton FWM inside of RegiondPNi[j]</c>
<l>    pnumr := -1</l>
<l>*     RowSkTh := 0</l>
<l>*     ColSkTh := 0</l>
<l>    npreg := 0</l>
<l>    if (a&gt;0)</l>
<c>        * *** non-empty regions</c>
<l>        get_region_points (ObjectSelected1, R, C)</l>
<l>        tuple_length (R, nsp)</l>
<c></c>
<l>        get_grayval (ImageIR, R, C, PnValr)</l>
<l>        tuple_median (PnValr, pnumr)</l>
<l>*         tuple_max(Val,vmax)</l>
<l>*         if(vmax!=j)</l>
<l>*             stop()</l>
<l>*         endif</l>
<c></c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld (ObjectSelected1, Contours, 1, 'filter')</l>
<l>        count_obj (Contours, nC)</l>
<l>        tuple_concat (PCinRnum, nC, PCinRnum)</l>
<c></c>
<l>        tuple_concat (PcontR, pcont, PcontR)</l>
<l>        pcont := pcont+nC</l>
<c></c>
<l>        for jj := 1 to nC by 1</l>
<l>            select_obj (Contours, Contour, jj)</l>
<l>            get_contour_xld (Contour, R, C)</l>
<l>            get_grayval (ImageIR, R, C, PnVal)</l>
<c>            </c>
<l>*             get_grayval (ImageIR, R, C, Val)</l>
<l>*             tuple_median (Val, pnum)</l>
<l>            tuple_length (R, pN)</l>
<c>            </c>
<l>             tuple_gen_const(pN, 1, Pui)</l>
<l>            if(pN &gt;=notusedint*2)</l>
<l>                tuple_gen_sequence (pN-notusedint, pN-1, 1, End)</l>
<l>                tuple_replace(Pui, Beg, Notused, Pui)</l>
<l>                tuple_replace(Pui, End, Notused, Pui)</l>
<l>            endif</l>
<c>            </c>
<c>            **** can't skip any contour, numberings don't match!!!</c>
<l>*             if(pN &lt; 100)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>            tuple_concat (PaddrC, paddrC, PaddrC)</l>
<l>*             pcont := pcont+1</l>
<l>            paddrC := paddrC + pN</l>
<l>            tuple_concat (PregC, j, PregC)</l>
<l>*             if (pN&gt;100)</l>
<l>                tuple_concat (RowSkTh, R, RowSkTh)</l>
<l>                tuple_concat (ColSkTh, C, ColSkTh)</l>
<l>            get_grayval(DirImageP, R, C, Dirs)</l>
<l>            Dirsi:=Dirs</l>
<l>            tuple_length(Dirs, nD)</l>
<l>            for jjj:=0 to nD-2 by 1</l>
<l>*                 if(jjj==641)</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<l>                d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>                if(d &gt; 128)</l>
<l>                    d:= d-255</l>
<l>                elseif(d &lt; -128)</l>
<l>                    d:= d+255</l>
<l>                endif</l>
<l>                Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>            endfor</l>
<l>*             endif</l>
<l>            npreg := npreg+pN</l>
<l>            create_funct_1d_array(Dirs, FDirs)</l>
<l>            create_funct_1d_array(Dirsi, FDirsi)</l>
<l>            derivate_funct_1d(FDirs, 'first', Derivative)</l>
<l>            y_range_funct_1d(Derivative, YMin, YMax)</l>
<l>            if(YMin &lt; -20 or YMax &gt; 20)</l>
<l>*                 stop()</l>
<l>            endif</l>
<l>            dev_display(Contour)</l>
<l>            tuple_concat (Puseint, Pui, Puseint)</l>
<l>            tuple_concat (Pnum, PnVal, Pnum)</l>
<l>        endfor</l>
<l>    else</l>
<l>        tuple_concat (PCinRnum, 0, PCinRnum)</l>
<l>        tuple_concat (PcontR, -1, PcontR)</l>
<l>*         tuple_concat (PaddrC, -1, PaddrC)</l>
<l>    endif</l>
<l>    tuple_gen_const (npreg, pnumr, Pn)</l>
<l>*     tuple_concat (Pnum, Pn, Pnum)</l>
<l>    tuple_concat (PnumR, pnumr, PnumR)</l>
<l>    tuple_concat (PaddrR, paddrR, PaddrR)</l>
<c>    </c>
<l>    paddrR := paddrR + npreg</l>
<l>endfor</l>
<c></c>
<c>****** making Pnum2</c>
<l>tuple_length(Pnum, nPnum)</l>
<l>lpnum2:= 30</l>
<c></c>
<l>for j:=0 to nPnum-1 by 1</l>
<l>    Pnum2[j]:=-1</l>
<l>endfor</l>
<l>pnump:=Pnum[0]</l>
<l>for j:=lpnum2 to nPnum-1 by 1</l>
<l>    pnumc:=Pnum[j]</l>
<l>    if(pnumc!=pnump)</l>
<l>        for jj:=1 to lpnum2 by 1</l>
<l>            Pnum2[j-jj]:=pnumc</l>
<l>            Pnum2[j+jj]:=pnump</l>
<l>        endfor</l>
<l>        Pnum2[j]:=pnump</l>
<l>    endif</l>
<l>    pnump:=pnumc</l>
<l>endfor</l>
<c>* ** test ***</c>
<l>* sj := 1100</l>
<l>* pnum := PnumR[sj-1]</l>
<l>* a := PaddrR[sj-1]</l>
<l>* pnum1 := Pnum[a]</l>
<c>* **************</c>
<l>get_grayval (WidthImageP, RowSkTh, ColSkTh, WG)</l>
<l>get_grayval (DirImageP, RowSkTh, ColSkTh, Dir)</l>
<l>Ang := Dir*1.0*3.1415926/256.0</l>
<l>K:=1.</l>
<l>Y1 := RowSkTh-sin(Ang)*(WG/K+wpl)</l>
<l>X1 := ColSkTh+cos(Ang)*(WG/K+wpl)</l>
<l>Y2 := RowSkTh+sin(Ang)*(WG/K+wpl)</l>
<l>X2 := ColSkTh-cos(Ang)*(WG/K+wpl)</l>
<l>YC := RowSkTh</l>
<l>XC := ColSkTh</l>
<c></c>
<l>* gen_region_points(P2, Y2, X2)</l>
<l>return ()</l>
</body>
<docu id="MSBuildFWM52">
<parameters>
<parameter id="DirImageP"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumR"/>
<parameter id="PregC"/>
<parameter id="Puseint"/>
<parameter id="SkeletonsGThin"/>
<parameter id="WG"/>
<parameter id="WidthImageP"/>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YC"/>
<parameter id="notusedint"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain124">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="RegionsmainSNoCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumS2" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain124 </c>
<c>*** 240224 - Cut without overlap for both P and S</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>TotalPRC:=5</l>
<l>CurrentOper:='Starting'</l>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>connection (RegionGid, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<l>TotalPRC:=7</l>
<l>CurrentOper:='Smoothing regions'</l>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<c>* 16.04.2024 </c>
<l>* difference (DomainG, RegionGsm, RegionGSi)</l>
<l>difference (DomainG, RegionG, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c>* 16.04.2024</c>
<l>* intersection (RegionGSi, RC, RegionGSii)</l>
<l>* difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<c></c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>connection(SkeletonGS, SkeletonsGS)</l>
<c></c>
<l>* select_shape(ConnectedRegionsS, SkeletonsGS, 'area', 'and', minlen, 9999999)  </l>
<l>junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(SkeletonsGS,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(SkeletonsGS, CMSSEu, SkeletonsGS)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<l>* stop()</l>
<l>* ExtendedSkeletonWFMP5(RegionG, SkeletonsGS, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<c></c>
<c></c>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>TotalPRC:=10</l>
<l>CurrentOper:='Building width and direction images'</l>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** 24.04.02 RegionGSi -&gt; RegionGSii</c>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>TotalPRC:=20</l>
<l>CurrentOper:='Building Pattern Skeletons'</l>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>tuple_length (WGSi, nWGSi)</l>
<l>tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGSi-1 by 1</l>
<l>    if(WGSi[j]&lt; minWGS)</l>
<l>        WGSi[j] := minWGS</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c></c>
<c>****** Auto setting of FWM/S widths using width histogram 16.04.2024 </c>
<l>create_funct_1d_array(PrcWGSi, FPrcWGSi)</l>
<l>local_min_max_funct_1d(FPrcWGSi, 'strict_min_max', 'true', MinPrcWGS, MaxPrcWGS)</l>
<l>tuple_length(MinPrcWGS, nMinPrcWGS)</l>
<l>tuple_length(MaxPrcWGS, nMaxPrcWGS)</l>
<l>get_y_value_funct_1d(FPrcWGSi, MinPrcWGS, 'constant', YMinPrcWGS)</l>
<l>get_y_value_funct_1d(FPrcWGSi, MaxPrcWGS, 'constant', YMaxPrcWGS)</l>
<c></c>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>* get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>* get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>* tuple_length(WdG, nWdG)</l>
<l>* tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>* PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0 and useODB&lt;3)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>prcmin:=5</l>
<l>numP:=3</l>
<l>numS:=1</l>
<l>wmax:=45</l>
<l>if(useODB==1)</l>
<l>      WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>endif</l>
<c></c>
<l>numS:=1</l>
<l>WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    WminP := wFWM</l>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>elseif(useODB==1)</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>else </l>
<l>    RegionmainNoCut:=SkeletonGS</l>
<l>    connection(RegionmainNoCut, RegionsmainNoCut)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>TotalPRC:=40</l>
<l>CurrentOper:='Building Space Skeletons'</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<c></c>
<l>WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c></c>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>connection(RmainS, ConnectedRegionsS)</l>
<l>select_shape(ConnectedRegionsS, RegionsmainSNoCut, 'area', 'and', minlen, 9999999)  </l>
<l>junctions_skeleton(RegionsmainSNoCut, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSNoCut,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(RegionsmainSNoCut, CMSSEu, RegionsmainSNoCut)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>* RegionsmainS:=RegionsmainSn</l>
<l>union1(RegionsmainSNoCut, RegionmainSNoCut)</l>
<l>difference(RegionmainSNoCut, RegionCut, RegionmainS)</l>
<l>connection(RegionmainS, RegionsmainS)</l>
<l>union1(RegionsmainS, RegionmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>SkeletonsFWMScut:=RegionsmainS</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>SkeletonsFWMS:=RegionsmainSNoCut</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<l>TotalPRC:=60</l>
<l>CurrentOper:='Preparing IRB'</l>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>TotalPRC:=70</l>
<l>CurrentOper:='Building non-FWM sensors'</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>* union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>* connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>* count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMScut, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (2, nINBS+1, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseqS := nEMPTY+1</l>
<l>* overfS := 255-stseqS</l>
<l>* SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>* SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBSi, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<c></c>
<c></c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<c></c>
<l>TotalPRC:=80</l>
<l>CurrentOper:='Building pattern sensors'</l>
<c></c>
<c></c>
<l>MSBuildFWM52 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, \
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<c></c>
<l>TotalPRC:=90</l>
<l>CurrentOper:='Building space sensors'</l>
<c></c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM52 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumS2, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>TotalPRC:=100</l>
<l>CurrentOper:='End of Teaching'</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain124">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="CurrentOper"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PnumS2"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsmainSNoCut"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="TotalPRC"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc37B2">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="pnum2" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSSpProc37B2 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*</c>
<c>** 2024.02.26 pnum and pnum2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>** 2022.09.15 MSSpProc34() modified very narrow space</c>
<c>** 2022.12.28 MSSpProc36() modified from MSPtProc36()</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [0,0,0,0,0,0]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>merr:=0</l>
<l>err:=0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>** finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>* no0:=1</l>
<l>vp := Pval[0]</l>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if (i==1 and v==1)</l>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and v!=pnum2 and begtype==1)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum or v==pnum2)</l>
<l>        if (vp==0 and (vn ==pnum or vn ==pnum2 or vn==1))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and (vp!=pnum or vp!=pnum2)) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif (vp==0 and vn==0)</l>
<l>            btype := 2</l>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and v==0 and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>*     if(vn==0)</l>
<l>*         no0:=0</l>
<l>*     endif</l>
<c>    </c>
<l>    vp := v</l>
<c>   </c>
<l>*     if (v==pnum)</l>
<l>*         PIntY[ii]:=yc</l>
<l>*         PIntX[ii]:=xc</l>
<l>*         PInti[ii]:=i</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>endfor</l>
<c></c>
<l>intnum:=ii</l>
<l>jSPdn:=0</l>
<l>jSPup:=ii-1</l>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>if (intnum==0 )</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<l>jSPdn := PB[0]</l>
<l>jSPup := PE[ie-1]</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<c>****Hong ****</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<c>		</c>
<l>				jSPdn := jSPdn</l>
<c></c>
<l>			else</l>
<c></c>
<l>				jSPdn := intnum - 2</l>
<l>   endif</l>
<c>   *******</c>
<l>* if(intnum==0)</l>
<l>*     w:=0.5</l>
<l>*     wmin:=0.5</l>
<l>*     return()</l>
<l>* elseif(intnum==1)</l>
<l>*     wmax:=1.0</l>
<l>*     wmin:=1.0</l>
<l>*     i:=PInti[0]</l>
<l>*     return()</l>
<l>*     intnum:=2</l>
<l>*     PInti[0]:=i-1</l>
<l>*     PInti[1]:=i+1</l>
<l>*     jSPup:=1</l>
<l>* endif</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    i:=PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i],  g)</l>
<l>*     typ:=j%2</l>
<l>*     if(g&lt;thr)</l>
<l>*         if(typ==0)</l>
<l>*             i:=i-1</l>
<l>*         else</l>
<l>*             i:=i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i],  g)    </l>
<l>*     endif</l>
<l>    PIntcor[j]:=i</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[i+1], PPx[i+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax:=max(g0)</l>
<l>*     gmin:=min(g0)</l>
<l>*     gmax:=max2(g0[0], g0[1])</l>
<l>    if(i&lt;pind-1 and i&gt;0)</l>
<l>        SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX:=PIntX[j]</l>
<l>        fIntY:=PIntY[j]</l>
<l>    endif</l>
<l>*     SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    if(err==1)</l>
<l>        merr:=1</l>
<l>    endif</l>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*         SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>* stop()</l>
<l>* gen_region_points(PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi:=PInti[i]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* previous clc </c>
<l>*         pclc:=-2</l>
<l>*         fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>* if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii]:=PPy[0]</l>
<l>*     PIntX[ii]:=PPx[0]</l>
<l>*     PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>*     get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if(Pval[0]==pnum)</l>
<l>*         PCLC[ii]:=clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii]:=-2</l>
<l>*     endif</l>
<l>*     ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>*     if(Pval[0]==1)</l>
<l>*         fi1:=1</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>*             PIntY[ii]:=PPy[0]</l>
<l>*             PIntX[ii]:=PPx[0]</l>
<l>*             PInti[ii]:=0</l>
<l>*             PCLC[ii]:=clc</l>
<l>*             PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>*             ii:=ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1:=0</l>
<l>* endif</l>
<c>***********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>*     if(fi1==1)</l>
<l>*         if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii:=ii-1</l>
<l>*             fi1:=0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1:=0</l>
<c>        * previous and next values</c>
<l>*         vp:=Pval[i-1]</l>
<l>*         vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>*         dev_set_color('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj(PC, Pc, PC)</l>
<l>*         dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>*             get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval(ImageIRBS, yc, xc, irbs)</l>
<c>*            </c>
<l>*                 PIntY[ii]:=yc</l>
<l>*                 PIntX[ii]:=xc</l>
<l>*                 PInti[ii]:=i</l>
<l>*                 Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>*                 if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>*                     ii:=ii+1</l>
<l>*                     PIntY[ii-1]:=yc-0.35*signY</l>
<l>*                     PIntX[ii-1]:=xc-0.35*signX</l>
<l>*                     Psubpix[ii-1]:=0</l>
<l>*                     PIntY[ii]:=yc+0.35*signY</l>
<l>*                     PIntX[ii]:=xc+0.35*signX</l>
<l>*                     PInti[ii]:=i</l>
<l>*                     Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<c>                </c>
<l>*                 PCLC[ii]:=clc</l>
<l>*                 PIRBS[ii]:=irbs</l>
<l>*                 ii:=ii+1</l>
<l>*                 pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>*         endif</l>
<l>*       endif</l>
<l>*     vp:=v</l>
<l>*     gp:=g</l>
<l>* endfor</l>
<c></c>
<c>*checking last MS pixel</c>
<l>* if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if(Pval[pind-1]==pnum)</l>
<l>*         get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc:=PCLC[ii-1]</l>
<l>*         irbs:=PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii]:=PPy[pind-1]</l>
<l>*     PIntX[ii]:=PPx[pind-1]</l>
<l>*     PInti[ii]:=pind-1</l>
<l>*     PCLC[ii]:=clc</l>
<l>*     ii:=ii+1</l>
<l>*     if(Pval[pind-2]==1)</l>
<l>*         PIntY[ii]:=PPy[pind-1]</l>
<l>*         PIntX[ii]:=PPx[pind-1]</l>
<l>*         PInti[ii]:=pind-1</l>
<l>*         PCLC[ii]:=clc</l>
<l>*         PIRBS[ii]:=irbs</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii]:=0</l>
<l>* endif</l>
<c>**************************</c>
<l>* gen_region_points(PInt, PIntY, PIntX) </l>
<l>* intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>* if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>*     wmin := 0.</l>
<l>*     wmax := 0.</l>
<l>*     shift:=0.</l>
<l>*     return()</l>
<l>* endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>* pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>*     g0[1] := g</l>
<l>*     if(PInti[j]&gt;0)</l>
<l>*         get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*         g0[0] := g</l>
<l>*     else</l>
<l>*         g0[0] := g0[1]</l>
<l>*     endif</l>
<l>*     if(PInti[j]&lt;pind-1)</l>
<l>*        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>*        g0[2] := g</l>
<l>*     else</l>
<l>*         g0[2] := g0[1]</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*             SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*         FIntX[j]:=fIntX</l>
<l>*         FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>*     if(g0[2]-g0[0]&gt;0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     elseif(g0[0]-g0[2]&gt;0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     if(pdir &gt; 0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     elseif(pdir &lt; 0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     pdir:=Pdir[j]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>* nmwc:=0</l>
<c>* MW segment</c>
<l>* mw:=-1</l>
<l>* dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*     get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*     if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*         clc:=0</l>
<l>*         for dx:=-3 to 3 by 1</l>
<l>*             for dy:=-3 to 3 by 1</l>
<l>*                 get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                 if(vclc!=0)</l>
<l>*                     clc:=vclc</l>
<l>*                     break</l>
<l>*                 endif</l>
<l>*             endfor</l>
<l>*         endfor</l>
<l>*         PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>*     else</l>
<l>*         PCLC[j]:=vclc</l>
<l>*     endif</l>
<l>*     Pnums[j]:=vpnums</l>
<l>* endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     pclc:=PCLC[j]</l>
<l>*     clc:=PCLC[j+1]</l>
<c>    </c>
<l>*     dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*     if(dclc&gt;clcmax)</l>
<l>*         if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*             continue</l>
<l>*         endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*         d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*         d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*         d:=sqrt( min2(d1,d2) )</l>
<l>*         if(d&lt;dmin)</l>
<l>*             mw:=j</l>
<l>*             nmwc:=nmwc+1</l>
<l>*             dmin:=d</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* if(mw==-1)</l>
<l>*     mw:=0</l>
<l>*     stop()</l>
<l>* endif</l>
<l>* dev_set_color('red')</l>
<l>* gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>* jSPdn:=mw</l>
<l>* jSPup:=mw+1</l>
<c></c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     if(j==mw)</l>
<l>*         continue</l>
<l>*     else</l>
<l>*         clc:=PCLC[j]</l>
<l>*         clc1:=PCLC[mw]</l>
<l>*         clc2:=PCLC[mw+1]</l>
<l>*         dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*         dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>*             if(j&lt;mw)</l>
<l>*                 dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPdn:=j</l>
<l>*                 endif</l>
<l>*             else</l>
<l>*                 dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPup:=j+1</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>* if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>*     stop()</l>
<l>* endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>* wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>wmin:=wmax</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc37B2">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="pnum2"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBP7B2">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBPOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* **** BuildIRBP7B2 </c>
<c>***- 28.02.2024 - for 2 pnum</c>
<c>*** big shift comp. attempt</c>
<c>***- 19.01.2024 - for SSPI</c>
<c>***- 07.12.2023 - same as S but for P</c>
<l>ImIRBPOut := ImIRBP</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 11</l>
<l>dilation_circle (SkeletonsFWM, SkeletonsFWMd, dil)</l>
<l>count_obj (SkeletonsFWMd, no)</l>
<c></c>
<l>* union1(SkeletonsFWMd, SkeletonFWMd)</l>
<l>* dilation_circle (SkeletonFWMd, RegionFWM, 40)</l>
<l>* intersection(RegionFWM, RegionInoD, RegionInoDfwm)</l>
<c></c>
<c></c>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWM, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoDS, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoDS, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1-5, Column1-5, Row2+5, Column2+5)</l>
<l>* difference (RecInoD, RegionInoDfwm, RegionInoDSfwm)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDS)</l>
<l>* expand_region(SkeletonsFWMd, RegionInoDS, RegionExpanded, 'maximal', 'image')</l>
<l>* intersection(RegionExpanded, RegionInoD, RegionsIntersection)</l>
<l>intersection(SkeletonsFWMd, RegionInoD, RegionsIntersection)</l>
<l>count_obj(RegionsIntersection, n)</l>
<l>gen_empty_obj(RegsInoD)</l>
<l>for i:=1 to n by 1</l>
<l>    select_obj(RegionsIntersection, Obj, i)</l>
<l>    connection(Obj, Objs)</l>
<l>    count_obj(Objs, nO)</l>
<l>    if(nO&gt;1)</l>
<l>        area_center(Objs, AreaO, Row3, Column3)</l>
<l>        tuple_sort_index(AreaO,IndicesO)</l>
<l>        tuple_inverse(IndicesO, InvertedO)</l>
<l>        select_obj(Objs, Obj, InvertedO[0]+1)</l>
<l>    endif</l>
<l>    concat_obj(RegsInoD, Obj, RegsInoD)</l>
<l>endfor</l>
<l>expand_region(RegsInoD, RegionInoDS, RegionsFWMI, 'maximal', 'image')</l>
<l>* expand_region(RegsInoD, RegionInoDS, RegionsFWMI, 20, 'image')</l>
<l>* stop()</l>
<c></c>
<l>union1(RegionsFWMI, RegionFWMI)</l>
<c>*</c>
<l>count_obj (SkeletonsFWM, nRFWM)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (stseq, nRFWM+stseq-1, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary (RegionsFWMI, RegionsFWMBii, 'inner')</l>
<l>boundary(RegionFWMI, RegionInoDB, 'inner')</l>
<l>intersection(RegionsFWMBii, RegionInoDB, RegionsFWMB)</l>
<c></c>
<l>* dilation_circle(RegCut, RegCutdi, 2)</l>
<l>* intersection(RegionInoDB, RegCutdi, RegionInoDBcut)</l>
<l>* difference(RegCutdi, RegionInoDBcut,RegCutd)</l>
<l>* difference(RegionsFWMBi, RegCutd, RegionsFWMB)</l>
<l>count_obj (RegionsFWMB, nFWMP)</l>
<c></c>
<l>paint_region (RegionsFWMI, ImIRBPOut, ImIRBPOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMB, ImIRBPOut, ImIRBPOut, SequenceINBi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBP7B2">
<parameters>
<parameter id="ImIRBP"/>
<parameter id="ImIRBPOut"/>
<parameter id="RegCut"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="SkeletonsFWM"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMP"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBP7_COPY_1">
<interface>
<io>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBP" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegCut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBPOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMP" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* **** BuildIRBP7</c>
<c>* ** big shift comp. attempt</c>
<c>* **- 19.01.2024 - for SSPI</c>
<c>* **- 07.12.2023 - same as S but for P</c>
<l>ImIRBPOut := ImIRBP</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 11</l>
<l>dilation_circle (SkeletonsFWM, SkeletonsFWMd, dil)</l>
<l>count_obj (SkeletonsFWMd, no)</l>
<c></c>
<l>* union1 (SkeletonsFWMd, SkeletonFWMd)</l>
<l>* dilation_circle (SkeletonFWMd, RegionFWM, 40)</l>
<l>* intersection(RegionFWM, RegionInoD, RegionInoDfwm)</l>
<c></c>
<c></c>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWM, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoDS, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWM, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoDS, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1-5, Column1-5, Row2+5, Column2+5)</l>
<l>* difference (RecInoD, RegionInoDfwm, RegionInoDSfwm)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDS)</l>
<l>* expand_region (SkeletonsFWMd, RegionInoDS, RegionExpanded, 'maximal', 'image')</l>
<l>* intersection(RegionExpanded, RegionInoD, RegionsIntersection)</l>
<l>intersection (SkeletonsFWMd, RegionInoD, RegionsIntersection)</l>
<l>count_obj (RegionsIntersection, n)</l>
<l>gen_empty_obj (RegsInoD)</l>
<l>for i := 1 to n by 1</l>
<l>    select_obj (RegionsIntersection, Obj, i)</l>
<l>    connection (Obj, Objs)</l>
<l>    count_obj (Objs, nO)</l>
<l>    if (nO&gt;1)</l>
<l>        area_center (Objs, AreaO, Row3, Column3)</l>
<l>        tuple_sort_index (AreaO, IndicesO)</l>
<l>        tuple_inverse (IndicesO, InvertedO)</l>
<l>        select_obj (Objs, Obj, InvertedO[0]+1)</l>
<l>    endif</l>
<l>    concat_obj (RegsInoD, Obj, RegsInoD)</l>
<l>endfor</l>
<l>expand_region (RegsInoD, RegionInoDS, RegionsFWMI, 'maximal', 'image')</l>
<l>* stop ()</l>
<c></c>
<l>union1 (RegionsFWMI, RegionFWMI)</l>
<c></c>
<l>count_obj (SkeletonsFWM, nRFWM)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (stseq, nRFWM+stseq-1, 1, SequenceINBi)</l>
<l>SequenceIRB := SequenceINBi%overf+stseq</l>
<l>boundary (RegionsFWMI, RegionsFWMBi, 'inner')</l>
<l>boundary (RegionFWMI, RegionInoDB, 'inner')</l>
<l>dilation_circle (RegCut, RegCutdi, 2)</l>
<l>intersection (RegionInoDB, RegCutdi, RegionInoDBcut)</l>
<l>difference (RegCutdi, RegionInoDBcut, RegCutd)</l>
<l>difference (RegionsFWMBi, RegCutd, RegionsFWMB)</l>
<l>count_obj (RegionsFWMB, nFWMP)</l>
<c></c>
<l>paint_region (RegionsFWMI, ImIRBPOut, ImIRBPOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMB, ImIRBPOut, ImIRBPOut, SequenceINBi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBP7_COPY_1">
<parameters>
<parameter id="ImIRBP"/>
<parameter id="ImIRBPOut"/>
<parameter id="RegCut"/>
<parameter id="RegionInoD"/>
<parameter id="RegionsPNi"/>
<parameter id="SkeletonsFWM"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMP"/>
</parameters>
</docu>
</procedure>
<procedure name="ThresholdPHIsp">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegProc" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsPH" base_type="iconic" dimension="0"/>
<par name="RegionsIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPhnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionInoPhnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<c></c>
<l>threshold (Im, RegionIi, thr, 255)</l>
<l>get_domain(Im, DomainIm)</l>
<l>difference(DomainIm, RegionIi, RegionISi)</l>
<l>intersection(RegionIi, RegProc, RegionI)</l>
<l>intersection(RegionISi, RegProc, RegionIS)</l>
<c></c>
<l>* difference(RegionISi, RegProc, RegionIS)</l>
<c></c>
<l>fill_up_shape(RegionI, RegionFillUp1, 'area', 1, 8000)</l>
<l>difference(DomainIm, RegionFillUp1, RegionDifference3)</l>
<l>difference (RegionFillUp1, RegionI, RegionPH)</l>
<c></c>
<l>fill_up_shape(RegionDifference3, RegionISnoPhnoIsl, 'area', 1, 8000)</l>
<l>difference(DomainIm, RegionISnoPhnoIsl, RegionInoPhnoIsl)</l>
<l>difference (RegionISnoPhnoIsl, RegionDifference3, RegionIsl)</l>
<c></c>
<l>connection (RegionPH, RegionsPHi)</l>
<l>connection (RegionIsl, RegionsIsli)</l>
<c></c>
<l>select_shape(RegionsPHi, RegionsPHii, 'area', 'and', PHamin, 999999)</l>
<l>select_shape(RegionsPHii, RegionsPH, 'inner_radius', 'and', PHrmin, 999999)</l>
<c></c>
<l>select_shape (RegionsIsli, RegionsIslii, 'area', 'and', Islamin, 999999)</l>
<l>select_shape (RegionsIslii, RegionsIsl, 'inner_radius', 'and', Islrmin, 999999)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="ThresholdPHIsp">
<parameters>
<parameter id="Im"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="PHamin"/>
<parameter id="PHrmin"/>
<parameter id="RegProc"/>
<parameter id="RegionI"/>
<parameter id="RegionISnoPhnoIsl"/>
<parameter id="RegionInoPhnoIsl"/>
<parameter id="RegionsIsl"/>
<parameter id="RegionsPH"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain125">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="RegionsmainSNoCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumS2" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain125 </c>
<c>*** 240224 - Cut without overlap for both P and S</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<c></c>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>TotalPRC:=5</l>
<l>CurrentOper:='Starting'</l>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<l>difference(DomainG, RegNoProc, RegProc)</l>
<l>smallest_rectangle1(RegProc, Row11, Column11, Row21, Column21)</l>
<l>gen_rectangle1(Rectangle, Row11, Column11, Row21, Column21)</l>
<l>area_center(RegProc, Area3, RowDKu, ColumnDKu)</l>
<l>gen_rectangle1(RegionCut, RowDKu, Column11, RowDKu+1, Column21+1)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>* connection (RegionGid, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<l>TotalPRC:=7</l>
<l>CurrentOper:='Smoothing regions'</l>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<l>* read_image (Im2173, 'C:/TmpIm/Im2_173.tif')</l>
<l>* threshold(Im2173, Region, 90, 255)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<c>* 16.04.2024 </c>
<l>* difference (DomainG, RegionGsm, RegionGSi)</l>
<l>difference (DomainG, RegionG, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c>* 16.04.2024</c>
<l>* intersection (RegionGSi, RC, RegionGSii)</l>
<l>* difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<c></c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>connection(SkeletonGS, SkeletonsGS)</l>
<c></c>
<l>* select_shape(ConnectedRegionsS, SkeletonsGS, 'area', 'and', minlen, 9999999)  </l>
<l>junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>*** cutting ends of MSS</c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(SkeletonsGS,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(SkeletonsGS, CMSSEu, SkeletonsGS)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<l>* stop()</l>
<l>* ExtendedSkeletonWFMP5(RegionG, SkeletonsGS, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<c></c>
<c></c>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>TotalPRC:=10</l>
<l>CurrentOper:='Building width and direction images'</l>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** 24.04.02 RegionGSi -&gt; RegionGSii</c>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>TotalPRC:=20</l>
<l>CurrentOper:='Building Pattern Skeletons'</l>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_median(WGi, medWGi)</l>
<l>tuple_deviation(WGi, devWGi)</l>
<c></c>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>* tuple_min (WGi, minWGi)</l>
<l>* tuple_max (WGi, maxWGi)</l>
<l>* tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>* PrcWGi := HistoGi*100./nWGi</l>
<l>* tuple_length(PrcWGi, nP)</l>
<c></c>
<l>* write_tuple(PrcWGi, 'PrcWGi')</l>
<l>* read_tuple('PrcWGitst', PrcWGi)</l>
<l>if(autowidth==1)</l>
<l>    FindWidth (WGi, wside, WidthP)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* stop()</l>
<l>* tuple_max(MaxInd, pmax)</l>
<l>* tuple_min(MaxInd, pmin)</l>
<l>* pmid:=(pmax+pmin)/2</l>
<l>* span:=pmax-pmin</l>
<l>* stop()</l>
<c></c>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>wsideS:=3</l>
<l>if(autowidth==1)</l>
<l>    FindWidth (WGSi, wsideS, WidthS)</l>
<l>endif</l>
<c></c>
<l>* tuple_length (WGSi, nWGSi)</l>
<l>* tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>* for j:=0 to nWGSi-1 by 1</l>
<l>*     if(WGSi[j]&lt; minWGS)</l>
<l>*         WGSi[j] := minWGS</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>* tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>* PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c></c>
<c>****** Auto setting of FWM/S widths using width histogram 16.04.2024 </c>
<l>* create_funct_1d_array(PrcWGSi, FPrcWGSi)</l>
<l>* local_min_max_funct_1d(FPrcWGSi, 'strict_min_max', 'true', MinPrcWGS, MaxPrcWGS)</l>
<l>* tuple_length(MinPrcWGS, nMinPrcWGS)</l>
<l>* tuple_length(MaxPrcWGS, nMaxPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MinPrcWGS, 'constant', YMinPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MaxPrcWGS, 'constant', YMaxPrcWGS)</l>
<c></c>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>* get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>* get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>* tuple_length(WdG, nWdG)</l>
<l>* tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>* PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0 and useODB&lt;3)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>* prcmin:=5</l>
<l>* numP:=3</l>
<l>* numS:=1</l>
<l>* wmax:=45</l>
<l>* if(useODB==1)</l>
<l>*       WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>* endif</l>
<c></c>
<l>* numS:=1</l>
<l>* WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    if(autowidth==0)</l>
<l>        WminP := wFWM</l>
<l>    else</l>
<l>        WminP := WidthP</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>elseif(useODB==1)</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>else </l>
<l>    RegionmainNoCut:=SkeletonGS</l>
<l>    connection(RegionmainNoCut, RegionsmainNoCut)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>TotalPRC:=40</l>
<l>CurrentOper:='Building Space Skeletons'</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<l>if(autowidth==1)</l>
<l>   WminS := WidthS</l>
<l>else</l>
<l>   WminS := wFWMS</l>
<l>endif</l>
<l>* WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>tuple_length(WGSi, nWGSi)</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c></c>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>connection(RmainS, ConnectedRegionsS)</l>
<l>select_shape(ConnectedRegionsS, RegionsmainSNoCut, 'area', 'and', minlen, 9999999)  </l>
<l>junctions_skeleton(RegionsmainSNoCut, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSNoCut,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(RegionsmainSNoCut, CMSSEu, RegionsmainSNoCut)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>* RegionsmainS:=RegionsmainSn</l>
<l>union1(RegionsmainSNoCut, RegionmainSNoCut)</l>
<l>difference(RegionmainSNoCut, RegionCut, RegionmainS)</l>
<l>connection(RegionmainS, RegionsmainS)</l>
<l>union1(RegionsmainS, RegionmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>SkeletonsFWMScut:=RegionsmainS</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>SkeletonsFWMS:=RegionsmainSNoCut</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<l>TotalPRC:=60</l>
<l>CurrentOper:='Preparing IRB'</l>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>TotalPRC:=70</l>
<l>CurrentOper:='Building non-FWM sensors'</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>* union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>* connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>* count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMScut, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (2, nINBS+1, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseqS := nEMPTY+1</l>
<l>* overfS := 255-stseqS</l>
<l>* SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>* SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBSi, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<c></c>
<c></c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<c></c>
<l>TotalPRC:=80</l>
<l>CurrentOper:='Building pattern sensors'</l>
<c></c>
<c></c>
<l>MSBuildFWM52 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, \
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<c></c>
<l>TotalPRC:=90</l>
<l>CurrentOper:='Building space sensors'</l>
<c></c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM52 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumS2, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>TotalPRC:=100</l>
<c></c>
<l>if(autowidth==1)</l>
<l>    wFWM:=Width</l>
<l>    wFWMS:=WidthS</l>
<l>endif</l>
<c></c>
<l>CurrentOper:='End of Teaching'</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain125">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="CurrentOper"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PnumS2"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsmainSNoCut"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="TotalPRC"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="FindWidth">
<interface>
<ic>
<par name="WGi" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Width" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length(WGi, nWGi)</l>
<l>tuple_min (WGi, minWGi)</l>
<l>tuple_max (WGi, maxWGi)</l>
<l>tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>PrcWGi := HistoGi*100./nWGi</l>
<l>tuple_length(PrcWGi, nP)</l>
<l>create_funct_1d_array(PrcWGi, FPrcWGi)</l>
<l>smooth_funct_1d_mean(FPrcWGi, 3, 1, FPrcWGism)</l>
<l>local_min_max_funct_1d(FPrcWGism, 'plateaus_center', 'true', MinPrcWG, MaxPrcWG)</l>
<l>get_y_value_funct_1d(FPrcWGi, MinPrcWG, 'constant', YMinPrcWG)</l>
<l>get_y_value_funct_1d(FPrcWGi, MaxPrcWG, 'constant', YMaxPrcWG)</l>
<l>tuple_length(YMaxPrcWG, nMax)</l>
<l>tuple_length(YMinPrcWG, nMin)</l>
<c></c>
<l>tuple_gen_sequence(0, nP-1,1, Seq)</l>
<l>tuple_sort_index(PrcWGi, Indices)</l>
<l>tuple_sort(PrcWGi,Sorted)</l>
<l>tuple_inverse(Sorted, Inverted1)</l>
<l>tuple_inverse(Indices, Inverted)</l>
<l>for j:=0 to nP-1 by 1</l>
<l>    y:=PrcWGi[Inverted[j]]</l>
<l>    if(y&lt;6)</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>Width:=[]</l>
<l>tuple_select_range(Inverted, 0, j-1, MaxIndi)</l>
<l>tuple_length(MaxIndi, nMaxInd)</l>
<l>tuple_sort(MaxIndi, MaxInd)</l>
<l>if(nMaxInd==1)</l>
<l>    Width:=MaxInd</l>
<l>else</l>
<l>    for j:=0 to nMaxInd-1 by 1</l>
<l>*     jj:=j</l>
<l>        curMaxInd:=MaxInd[j]</l>
<l>        if(j&gt;0)</l>
<l>            jp:=j-1</l>
<l>        else</l>
<l>            jp:=j</l>
<l>        endif</l>
<l>        prevMaxInd:=MaxInd[jp]</l>
<l>        difind:=abs(curMaxInd-prevMaxInd)</l>
<l>        if(difind&lt;wside)</l>
<l>            curMaxInd:= (curMaxInd+prevMaxInd)/2</l>
<l>            for jj:=j+1 to nMaxInd-1 by 1</l>
<l>                nextMaxInd:=MaxInd[jj]</l>
<l>                difind:=abs(curMaxInd-nextMaxInd)</l>
<l>                if(difind&lt;wside)</l>
<l>                    curMaxInd:= (curMaxInd+nextMaxInd)/2</l>
<l>                    j:=jj</l>
<l>                else</l>
<l>*                     Width[j-1]:=curMaxInd</l>
<l>                    tuple_concat(Width, curMaxInd, Width)</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>*         Width[j-1]:=curMaxInd</l>
<l>    endfor</l>
<l>tuple_concat(Width, curMaxInd, Width)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="FindWidth">
<parameters>
<parameter id="WGi"/>
<parameter id="Width"/>
<parameter id="wside"/>
</parameters>
</docu>
</procedure>
<procedure name="DetectOpenN51">
<interface>
<io>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="RegionInoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="RegionISnoPHnoIsl" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionCheck" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionsOp" base_type="iconic" dimension="0"/>
<par name="RegionsOpCon" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>**** DetectOpenN51 : new detect open proc. 11.08.2022</c>
<c>*** modified 12.09.2023, overkills removed</c>
<c>* 03.05.2024 fixed empty case</c>
<c> </c>
<l>set_system('neighborhood', 8)</l>
<l>intersection (SkeletonG, RegionISnoPHnoIsl, OpCandAlli)</l>
<l>intersection(OpCandAlli, RegionCheck, OpCandAll)</l>
<l>connection(OpCandAll, OpCands)</l>
<l>count_obj(OpCands, nOpCands)</l>
<l>gen_empty_obj (RegionsOp)</l>
<l>gen_empty_obj (RegionsOpCon)</l>
<l>area_center(OpCands, AreaOpCands, Row1, Column1)</l>
<l>if (AreaOpCands&gt;0)</l>
<l>    for j:=1 to nOpCands by 1</l>
<l>*         if(j==1233)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*         j:=999</l>
<l>*         j:=18</l>
<l>        select_obj(OpCands, OpCand, j)</l>
<l>        area_center(OpCand, AreaC, RowC, ColumnC)</l>
<l>        if(AreaC &gt; 250)</l>
<l>*             stop()</l>
<l>        endif</l>
<l>        get_region_points(OpCand, Rows, Columns)</l>
<l>        get_grayval (WidthImageP, Rows, Columns, PpW)</l>
<l>        tuple_median(PpW, ppw)</l>
<l>        get_grayval (DirImageP, Rows, Columns, PpD)</l>
<l>        tuple_median(PpD, ppd)</l>
<l>        pa:=ppd*3.14159/256</l>
<l>        if(ppw&gt;100)</l>
<l>            continue</l>
<l>        endif</l>
<l>        if(AreaC&gt;1)</l>
<l>            smallest_rectangle2(OpCand, RowCm, ColumnCm, Phi, Length1, Length2)</l>
<l>            gen_rectangle2(R2, RowCm, ColumnCm, Phi, Length1+ppw, Length2+ppw+ppw/2)</l>
<l>            gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>        else</l>
<l>            gen_rectangle2(R2, RowC, ColumnC ,pa, ppw*2.5, ppw*2.5)</l>
<l>            gen_rectangle2(R3, RowC, ColumnC ,pa, ppw*2.5+5, ppw*2.5+5)</l>
<l>        endif</l>
<l>        intersection(RegionInoPHnoIsl, R2, RegionIR2)</l>
<l>        connection(RegionIR2, RegionsIR2)</l>
<l>        intersection (SkeletonG, R2, RegionGR2)</l>
<c>        </c>
<l>        connection(RegionGR2, RegionsGR2)</l>
<l>        intersection (RegionG, R2, RegionGR)</l>
<l>        connection(RegionGR, RegionsGR)</l>
<c>        </c>
<l>        count_obj(RegionsGR2, nGR2)</l>
<l>        for jj:=1 to nGR2 by 1</l>
<l>            select_obj(RegionsGR2, Rsel, jj)</l>
<l>            test_subset_region(OpCand, Rsel, IsSubset)</l>
<l>            if(IsSubset)</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(jj==nGR2+1)</l>
<l>            continue</l>
<l>        endif</l>
<l>        select_obj(RegionsGR2, Rskeli, jj)</l>
<l>        dilation_circle(Rskeli,Rskel, 3) </l>
<l>        intersection( RegionsIR2,Rskel, RegionIntersection)</l>
<l>        area_center(RegionIntersection, Area, Row, Column)</l>
<l>        tuple_select_mask(Area, Area, Arnonz)</l>
<l>        tuple_length(Arnonz, nArnonz)</l>
<c>        </c>
<l>        if(nArnonz &gt; 1)</l>
<l>*             Index:=[]</l>
<l>            IndexGAll:=[]</l>
<l>            SmallIs:=RegionIntersection</l>
<l>            union1(SmallIs, SmallI)</l>
<l>            connection(SmallI, SmallIs)</l>
<c>            </c>
<l>*             BigIs:=RegionsIR2</l>
<l>*     gen_rectangle2(R3, RowCm, ColumnCm, Phi, Length1+ppw+5, Length2+ppw+ppw+5)</l>
<l>            intersection(RegionInoPHnoIsl, R3, BigI)</l>
<l>            connection(BigI, BigIs)</l>
<l>            difference(BigIs, SmallI, BigInoSs)</l>
<c>            </c>
<l>            intersection (RegionG, R3, RegionGR3)</l>
<l>            connection(RegionGR3, RegionsGR3)        </l>
<l>            for jj:=1 to nArnonz by 1</l>
<l>                select_obj(SmallIs, Obj, jj)</l>
<l>                get_region_points(Obj, RowsO, ColumnsO)</l>
<l>                tuple_length(RowsO, nOp)</l>
<l>                get_region_index(BigIs, int(RowsO[nOp/2]), int(ColumnsO[nOp/2]), Index)</l>
<l>                select_obj(BigInoSs, CurBigInoS, Index)</l>
<l>                intersection(CurBigInoS, RegionG, CurBigInoSG)</l>
<l>                get_region_points(CurBigInoSG, RowsB, ColumnsB)</l>
<l>                tuple_length(RowsB, nB)</l>
<l>                if(nB==0)</l>
<l>                    continue</l>
<l>                endif</l>
<l>                get_region_index(RegionsGR3, int(RowsB[nB/2]), int(ColumnsB[nB/2]), IndexG)</l>
<l>                IndexGAll[jj-1]:=IndexG</l>
<l>            endfor</l>
<l>            tuple_length(IndexGAll, nGAll)</l>
<l>*             if(IndexGAll[0]==IndexGAll[1])</l>
<l>*                 intersection(RegionG, R2, RegionG2)</l>
<l>*             dev_display(R2)</l>
<l>                select_obj(RegionsGR3, RGR3, IndexG)</l>
<l>              intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>              intersection(Rop, RGR3, Ropf)</l>
<l>              concat_obj (RegionsOp, Ropf, RegionsOp)</l>
<l>*              dilation_circle(Rskel, RskelSd, 1)</l>
<l>*              concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>             concat_obj (RegionsOpCon, Rskel, RegionsOpCon)</l>
<l>*             endif</l>
<c>            </c>
<l>*            stop()</l>
<l>*         elseif(AreaC &gt; 10)</l>
<l>*             dilation_circle(OpCand, OpCandd, 3) </l>
<l>*             intersection(OpCandd, RegionIR2, RegionIntCandI)</l>
<l>*             connection(RegionIntCandI, RegionsIntCandI)</l>
<l>*             count_obj(RegionsIntCandI, n)</l>
<l>*             if(n==2)</l>
<l>*                 intersection(R2, RegionInoPHnoIsl, Rop)</l>
<l>*                 concat_obj (RegionsOp, Rop, RegionsOp)</l>
<l>*                 dilation_circle(Rskel, RskelSd, 1)</l>
<l>*                 concat_obj (RegionsOpCon, RskelSd, RegionsOpCon)</l>
<l>*             endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="DetectOpenN51">
<parameters>
<parameter id="DirImageP"/>
<parameter id="RegionCheck"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionISnoPHnoIsl"/>
<parameter id="RegionInoPHnoIsl"/>
<parameter id="RegionsOp"/>
<parameter id="RegionsOpCon"/>
<parameter id="SkeletonG"/>
<parameter id="WidthImageP"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain126">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="RegionsmainSNoCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumS2" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain126</c>
<c>*** 240504 - problems with SgeletonsGS at ends</c>
<c>*** 240224 - Cut without overlap for both P and S</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<c></c>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>TotalPRC:=5</l>
<l>CurrentOper:='Starting'</l>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<l>difference(DomainG, RegNoProc, RegProc)</l>
<l>smallest_rectangle1(RegProc, Row11, Column11, Row21, Column21)</l>
<l>gen_rectangle1(Rectangle, Row11, Column11, Row21, Column21)</l>
<l>area_center(RegProc, Area3, RowDKu, ColumnDKu)</l>
<l>gen_rectangle1(RegionCut, RowDKu, Column11, RowDKu+1, Column21+1)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>* connection (RegionGid, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<l>TotalPRC:=7</l>
<l>CurrentOper:='Smoothing regions'</l>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<l>* read_image (Im2173, 'C:/TmpIm/Im2_173.tif')</l>
<l>* threshold(Im2173, Region, 90, 255)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<c>* 16.04.2024 </c>
<l>* difference (DomainG, RegionGsm, RegionGSi)</l>
<l>difference (DomainG, RegionG, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c>* 16.04.2024</c>
<l>* intersection (RegionGSi, RC, RegionGSii)</l>
<l>* difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<c></c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>connection(SkeletonGS, SkeletonsGS)</l>
<c></c>
<l>* select_shape(ConnectedRegionsS, SkeletonsGS, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>*** cutting ends of MSS</c>
<l>if(cutendMSS &lt;0)</l>
<l>    junctions_skeleton(SkeletonGS, EndPointsGS, JuncPointsGS)</l>
<l>    dilation_circle(EndPointsGS, RegionDilationGS, -cutendMSS)</l>
<l>    intersection(SkeletonGSi, RegionDilationGS, RegionIntersection1)</l>
<c>*     union2</c>
<l>elseif(cutendMSS &gt;0)    </l>
<l>    for j:=1 to cutendMSS by 1</l>
<l>        junctions_skeleton(SkeletonsGS,EndPointsMSS, JuncPointsMSS)</l>
<l>        area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>        tuple_length(Area1, nEndPointsMSS)</l>
<l>        if(Area1&gt;0)</l>
<l>            union1(EndPointsMSS, EndPointsMSSu)</l>
<l>            connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>            area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>            tuple_length(RowMSS, nMSS)</l>
<l>            tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>            gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>            union1(CMSSE, CMSSEu)</l>
<l>            difference(SkeletonsGS, CMSSEu, SkeletonsGS)</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>endif</l>
<c></c>
<c></c>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* stop()</l>
<l>* ExtendedSkeletonWFMP5(RegionG, SkeletonsGS, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<c></c>
<c></c>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>TotalPRC:=10</l>
<l>CurrentOper:='Building width and direction images'</l>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** 24.04.02 RegionGSi -&gt; RegionGSii</c>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<l>junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>get_region_points(SkelEPu, Rows, Columns)</l>
<l>get_grayval(WidthImageS, Rows, Columns, wEPs)</l>
<l>tuple_max(wEPs, wEP)</l>
<c></c>
<l>dilation_circle(SkelEPu, SkelEP, wEP/2+EPexp)</l>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>TotalPRC:=20</l>
<l>CurrentOper:='Building Pattern Skeletons'</l>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_median(WGi, medWGi)</l>
<l>tuple_deviation(WGi, devWGi)</l>
<c></c>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>* tuple_min (WGi, minWGi)</l>
<l>* tuple_max (WGi, maxWGi)</l>
<l>* tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>* PrcWGi := HistoGi*100./nWGi</l>
<l>* tuple_length(PrcWGi, nP)</l>
<c></c>
<l>* write_tuple(PrcWGi, 'PrcWGi')</l>
<l>* read_tuple('PrcWGitst', PrcWGi)</l>
<l>if(autowidth==1)</l>
<l>    wside:=4</l>
<l>    FindWidth (WGi, wside, WidthP)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* stop()</l>
<l>* tuple_max(MaxInd, pmax)</l>
<l>* tuple_min(MaxInd, pmin)</l>
<l>* pmid:=(pmax+pmin)/2</l>
<l>* span:=pmax-pmin</l>
<l>* stop()</l>
<c></c>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>wsideS:=3</l>
<l>if(autowidth==1)</l>
<l>    FindWidth (WGSi, wsideS, WidthS)</l>
<l>endif</l>
<c></c>
<l>* tuple_length (WGSi, nWGSi)</l>
<l>* tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>* for j:=0 to nWGSi-1 by 1</l>
<l>*     if(WGSi[j]&lt; minWGS)</l>
<l>*         WGSi[j] := minWGS</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>* tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>* PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c></c>
<c>****** Auto setting of FWM/S widths using width histogram 16.04.2024 </c>
<l>* create_funct_1d_array(PrcWGSi, FPrcWGSi)</l>
<l>* local_min_max_funct_1d(FPrcWGSi, 'strict_min_max', 'true', MinPrcWGS, MaxPrcWGS)</l>
<l>* tuple_length(MinPrcWGS, nMinPrcWGS)</l>
<l>* tuple_length(MaxPrcWGS, nMaxPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MinPrcWGS, 'constant', YMinPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MaxPrcWGS, 'constant', YMaxPrcWGS)</l>
<c></c>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>* get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>* get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>* tuple_length(WdG, nWdG)</l>
<l>* tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>* PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0 and useODB&lt;3)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>* prcmin:=5</l>
<l>* numP:=3</l>
<l>* numS:=1</l>
<l>* wmax:=45</l>
<l>* if(useODB==1)</l>
<l>*       WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>* endif</l>
<c></c>
<l>* numS:=1</l>
<l>* WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    if(autowidth==0)</l>
<l>        WminP := wFWM</l>
<l>    else</l>
<l>        WminP := WidthP</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>elseif(useODB==1)</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>else </l>
<l>    RegionmainNoCut:=SkeletonGS</l>
<l>    connection(RegionmainNoCut, RegionsmainNoCut)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>TotalPRC:=40</l>
<l>CurrentOper:='Building Space Skeletons'</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<l>if(autowidth==1)</l>
<l>   WminS := WidthS</l>
<l>else</l>
<l>   WminS := wFWMS</l>
<l>endif</l>
<l>* WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>tuple_length(WGSi, nWGSi)</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c></c>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>connection(RmainS, ConnectedRegionsS)</l>
<l>select_shape(ConnectedRegionsS, RegionsmainSNoCut, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(RegionsmainSNoCut, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSNoCut,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(RegionsmainSNoCut, CMSSEu, RegionsmainSNoCut)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>* RegionsmainS:=RegionsmainSn</l>
<l>union1(RegionsmainSNoCut, RegionmainSNoCut)</l>
<l>difference(RegionmainSNoCut, RegionCut, RegionmainS)</l>
<l>connection(RegionmainS, RegionsmainS)</l>
<l>union1(RegionsmainS, RegionmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>SkeletonsFWMScut:=RegionsmainS</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>SkeletonsFWMS:=RegionsmainSNoCut</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<l>TotalPRC:=60</l>
<l>CurrentOper:='Preparing IRB'</l>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>TotalPRC:=70</l>
<l>CurrentOper:='Building non-FWM sensors'</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>* union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>* connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>* count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMScut, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (2, nINBS+1, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseqS := nEMPTY+1</l>
<l>* overfS := 255-stseqS</l>
<l>* SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>* SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBSi, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<c></c>
<c></c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<c></c>
<l>TotalPRC:=80</l>
<l>CurrentOper:='Building pattern sensors'</l>
<c></c>
<c></c>
<l>MSBuildFWM52 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, \
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<c></c>
<l>TotalPRC:=90</l>
<l>CurrentOper:='Building space sensors'</l>
<c></c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM52 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumS2, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>TotalPRC:=100</l>
<c></c>
<l>if(autowidth==1)</l>
<l>    wFWM:=Width</l>
<l>    wFWMS:=WidthS</l>
<l>endif</l>
<c></c>
<l>CurrentOper:='End of Teaching'</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain126">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="CurrentOper"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="EPexp"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PnumS2"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsmainSNoCut"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="TotalPRC"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS41B2">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBS41B2 - 18.04.2023 - removed difference for regions tuple</c>
<l>ImIRBSOut := ImIRBS</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>dil := 15</l>
<l>dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<l>count_obj (SkeletonsFWMSd, no)</l>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWMS, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoD, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMSd, RegionInoDC, SkeletonsFWMSm)</l>
<l>union1(SkeletonsFWMSd, SkeletonsFWMSdu)</l>
<l>intersection (SkeletonsFWMSdu, RegionInoDC, SkeletonsFWMSmu)</l>
<l>connection(SkeletonsFWMSmu, SkeletonsFWMSm2)</l>
<c>* 3</c>
<l>* difference (SkeletonsFWMSm, SkeletonsFWMSm2, RegionDifference1)</l>
<c></c>
<c></c>
<l>* area_center (SkeletonsFWMSm, Area, Row, Column)</l>
<l>* tuple_min (Area, amin)</l>
<l>* count_obj (SkeletonsFWMSm, nm)</l>
<c></c>
<l>* symm_difference (SkeletonsFWMSm, SkeletonsFWMSc, RegionDifference)</l>
<c></c>
<l>* intersection (SkeletonsFWMS, RegionInoD, RegionIntersection)</l>
<l>* union2 (SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region (RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>difference(SkelEP, SkeletonsFWMSd, SkelEP1)</l>
<l>union2(RegionInoD, SkelEP1, RegForbid)</l>
<l>expand_region (SkeletonsFWMSm, RegForbid, RegionsFWMS2i, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMSm, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMS, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>difference(RegionsFWMS2i, SkelEP1, RegionsFWMS2)</l>
<l>count_obj (SkeletonsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (2, nRFWMS+1, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS2, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS2, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS41B2">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain127">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsLG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="RegionsmainSNoCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="elongLG" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumS2" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain127</c>
<c>** added elongated SkeletonsLG</c>
<c>*** 240504 - problems with SgeletonsGS at ends</c>
<c>*** 240224 - Cut without overlap for both P and S</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<c></c>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>TotalPRC:=5</l>
<l>CurrentOper:='Starting'</l>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<l>difference(DomainG, RegNoProc, RegProc)</l>
<l>smallest_rectangle1(RegProc, Row11, Column11, Row21, Column21)</l>
<l>gen_rectangle1(Rectangle, Row11, Column11, Row21, Column21)</l>
<l>area_center(RegProc, Area3, RowDKu, ColumnDKu)</l>
<l>gen_rectangle1(RegionCut, RowDKu, Column11, RowDKu+1, Column21+1)</l>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGii, 127, 255)</l>
<l>closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>* connection (RegionGid, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<l>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<l>TotalPRC:=7</l>
<l>CurrentOper:='Smoothing regions'</l>
<l>* smooth := 21</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<l>* read_image (Im2173, 'C:/TmpIm/Im2_173.tif')</l>
<l>* threshold(Im2173, Region, 90, 255)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<c>* 16.04.2024 </c>
<l>* difference (DomainG, RegionGsm, RegionGSi)</l>
<l>difference (DomainG, RegionG, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>closing_circle(RegionGii, RegionGiic, 1)</l>
<l>skeleton (RegionGiic, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c>* 16.04.2024</c>
<l>* intersection (RegionGSi, RC, RegionGSii)</l>
<l>* difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<c></c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>connection(SkeletonGS, SkeletonsGS)</l>
<c></c>
<l>* select_shape(ConnectedRegionsS, SkeletonsGS, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>*** cutting ends of MSS</c>
<l> if(elongLG &gt;0)</l>
<l>    junctions_skeleton(SkeletonGS, EndPointsGS, JuncPointsGS)</l>
<l>    dilation_circle(EndPointsGS, RegionDilationGS, elongLG)</l>
<l>    intersection(SkeletonGSi, RegionDilationGS, RegionIntersection1)</l>
<l>    union2(SkeletonGS, RegionIntersection1, SkeletonLG)</l>
<l>    connection(SkeletonLG, SkeletonsLG)</l>
<l> endif</l>
<c>*     union2</c>
<l>* elseif(cutendMSS &gt;0)    </l>
<l>    for j:=1 to cutendMSS by 1</l>
<l>        junctions_skeleton(SkeletonsGS,EndPointsMSS, JuncPointsMSS)</l>
<l>        area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>        tuple_length(Area1, nEndPointsMSS)</l>
<l>        if(Area1&gt;0)</l>
<l>            union1(EndPointsMSS, EndPointsMSSu)</l>
<l>            connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>            area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>            tuple_length(RowMSS, nMSS)</l>
<l>            tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>            gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>            union1(CMSSE, CMSSEu)</l>
<l>            difference(SkeletonsGS, CMSSEu, SkeletonsGS)</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>* endif</l>
<c></c>
<c></c>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* stop()</l>
<l>* ExtendedSkeletonWFMP5(RegionG, SkeletonsGS, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<c></c>
<c></c>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>TotalPRC:=10</l>
<l>CurrentOper:='Building width and direction images'</l>
<l>PatternWidthDirImages (RegionGiic, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGii, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** 24.04.02 RegionGSi -&gt; RegionGSii</c>
<l>SpaceWidthDirImages (RegionGSii, SkeletonLG, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<l>junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>get_region_points(SkelEPu, Rows, Columns)</l>
<l>get_grayval(WidthImageS, Rows, Columns, wEPs)</l>
<l>tuple_max(wEPs, wEP)</l>
<c></c>
<l>dilation_circle(SkelEPu, SkelEP, wEP/2+EPexp)</l>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>TotalPRC:=20</l>
<l>CurrentOper:='Building Pattern Skeletons'</l>
<l>minlen := 50</l>
<c></c>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_median(WGi, medWGi)</l>
<l>tuple_deviation(WGi, devWGi)</l>
<c></c>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>* tuple_min (WGi, minWGi)</l>
<l>* tuple_max (WGi, maxWGi)</l>
<l>* tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>* PrcWGi := HistoGi*100./nWGi</l>
<l>* tuple_length(PrcWGi, nP)</l>
<c></c>
<l>* write_tuple(PrcWGi, 'PrcWGi')</l>
<l>* read_tuple('PrcWGitst', PrcWGi)</l>
<l>if(autowidth==1)</l>
<l>    wside:=6</l>
<l>    FindWidth (WGi, wside, WidthP)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* stop()</l>
<l>* tuple_max(MaxInd, pmax)</l>
<l>* tuple_min(MaxInd, pmin)</l>
<l>* pmid:=(pmax+pmin)/2</l>
<l>* span:=pmax-pmin</l>
<l>* stop()</l>
<c></c>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>wsideS:=3</l>
<l>if(autowidth==1)</l>
<l>    FindWidth (WGSi, wsideS, WidthS)</l>
<l>endif</l>
<c></c>
<l>* tuple_length (WGSi, nWGSi)</l>
<l>* tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>* for j:=0 to nWGSi-1 by 1</l>
<l>*     if(WGSi[j]&lt; minWGS)</l>
<l>*         WGSi[j] := minWGS</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>* tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>* PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c></c>
<c>****** Auto setting of FWM/S widths using width histogram 16.04.2024 </c>
<l>* create_funct_1d_array(PrcWGSi, FPrcWGSi)</l>
<l>* local_min_max_funct_1d(FPrcWGSi, 'strict_min_max', 'true', MinPrcWGS, MaxPrcWGS)</l>
<l>* tuple_length(MinPrcWGS, nMinPrcWGS)</l>
<l>* tuple_length(MaxPrcWGS, nMaxPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MinPrcWGS, 'constant', YMinPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MaxPrcWGS, 'constant', YMaxPrcWGS)</l>
<c></c>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>* get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>* get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>* tuple_length(WdG, nWdG)</l>
<l>* tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>* PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0 and useODB&lt;3)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>* prcmin:=5</l>
<l>* numP:=3</l>
<l>* numS:=1</l>
<l>* wmax:=45</l>
<l>* if(useODB==1)</l>
<l>*       WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>* endif</l>
<c></c>
<l>* numS:=1</l>
<l>* WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    if(autowidth==0)</l>
<l>        WminP := wFWM</l>
<l>    else</l>
<l>        WminP := WidthP</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>elseif(useODB==1)</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>else </l>
<l>    RegionmainNoCut:=SkeletonGS</l>
<l>    connection(RegionmainNoCut, RegionsmainNoCut)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>TotalPRC:=40</l>
<l>CurrentOper:='Building Space Skeletons'</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<l>if(autowidth==1)</l>
<l>   WminS := WidthS</l>
<l>else</l>
<l>   WminS := wFWMS</l>
<l>endif</l>
<l>* WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>tuple_length(WGSi, nWGSi)</l>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c></c>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>connection(RmainS, ConnectedRegionsS)</l>
<l>select_shape(ConnectedRegionsS, RegionsmainSNoCut, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(RegionsmainSNoCut, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c></c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSNoCut,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(RegionsmainSNoCut, CMSSEu, RegionsmainSNoCut)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>* RegionsmainS:=RegionsmainSn</l>
<l>union1(RegionsmainSNoCut, RegionmainSNoCut)</l>
<l>difference(RegionmainSNoCut, RegionCut, RegionmainS)</l>
<l>connection(RegionmainS, RegionsmainS)</l>
<l>union1(RegionsmainS, RegionmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>SkeletonsFWMScut:=RegionsmainS</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>SkeletonsFWMS:=RegionsmainSNoCut</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<l>TotalPRC:=60</l>
<l>CurrentOper:='Preparing IRB'</l>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>TotalPRC:=70</l>
<l>CurrentOper:='Building non-FWM sensors'</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>* union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>* connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>* count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMScut, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (2, nINBS+1, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseqS := nEMPTY+1</l>
<l>* overfS := 255-stseqS</l>
<l>* SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>* SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBSi, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<c></c>
<c></c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<c></c>
<l>TotalPRC:=80</l>
<l>CurrentOper:='Building pattern sensors'</l>
<c></c>
<c></c>
<l>MSBuildFWM52 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, \
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<c></c>
<l>TotalPRC:=90</l>
<l>CurrentOper:='Building space sensors'</l>
<c></c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM52 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumS2, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>TotalPRC:=100</l>
<c></c>
<l>if(autowidth==1)</l>
<l>    wFWM:=Width</l>
<l>    wFWMS:=WidthS</l>
<l>endif</l>
<c></c>
<l>CurrentOper:='End of Teaching'</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain127">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="CurrentOper"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="EPexp"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PnumS2"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsmainSNoCut"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsLG"/>
<parameter id="TotalPRC"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elongLG"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="UpdateFileName">
<interface>
<ic>
<par name="name" base_type="ctrl" dimension="0"/>
<par name="spl" base_type="ctrl" dimension="0"/>
<par name="nch" base_type="ctrl" dimension="0"/>
<par name="rch" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="fname" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> * UpdateFileName </c>
<c> * 24.06.2024</c>
<l>tuple_split(name, spl, Folders)</l>
<c></c>
<l>  tuple_length(Folders, nf)</l>
<l> fname:=Folders[nf-1]</l>
<l> path:=Folders[0]</l>
<l> for j:=1 to nf-2 by 1</l>
<l>     path:=path+spl</l>
<l>     path:=path+Folders[j]</l>
<l> endfor</l>
<l> path:=path+spl</l>
<l>*  fname1:=Folders[0]+'/'+Folders[1]+'/'</l>
<c> </c>
<l> tuple_split(fname, '_', Substrings)</l>
<l> tuple_length(Substrings, n)</l>
<l> trow:=Substrings[n-2]</l>
<l> tuple_number(trow, urow)</l>
<l> urow:=urow+rch</l>
<l> urstr := urow $ 'd'</l>
<l> tnum:=Substrings[n-1]</l>
<l> tuple_split(tnum, '.', Ts)</l>
<l> tuple_number(Ts, Tn)</l>
<l> unum:=Tn[0]+nch</l>
<l>unstr := unum $ 'd'</l>
<l>fname:=path+'RawImage_'+ urstr+'_'+unstr+'.bmp'</l>
<l>return ()</l>
</body>
<docu id="UpdateFileName">
<parameters>
<parameter id="fname"/>
<parameter id="name"/>
<parameter id="nch"/>
<parameter id="rch"/>
<parameter id="spl"/>
</parameters>
</docu>
</procedure>
<procedure name="MSPtProc39B2">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="pnum2" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSPtProc39B2 (MeasIntBresenham), single Bres. P1-P2</c>
<c>* * 2024.07.10 fixed overkills when 1 int. point was detected</c>
<c>* * 2024.01.19 two pnum</c>
<c>* * 2023.10.25 skipnext modified</c>
<c>* * 2023.10.23 skipnext modified</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>* * 2023.04.01 dual int point</c>
<c>* * 2023.03.16 fixed one int case</c>
<c>* *2022.11.07 pnfound</c>
<c>* * 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>* * 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>* * 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>* * 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c></c>
<l>normint := 0</l>
<l>nn := 0</l>
<c>* *****************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>* *** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic := -1</l>
<c></c>
<l>gen_empty_obj (PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if (ix==ixc and iy==iyc)</l>
<l>        ic := pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points (PC, iyc, ixc)</l>
<l>* dev_display (PPR)</l>
<c></c>
<l>* read_object (Reg0001, 'C:/Defect/OFFLINE/Reg_0001.hobj')</l>
<c></c>
<c></c>
<l>gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop ()</l>
<c>* ** Intersection point coordinates</c>
<c>* *** intersection index</c>
<l>ii := 0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0,</c>
<l>PType := [0,0,0,0,0,0]</l>
<c>* ** Intersection point CLC val,</c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>* ** Intersection point IRBS val,</c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>* ****************************</c>
<l>PInti := [-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix := [1,1,1,1,1,1]</l>
<l>Psubpix := [0,0,0,0,0,0]</l>
<l>Pdir := [0,0,0,0,0,0]</l>
<l>Pnum := [-1,-1,-1,-1,-1,-1]</l>
<l>merr := 0</l>
<l>err := 0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp := Pval[0]</l>
<l>* get_grayval (Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>* *** for P1---&gt;P2</c>
<c>* * finding all boundary intersection points</c>
<c></c>
<c>* Going forward from PS1</c>
<l>pin := 1</l>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>vp := Pval[0]</l>
<l>get_grayval (Im, PPy[0], PPx[0], gvp)</l>
<l>skipnext := 0</l>
<l>for i := 1 to pind-2 by 1</l>
<l>*     btype := 0</l>
<l>    if (skipnext==1)</l>
<l>        skipnext := 0</l>
<l>        continue</l>
<l>    endif</l>
<c></c>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color ('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>*     get_grayval (ImageIRBS, yc, xc, irbs)</l>
<l>    get_grayval (Im, yc, xc, gv)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if(v==0)</l>
<l>        pin := 0</l>
<l>    endif</l>
<c></c>
<l>    if (i==1 and v==1)</l>
<c>        * *** inside of Spur ***</c>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and v==1)</l>
<c>        * *** inside of Spur ***</c>
<l>        ptype := -1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>*         begtype := 1</l>
<l>*         ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<c>        * ** reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and v!=pnum2 and begtype==1 )</l>
<c>        * ** met wrong region, so reset ***</c>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum or  v==pnum2)</l>
<l>*         if (vp==0 and (vn ==pnum or vn==1))</l>
<c>        * ** 2 points ******</c>
<c>        * changed index ip</c>
<l>*         ip := ii</l>
<l>*         skipnext := 0</l>
<l>        if(pin == 1)</l>
<l>            PIntY[ii] := PPy[1]</l>
<l>            PIntX[ii] := PPx[1]</l>
<l>            PInti[ii] := 1</l>
<l>            PCLC[ii] := -2</l>
<l>            PType[ii] := 1</l>
<l>            ii := ii+1</l>
<l>        endif</l>
<l>        if ( (i!=pind-2) and ((vp==pnum or vn==pnum) and (i!=1) or (vp==pnum2 or vn==pnum2)and (i!=1)))</l>
<l>*             vp := v</l>
<l>            continue</l>
<l>*             skipnext := 1</l>
<l>*             if (vn==0)</l>
<l>*                 btype := -1</l>
<l>*             elseif (vn==1)</l>
<l>*                 btype := 1</l>
<l>*             elseif (vn==pnum)</l>
<l>*                 btype := 1</l>
<l>*             endif</l>
<l>*             if (gv&gt;gvp)</l>
<l>*                 ip := ii-1</l>
<l>*             endif</l>
<l>*             endif</l>
<c>            * ******************</c>
<l>        elseif (vp==0 and (vn ==pnum or vn ==pnum2 or vn==1 or vn==0))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and vp!=pnum and vp!=pnum2) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif ((vn==1 and (vp==pnum or vp==pnum2)) or (vp==1 and vn==pnum))</l>
<l>            btype := 1</l>
<l>        elseif (vn==1 and (pnfound==0) )</l>
<l>            btype := 1</l>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        if(btype==1)</l>
<l>            pnfound:=1</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>*         pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-2 and (v==1 or v==pnum or v==pnum2) and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        PType[ii] := -1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<c></c>
<l>    vp := v</l>
<l>    gvp := gv</l>
<l>endfor</l>
<l>intnum := ii</l>
<c></c>
<l>gen_region_points (PInt, PIntY, PIntX)</l>
<l>if (intnum==0)</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    shift := 0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<l>    wmax := 1.0</l>
<l>    wmin := 1.0</l>
<l>    shift := 0.0</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<l>    if (PType[j]==1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<l>endfor</l>
<c>* ****</c>
<c>* **Hong</c>
<l>if (jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<l>    jSPdn := jSPdn</l>
<l>else</l>
<l>    jSPdn := intnum - 2</l>
<l>endif</l>
<c>* ****</c>
<l>* jSPdn := PB[0]</l>
<l>* jSPup := PE[ie-1]</l>
<c></c>
<l>* threshold (ImageIRB, RegionIRB, 3, 255)</l>
<l>tuple_length (PB, nPB)</l>
<l>tuple_length (PE, nPE)</l>
<l>if (intnum &lt;3 or PB!=PE)</l>
<l>    jMBdn := jSPdn</l>
<l>    jMBup := jSPup</l>
<l>elseif (intnum ==4)</l>
<l>    dif0 := abs(PCLC[PB[0]]-PCLC[PE[0]])</l>
<l>    dif1 := abs(PCLC[PB[1]]-PCLC[PE[1]])</l>
<c></c>
<c></c>
<l>    if (dif0&gt;dif1)</l>
<l>        jMBdn := PB[0]</l>
<l>        jMBup := PE[0]</l>
<l>    else</l>
<l>        jMBdn := PB[1]</l>
<l>        jMBup := PE[1]</l>
<l>    endif</l>
<l>else</l>
<l>    jMBdn := jSPdn</l>
<l>    jMBup := jSPup</l>
<l>endif</l>
<c></c>
<l>gen_region_points (PMB, [PIntY[jMBdn],PIntY[jMBup]], [PIntX[jMBdn],PIntX[jMBup]])</l>
<l>gen_region_points (PSP, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<c></c>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<l>* stop ()</l>
<c>* *************** SUBPIX COORD. ******************************</c>
<l>for j := 0 to intnum-1 by 1</l>
<l>    i := PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     typ := j%2</l>
<l>*     if (g&lt;thr)</l>
<l>*         if (typ==0)</l>
<l>*             i := i-1</l>
<l>*         else</l>
<l>*             i := i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i], g)</l>
<l>*     endif</l>
<l>    PIntcor[j] := i</l>
<l>    g0[1] := g</l>
<l>    if (PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if (PInti[j]&lt;pind-1)</l>
<l>        get_grayval (Im, PPy[i+1], PPx[i+1], g)</l>
<l>        g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<c></c>
<l>    if (i&lt;pind-1 and i&gt;0)</l>
<l>SubPixCrdP (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX := PPx[i]</l>
<l>        fIntY := PPy[i]</l>
<l>    endif</l>
<c></c>
<l>    if (err==1)</l>
<l>        merr := 1</l>
<l>    endif</l>
<c></c>
<l>        FIntX[j] := fIntX</l>
<l>        FIntY[j] := fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>gen_region_points (PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<c></c>
<c>    * ************************************************</c>
<l>    wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>*     wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>*     if (wmax&gt;35)</l>
<l>*         gen_region_points (Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*         gen_region_points (Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*         irbs1 := PIRBS[jSPup]</l>
<l>*         irbs2 := PIRBS[jSPdn]</l>
<l>*         if (irbs1==irbs2)</l>
<l>*             stop ()</l>
<l>*         endif</l>
<c></c>
<l>*     endif</l>
<l>*     wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>*     wmin := wmax</l>
<l>    wmin := sqrt( (FIntX[jMBup] - FIntX[jMBdn])*(FIntX[jMBup] - FIntX[jMBdn]) + (FIntY[jMBup] - FIntY[jMBdn])*(FIntY[jMBup] - FIntY[jMBdn]) )</l>
<c></c>
<l>    if (wmax&gt;3.0)</l>
<l>        xmid := (FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>        ymid := (FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>        shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c></c>
<l>    else</l>
<l>        shift := 0</l>
<l>    endif</l>
<l>    normint := intnum</l>
<l>*     if (intnum==2)</l>
<l>*         normint := 1</l>
<l>*     else</l>
<l>*         normint := 0</l>
<l>*     endif</l>
<l>*     else</l>
<l>* endif</l>
<c></c>
<l>* stop ()</l>
<l>return ()</l>
<c>* **********************************************************</c>
<c>* **********************************************************</c>
<c></c>
</body>
<docu id="MSPtProc39B2">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="pnum2"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS42B2">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBS42B2 - 18.04.2023 - removed difference for regions tuple</c>
<l>ImIRBSOut := ImIRBS</l>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>* dil := 33</l>
<l>dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<l>count_obj (SkeletonsFWMSd, no)</l>
<c></c>
<c>* 2</c>
<l>* union1 (SkeletonsFWMS, SkeletonFWMS)</l>
<l>* difference (SkeletonFWMS, RegionInoD, SkeletonFWMSdif)</l>
<l>* connection (SkeletonFWMS, SkeletonsFWMSc)</l>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, dil)</l>
<c></c>
<l>* count_obj (SkeletonsFWMSc, n2)</l>
<c></c>
<c></c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd2, dil)</l>
<l>* count_obj (SkeletonsFWMSd2, n2)</l>
<c></c>
<c></c>
<c>* 1</c>
<l>* difference (SkeletonsFWMSd, RegionInoD, SkeletonsFWMSm)</l>
<c>* 3</c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMSd, RegionInoDC, SkeletonsFWMSm)</l>
<l>union1(SkeletonsFWMSd, SkeletonsFWMSdu)</l>
<l>intersection (SkeletonsFWMSdu, RegionInoDC, SkeletonsFWMSmu)</l>
<l>connection(SkeletonsFWMSmu, SkeletonsFWMSm2)</l>
<c>* 3</c>
<l>* difference (SkeletonsFWMSm, SkeletonsFWMSm2, RegionDifference1)</l>
<c></c>
<c></c>
<l>* area_center (SkeletonsFWMSm, Area, Row, Column)</l>
<l>* tuple_min (Area, amin)</l>
<l>* count_obj (SkeletonsFWMSm, nm)</l>
<c></c>
<l>* symm_difference (SkeletonsFWMSm, SkeletonsFWMSc, RegionDifference)</l>
<c></c>
<l>* intersection (SkeletonsFWMS, RegionInoD, RegionIntersection)</l>
<l>* union2 (SkeletonsFWMS, RegionIntersection, RegionUnion)</l>
<l>* expand_region (RegionUnion, RegionInoD, RegionsFWMS, expsize, 'image')</l>
<l>difference(SkelEP, SkeletonsFWMSd, SkelEP1)</l>
<l>union2(RegionInoD, SkelEP1, RegForbid)</l>
<l>expand_region (SkeletonsFWMSm, RegForbid, RegionsFWMS2i, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMSm, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMS, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>difference(RegionsFWMS2i, SkelEP1, RegionsFWMS2)</l>
<l>count_obj (SkeletonsFWMS, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (2, nRFWMS+1, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS2, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS2, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS42B2">
<parameters>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain128">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsLG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="RegionsmainSNoCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="elongLG" base_type="ctrl" dimension="0"/>
<par name="minPSklen" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumS2" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain128</c>
<c>** added elongated SkeletonsLG</c>
<c>*** 240504 - problems with SgeletonsGS at ends</c>
<c>*** 240224 - Cut without overlap for both P and S</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<c></c>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>TotalPRC:=5</l>
<l>CurrentOper:='Starting'</l>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<l>difference(DomainG, RegNoProc, RegProc)</l>
<l>smallest_rectangle1(RegProc, Row11, Column11, Row21, Column21)</l>
<l>gen_rectangle1(Rectangle, Row11, Column11, Row21, Column21)</l>
<l>area_center(RegProc, Area3, RowDKu, ColumnDKu)</l>
<l>gen_rectangle1(RegionCut, RowDKu, Column11, RowDKu+1, Column21+1)</l>
<c></c>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGi, 127, 255)</l>
<l>* closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>* connection (RegionGid, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<c>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)ImIRBS:= ImageIRBS</c>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<l>TotalPRC:=7</l>
<l>CurrentOper:='Smoothing regions'</l>
<l>* smoothCADcontours := 0</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<l>* read_image (Im2173, 'C:/TmpIm/Im2_173.tif')</l>
<l>* threshold(Im2173, Region, 90, 255)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<c>* 16.04.2024 </c>
<l>* difference (DomainG, RegionGsm, RegionGSi)</l>
<l>difference (DomainG, RegionG, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>* closing_circle(RegionGi, RegionGiic, 1)</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c>* 16.04.2024</c>
<l>* intersection (RegionGSi, RC, RegionGSii)</l>
<l>* difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<c></c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>connection(SkeletonGS, SkeletonsGS)</l>
<c></c>
<l>* select_shape(ConnectedRegionsS, SkeletonsGS, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>*** cutting ends of MSS</c>
<c></c>
<c></c>
<c>*** Old LG</c>
<l>*  if(elongLG &gt;0)</l>
<l>*     junctions_skeleton(SkeletonGS, EndPointsGS, JuncPointsGS)</l>
<l>*     dilation_circle(EndPointsGS, RegionDilationGS, elongLG)</l>
<l>*     intersection(SkeletonGSi, RegionDilationGS, RegionIntersection1)</l>
<l>*     union2(SkeletonGS, RegionIntersection1, SkeletonLG)</l>
<l>*     connection(SkeletonLG, SkeletonsLG)</l>
<l>*  endif</l>
<c>*     union2</c>
<l>* elseif(cutendMSS &gt;0)    </l>
<l>    for j:=1 to cutendMSS by 1</l>
<l>        junctions_skeleton(SkeletonsGS,EndPointsMSS, JuncPointsMSS)</l>
<l>        area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>        tuple_length(Area1, nEndPointsMSS)</l>
<l>        if(Area1&gt;0)</l>
<l>            union1(EndPointsMSS, EndPointsMSSu)</l>
<l>            connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>            area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>            tuple_length(RowMSS, nMSS)</l>
<l>            tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>            gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>            union1(CMSSE, CMSSEu)</l>
<l>            difference(SkeletonsGS, CMSSEu, SkeletonsGS)</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>* endif</l>
<c></c>
<c></c>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* stop()</l>
<l>* ExtendedSkeletonWFMP5(RegionG, SkeletonsGS, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<c></c>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>TotalPRC:=10</l>
<l>CurrentOper:='Building width and direction images'</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGi, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** 24.04.02 RegionGSi -&gt; RegionGSii</c>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*******250308</c>
<c>******</c>
<c></c>
<l>junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>get_region_points(SkelEPu, Rows, Columns)</l>
<l>get_grayval(WidthImageS, Rows, Columns, wEPs)</l>
<l>tuple_max(wEPs, wEP)</l>
<c></c>
<l>dilation_circle(SkelEPu, SkelEP, wEP/2+EPexp)</l>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>TotalPRC:=20</l>
<l>CurrentOper:='Building Pattern Skeletons'</l>
<l>minlen := minPSklen</l>
<l>pruning(SkeletonG,SkeletonG, 10)</l>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_median(WGi, medWGi)</l>
<l>tuple_deviation(WGi, devWGi)</l>
<c></c>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>* tuple_min (WGi, minWGi)</l>
<l>* tuple_max (WGi, maxWGi)</l>
<l>* tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>* PrcWGi := HistoGi*100./nWGi</l>
<l>* tuple_length(PrcWGi, nP)</l>
<c></c>
<l>* write_tuple(PrcWGi, 'PrcWGi')</l>
<l>* read_tuple('PrcWGitst', PrcWGi)</l>
<l>if(autowidth==1)</l>
<l>*     wside:=6</l>
<l>    FindWidth (WGi, wside, WidthP)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* stop()</l>
<l>* tuple_max(MaxInd, pmax)</l>
<l>* tuple_min(MaxInd, pmin)</l>
<l>* pmid:=(pmax+pmin)/2</l>
<l>* span:=pmax-pmin</l>
<l>* stop()</l>
<c></c>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>wsideS:=6</l>
<l>if(autowidth==1)</l>
<l>    FindWidth (WGSi, wsideS, WidthS)</l>
<l>endif</l>
<c></c>
<l>* tuple_length (WGSi, nWGSi)</l>
<l>* tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>* for j:=0 to nWGSi-1 by 1</l>
<l>*     if(WGSi[j]&lt; minWGS)</l>
<l>*         WGSi[j] := minWGS</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>* tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>* PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c></c>
<c>****** Auto setting of FWM/S widths using width histogram 16.04.2024 </c>
<l>* create_funct_1d_array(PrcWGSi, FPrcWGSi)</l>
<l>* local_min_max_funct_1d(FPrcWGSi, 'strict_min_max', 'true', MinPrcWGS, MaxPrcWGS)</l>
<l>* tuple_length(MinPrcWGS, nMinPrcWGS)</l>
<l>* tuple_length(MaxPrcWGS, nMaxPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MinPrcWGS, 'constant', YMinPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MaxPrcWGS, 'constant', YMaxPrcWGS)</l>
<c></c>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>* get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>* get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>* tuple_length(WdG, nWdG)</l>
<l>* tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>* PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0 and useODB&lt;3)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>* prcmin:=5</l>
<l>* numP:=3</l>
<l>* numS:=1</l>
<l>* wmax:=45</l>
<l>* if(useODB==1)</l>
<l>*       WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>* endif</l>
<c></c>
<l>* numS:=1</l>
<l>* WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    if(autowidth==0)</l>
<l>        WminP := wFWM</l>
<l>    else</l>
<l>        WminP := WidthP</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>elseif(useODB==1)</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>else </l>
<l>    RegionmainNoCut:=SkeletonGS</l>
<l>    connection(RegionmainNoCut, RegionsmainNoCut)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonG, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>TotalPRC:=40</l>
<l>CurrentOper:='Building Space Skeletons'</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<l>if(autowidth==1)</l>
<l>   WminS := WidthS</l>
<l>else</l>
<l>   WminS := wFWMS</l>
<l>endif</l>
<l>* WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>tuple_length(WGSi, nWGSi)</l>
<c></c>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c></c>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>connection(RmainS, ConnectedRegionsS)</l>
<l>select_shape(ConnectedRegionsS, RegionsmainSNoCut, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(RegionsmainSNoCut, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>**** New LG ******</c>
<l>    junctions_skeleton(RegionsmainSNoCut, EndPointsSN, JuncPointsSN)</l>
<l>    dilation_circle(EndPointsSN, RegionDilationSN, elongLG)</l>
<l>    intersection(SkeletonGSi, RegionDilationSN, RegionIntersection1)</l>
<l>    union2(RegionsmainSNoCut, RegionIntersection1, SkeletonLG)</l>
<l>    connection(SkeletonLG, SkeletonsLG)</l>
<c></c>
<c>*************</c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSNoCut,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(RegionsmainSNoCut, CMSSEu, RegionsmainSNoCut)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>* RegionsmainS:=RegionsmainSn</l>
<l>union1(RegionsmainSNoCut, RegionmainSNoCut)</l>
<l>difference(RegionmainSNoCut, RegionCut, RegionmainS)</l>
<l>connection(RegionmainS, RegionsmainS)</l>
<l>union1(RegionsmainS, RegionmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>SkeletonsFWMScut:=RegionsmainS</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>SkeletonsFWMS:=RegionsmainSNoCut</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>cut:=0</l>
<l>cyc:=255</l>
<l>for j:=1 to nFWMS by 1</l>
<l>    select_obj(SkeletonsFWMS, Sk, j)</l>
<l>    get_region_points(Sk, RowsSk, ColumnsSk)</l>
<l>    get_grayval(DirImageS, RowsSk, ColumnsSk, DSk)</l>
<c>    * unwrapping DSk</c>
<l>    Unwrap (DSk, cyc, DSku)</l>
<c>    *****</c>
<l>    tuple_min(DSku, dSkumin)</l>
<l>    tuple_max(DSku, dSkumax)</l>
<l>    dSkuspan:=dSkumax-dSkumin</l>
<c>    </c>
<l>    if(dSkuspan &gt; 250)</l>
<l>        cut:=1</l>
<l>    endif</l>
<l>endfor</l>
<l>if(cut==0)</l>
<l>    gen_empty_obj(RegionCut)</l>
<l>    SkeletonsFWMScut:=SkeletonsFWMS</l>
<l>endif</l>
<c></c>
<c>*****</c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<l>TotalPRC:=60</l>
<l>CurrentOper:='Preparing IRB'</l>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>TotalPRC:=70</l>
<l>CurrentOper:='Building non-FWM sensors'</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>* union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>* connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>* count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMScut, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (2, nINBS+1, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseqS := nEMPTY+1</l>
<l>* overfS := 255-stseqS</l>
<l>* SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>* SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBSi, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<c></c>
<c></c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<c></c>
<l>TotalPRC:=80</l>
<l>CurrentOper:='Building pattern sensors'</l>
<c></c>
<l>lpnum2:=30</l>
<l>MSBuildFWM53 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, lpnum2,\
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<c></c>
<l>TotalPRC:=90</l>
<l>CurrentOper:='Building space sensors'</l>
<c></c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM52 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumS2, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>TotalPRC:=100</l>
<c></c>
<l>if(autowidth==1)</l>
<l>    wFWM:=Width</l>
<l>    wFWMS:=WidthS</l>
<l>endif</l>
<c></c>
<l>CurrentOper:='End of Teaching'</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain128">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="CurrentOper"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="EPexp"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PnumS2"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsmainSNoCut"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsLG"/>
<parameter id="TotalPRC"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elongLG"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="maxdirSP"/>
<parameter id="minPSklen"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="MSSpProc38B2">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="ImageIRB" base_type="iconic" dimension="0"/>
<par name="ImageCLC" base_type="iconic" dimension="0"/>
<par name="ImageIRBS" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PC" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pnum" base_type="ctrl" dimension="0"/>
<par name="pnum2" base_type="ctrl" dimension="0"/>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
<par name="sub" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="clcmax" base_type="ctrl" dimension="0"/>
<par name="pat0space1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PIntX" base_type="ctrl" dimension="0"/>
<par name="PIntY" base_type="ctrl" dimension="0"/>
<par name="wmax" base_type="ctrl" dimension="0"/>
<par name="wmin" base_type="ctrl" dimension="0"/>
<par name="shift" base_type="ctrl" dimension="0"/>
<par name="normint" base_type="ctrl" dimension="0"/>
<par name="merr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSSpProc38B2 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*</c>
<c>** 2024.06.19 single point intersection</c>
<c>** 2024.02.26 pnum and pnum2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>** 2022.09.15 MSSpProc34() modified very narrow space</c>
<c>** 2022.12.28 MSSpProc36() modified from MSPtProc36()</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (ImageIRB, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_region_points (PS1, PPy[0], PPx[0])</l>
<l>* stop()</l>
<c>*** Intersection point coordinates</c>
<c>**** intersection index</c>
<l>ii:=0</l>
<l>PIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>PIntX := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntY := [-1,-1,-1,-1,-1,-1]</l>
<l>FIntX := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point type space-&gt;Pat = 1, Pat-&gt;space = 0, </c>
<l>PType := [0,0,0,0,0,0]</l>
<c>*** Intersection point CLC val, </c>
<l>PCLC := [-1,-1,-1,-1,-1,-1]</l>
<c>*** Intersection point IRBS val, </c>
<l>PIRBS := [-1,-1,-1,-1,-1,-1]</l>
<c>*****************************</c>
<l>PInti:=[-1,-1,-1,-1,-1,-1]</l>
<l>* Psubpix:=[1,1,1,1,1,1]</l>
<l>Psubpix:=[0,0,0,0,0,0]</l>
<l>Pdir:=[0,0,0,0,0,0]</l>
<l>Pnum:=[-1,-1,-1,-1,-1,-1]</l>
<l>merr:=0</l>
<l>err:=0</l>
<l>* i0 := -1</l>
<l>* i2 := -1</l>
<l>* i1 := -1</l>
<l>* i3 := -1</l>
<l>* bfound := 0</l>
<l>* vp:=Pval[0]</l>
<l>* get_grayval(Im, PPy[0], PPx[0], gp)</l>
<c></c>
<c>**** for P1---&gt;P2</c>
<c>** finding all boundary intersection points</c>
<l>pnfound := 0</l>
<l>begtype := 0</l>
<l>endtype := 0</l>
<l>* no0:=1</l>
<l>vp := Pval[0]</l>
<l>for i := 1 to pind-2 by 1</l>
<l>    xc := PPx[i]</l>
<l>    yc := PPy[i]</l>
<l>    dev_set_color('cyan')</l>
<l>    gen_region_points (Pc, yc, xc)</l>
<l>    get_grayval(ImageIRBS, yc, xc, irbs)</l>
<l>    v := Pval[i]</l>
<l>    vn := Pval[i+1]</l>
<l>    if (i==1 and v==1)</l>
<l>        ptype := 1</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        begtype := 1</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (v==0)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>    endif</l>
<l>    if (v&gt;1 and v!=pnum and v!=pnum2 and begtype==1)</l>
<l>        begtype := 0</l>
<l>        pnfound := 0</l>
<l>        ii := ii-1</l>
<l>    endif</l>
<l>    if (v==pnum or v==pnum2)</l>
<l>        if (vp==0 and (vn ==pnum or vn ==pnum2 or vn==1))</l>
<l>            btype := 1</l>
<l>        elseif ((vp==1 and (vp!=pnum or vp!=pnum2)) or (vn==0 and vp!=0))</l>
<l>            btype := -1</l>
<l>        elseif (vp==0 and vn==0)</l>
<l>            btype := 2</l>
<l>        else</l>
<l>            btype := 0</l>
<l>        endif</l>
<l>        PType[ii] := btype</l>
<l>        pnfound := 1</l>
<l>        if (btype==0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        get_grayval (ImageCLC, yc, xc, clc)</l>
<l>        PCLC[ii] := clc</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>    if (i==pind-1 and v==0 and pnfound==1)</l>
<l>        PIntY[ii] := yc</l>
<l>        PIntX[ii] := xc</l>
<l>        PInti[ii] := i</l>
<l>        PCLC[ii] := -2</l>
<l>        ii := ii+1</l>
<l>    endif</l>
<l>*     if(vn==0)</l>
<l>*         no0:=0</l>
<l>*     endif</l>
<c>    </c>
<l>    vp := v</l>
<c>   </c>
<l>*     if (v==pnum)</l>
<l>*         PIntY[ii]:=yc</l>
<l>*         PIntX[ii]:=xc</l>
<l>*         PInti[ii]:=i</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>intnum:=ii</l>
<l>jSPdn:=0</l>
<l>jSPup:=ii-1</l>
<l>gen_region_points(PInt, PIntY, PIntX) </l>
<l>if (intnum==0 )</l>
<l>    wmax := 0.0</l>
<l>    wmin := 0.0</l>
<l>    return ()</l>
<l>elseif (intnum==1)</l>
<c>    </c>
<l>    wmax := 1.4</l>
<l>    wmin := 1.4</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>jSPdn := 0</l>
<l>jSPup := ii-1</l>
<c>* *** finding parts beg. and ends</c>
<l>PB := []</l>
<l>PE := []</l>
<l>ib := 0</l>
<l>ie := 0</l>
<l>for j := 0 to ii-1 by 1</l>
<c>*     if (PType[j]==1) changed 240712</c>
<l>    if (PType[j]&gt;=1)</l>
<l>        PB[ib] := j</l>
<l>        ib := ib+1</l>
<l>    elseif (PType[j]==-1)</l>
<l>        PE[ie] := j</l>
<l>        ie := ie+1</l>
<l>    endif</l>
<c>    </c>
<l>     if(PType[j]==2)</l>
<c>         * 240717</c>
<l>         if(ie&gt;0)</l>
<l>             PE[ie-1] := j</l>
<l>         endif</l>
<c>         </c>
<l>     endif</l>
<l>endfor</l>
<l>jSPdn := PB[0]</l>
<l>jSPup := PE[ie-1]</l>
<l>gen_region_points (PI, [PIntY[jSPdn],PIntY[jSPup]], [PIntX[jSPdn],PIntX[jSPup]])</l>
<l>dev_set_color ('red')</l>
<l>dev_display (PI)</l>
<c>****Hong ****</c>
<l>if(jSPdn == 0 or jSPdn ==1 or jSPdn == 2)</l>
<c>		</c>
<l>				jSPdn := jSPdn</l>
<c></c>
<l>			else</l>
<c></c>
<l>				jSPdn := intnum - 2</l>
<l>   endif</l>
<c>   *******</c>
<l>* if(intnum==0)</l>
<l>*     w:=0.5</l>
<l>*     wmin:=0.5</l>
<l>*     return()</l>
<l>* elseif(intnum==1)</l>
<l>*     wmax:=1.0</l>
<l>*     wmin:=1.0</l>
<l>*     i:=PInti[0]</l>
<l>*     return()</l>
<l>*     intnum:=2</l>
<l>*     PInti[0]:=i-1</l>
<l>*     PInti[1]:=i+1</l>
<l>*     jSPup:=1</l>
<l>* endif</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>for j:=0 to intnum-1 by 1</l>
<l>    i:=PInti[j]</l>
<l>    get_grayval (Im, PPy[i], PPx[i],  g)</l>
<l>*     typ:=j%2</l>
<l>*     if(g&lt;thr)</l>
<l>*         if(typ==0)</l>
<l>*             i:=i-1</l>
<l>*         else</l>
<l>*             i:=i+1</l>
<l>*         endif</l>
<l>*         get_grayval (Im, PPy[i], PPx[i],  g)    </l>
<l>*     endif</l>
<l>    PIntcor[j]:=i</l>
<l>    g0[1] := g</l>
<l>    if(PInti[j]&gt;0)</l>
<l>        get_grayval (Im, PPy[i-1], PPx[i-1], g)</l>
<l>        g0[0] := g</l>
<l>    else</l>
<l>        g0[0] := g0[1]</l>
<l>    endif</l>
<l>    if(PInti[j]&lt;pind-1)</l>
<l>       get_grayval (Im, PPy[i+1], PPx[i+1], g) </l>
<l>       g0[2] := g</l>
<l>    else</l>
<l>        g0[2] := g0[1]</l>
<l>    endif</l>
<l>*     gmax:=max(g0)</l>
<l>*     gmin:=min(g0)</l>
<l>*     gmax:=max2(g0[0], g0[1])</l>
<l>    if(i&lt;pind-1 and i&gt;0)</l>
<l>        SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    else</l>
<l>        fIntX:=PIntX[j]</l>
<l>        fIntY:=PIntY[j]</l>
<l>    endif</l>
<l>*     SubPixCrdS (g0, i, PPx, PPy, sub, thr, fIntX, fIntY, err)</l>
<l>    if(err==1)</l>
<l>        merr:=1</l>
<l>    endif</l>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*         SubPixCrdT (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY)</l>
<l>        FIntX[j]:=fIntX</l>
<l>        FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>endfor</l>
<l>* stop()</l>
<l>* gen_region_points(PInt2, PPy[PIntcor], PPx[PIntcor])</l>
<l>* stop()</l>
<l>* for i := 0 to ii-1 by 1</l>
<l>*     pi:=PInti[i]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* previous clc </c>
<l>*         pclc:=-2</l>
<l>*         fi1:=0</l>
<c>*checking 1st MS pixel</c>
<l>* if(Pval[0]==1 or Pval[0]==pnum)</l>
<l>*     PIntY[ii]:=PPy[0]</l>
<l>*     PIntX[ii]:=PPx[0]</l>
<l>*     PInti[ii]:=0</l>
<l>*     Psubpix[ii]:=0</l>
<l>*     get_grayval(ImageCLC, PPy[0], PPx[0], clc)</l>
<l>*     get_grayval(ImageIRBS, PPy[0], PPx[0], irbs)</l>
<l>*     if(Pval[0]==pnum)</l>
<l>*         PCLC[ii]:=clc</l>
<l>*     else</l>
<c>        * no clc yet</c>
<l>*         PCLC[ii]:=-2</l>
<l>*     endif</l>
<l>*     ii:=ii+1</l>
<c>    ** 1st pix is 1</c>
<l>*     if(Pval[0]==1)</l>
<l>*         fi1:=1</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Pval[1]==0 and Pval[0]==pnum)</l>
<l>*             PIntY[ii]:=PPy[0]</l>
<l>*             PIntX[ii]:=PPx[0]</l>
<l>*             PInti[ii]:=0</l>
<l>*             PCLC[ii]:=clc</l>
<l>*             PIRBS[ii]:=irbs</l>
<l>*             Psubpix[ii]:=0</l>
<l>*             ii:=ii+1</l>
<l>*     endif</l>
<l>* else</l>
<l>*     fi1:=0</l>
<l>* endif</l>
<c>***********  All Br. pixels*******</c>
<l>* for i := 1 to pind-2 by 1</l>
<l>*     xc := PPx[i]</l>
<l>*     yc := PPy[i]</l>
<l>*     dev_set_color('cyan')</l>
<l>*     gen_region_points (Pc, yc, xc)</l>
<l>*     if(i==9)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     dev_display(Pc)</l>
<l>*     v := Pval[i]</l>
<c>    ** check for 1st pix == 1 case</c>
<l>*     if(fi1==1)</l>
<l>*         if(v==0 or (v&gt;1 and v!=pnum))</l>
<l>*             ii:=ii-1</l>
<l>*             fi1:=0</l>
<l>*         endif</l>
<l>*     endif</l>
<l>*     if (v==pnum)</l>
<l>*         fi1:=0</l>
<c>        * previous and next values</c>
<l>*         vp:=Pval[i-1]</l>
<l>*         vn:=Pval[i+1]</l>
<c>        *intersection type detection</c>
<l>*         dev_set_color('yellow')</l>
<l>*         gen_region_points (Pc, yc, xc)</l>
<l>*         concat_obj(PC, Pc, PC)</l>
<l>*         dev_display(Pc)</l>
<c>        * checking previous and next sensor points</c>
<l>*         if((vp==pat0space1 ) or (vn==pat0space1 ) or (vn==pnum ))    </l>
<c>    </c>
<l>*             get_grayval(ImageCLC, yc, xc, clc)</l>
<l>*             get_grayval(ImageIRBS, yc, xc, irbs)</l>
<c>*            </c>
<l>*                 PIntY[ii]:=yc</l>
<l>*                 PIntX[ii]:=xc</l>
<l>*                 PInti[ii]:=i</l>
<l>*                 Psubpix[ii]:=1</l>
<l>*                 dev_set_color('red')</l>
<l>*                 gen_region_points (Pc, yc, xc)</l>
<l>*                  dev_display(Pc)</l>
<l>*                 if((vp==0 )and vn==0)</l>
<c>                    * single point special case</c>
<l>*                     ii:=ii+1</l>
<l>*                     PIntY[ii-1]:=yc-0.35*signY</l>
<l>*                     PIntX[ii-1]:=xc-0.35*signX</l>
<l>*                     Psubpix[ii-1]:=0</l>
<l>*                     PIntY[ii]:=yc+0.35*signY</l>
<l>*                     PIntX[ii]:=xc+0.35*signX</l>
<l>*                     PInti[ii]:=i</l>
<l>*                     Psubpix[ii]:=0</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<c>                </c>
<l>*                 PCLC[ii]:=clc</l>
<l>*                 PIRBS[ii]:=irbs</l>
<l>*                 ii:=ii+1</l>
<l>*                 pclc:=clc</l>
<l>*             endif</l>
<c>            </c>
<l>*         endif</l>
<l>*       endif</l>
<l>*     vp:=v</l>
<l>*     gp:=g</l>
<l>* endfor</l>
<c></c>
<c>*checking last MS pixel</c>
<l>* if((Pval[pind-1]==0 and ii%2==1) or Pval[pind-1]==pnum)</l>
<l>*     if(Pval[pind-1]==pnum)</l>
<l>*         get_grayval(ImageCLC, PPy[pind-1], PPx[pind-1], clc)</l>
<l>*         get_grayval(ImageIRBS, PPy[pind-1], PPx[pind-1], irbs)</l>
<l>*     else</l>
<l>*         clc:=PCLC[ii-1]</l>
<l>*         irbs:=PIRBS[ii-1]</l>
<l>*     endif</l>
<l>*     PIntY[ii]:=PPy[pind-1]</l>
<l>*     PIntX[ii]:=PPx[pind-1]</l>
<l>*     PInti[ii]:=pind-1</l>
<l>*     PCLC[ii]:=clc</l>
<l>*     ii:=ii+1</l>
<l>*     if(Pval[pind-2]==1)</l>
<l>*         PIntY[ii]:=PPy[pind-1]</l>
<l>*         PIntX[ii]:=PPx[pind-1]</l>
<l>*         PInti[ii]:=pind-1</l>
<l>*         PCLC[ii]:=clc</l>
<l>*         PIRBS[ii]:=irbs</l>
<l>*         ii:=ii+1</l>
<l>*     endif</l>
<l>*     Psubpix[ii]:=0</l>
<l>* endif</l>
<c>**************************</c>
<l>* gen_region_points(PInt, PIntY, PIntX) </l>
<l>* intnum:=ii</l>
<l>* if(intnum%2 == 1 or intnum==0)</l>
<c>    **** error, odd number of intersection points</c>
<l>*     stop()</l>
<l>* else</l>
<l>* if(intnum&lt;=1)</l>
<c>    ** no pattern case</c>
<l>*     wmin := 0.</l>
<l>*     wmax := 0.</l>
<l>*     shift:=0.</l>
<l>*     return()</l>
<l>* endif</l>
<l>* stop()</l>
<l>* t:=thr</l>
<c>*** previous dir</c>
<l>* pdir:=-1</l>
<c>**************** SUBPIX COORD. ******************************</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     get_grayval (Im, PPy[PInti[j]+0], PPx[PInti[j]+0],  g)</l>
<l>*     g0[1] := g</l>
<l>*     if(PInti[j]&gt;0)</l>
<l>*         get_grayval (Im, PPy[PInti[j]-1], PPx[PInti[j]-1], g)</l>
<l>*         g0[0] := g</l>
<l>*     else</l>
<l>*         g0[0] := g0[1]</l>
<l>*     endif</l>
<l>*     if(PInti[j]&lt;pind-1)</l>
<l>*        get_grayval (Im, PPy[PInti[j]+1], PPx[PInti[j]+1], g) </l>
<l>*        g0[2] := g</l>
<l>*     else</l>
<l>*         g0[2] := g0[1]</l>
<l>*     endif</l>
<c>    </c>
<l>*     if(Psubpix[j]==0)</l>
<l>*         FIntX[j]:=PIntX[j]</l>
<l>*         FIntY[j]:=PIntY[j]</l>
<l>*     else</l>
<l>*             SubPixCrdS (g0, PInti[j], PPx, PPy, sub, thr, fIntX, fIntY, err1)</l>
<l>*         FIntX[j]:=fIntX</l>
<l>*         FIntY[j]:=fIntY</l>
<l>*     endif</l>
<l>*     if(g0[2]-g0[0]&gt;0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     elseif(g0[0]-g0[2]&gt;0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     if(pdir &gt; 0)</l>
<l>*         Pdir[j] := -1</l>
<l>*     elseif(pdir &lt; 0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==0 and Pdir[j]!=0 and j==0)</l>
<l>*         Pdir[j] := 1</l>
<l>*     endif</l>
<l>*     if(PInti[j]==pind-1 and Pdir[j]!=0 and j==intnum-1)</l>
<l>*         Pdir[j] := -1</l>
<l>*     endif</l>
<l>*     pdir:=Pdir[j]</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* number of MW candidates</c>
<l>* nmwc:=0</l>
<c>* MW segment</c>
<l>* mw:=-1</l>
<l>* dmin:=55555</l>
<c>******************** Check Segments ********</c>
<c>*** finding MW (main wire) segment</c>
<c>*** fixing PCLC and Pnums</c>
<l>* for j:=0 to intnum-1 by 1</l>
<l>*     if(j==3)</l>
<l>*         stop()</l>
<l>*     endif</l>
<l>*     get_grayval(ImageCLC, PIntY[j], PIntX[j], vclc)</l>
<l>*     get_grayval(ImageIRBS, PIntY[j], PIntX[j], vpnums)</l>
<l>*     if(vclc==0)</l>
<c>        ***** shift from ImageCLC, thus searching CLC nearby *******</c>
<l>*         clc:=0</l>
<l>*         for dx:=-3 to 3 by 1</l>
<l>*             for dy:=-3 to 3 by 1</l>
<l>*                 get_grayval(ImageCLC, PIntY[j]+dy, PIntX[j]+dx, vclc)</l>
<l>*                 if(vclc!=0)</l>
<l>*                     clc:=vclc</l>
<l>*                     break</l>
<l>*                 endif</l>
<l>*             endfor</l>
<l>*         endfor</l>
<l>*         PCLC[j]:=clc</l>
<c>        *************************************************************</c>
<l>*     else</l>
<l>*         PCLC[j]:=vclc</l>
<l>*     endif</l>
<l>*     Pnums[j]:=vpnums</l>
<l>* endfor</l>
<l>* stop()</l>
<c>********* checking segments for main wire (mw) *****</c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     pclc:=PCLC[j]</l>
<l>*     clc:=PCLC[j+1]</l>
<c>    </c>
<l>*     dclc:=min2(abs(clc-pclc), abs(clc-65536-pclc))</l>
<l>*     if(dclc&gt;clcmax)</l>
<l>*         if(Pdir[j] != 1 or Pdir[j+1]!=-1)</l>
<l>*             continue</l>
<l>*         endif</l>
<c>        * could be MW, so check distance from P1 and P2</c>
<l>*         da:=(ixc-(FIntX[j]+FIntX[j+1])/2.)*(ixc-(FIntX[j]+FIntX[j+1])/2.) + (iyc-(FIntY[j]+FIntY[j+1])/2.)*(iyc-(FIntY[j]+FIntY[j+1])/2.)</l>
<l>*         d1:=(ixc-FIntX[j])*(ixc-FIntX[j])+(iyc-FIntY[j])*(iyc-FIntY[j])</l>
<l>*         d2:=(ixc-FIntX[j+1])*(ixc-FIntX[j+1]) + (iyc-FIntY[j+1])*(iyc-FIntY[j+1])</l>
<l>*         d:=sqrt( min2(d1,d2) )</l>
<l>*         if(d&lt;dmin)</l>
<l>*             mw:=j</l>
<l>*             nmwc:=nmwc+1</l>
<l>*             dmin:=d</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* if(mw==-1)</l>
<l>*     mw:=0</l>
<l>*     stop()</l>
<l>* endif</l>
<l>* dev_set_color('red')</l>
<l>* gen_region_points(PMW, [PIntY[mw],PIntY[mw+1]], [PIntX[mw],PIntX[mw+1]])</l>
<l>* dev_display(PMW)</l>
<l>* gen_region_points(PC, iyc, ixc)</l>
<l>* stop()</l>
<c>*** finding Spur points</c>
<l>* jSPdn:=mw</l>
<l>* jSPup:=mw+1</l>
<c></c>
<l>* for j:=0 to intnum-1 by 2</l>
<l>*     if(j==mw)</l>
<l>*         continue</l>
<l>*     else</l>
<l>*         clc:=PCLC[j]</l>
<l>*         clc1:=PCLC[mw]</l>
<l>*         clc2:=PCLC[mw+1]</l>
<l>*         dclc1:=min2(abs(clc-clc1), abs(clc-65536-clc1))</l>
<l>*         dclc2:=min2(abs(clc-clc2), abs(clc-65536-clc2))</l>
<l>*         if(dclc1 &gt; clcmax and dclc2 &gt; clcmax)</l>
<c>            * not SP because of big dCLC</c>
<l>*             continue</l>
<l>*         else</l>
<l>*             if(j&lt;mw)</l>
<l>*                 dclc:=min2(abs(PCLC[mw]-clc1), abs(PCLC[mw]-65536-clc1))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPdn:=j</l>
<l>*                 endif</l>
<l>*             else</l>
<l>*                 dclc:=min2(abs(PCLC[mw+1]-clc), abs(PCLC[mw+1]-65536-clc))</l>
<l>*                 if(dclc &gt; clcmax)</l>
<c>                    * not SP because of big dCLC from MW point</c>
<l>*                     continue</l>
<l>*                 else</l>
<l>*                     jSPup:=j+1</l>
<l>*                 endif</l>
<l>*             endif</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>**** both sides are rising or falling - error</c>
<l>* if(Pdir[jSPup]==Pdir[jSPdn])</l>
<l>*     jSPup:=jSPdn+1</l>
<l>*     stop()</l>
<l>* endif</l>
<c>*************************************************</c>
<l>wmax := sqrt( (FIntX[jSPup] - FIntX[jSPdn])*(FIntX[jSPup] - FIntX[jSPdn]) + (FIntY[jSPup] - FIntY[jSPdn])*(FIntY[jSPup] - FIntY[jSPdn]) )</l>
<l>* wmax := sqrt( (FIntX[intnum-1] - FIntX[0])*(FIntX[intnum-1] - FIntX[0]) + (FIntY[intnum-1] - FIntY[0])*(FIntY[intnum-1] - FIntY[0]) )</l>
<l>* if(wmax&gt;35)</l>
<l>*     gen_region_points(Pi1, FIntY[jSPup], FIntX[jSPup])</l>
<l>*     gen_region_points(Pi2, FIntY[jSPdn], FIntX[jSPdn])</l>
<l>*     irbs1:=PIRBS[jSPup]</l>
<l>*     irbs2:=PIRBS[jSPdn]</l>
<l>*     if(irbs1==irbs2)</l>
<l>*         stop()</l>
<l>*     endif</l>
<c>    </c>
<l>* endif</l>
<l>* wmin := sqrt( (FIntX[mw] - FIntX[mw+1])*(FIntX[mw] - FIntX[mw+1]) + (FIntY[mw] - FIntY[mw+1])*(FIntY[mw] - FIntY[mw+1]) )</l>
<l>wmin:=wmax</l>
<l>if(wmax&gt;3.0)</l>
<l>    xmid:=(FIntX[jSPup] + FIntX[jSPdn])/2.</l>
<l>    ymid:=(FIntY[jSPup] + FIntY[jSPdn])/2.</l>
<l>    shift := sqrt( (ixc - xmid)*(ixc - xmid) + (iyc - ymid)*(iyc - ymid) )</l>
<c>    </c>
<l>else</l>
<l>    shift:=0</l>
<l>endif</l>
<l>normint:=intnum</l>
<l>* if(intnum==2)</l>
<l>*     normint:=1</l>
<l>* else</l>
<l>*     normint:=0</l>
<l>* endif</l>
<l>* else    </l>
<l>* endif</l>
<c></c>
<l>* stop()</l>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="MSSpProc38B2">
<parameters>
<parameter id="Im"/>
<parameter id="ImageCLC"/>
<parameter id="ImageIRB"/>
<parameter id="ImageIRBS"/>
<parameter id="PC"/>
<parameter id="PIntX"/>
<parameter id="PIntY"/>
<parameter id="clcmax"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="merr"/>
<parameter id="normint"/>
<parameter id="pat0space1"/>
<parameter id="pnum"/>
<parameter id="pnum2"/>
<parameter id="shift"/>
<parameter id="sub"/>
<parameter id="thr"/>
<parameter id="wmax"/>
<parameter id="wmin"/>
</parameters>
</docu>
</procedure>
<procedure name="SpMeasGray">
<interface>
<io>
<par name="Im" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ix1" base_type="ctrl" dimension="0"/>
<par name="iy1" base_type="ctrl" dimension="0"/>
<par name="ix2" base_type="ctrl" dimension="0"/>
<par name="iy2" base_type="ctrl" dimension="0"/>
<par name="ixc" base_type="ctrl" dimension="0"/>
<par name="iyc" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="minPVal" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *** MSSpProc38B2 V1 (MeasIntBresenham), single Bres. P1-P2</c>
<c>*</c>
<c>** 2024.06.19 single point intersection</c>
<c>** 2024.02.26 pnum and pnum2</c>
<c>* save clc and type</c>
<c>* measuring shift</c>
<c>** 2022.06.20 added PC (to be used in building NonFWM)</c>
<c>** 2022.06.23 added normint - "normal intersection", intnum==2</c>
<c>** 2022.07.04 Space version pat0space1 - defines pat.(0) or space(1)</c>
<c>** 2022.08.08 MSSProc33() checkes IRBS value to avoid selecting wrong int. point</c>
<c>** 2022.09.15 MSSpProc34() modified very narrow space</c>
<c>** 2022.12.28 MSSpProc36() modified from MSPtProc36()</c>
<l>normint:=0</l>
<c>******************</c>
<l>PIntX := []</l>
<l>PIntY := []</l>
<l>wmax := []</l>
<c>**** for P1---&gt;P2</c>
<l>deltaX := abs(ix2 - ix1)</l>
<l>deltaY := abs(iy2 - iy1)</l>
<l>if (ix1 &lt; ix2)</l>
<l>    signX := 1</l>
<l>else</l>
<l>    signX := -1</l>
<l>endif</l>
<l>if (iy1 &lt; iy2)</l>
<l>    signY := 1</l>
<l>else</l>
<l>    signY := -1</l>
<l>endif</l>
<c>* 	int signY = y1 &lt; y2 ? 1 : -1;</c>
<l>error := deltaX - deltaY</l>
<c></c>
<l>signX2 := -signX</l>
<l>signY2 := -signY</l>
<c></c>
<l>intind := 0</l>
<l>xintc := ix1</l>
<l>yintc := iy1</l>
<l>xintn := ix1</l>
<l>yintn := iy1</l>
<c></c>
<l>xpb := ix1</l>
<l>ypb := iy1</l>
<l>xc := ix1</l>
<l>yc := iy1</l>
<l>xn := ix1</l>
<l>yn := iy1</l>
<c></c>
<l>vp := 0</l>
<l>vc := 0</l>
<l>vn := 0</l>
<l>* gen_region_points (R1Out, iy1, ix1)</l>
<l>PPx := []</l>
<l>PPy := []</l>
<l>Pval := []</l>
<l>g0 := [0,0,0]</l>
<l>g1 := [0,0,0]</l>
<c>* *******main cycle***********************</c>
<l>ix := ix1</l>
<l>iy := iy1</l>
<l>cnt := 0</l>
<l>error := deltaX - deltaY</l>
<l>pind := 0</l>
<l>ic:=-1</l>
<c></c>
<l>gen_empty_obj(PC)</l>
<c></c>
<c>* filling in Bresenham's array</c>
<l>while (ix != ix2 or iy != iy2)</l>
<l>    if( ix==ixc and iy==iyc)</l>
<l>        ic:=pind</l>
<l>    endif</l>
<l>*     gen_region_points (RR, iy, ix)</l>
<l>    get_grayval (Im, iy, ix, v)</l>
<l>    PPx := [PPx,ix]</l>
<l>    PPy := [PPy,iy]</l>
<l>    Pval := [Pval,v]</l>
<l>    error2 := error * 2</l>
<l>    if (error2 &gt; -deltaY)</l>
<l>        error := error-deltaY</l>
<l>        ix := ix+signX</l>
<l>    endif</l>
<l>    if (error2 &lt; deltaX)</l>
<l>        error := error+deltaX</l>
<l>        iy := iy+signY</l>
<l>    endif</l>
<l>    pind := pind+1</l>
<l>endwhile</l>
<l>gen_region_points (PPR, PPy, PPx)</l>
<l>gen_region_points(PC, iyc, ixc)</l>
<l>* dev_display(PPR)</l>
<c></c>
<l>tuple_min(Pval, minPVal)</l>
<c></c>
<c></c>
<c>*</c>
<l>return()</l>
<c>***********************************************************</c>
<c>***********************************************************</c>
<c></c>
</body>
<docu id="SpMeasGray">
<parameters>
<parameter id="Im"/>
<parameter id="ix1"/>
<parameter id="ix2"/>
<parameter id="ixc"/>
<parameter id="iy1"/>
<parameter id="iy2"/>
<parameter id="iyc"/>
<parameter id="minPVal"/>
</parameters>
</docu>
</procedure>
<procedure name="PlotT">
<interface>
<ic>
<par name="Tuple" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_open_window (0, 0, 1194, 519, 'white', TmpCtrl_Handle)</l>
<l>TmpCtrl_LimitNames := ['start_x','end_x','start_y','end_y']</l>
<l>tuple_length(Tuple, tl)</l>
<l>tuple_max(Tuple, tmax)</l>
<l>tuple_min(Tuple, tmin)</l>
<l>TmpCtrl_LimitValues := [0, tl, tmin, tmax]</l>
<l>TmpCtrl_GenParamNames := ['axes_color','ticks_x','ticks_y','grid_x','grid_y',TmpCtrl_LimitNames]</l>
<l>TmpCtrl_GenParamValues := ['black', 2000, 10, 2000, 10, TmpCtrl_LimitValues]</l>
<l>dev_clear_window ()</l>
<l>plot_tuple (TmpCtrl_Handle, [], [], '', 'Tuple', 'none', TmpCtrl_GenParamNames, TmpCtrl_GenParamValues)</l>
<l>plot_tuple (TmpCtrl_Handle, [], Tuple, '', '', 'blue', ['axes_color', 'style', TmpCtrl_LimitNames], ['none','line', TmpCtrl_LimitValues])</l>
<l>return ()</l>
</body>
<docu id="PlotT">
<parameters>
<parameter id="Tuple"/>
</parameters>
</docu>
</procedure>
<procedure name="FixThinSpace">
<interface>
<io>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="DomainG" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionInoDr" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>get_system('neighborhood', nb)</l>
<l>set_system('neighborhood', 4)</l>
<l>* smallest_rectangle1(RegionInoD, Row11, Column11, Row21, Column21)</l>
<l>* gen_rectangle1(DomR, Row11, Column11, Row21, Column21) </l>
<l>DomR:=DomainG</l>
<l>difference(DomR,RegionInoD,  RegionInoDCr)</l>
<l>connection(RegionInoDCr, RegionsInoDCr)</l>
<l>select_shape(RegionsInoDCr, RegionsInoDCrs, 'area', 'and', 150, 99999999)</l>
<l>* select_obj(RegionsInoDCr, RegionInoDCr, 1)</l>
<l>union1(RegionsInoDCrs, RegionInoDCr)</l>
<l>difference(DomR,RegionInoDCr,  RegionInoDr)</l>
<l>connection(RegionInoDr, RegionsInoDr)</l>
<l>set_system('neighborhood', nb)</l>
<l>return ()</l>
</body>
<docu id="FixThinSpace">
<parameters>
<parameter id="DomainG"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoDr"/>
</parameters>
</docu>
</procedure>
<procedure name="SavePars1">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="elongLG" base_type="ctrl" dimension="0"/>
<par name="minPSklen" base_type="ctrl" dimension="0"/>
<par name="lpnum2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TeachParsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**************************************</c>
<c>***** Teaching Parameters setting ****</c>
<c>**************************************</c>
<l>* GNDamin := 410000</l>
<l>* fwmhw:=12.5</l>
<l>* parop:=2.5</l>
<c>**** for skeletons *******</c>
<l>* gap:=1</l>
<l>* jrad:=10</l>
<c></c>
<l>* groundpn:=1 </l>
<c></c>
<l>* groundgval:=3</l>
<l>* sm_factor:=7</l>
<l>* lookaround:=7</l>
<l>* wpl:=15.5</l>
<l>* smoothCADcontours:=1</l>
<l>* maxdirSP:=40</l>
<l>* wFWM:=[30,40]</l>
<l>* wside:=5</l>
<l>* wFWMS:=[20,31]</l>
<l>* wsideS:=3</l>
<l>* eradMSe:=9</l>
<l>* eradNFWMremove:=9</l>
<l>* elengthend:=-1</l>
<l>* elengthnoend:=-25</l>
<l>* jpadd:=3</l>
<l>* removeGNDfromFWM:=0</l>
<l>* cutendMSS:=25</l>
<l>* minWGS:=3</l>
<l>* minWG:=4</l>
<l>* useODB:=0</l>
<l>* autowidth:=1</l>
<l>* EPexp:=5</l>
<l>* elongLG:=10</l>
<c>***********************************</c>
<l>TeachParsOut:=[GNDamin, fwmhw, parop, jrad, gap, groundpn, groundgval, sm_factor, lookaround, wpl, smoothCADcontours, maxdirSP, wFWM, wside, wFWMS, wsideS, eradMSe, eradNFWMremove, elengthend, elengthnoend, jpadd, removeGNDfromFWM, cutendMSS, minWGS, minWG, useODB, autowidth, EPexp, elongLG, minPSklen,lpnum2]</l>
<l>serialize_tuple(TeachParsOut, SerializedItemHandle)</l>
<l>* fileser := pathfile+'/Teach/TeachPars.ser'</l>
<l>open_file(pathfile, 'output_binary', FileHandle)</l>
<l>fwrite_serialized_item(FileHandle, SerializedItemHandle)</l>
<l>close_file(FileHandle)</l>
<l>return ()</l>
</body>
<docu id="SavePars1">
<parameters>
<parameter id="EPexp"/>
<parameter id="GNDamin"/>
<parameter id="TeachParsOut"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elongLG"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="lpnum2"/>
<parameter id="maxdirSP"/>
<parameter id="minPSklen"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="parop"/>
<parameter id="pathfile"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="MakeandSavePars1">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TeachParsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**************************************</c>
<c>***** Teaching Parameters setting ****</c>
<c>**************************************</c>
<l>GNDamin := 410000</l>
<l>fwmhw:=12.5</l>
<l>parop:=2.5</l>
<c>**** for skeletons *******</c>
<l>gap:=1</l>
<l>jrad:=10</l>
<c></c>
<l>groundpn:=1 </l>
<l>* groundpn:=TeachPars[0]</l>
<c></c>
<l>groundgval:=3</l>
<l>sm_factor:=7</l>
<l>lookaround:=7</l>
<l>wpl:=15.5</l>
<l>smoothCADcontours:=1</l>
<l>maxdirSP:=40</l>
<l>wFWM:=[30,40]</l>
<l>wside:=5</l>
<l>wFWMS:=[20,31]</l>
<l>wsideS:=3</l>
<l>eradMSe:=9</l>
<l>eradNFWMremove:=9</l>
<l>elengthend:=-1</l>
<l>elengthnoend:=-25</l>
<l>jpadd:=3</l>
<l>removeGNDfromFWM:=0</l>
<l>cutendMSS:=25</l>
<l>minWGS:=3</l>
<l>minWG:=4</l>
<l>useODB:=0</l>
<l>autowidth:=1</l>
<l>EPexp:=5</l>
<l>elongLG:=10</l>
<c>***********************************</c>
<l>TeachParsOut:=[GNDamin, fwmhw, parop, jrad, gap, groundpn, groundgval, sm_factor, lookaround, wpl, smoothCADcontours, maxdirSP, wFWM, wside, wFWMS, wsideS, eradMSe, eradNFWMremove, elengthend, elengthnoend, jpadd, removeGNDfromFWM, cutendMSS, minWGS, minWG, useODB, autowidth, EPexp, elongLG]</l>
<l>serialize_tuple(TeachParsOut, SerializedItemHandle)</l>
<l>* fileser := pathfile+'/Teach/TeachPars.ser'</l>
<l>open_file(pathfile, 'output_binary', FileHandle)</l>
<l>fwrite_serialized_item(FileHandle, SerializedItemHandle)</l>
<l>close_file(FileHandle)</l>
<l>return ()</l>
</body>
<docu id="MakeandSavePars1">
<parameters>
<parameter id="TeachParsOut"/>
<parameter id="pathfile"/>
</parameters>
</docu>
</procedure>
<procedure name="LoadPars1">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
<par name="SetDefault" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="elongLG" base_type="ctrl" dimension="0"/>
<par name="minPSklen" base_type="ctrl" dimension="0"/>
<par name="lpnum2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *************************************</c>
<c>* **** Teaching deserialization   *****</c>
<c>* *************************************</c>
<l>if (SetDefault == 1)</l>
<l>    GNDamin := 410000</l>
<l>    fwmhw := 12.5</l>
<l>    parop := 2.5</l>
<c>    * *** for skeletons *******</c>
<l>    gap := 1</l>
<l>    jrad := 10</l>
<c>    </c>
<l>    groundpn := 1</l>
<l>*     groundpn := TeachPars[0]</l>
<c>    </c>
<l>    groundgval := 3</l>
<l>    sm_factor := 7</l>
<l>    lookaround := 7</l>
<l>    wpl := 15.5</l>
<l>    smoothCADcontours := 1</l>
<l>    maxdirSP := 40</l>
<l>    wFWM := [30,40]</l>
<l>    wside := 9</l>
<l>    wFWMS := [20,31]</l>
<l>    wsideS := 3</l>
<l>    eradMSe := 9</l>
<l>    eradNFWMremove := 9</l>
<l>    elengthend := -1</l>
<l>    elengthnoend := -25</l>
<l>    jpadd := 3</l>
<l>    removeGNDfromFWM := 0</l>
<l>    cutendMSS := 25</l>
<l>    minWGS := 3</l>
<l>    minWG := 4</l>
<l>    useODB := 0</l>
<l>    autowidth := 1</l>
<l>    EPexp := 5</l>
<l>    elongLG := 10</l>
<l>    minPSklen:=200</l>
<l>    lpnum2:=30</l>
<l>else</l>
<l>    open_file (pathfile, 'input_binary', FileHandleIn)</l>
<l>    fread_serialized_item (FileHandleIn, SerializedItemHandle1)</l>
<l>    deserialize_tuple (SerializedItemHandle1, TeachParsIn)</l>
<l>    close_file (FileHandleIn)</l>
<l>*     tuple_equal(TeachParsIn, TeachParsOut, equal)</l>
<l>*     stop ()</l>
<c>    </c>
<l>    TeachPars := TeachParsIn</l>
<l>    i := 0</l>
<l>    GNDamin := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    fwmhw := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    parop := TeachPars[i]</l>
<l>    i := i+1</l>
<c>    * *** for skeletons *******</c>
<l>    jrad := TeachPars[i]</l>
<l>    i := i+1</l>
<c></c>
<l>    gap := TeachPars[i]</l>
<l>    i := i+1</l>
<c>    </c>
<l>    groundpn := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    groundgval := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    sm_factor := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    lookaround := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    wpl := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    smoothCADcontours := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    maxdirSP := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    wFWM := [TeachPars[i],TeachPars[i+1]]</l>
<l>    i := i+2</l>
<l>    wside := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    wFWMS := [TeachPars[i],TeachPars[i+1]]</l>
<l>    i := i+2</l>
<l>    wsideS := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    eradMSe := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    eradNFWMremove := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    elengthend := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    elengthnoend := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    jpadd := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    removeGNDfromFWM := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    cutendMSS := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    minWGS := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    minWG := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    useODB := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    autowidth := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    EPexp := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    elongLG := TeachPars[i]</l>
<l>    i := i+1</l>
<l>    minPSklen := TeachPars[i] </l>
<l>    i := i+1</l>
<l>    lpnum2 := TeachPars[i]  </l>
<l>endif</l>
<c></c>
<c></c>
<c>* **********************************</c>
<l>return ()</l>
</body>
<docu id="LoadPars1">
<parameters>
<parameter id="EPexp"/>
<parameter id="GNDamin"/>
<parameter id="SetDefault"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elongLG"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="lpnum2"/>
<parameter id="maxdirSP"/>
<parameter id="minPSklen"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="parop"/>
<parameter id="pathfile"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
<procedure name="LoadInspectionPars1">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
<par name="SetDefault" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="aphmax" base_type="ctrl" dimension="0"/>
<par name="dilS" base_type="ctrl" dimension="0"/>
<par name="dilFWM" base_type="ctrl" dimension="0"/>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="lMB" base_type="ctrl" dimension="0"/>
<par name="prcMB" base_type="ctrl" dimension="0"/>
<par name="absMB" base_type="ctrl" dimension="0"/>
<par name="minMB" base_type="ctrl" dimension="0"/>
<par name="lSP" base_type="ctrl" dimension="0"/>
<par name="prcSP" base_type="ctrl" dimension="0"/>
<par name="absSP" base_type="ctrl" dimension="0"/>
<par name="minSP" base_type="ctrl" dimension="0"/>
<par name="sz1" base_type="ctrl" dimension="0"/>
<par name="lMBS" base_type="ctrl" dimension="0"/>
<par name="sz2" base_type="ctrl" dimension="0"/>
<par name="ang" base_type="ctrl" dimension="0"/>
<par name="prcMBS" base_type="ctrl" dimension="0"/>
<par name="absMBS" base_type="ctrl" dimension="0"/>
<par name="minMBS" base_type="ctrl" dimension="0"/>
<par name="minWSpace" base_type="ctrl" dimension="0"/>
<par name="dclcmax" base_type="ctrl" dimension="0"/>
<par name="LG_SensLen" base_type="ctrl" dimension="0"/>
<par name="LG_m_szw" base_type="ctrl" dimension="0"/>
<par name="LG_m_prcLG" base_type="ctrl" dimension="0"/>
<par name="mmat_shift" base_type="ctrl" dimension="0"/>
<par name="mmat_fsz" base_type="ctrl" dimension="0"/>
<par name="PHash" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *************************************</c>
<c>* **** Inspection deserialization   *****</c>
<c>* *************************************</c>
<l>if (SetDefault == 1)</l>
<l>    thr:=88</l>
<c>    </c>
<c>    *****</c>
<l>    fumax:=1000</l>
<c>**** Comp</c>
<l>* aislmax:=8000</l>
<c>****LG</c>
<l>aislmax:=8000</l>
<l>PHrmin:=3.0</l>
<l>PHamin:=5</l>
<c></c>
<l>Islrmin:=2</l>
<l>Islamin:=10</l>
<l>*aislmax:=300</l>
<l>aphmax:=300</l>
<c></c>
<c></c>
<c>********** Short</c>
<l>dilS:=9.5</l>
<l>* Ops:=2.5</l>
<l>* ClS:=2.5</l>
<l>dilFWM:=10</l>
<c></c>
<c>**** for FWMS</c>
<l>expsize:=19.5</l>
<c>**** for FWMS</c>
<l>dil := 7</l>
<l>EPexp:=5</l>
<c></c>
<l>lMB:=1</l>
<l>prcMB:=40.</l>
<l>absMB:=30.</l>
<l>minMB:=1.5</l>
<l>lSP:=1</l>
<l>prcSP:=30.</l>
<l>absSP:=10.</l>
<l>minSP:=1.5</l>
<l>sz1:=51</l>
<l>lMBS:=0</l>
<l>sz2:=50</l>
<l>ang:=3.</l>
<l>prcMBS:=30.</l>
<l>absMBS:=10.</l>
<l>minMBS:=4.5</l>
<l>minWSpace:=0.4</l>
<l>dclcmax:=72</l>
<l>LG_SensLen:=50</l>
<l>LG_m_szw:=8</l>
<l>LG_m_prcLG:=20</l>
<l>mmat_shift:=20</l>
<l>mmat_fsz:=91</l>
<c></c>
<c>*// if pinhole area is bigger the value, than it's not removed from ho_RegionInoPhnoIsl (used in ThresholdPHIsp() )</c>
<c></c>
<l>PHash := 200 </l>
<l>else</l>
<l>    open_file (pathfile, 'input_binary', FileHandleIn)</l>
<l>    fread_serialized_item (FileHandleIn, SerializedItemHandle1)</l>
<l>    deserialize_tuple (SerializedItemHandle1, InspectionParsIn)</l>
<l>    close_file (FileHandleIn)</l>
<l>*     tuple_equal(InspectionParsIn, InspectionParsOut, equal)</l>
<l>*     stop ()</l>
<c>    </c>
<l>    InspectionPars := InspectionParsIn</l>
<l>    i := 0</l>
<l>    thr := InspectionParsIn[i]</l>
<l>    i := i+1</l>
<l>    fumax := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    aislmax := InspectionPars[i]</l>
<l>    i := i+1</l>
<c>    * *** for skeletons *******</c>
<l>    PHrmin := InspectionPars[i]</l>
<l>    i := i+1</l>
<c></c>
<l>    PHamin := InspectionPars[i]</l>
<l>    i := i+1</l>
<c>    </c>
<l>    Islrmin := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    aislmax := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    aphmax := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    dilS := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    dilFWM := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    expsize := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    dil := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    EPexp := InspectionPars[i]</l>
<c>    *</c>
<l>    i := i+1</l>
<l>    lMB := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    prcMB := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    absMB := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    minMB := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    lSP := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    prcSP := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    absSP := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    minSP := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    sz1 := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    lMBS := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    sz2 := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    ang := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    prcMBS := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    absMBS := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    minMBS := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    minWSpace := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    dclcmax := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    LG_SensLen := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    LG_m_szw := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    LG_m_prcLG := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    mmat_shift := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    mmat_fsz := InspectionPars[i]</l>
<l>    i := i+1</l>
<l>    PHash := InspectionPars[i]</l>
<c>   </c>
<l>endif</l>
<c></c>
<c></c>
<c>* **********************************</c>
<l>return ()</l>
</body>
<docu id="LoadInspectionPars1">
<parameters>
<parameter id="EPexp"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="LG_SensLen"/>
<parameter id="LG_m_prcLG"/>
<parameter id="LG_m_szw"/>
<parameter id="PHamin"/>
<parameter id="PHash"/>
<parameter id="PHrmin"/>
<parameter id="SetDefault"/>
<parameter id="absMB"/>
<parameter id="absMBS"/>
<parameter id="absSP"/>
<parameter id="aislmax"/>
<parameter id="ang"/>
<parameter id="aphmax"/>
<parameter id="dclcmax"/>
<parameter id="dil"/>
<parameter id="dilFWM"/>
<parameter id="dilS"/>
<parameter id="expsize"/>
<parameter id="fumax"/>
<parameter id="lMB"/>
<parameter id="lMBS"/>
<parameter id="lSP"/>
<parameter id="minMB"/>
<parameter id="minMBS"/>
<parameter id="minSP"/>
<parameter id="minWSpace"/>
<parameter id="mmat_fsz"/>
<parameter id="mmat_shift"/>
<parameter id="pathfile"/>
<parameter id="prcMB"/>
<parameter id="prcMBS"/>
<parameter id="prcSP"/>
<parameter id="sz1"/>
<parameter id="sz2"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS42B3">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
<par name="stopperT" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBS42B3 - 18.04.2023 - removed difference for regions tuple</c>
<c>** 12/09/2024 - changed to cut of the ends using rec2</c>
<l>ImIRBSOut := ImIRBS</l>
<c></c>
<l>junctions_skeleton(SkeletonsFWMS, SkelSEP, JuncPoints)</l>
<l>union1(SkelSEP, SkelSEPu)</l>
<l>union1(SkeletonsFWMS,hoSkeletonFWMS)</l>
<c></c>
<l>* count_obj(SkelSEP, nSEP)</l>
<l>get_region_points(SkelSEPu, RowsSEP, ColumnsSEP)</l>
<l>get_grayval(DirImageS, RowsSEP, ColumnsSEP, AngS)</l>
<l>get_grayval(WidthImageS, RowsSEP, ColumnsSEP, WidthS)</l>
<l>* AngS:=[AngS, 17,232]</l>
<l>* RowsSEP:=[RowsSEP, 913,663]</l>
<l>* ColumnsSEP:=[ColumnsSEP, 257,2254]</l>
<l>* WidthS:=[WidthS, 31,31]</l>
<c></c>
<l>Phi:=(AngS-128.)/255.*3.14-3.14/2.</l>
<l>* AngSt:=(AngS)/255.*3.14</l>
<l>* AngEnd:=(AngS)/255.*3.14+3.14</l>
<l>tuple_length(AngS, nEPS)</l>
<l>stopperT:=7</l>
<l>tuple_gen_const(nEPS,stopperT, LSt)</l>
<l>gen_rectangle2(R2, RowsSEP, ColumnsSEP, Phi, WidthS/2.+13, LSt+4)</l>
<c>******* changed on 2025.03.18</c>
<l>gen_empty_obj(RSt)</l>
<l>tuple_length(RowsSEP, n)</l>
<l>for j:=1 to n by 1</l>
<l>    select_obj(R2, R2s, j)</l>
<l>    intersection(R2s, SkeletonGS, RegionIntersection)</l>
<l>    junctions_skeleton(RegionIntersection, EndPoints1, JuncPoints1)</l>
<l>    difference(EndPoints1, hoSkeletonFWMS, StCent)</l>
<l>    get_region_points(StCent, RowsStC, ColumnsStC)</l>
<l>    gen_rectangle2(RStj, RowsStC, ColumnsStC, Phi[j-1], WidthS[j-1]/2.+15, LSt[j-1]+2)</l>
<l>    concat_obj(RSt,RStj,RSt)</l>
<l>endfor</l>
<l>gen_region_points(Region, RowsStC, ColumnsStC)</l>
<c>* changed to upper on 2025.03.18 because in rare case sequence of points changes</c>
<l>* gen_circle_sector(CircleSector, RowsSEP, ColumnsSEP, WidthS/2.+3, AngSt, AngEnd)</l>
<l>* intersection(R2, SkeletonGS, RegionIntersection)</l>
<l>* junctions_skeleton(RegionIntersection, EndPoints1, JuncPoints1)</l>
<l>* difference(EndPoints1, hoSkeletonFWMS, StCents)</l>
<l>* union1(StCents, StCentsu)</l>
<l>* get_region_points(StCentsu, RowsStC, ColumnsStC)</l>
<l>* gen_rectangle2(RSt, RowsStC, ColumnsStC, Phi, WidthS/2.+9, LSt+2)</l>
<c></c>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>* dil := 5</l>
<l>dilation_circle (SkeletonsFWMScut, SkeletonsFWMSd, dil)</l>
<l>count_obj (SkeletonsFWMSd, no)</l>
<c></c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMSd, RegionInoDC, SkeletonsFWMSmi)</l>
<c></c>
<l>difference(SkeletonsFWMSmi, RSt, SkeletonsFWMSm)</l>
<c></c>
<l>* difference(SkelEP, SkeletonsFWMSd, SkelEP1)</l>
<l>difference(RSt, RegionInoD, RStm)</l>
<l>union2(RegionInoD, RSt, RegForbid)</l>
<l>* expsize:=101</l>
<l>expand_region (SkeletonsFWMSm, RegForbid, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMSm, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMS, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* difference(RegionsFWMS2i, SkelEP1, RegionsFWMS2)</l>
<l>count_obj (SkeletonsFWMScut, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (2, nRFWMS+1, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS2, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS2, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS42B3">
<parameters>
<parameter id="DirImageS"/>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="WidthImageS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
<parameter id="stopperT"/>
</parameters>
</docu>
</procedure>
<procedure name="SaveInspectionPars1">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="fumax" base_type="ctrl" dimension="0"/>
<par name="aislmax" base_type="ctrl" dimension="0"/>
<par name="PHrmin" base_type="ctrl" dimension="0"/>
<par name="PHamin" base_type="ctrl" dimension="0"/>
<par name="Islrmin" base_type="ctrl" dimension="0"/>
<par name="Islamin" base_type="ctrl" dimension="0"/>
<par name="aphmax" base_type="ctrl" dimension="0"/>
<par name="dilS" base_type="ctrl" dimension="0"/>
<par name="dilFWM" base_type="ctrl" dimension="0"/>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="lMB" base_type="ctrl" dimension="0"/>
<par name="prcMB" base_type="ctrl" dimension="0"/>
<par name="absMB" base_type="ctrl" dimension="0"/>
<par name="minMB" base_type="ctrl" dimension="0"/>
<par name="lSP" base_type="ctrl" dimension="0"/>
<par name="prcSP" base_type="ctrl" dimension="0"/>
<par name="absSP" base_type="ctrl" dimension="0"/>
<par name="minSP" base_type="ctrl" dimension="0"/>
<par name="sz1" base_type="ctrl" dimension="0"/>
<par name="lMBS" base_type="ctrl" dimension="0"/>
<par name="sz2" base_type="ctrl" dimension="0"/>
<par name="ang" base_type="ctrl" dimension="0"/>
<par name="prcMBS" base_type="ctrl" dimension="0"/>
<par name="absMBS" base_type="ctrl" dimension="0"/>
<par name="minMBS" base_type="ctrl" dimension="0"/>
<par name="minWSpace" base_type="ctrl" dimension="0"/>
<par name="dclcmax" base_type="ctrl" dimension="0"/>
<par name="LG_SensLen" base_type="ctrl" dimension="0"/>
<par name="LG_m_szw" base_type="ctrl" dimension="0"/>
<par name="LG_m_prcLG" base_type="ctrl" dimension="0"/>
<par name="mmat_shift" base_type="ctrl" dimension="0"/>
<par name="mmat_fsz" base_type="ctrl" dimension="0"/>
<par name="PHash" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* *************************************</c>
<c>* **** Inspection main param. serialization   *****</c>
<c>* *************************************</c>
<c></c>
<l>InspectParsOut:=[autothr, thr, \
                 PrcMBS, PrcSPS,minMBS, narWSpace,szS,\
                 PrcMBP, PrcSPP,pabs, minwp,narrowwp,widewp,szP,\
                 LG_m_prsLG_P,LG_m_szw_P,LG_m_Avg_Par,LG_m_prsLG_S, LG_m_szw_S ]</l>
<c></c>
<c></c>
<l>serialize_tuple(InspectParsOut, SerializedItemHandle)</l>
<l>* fileser := pathfile+'/Teach/TeachPars.ser'</l>
<l>open_file(pathfile, 'output_binary', FileHandle)</l>
<l>fwrite_serialized_item(FileHandle, SerializedItemHandle)</l>
<l>close_file(FileHandle)</l>
<c> </c>
<c>* **********************************</c>
<l>return ()</l>
</body>
<docu id="SaveInspectionPars1">
<parameters>
<parameter id="EPexp"/>
<parameter id="Islamin"/>
<parameter id="Islrmin"/>
<parameter id="LG_SensLen"/>
<parameter id="LG_m_prcLG"/>
<parameter id="LG_m_szw"/>
<parameter id="PHamin"/>
<parameter id="PHash"/>
<parameter id="PHrmin"/>
<parameter id="absMB"/>
<parameter id="absMBS"/>
<parameter id="absSP"/>
<parameter id="aislmax"/>
<parameter id="ang"/>
<parameter id="aphmax"/>
<parameter id="dclcmax"/>
<parameter id="dil"/>
<parameter id="dilFWM"/>
<parameter id="dilS"/>
<parameter id="expsize"/>
<parameter id="fumax"/>
<parameter id="lMB"/>
<parameter id="lMBS"/>
<parameter id="lSP"/>
<parameter id="minMB"/>
<parameter id="minMBS"/>
<parameter id="minSP"/>
<parameter id="minWSpace"/>
<parameter id="mmat_fsz"/>
<parameter id="mmat_shift"/>
<parameter id="pathfile"/>
<parameter id="prcMB"/>
<parameter id="prcMBS"/>
<parameter id="prcSP"/>
<parameter id="sz1"/>
<parameter id="sz2"/>
<parameter id="thr"/>
</parameters>
</docu>
</procedure>
<procedure name="Unwrap">
<interface>
<ic>
<par name="DSk" base_type="ctrl" dimension="0"/>
<par name="cyc" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DSku" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_length(DSk, n)</l>
<l>DSku:=[]</l>
<l>dp:=DSk[0]</l>
<l>for i:=0 to n-1 by 1</l>
<l>    d:=DSk[i]</l>
<l>*     dp:=DSk[i-1]</l>
<l>    dif:=d-dp</l>
<l>    if(dif&lt;-cyc/2)</l>
<l>        DSku[i]:=DSk[i]+cyc</l>
<l>    elseif(dif&gt;128)</l>
<l>        DSku[i]:=DSk[i]-cyc</l>
<l>    else</l>
<l>        DSku[i]:=d</l>
<l>    endif</l>
<l>    dp:=DSku[i]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="Unwrap">
<parameters>
<parameter id="DSk"/>
<parameter id="DSku"/>
<parameter id="cyc"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildRegionInoD2">
<interface>
<io>
<par name="RegionsSh2" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionInoIslnoPh" base_type="iconic" dimension="0"/>
<par name="RegionOp2" base_type="iconic" dimension="0"/>
<par name="R" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>union1 (RegionsSh2, RegionShUnion)</l>
<l>intersection(RegionShUnion, SkeletonGS, RegionSkIntersection)</l>
<l>dilation_circle(RegionSkIntersection, RegionRemoveSh, 1.5)</l>
<c>******* fixing Shorts ******</c>
<l>difference(RegionInoIslnoPh, RegionRemoveSh, RegionI1noPh5noIsl1noSh1)</l>
<l>* difference(RegionI1noPh5noIsl1, RegionRemoveSh, RegionI1noPh5noIsl1noSh1)</l>
<l>* difference(RegionI2noPh5noIsl1, RegionRemoveSh, RegionI2noPh5noIsl1noSh1)</l>
<l>* difference(RegionI3noPh5noIsl1, RegionRemoveSh, RegionI3noPh5noIsl1noSh1)</l>
<l>* difference(RegionI4noPh5noIsl1, RegionRemoveSh, RegionI4noPh5noIsl1noSh1)</l>
<l>* difference(RegionI5noPh5noIsl1, RegionRemoveSh, RegionI5noPh5noIsl1noSh1)</l>
<c></c>
<l>count_obj (RegionsSh2, nShi)</l>
<l>connection(RegionShUnion, RegionsSh)</l>
<l>count_obj(RegionsSh, nSh)</l>
<c>***** final RegionInoD 1,2,3,4,5 ******</c>
<l>union2 (RegionI1noPh5noIsl1noSh1, RegionOp2, RegionInoDi)</l>
<l>difference(RegionInoDi, R, RegionInoD)</l>
<l>return ()</l>
</body>
<docu id="BuildRegionInoD2">
<parameters>
<parameter id="R"/>
<parameter id="RegionInoD"/>
<parameter id="RegionInoIslnoPh"/>
<parameter id="RegionOp2"/>
<parameter id="RegionsSh2"/>
<parameter id="SkeletonGS"/>
</parameters>
</docu>
</procedure>
<procedure name="GetFWMStandardWidth">
<interface>
<io>
<par name="SkeletonFWMi" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="stdWFWM" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** GetFWMStandardWidth </c>
<c>* 250228</c>
<c></c>
<l>get_region_points(SkeletonFWMi,RowsFWM, ColumnsFWM)</l>
<l>get_grayval(WidthImageP, RowsFWM, ColumnsFWM, GWFWM)</l>
<l>tuple_median (GWFWM, stdWFWM)</l>
<l>return ()</l>
</body>
<docu id="GetFWMStandardWidth">
<parameters>
<parameter id="SkeletonFWMi"/>
<parameter id="WidthImageP"/>
<parameter id="stdWFWM"/>
</parameters>
</docu>
</procedure>
<procedure name="SaveMainInspectionPars">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
<par name="autothr" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="mmat_shift" base_type="ctrl" dimension="0"/>
<par name="PrcMBS" base_type="ctrl" dimension="0"/>
<par name="PrcSPS" base_type="ctrl" dimension="0"/>
<par name="minMBS" base_type="ctrl" dimension="0"/>
<par name="narWSpace" base_type="ctrl" dimension="0"/>
<par name="szS" base_type="ctrl" dimension="0"/>
<par name="PrcMBP" base_type="ctrl" dimension="0"/>
<par name="PrcSPP" base_type="ctrl" dimension="0"/>
<par name="minwp" base_type="ctrl" dimension="0"/>
<par name="narwp" base_type="ctrl" dimension="0"/>
<par name="widewp" base_type="ctrl" dimension="0"/>
<par name="szP" base_type="ctrl" dimension="0"/>
<par name="Prs_P" base_type="ctrl" dimension="0"/>
<par name="szw_P" base_type="ctrl" dimension="0"/>
<par name="Avg_P" base_type="ctrl" dimension="0"/>
<par name="Prs_S" base_type="ctrl" dimension="0"/>
<par name="szw_S" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* *************************************</c>
<c>* **** Inspection serialization   *****</c>
<c>* *************************************</c>
<c></c>
<l>InspectMainParsOut:=[autothr,thr, mmat_shift,\
                 PrcMBS, PrcSPS, minMBS, narWSpace, szS,\
                 PrcMBP, PrcSPP, minwp, narwp, widewp,szP,\
                 Prs_P, szw_P, Avg_P, Prs_S,szw_S]</l>
<c></c>
<l>serialize_tuple(InspectMainParsOut, SerializedItemHandle)</l>
<l>* fileser := pathfile+'/Teach/TeachPars.ser'</l>
<l>open_file(pathfile, 'output_binary', FileHandle)</l>
<l>fwrite_serialized_item(FileHandle, SerializedItemHandle)</l>
<l>close_file(FileHandle)</l>
<c> </c>
<c>* **********************************</c>
<l>return ()</l>
</body>
<docu id="SaveMainInspectionPars">
<parameters>
<parameter id="Avg_P"/>
<parameter id="PrcMBP"/>
<parameter id="PrcMBS"/>
<parameter id="PrcSPP"/>
<parameter id="PrcSPS"/>
<parameter id="Prs_P"/>
<parameter id="Prs_S"/>
<parameter id="autothr"/>
<parameter id="minMBS"/>
<parameter id="minwp"/>
<parameter id="mmat_shift"/>
<parameter id="narWSpace"/>
<parameter id="narwp"/>
<parameter id="pathfile"/>
<parameter id="szP"/>
<parameter id="szS"/>
<parameter id="szw_P"/>
<parameter id="szw_S"/>
<parameter id="thr"/>
<parameter id="widewp"/>
</parameters>
</docu>
</procedure>
<procedure name="GetFWMStandardWidth_COPY_1">
<interface>
<io>
<par name="SkeletonFWMi" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="stdWFWM" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_region_points (SkeletonFWMi, RowsFWM, ColumnsFWM)</l>
<l>get_grayval (WidthImageP, RowsFWM, ColumnsFWM, GWFWM)</l>
<l>tuple_median (GWFWM, stdWFWM)</l>
<l>return ()</l>
</body>
<docu id="GetFWMStandardWidth_COPY_1">
<parameters>
<parameter id="SkeletonFWMi"/>
<parameter id="WidthImageP"/>
<parameter id="stdWFWM"/>
</parameters>
</docu>
</procedure>
<procedure name="SaveInspectionMainPars">
<interface>
<ic>
<par name="pathfile" base_type="ctrl" dimension="0"/>
<par name="autothr" base_type="ctrl" dimension="0"/>
<par name="thr" base_type="ctrl" dimension="0"/>
<par name="PrcMBS" base_type="ctrl" dimension="0"/>
<par name="PrcSPS" base_type="ctrl" dimension="0"/>
<par name="minMBS" base_type="ctrl" dimension="0"/>
<par name="narWSpace" base_type="ctrl" dimension="0"/>
<par name="szS" base_type="ctrl" dimension="0"/>
<par name="PrcMBP" base_type="ctrl" dimension="0"/>
<par name="PrcSPP" base_type="ctrl" dimension="0"/>
<par name="pabs" base_type="ctrl" dimension="0"/>
<par name="minwp" base_type="ctrl" dimension="0"/>
<par name="narrowwp" base_type="ctrl" dimension="0"/>
<par name="widewp" base_type="ctrl" dimension="0"/>
<par name="szP" base_type="ctrl" dimension="0"/>
<par name="LG_m_prsLG_P" base_type="ctrl" dimension="0"/>
<par name="LG_m_szw_P" base_type="ctrl" dimension="0"/>
<par name="LG_m_Avg_Par" base_type="ctrl" dimension="0"/>
<par name="LG_m_prsLG_S" base_type="ctrl" dimension="0"/>
<par name="LG_m_szw_S" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* *************************************</c>
<c>* **** Inspection main param. serialization   *****</c>
<c>* *************************************</c>
<c></c>
<l>InspectParsOut:=[autothr, thr, \
                 PrcMBS, PrcSPS,minMBS, narWSpace,szS,\
                 PrcMBP, PrcSPP,pabs, minwp,narrowwp,widewp,szP,\
                 LG_m_prsLG_P,LG_m_szw_P,LG_m_Avg_Par,LG_m_prsLG_S, LG_m_szw_S ]</l>
<c></c>
<c></c>
<l>serialize_tuple(InspectParsOut, SerializedItemHandle)</l>
<l>* fileser := pathfile+'/Teach/TeachPars.ser'</l>
<l>open_file(pathfile, 'output_binary', FileHandle)</l>
<l>fwrite_serialized_item(FileHandle, SerializedItemHandle)</l>
<l>close_file(FileHandle)</l>
<c> </c>
<c>* **********************************</c>
<l>return ()</l>
</body>
<docu id="SaveInspectionMainPars">
<parameters>
<parameter id="LG_m_Avg_Par"/>
<parameter id="LG_m_prsLG_P"/>
<parameter id="LG_m_prsLG_S"/>
<parameter id="LG_m_szw_P"/>
<parameter id="LG_m_szw_S"/>
<parameter id="PrcMBP"/>
<parameter id="PrcMBS"/>
<parameter id="PrcSPP"/>
<parameter id="PrcSPS"/>
<parameter id="autothr"/>
<parameter id="minMBS"/>
<parameter id="minwp"/>
<parameter id="narWSpace"/>
<parameter id="narrowwp"/>
<parameter id="pabs"/>
<parameter id="pathfile"/>
<parameter id="szP"/>
<parameter id="szS"/>
<parameter id="thr"/>
<parameter id="widewp"/>
</parameters>
</docu>
</procedure>
<procedure name="BuildIRBS42B4">
<interface>
<io>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="RegionInoD" base_type="iconic" dimension="0"/>
<par name="ImIRBS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImIRBSOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="expsize" base_type="ctrl" dimension="0"/>
<par name="nEmpty" base_type="ctrl" dimension="0"/>
<par name="dil" base_type="ctrl" dimension="0"/>
<par name="stopperT" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWMSB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ****BuildIRBS42B4 </c>
<c>***18.04.2023 - removed difference for regions tuple</c>
<c>** 12/09/2024 - changed to cut of the ends using rec2</c>
<c>** 07/05/2025 - changed rec2 not to cut next space</c>
<l>ImIRBSOut := ImIRBS</l>
<c></c>
<l>junctions_skeleton(SkeletonsFWMS, SkelSEP, JuncPoints)</l>
<l>union1(SkelSEP, SkelSEPu)</l>
<l>union1(SkeletonsFWMS,hoSkeletonFWMS)</l>
<c></c>
<l>* count_obj(SkelSEP, nSEP)</l>
<l>get_region_points(SkelSEPu, RowsSEP, ColumnsSEP)</l>
<l>get_grayval(DirImageS, RowsSEP, ColumnsSEP, AngS)</l>
<l>get_grayval(WidthImageS, RowsSEP, ColumnsSEP, WidthS)</l>
<l>* AngS:=[AngS, 17,232]</l>
<l>* RowsSEP:=[RowsSEP, 913,663]</l>
<l>* ColumnsSEP:=[ColumnsSEP, 257,2254]</l>
<l>* WidthS:=[WidthS, 31,31]</l>
<c></c>
<l>Phi:=(AngS-128.)/255.*3.14-3.14/2.</l>
<l>* AngSt:=(AngS)/255.*3.14</l>
<l>* AngEnd:=(AngS)/255.*3.14+3.14</l>
<l>tuple_length(AngS, nEPS)</l>
<l>stopperT:=7</l>
<l>tuple_gen_const(nEPS,stopperT, LSt)</l>
<l>gen_rectangle2(R2, RowsSEP, ColumnsSEP, Phi, WidthS/2.+13, LSt+4)</l>
<c>******* changed on 2025.03.18</c>
<l>gen_empty_obj(RSt)</l>
<l>gen_empty_obj(RegStC)</l>
<l>tuple_length(RowsSEP, n)</l>
<l>for j:=1 to n by 1</l>
<l>    select_obj(R2, R2s, j)</l>
<l>    intersection(R2s, SkeletonGS, RegionIntersection)</l>
<l>    junctions_skeleton(RegionIntersection, EndPoints1, JuncPoints1)</l>
<l>    difference(EndPoints1, hoSkeletonFWMS, StCent)</l>
<l>    get_region_points(StCent, RowsStC, ColumnsStC)</l>
<l>    gen_rectangle2(RStj, RowsStC, ColumnsStC, Phi[j-1], WidthS[j-1]/2.+14, LSt[j-1]+2)</l>
<l>    concat_obj(RSt,RStj,RSt)</l>
<l>    gen_region_points(RStC, RowsStC, ColumnsStC)</l>
<l>    concat_obj(RegStC,RStC,RegStC)</l>
<l>endfor</l>
<c></c>
<c>* changed to upper on 2025.03.18 because in rare case sequence of points changes</c>
<l>* gen_circle_sector(CircleSector, RowsSEP, ColumnsSEP, WidthS/2.+3, AngSt, AngEnd)</l>
<l>* intersection(R2, SkeletonGS, RegionIntersection)</l>
<l>* junctions_skeleton(RegionIntersection, EndPoints1, JuncPoints1)</l>
<l>* difference(EndPoints1, hoSkeletonFWMS, StCents)</l>
<l>* union1(StCents, StCentsu)</l>
<l>* get_region_points(StCentsu, RowsStC, ColumnsStC)</l>
<l>* gen_rectangle2(RSt, RowsStC, ColumnsStC, Phi, WidthS/2.+9, LSt+2)</l>
<c></c>
<c>* * dif. is used to exclude points of SkeletonsFWMS from RegionsFWMS if necessary</c>
<l>* dilation_circle (SkeletonsFWMS, SkeletonsFWMSd, 2.5)</l>
<c>* 1+2</c>
<l>* dil := 5</l>
<l>dilation_circle (SkeletonsFWMScut, SkeletonsFWMSd, dil)</l>
<l>count_obj (SkeletonsFWMSd, no)</l>
<c></c>
<l>smallest_rectangle1 (RegionInoD, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (RecInoD, Row1, Column1, Row2, Column2)</l>
<l>difference (RecInoD, RegionInoD, RegionInoDC)</l>
<l>* area_center(SkeletonsFWMSd, Area, Row, Column)</l>
<l>* tuple_min(Area, Min)</l>
<l>intersection (SkeletonsFWMSd, RegionInoDC, SkeletonsFWMSmi)</l>
<c></c>
<l>difference(SkeletonsFWMSmi, RSt, SkeletonsFWMSm)</l>
<c></c>
<l>* difference(SkelEP, SkeletonsFWMSd, SkelEP1)</l>
<l>difference(RSt, RegionInoD, RStm)</l>
<l>union1(RStm, RStmu)</l>
<l>connection(RStmu, RStm)</l>
<l>count_obj(RStm, nRStm)</l>
<l>union1(RegStC, RegStCu)</l>
<l>gen_empty_obj(RStmm)</l>
<l>for j:=1 to nRStm by 1</l>
<l>    select_obj(RStm, RStmseli, j)</l>
<l>    dilation_circle(RStmseli, RStmsel, 5)</l>
<l>    intersection(RStmsel, RegStCu, RegionIntersection1)</l>
<l>    area_center(RegionIntersection1, Area, Row, Column)</l>
<l>    if (Area)</l>
<l>        concat_obj(RStmm, RStmsel,RStmm)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union2(RegionInoD, RStmm, RegForbid)</l>
<l>* expsize:=101</l>
<l>expand_region (SkeletonsFWMSm, RegForbid, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMSm, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* expand_region (SkeletonsFWMS, RegionInoD, RegionsFWMS2, expsize, 'image')</l>
<l>* difference(RegionsFWMS2i, SkelEP1, RegionsFWMS2)</l>
<l>count_obj (SkeletonsFWMScut, nRFWMS)</l>
<l>stseq := nEmpty+1</l>
<l>overf := 255-stseq</l>
<l>tuple_gen_sequence (2, nRFWMS+1, 1, SequenceINBSi)</l>
<l>SequenceIRBS := SequenceINBSi%overf+stseq</l>
<l>boundary (RegionsFWMS2, RegionsFWMSB, 'inner')</l>
<l>count_obj (RegionsFWMSB, nFWMSB)</l>
<l>paint_region (RegionsFWMS2, ImIRBSOut, ImIRBSOut, 1, 'fill')</l>
<l>paint_region (RegionsFWMSB, ImIRBSOut, ImIRBSOut, SequenceINBSi, 'fill')</l>
<l>return ()</l>
</body>
<docu id="BuildIRBS42B4">
<parameters>
<parameter id="DirImageS"/>
<parameter id="ImIRBS"/>
<parameter id="ImIRBSOut"/>
<parameter id="RegionInoD"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="WidthImageS"/>
<parameter id="dil"/>
<parameter id="expsize"/>
<parameter id="nEmpty"/>
<parameter id="nFWMSB"/>
<parameter id="stopperT"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ncc_matching_results_COPY_1">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Correlation-Based Matching.</c>
<c></c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_ncc_model_region (ModelRegion, ModelID[Index])</l>
<l>        gen_contour_region_xld (ModelRegion, ModelContours, 'border_holes')</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_rotate (HomMat2DIdentity, Angle[Match], 0, 0, HomMat2DRotate)</l>
<l>                hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>                affine_trans_pixel (HomMat2DTranslate, 0, 0, RowTrans, ColTrans)</l>
<l>                gen_cross_contour_xld (Cross, RowTrans, ColTrans, 6, Angle[Match])</l>
<l>                dev_display (Cross)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_ncc_matching_results_COPY_1">
<abstract lang="en_US">The procedure dev_display_ncc_matching_results displays the results of correlation-based matching. 

In ModelID, the NCC models for which results should be displayed are passed. This parameter typically contains the same values that were returned by the operators find_ncc_model or find_ncc_models.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective NCC model, the number of colors has to correspond to the number of NCC models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results.


Row, Column, and Angle contain the position and rotation information of the found instances of the NCC models.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operator find_ncc_models can be used directly.
</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Korrelationsbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Correlation-Based</item>
</chapters>
<example lang="en_US">read_image (Image, 'circle_plate')
* 
gen_rectangle2 (Template, 420, 786, 0, 50, 50)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model1ID)
*
gen_rectangle2 (Template, 710, 790, 0, 100, 100)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model2ID)
*
ModelIDs := [Model1ID,Model2ID]
rotate_image (ImageTemplate, ImageRotate, 10, 'constant')
find_ncc_models (ImageRotate, ModelIDs,  -rad(45), rad(90), 0.8, 2, 0.5, 'true', 0, Row, Column, Angle, Score, Model)
*
dev_display_ncc_matching_results (ModelIDs, ['green', 'blue'], Row, Column, Angle, Model)
</example>
<keywords lang="de_DE">
<item>Ergebnisse des korrelationsbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of correlation-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_ncc_model</item>
<item>find_ncc_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse der korrelationsbasierten Matchings.</short>
<short lang="en_US">Display the results of Correlation-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the NCC models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>ncc_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="SetWpNarrowWide">
<interface>
<io>
<par name="SkeletonFWMi" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="kw" base_type="ctrl" dimension="0"/>
<par name="dw" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="narrowwp" base_type="ctrl" dimension="0"/>
<par name="widewp" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>** SetWpNarrowWide - Auto setting narrowwp and widewp parameters</c>
<c>** 250513</c>
<l>get_region_points(SkeletonFWMi,Rows1, Columns1)</l>
<l>get_grayval(WidthImageP, Rows1, Columns1, Grayval1)</l>
<l>tuple_min(Grayval1, wpmin)</l>
<l>tuple_max(Grayval1, wpmax)</l>
<l>narrowwp:=wpmin*kw/2.</l>
<l>widewp:=wpmax*kw+dw</l>
<l>return ()</l>
</body>
<docu id="SetWpNarrowWide">
<parameters>
<parameter id="SkeletonFWMi"/>
<parameter id="WidthImageP"/>
<parameter id="dw"/>
<parameter id="kw"/>
<parameter id="narrowwp"/>
<parameter id="widewp"/>
</parameters>
</docu>
</procedure>
<procedure name="WriteTeachData">
<interface>
<io>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMi" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="SkeletonsLG" base_type="iconic" dimension="0"/>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="stdWFWM" base_type="ctrl" dimension="0"/>
<par name="pathTeach" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="Pnum2S" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>pathTeachOut := pathTeach</l>
<l>write_tuple (stdWFWM, pathTeachOut+'FWMpar.tup')</l>
<l>* pathTeachOut := 'D:/250307/model/p2209-020t1_LayerL1-T-SHORT1.0-0200_test/Model - new/Teach/'</l>
<l>write_image (Gi, 'tiff', 0, pathTeachOut+'Gi')</l>
<l>gen_image_const(ImageChainLength,'uint2', WidthG, HeightG)</l>
<l>write_image (ImageChainLength, 'tiff', 0, pathTeachOut+'ImCLC.tif')</l>
<l>write_image (WidthImageP, 'tiff', 0, pathTeachOut+'WidthImageP')</l>
<l>write_image (DirImageP, 'tiff', 0, pathTeachOut+'DirImageP')</l>
<l>write_image (WidthImageS, 'tiff', 0, pathTeachOut+'WidthImageS')</l>
<l>write_image (DirImageS, 'tiff', 0, pathTeachOut+'DirImageS')</l>
<c></c>
<l>write_object (RegionG, pathTeachOut+'RegionG')</l>
<l>write_object (RegionGS, pathTeachOut+'RegionGS')</l>
<l>write_object (SkeletonG, pathTeachOut+'SkeletonG')</l>
<l>write_object (SkeletonGS, pathTeachOut+'SkeletonGS')</l>
<c></c>
<l>write_object (RegionsGND, pathTeachOut+'RegionsGND')</l>
<l>write_object (RegionsEMPTY, pathTeachOut+'RegionsEMPTY')</l>
<l>write_object (RegionFWM, pathTeachOut+'RegionFWM')</l>
<c></c>
<l>write_object (RegionsPNSi, pathTeachOut+'RegionsPNSi')</l>
<l>write_object (RegionsPNPi, pathTeachOut+'RegionsPNPi')</l>
<c></c>
<l>write_object (SkeletonsFWMi, pathTeachOut+'SkeletonsFWM')</l>
<l>write_object (SkeletonsFWMS, pathTeachOut+'SkeletonsFWMS')</l>
<l>write_object (SkeletonsFWMcut, pathTeachOut+'SkeletonsFWMcut')</l>
<l>write_object (SkeletonsFWMScut, pathTeachOut+'SkeletonsFWMScut')</l>
<l>write_object (SkeletonsLG, pathTeachOut+'SkeletonsLG')</l>
<l>write_object (RegNoProc, pathTeachOut+'RegNoProc')</l>
<l>write_object (RegionCut, pathTeachOut+'RegionCut')</l>
<l>write_object (SkelEP, pathTeachOut+'SkelSEP')</l>
<c></c>
<c>***********************************</c>
<c>***********************************</c>
<l>* write_object (SkeletonsG, pathTeachOut+'SkeletonsG')</l>
<l>* write_object (SkeletonsFWMi, pathTeachOut+'SkeletonsFWM')</l>
<l>* write_image (ImageIR, 'tiff', 0, pathTeachOut+'ImageIR')</l>
<l>* write_object (RegionsPNi, pathTeachOut+'RegionsPNi')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* write_image (ImDisplacement, 'tiff', 0, pathTeachOut+'ImDisplacement')</l>
<l>* write_object (SkeletonPartsP, pathTeachOut+'SkeletonPartsP')</l>
<l>* write_image (ImageIR16, 'tiff', 0, pathTeachOut+'ImageIR16')</l>
<l>* write_image (ImageIRS, 'tiff', 0, pathTeachOut+'ImageIRS')</l>
<l>* write_object (RegionMS, pathTeachOut+'RegionMS')</l>
<l>stop()</l>
<c>***********************************</c>
<c>*** Teach tuple OUT (FWM only)</c>
<l>pathTeachT := pathTeachOut+'Tuples/'</l>
<l>write_tuple(WG, pathTeachT+'WG.tup')</l>
<l>write_tuple(XC, pathTeachT+'XC.tup')</l>
<l>write_tuple(YC, pathTeachT+'YC.tup')</l>
<l>write_tuple(X1, pathTeachT+'X1.tup')</l>
<l>write_tuple(Y1, pathTeachT+'Y1.tup')</l>
<l>write_tuple(X2, pathTeachT+'X2.tup')</l>
<l>write_tuple(Y2, pathTeachT+'Y2.tup')</l>
<l>write_tuple(Pnum, pathTeachT+'Pnum.tup')</l>
<l>write_tuple(Pnum2, pathTeachT+'Pnum2.tup')</l>
<l>write_tuple(PnumR, pathTeachT+'PnumR.tup')</l>
<l>write_tuple(PaddrR, pathTeachT+'PaddrR.tup')</l>
<l>write_tuple(PaddrC, pathTeachT+'PaddrC.tup')</l>
<l>write_tuple(PregC, pathTeachT+'PregC.tup')</l>
<l>write_tuple(PCinRnum, pathTeachT+'PCinRnum.tup')</l>
<l>write_tuple(PcontR, pathTeachT+'PcontR.tup')</l>
<c></c>
<c></c>
<l>write_tuple(PuseintP, pathTeachT+'PuseintP.tup')</l>
<l>write_tuple (WG, pathTeachOut+'WG.tup')</l>
<c></c>
<c>*** Teach tuple OUT (FWMS only)</c>
<l>write_tuple(WGS, pathTeachT+'WGS.tup')</l>
<l>write_tuple(XCS, pathTeachT+'XCS.tup')</l>
<l>write_tuple(YCS, pathTeachT+'YCS.tup')</l>
<l>write_tuple(X1S, pathTeachT+'X1S.tup')</l>
<l>write_tuple(Y1S, pathTeachT+'Y1S.tup')</l>
<l>write_tuple(X2S, pathTeachT+'X2S.tup')</l>
<l>write_tuple(Y2S, pathTeachT+'Y2S.tup')</l>
<l>write_tuple(PnumS, pathTeachT+'PnumS.tup')</l>
<l>write_tuple(Pnum2S, pathTeachT+'Pnum2S.tup')</l>
<l>write_tuple(PnumRS, pathTeachT+'PnumRS.tup')</l>
<l>write_tuple(PaddrRS, pathTeachT+'PaddrRS.tup')</l>
<l>write_tuple(PaddrCS, pathTeachT+'PaddrCS.tup')</l>
<l>write_tuple(PregCS, pathTeachT+'PregCS.tup')</l>
<l>write_tuple(PCinRnumS, pathTeachT+'PCinRnumS.tup')</l>
<l>write_tuple(PcontRS, pathTeachT+'PcontRS.tup')</l>
<l>read_image (HoImirbs, 'C:/Temp/ho_ImIRBS.hobj')</l>
<l>return ()</l>
</body>
<docu id="WriteTeachData">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="Pnum2S"/>
<parameter id="PnumR"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsFWMi"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsLG"/>
<parameter id="WG"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCS"/>
<parameter id="pathTeach"/>
<parameter id="stdWFWM"/>
</parameters>
</docu>
</procedure>
<procedure name="WriteTeachData1">
<interface>
<io>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="RegionFWM" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMi" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="SkeletonsLG" base_type="iconic" dimension="0"/>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="pathTeach" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="Pnum2S" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>pathTeachOut := pathTeach</l>
<l>* write_tuple (stdWFWM, pathTeachOut+'FWMpar.tup')</l>
<l>* pathTeachOut := 'D:/250307/model/p2209-020t1_LayerL1-T-SHORT1.0-0200_test/Model - new/Teach/'</l>
<l>write_image (Gi, 'tiff', 0, pathTeachOut+'Gi')</l>
<l>gen_image_const(ImageChainLength,'uint2', WidthG, HeightG)</l>
<l>write_image (ImageChainLength, 'tiff', 0, pathTeachOut+'ImCLC.tif')</l>
<l>write_image (WidthImageP, 'tiff', 0, pathTeachOut+'WidthImageP')</l>
<l>write_image (DirImageP, 'tiff', 0, pathTeachOut+'DirImageP')</l>
<l>write_image (WidthImageS, 'tiff', 0, pathTeachOut+'WidthImageS')</l>
<l>write_image (DirImageS, 'tiff', 0, pathTeachOut+'DirImageS')</l>
<c></c>
<l>write_object (RegionG, pathTeachOut+'RegionG')</l>
<l>write_object (RegionGS, pathTeachOut+'RegionGS')</l>
<l>write_object (SkeletonG, pathTeachOut+'SkeletonG')</l>
<l>write_object (SkeletonGS, pathTeachOut+'SkeletonGS')</l>
<c></c>
<l>write_object (RegionsGND, pathTeachOut+'RegionsGND')</l>
<l>write_object (RegionsEMPTY, pathTeachOut+'RegionsEMPTY')</l>
<l>write_object (RegionFWM, pathTeachOut+'RegionFWM')</l>
<c></c>
<l>write_object (RegionsPNSi, pathTeachOut+'RegionsPNSi')</l>
<l>write_object (RegionsPNPi, pathTeachOut+'RegionsPNPi')</l>
<c></c>
<l>write_object (SkeletonsFWMi, pathTeachOut+'SkeletonsFWM')</l>
<l>write_object (SkeletonsFWMS, pathTeachOut+'SkeletonsFWMS')</l>
<l>write_object (SkeletonsFWMcut, pathTeachOut+'SkeletonsFWMcut')</l>
<l>write_object (SkeletonsFWMScut, pathTeachOut+'SkeletonsFWMScut')</l>
<l>write_object (SkeletonsLG, pathTeachOut+'SkeletonsLG')</l>
<l>write_object (RegNoProc, pathTeachOut+'RegNoProc')</l>
<l>write_object (RegionCut, pathTeachOut+'RegionCut')</l>
<l>write_object (SkelEP, pathTeachOut+'SkelSEP')</l>
<c></c>
<c>***********************************</c>
<c>***********************************</c>
<c></c>
<l>* stop()</l>
<c>***********************************</c>
<c>*** Teach tuple OUT (FWM only)</c>
<l>pathTeachT := pathTeachOut+'Tuples/'</l>
<l>write_tuple(WG, pathTeachT+'WG.tup')</l>
<l>write_tuple(XC, pathTeachT+'XC.tup')</l>
<l>write_tuple(YC, pathTeachT+'YC.tup')</l>
<l>write_tuple(X1, pathTeachT+'X1.tup')</l>
<l>write_tuple(Y1, pathTeachT+'Y1.tup')</l>
<l>write_tuple(X2, pathTeachT+'X2.tup')</l>
<l>write_tuple(Y2, pathTeachT+'Y2.tup')</l>
<l>write_tuple(Pnum, pathTeachT+'Pnum.tup')</l>
<l>write_tuple(Pnum2, pathTeachT+'Pnum2.tup')</l>
<l>write_tuple(PnumR, pathTeachT+'PnumR.tup')</l>
<l>write_tuple(PaddrR, pathTeachT+'PaddrR.tup')</l>
<l>write_tuple(PaddrC, pathTeachT+'PaddrC.tup')</l>
<l>write_tuple(PregC, pathTeachT+'PregC.tup')</l>
<l>write_tuple(PCinRnum, pathTeachT+'PCinRnum.tup')</l>
<l>write_tuple(PcontR, pathTeachT+'PcontR.tup')</l>
<c></c>
<c></c>
<l>write_tuple(PuseintP, pathTeachT+'PuseintP.tup')</l>
<l>write_tuple (WG, pathTeachOut+'WG.tup')</l>
<c></c>
<c>*** Teach tuple OUT (FWMS only)</c>
<l>write_tuple(WGS, pathTeachT+'WGS.tup')</l>
<l>write_tuple(XCS, pathTeachT+'XCS.tup')</l>
<l>write_tuple(YCS, pathTeachT+'YCS.tup')</l>
<l>write_tuple(X1S, pathTeachT+'X1S.tup')</l>
<l>write_tuple(Y1S, pathTeachT+'Y1S.tup')</l>
<l>write_tuple(X2S, pathTeachT+'X2S.tup')</l>
<l>write_tuple(Y2S, pathTeachT+'Y2S.tup')</l>
<l>write_tuple(PnumS, pathTeachT+'PnumS.tup')</l>
<l>write_tuple(Pnum2S, pathTeachT+'Pnum2S.tup')</l>
<l>write_tuple(PnumRS, pathTeachT+'PnumRS.tup')</l>
<l>write_tuple(PaddrRS, pathTeachT+'PaddrRS.tup')</l>
<l>write_tuple(PaddrCS, pathTeachT+'PaddrCS.tup')</l>
<l>write_tuple(PregCS, pathTeachT+'PregCS.tup')</l>
<l>write_tuple(PCinRnumS, pathTeachT+'PCinRnumS.tup')</l>
<l>write_tuple(PcontRS, pathTeachT+'PcontRS.tup')</l>
<c></c>
<l>* GetFWMStandardWidth (SkeletonFWMi, WidthImageP, stdWFWM)</l>
<l>return ()</l>
</body>
<docu id="WriteTeachData1">
<parameters>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="Pnum2S"/>
<parameter id="PnumR"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PregC"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFWM"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsFWMi"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsLG"/>
<parameter id="WG"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCS"/>
<parameter id="pathTeach"/>
</parameters>
</docu>
</procedure>
<procedure name="MSBuildFWM53">
<interface>
<io>
<par name="SkeletonsGThin" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="notusedint" base_type="ctrl" dimension="0"/>
<par name="lpnum2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="Puseint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**** MSBuildFWM52 </c>
<c>**** 2024.02.19 - Pnum2 near changes of Pnum</c>
<c>**** 2022.06.17 - added Puseint - used intersection points tuple</c>
<c>****</c>
<l>RowSkTh := []</l>
<l>ColSkTh := []</l>
<c>* * pnum corresponding to current MS</c>
<l>Pnum := []</l>
<c>* * pnum corresponding to current MS near cuts</c>
<l>Pnum2 := []</l>
<c>* * pnum corresponding to region</c>
<l>PnumR := []</l>
<c>* * start address of a contour</c>
<l>PaddrC := []</l>
<c>* * start address for region</c>
<l>PaddrR := []</l>
<c>* * Region number corresponding to contour</c>
<l>PregC := []</l>
<c>* * number of countours per region</c>
<l>PCinRnum := []</l>
<c>* * 1st Contour number corresponding to region</c>
<l>PcontR := []</l>
<c>* * saving intersect. points for current MS ==1, not saving ==0</c>
<l>Puseint := []</l>
<l>paddrC := 0</l>
<l>paddrR := 0</l>
<l>pcont := 0</l>
<l>tuple_gen_const (notusedint, 0, Notused)</l>
<l>tuple_gen_sequence (0, notusedint-1, 1, Beg)</l>
<c></c>
<l>count_obj (SkeletonsGThin, nSGThin)</l>
<l>for j := 1 to nSGThin by 1</l>
<l>*     if (j==871)</l>
<l>*         stop ()</l>
<l>*     endif</l>
<c></c>
<l>*     j:=871</l>
<l>    select_obj (SkeletonsGThin, ObjectSelected1, j)</l>
<l>    area_center (ObjectSelected1, a, r, c)</l>
<c>    * *** empty regions (no skeleton FWM inside of RegiondPNi[j]</c>
<l>    pnumr := -1</l>
<l>*     RowSkTh := 0</l>
<l>*     ColSkTh := 0</l>
<l>    npreg := 0</l>
<l>    if (a&gt;0)</l>
<c>        * *** non-empty regions</c>
<l>        get_region_points (ObjectSelected1, R, C)</l>
<l>        tuple_length (R, nsp)</l>
<c></c>
<l>        get_grayval (ImageIR, R, C, PnValr)</l>
<l>        tuple_median (PnValr, pnumr)</l>
<l>*         tuple_max(Val,vmax)</l>
<l>*         if(vmax!=j)</l>
<l>*             stop()</l>
<l>*         endif</l>
<c></c>
<c>        * * contour is used to avoid points discontinuation ***</c>
<l>        gen_contours_skeleton_xld (ObjectSelected1, Contours, 1, 'filter')</l>
<l>        count_obj (Contours, nC)</l>
<l>        tuple_concat (PCinRnum, nC, PCinRnum)</l>
<c></c>
<l>        tuple_concat (PcontR, pcont, PcontR)</l>
<l>        pcont := pcont+nC</l>
<c></c>
<l>        for jj := 1 to nC by 1</l>
<l>            select_obj (Contours, Contour, jj)</l>
<l>            get_contour_xld (Contour, R, C)</l>
<l>            get_grayval (ImageIR, R, C, PnVal)</l>
<c>            </c>
<l>*             get_grayval (ImageIR, R, C, Val)</l>
<l>*             tuple_median (Val, pnum)</l>
<l>            tuple_length (R, pN)</l>
<c>            </c>
<l>             tuple_gen_const(pN, 1, Pui)</l>
<l>            if(pN &gt;=notusedint*2)</l>
<l>                tuple_gen_sequence (pN-notusedint, pN-1, 1, End)</l>
<l>                tuple_replace(Pui, Beg, Notused, Pui)</l>
<l>                tuple_replace(Pui, End, Notused, Pui)</l>
<l>            endif</l>
<c>            </c>
<c>            **** can't skip any contour, numberings don't match!!!</c>
<l>*             if(pN &lt; 100)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>            tuple_concat (PaddrC, paddrC, PaddrC)</l>
<l>*             pcont := pcont+1</l>
<l>            paddrC := paddrC + pN</l>
<l>            tuple_concat (PregC, j, PregC)</l>
<l>*             if (pN&gt;100)</l>
<l>                tuple_concat (RowSkTh, R, RowSkTh)</l>
<l>                tuple_concat (ColSkTh, C, ColSkTh)</l>
<l>            get_grayval(DirImageP, R, C, Dirs)</l>
<l>            Dirsi:=Dirs</l>
<l>            tuple_length(Dirs, nD)</l>
<l>            for jjj:=0 to nD-2 by 1</l>
<l>*                 if(jjj==641)</l>
<l>*                     stop()</l>
<l>*                 endif</l>
<l>                d:= Dirsi[jjj+1]-Dirsi[jjj+0]</l>
<l>                if(d &gt; 128)</l>
<l>                    d:= d-255</l>
<l>                elseif(d &lt; -128)</l>
<l>                    d:= d+255</l>
<l>                endif</l>
<l>                Dirs[jjj+1]:=Dirs[jjj+0]+d</l>
<l>            endfor</l>
<l>*             endif</l>
<l>            npreg := npreg+pN</l>
<l>            create_funct_1d_array(Dirs, FDirs)</l>
<l>            create_funct_1d_array(Dirsi, FDirsi)</l>
<l>            derivate_funct_1d(FDirs, 'first', Derivative)</l>
<l>            y_range_funct_1d(Derivative, YMin, YMax)</l>
<l>            if(YMin &lt; -20 or YMax &gt; 20)</l>
<l>*                 stop()</l>
<l>            endif</l>
<l>            dev_display(Contour)</l>
<l>            tuple_concat (Puseint, Pui, Puseint)</l>
<l>            tuple_concat (Pnum, PnVal, Pnum)</l>
<l>        endfor</l>
<l>    else</l>
<l>        tuple_concat (PCinRnum, 0, PCinRnum)</l>
<l>        tuple_concat (PcontR, -1, PcontR)</l>
<l>*         tuple_concat (PaddrC, -1, PaddrC)</l>
<l>    endif</l>
<l>    tuple_gen_const (npreg, pnumr, Pn)</l>
<l>*     tuple_concat (Pnum, Pn, Pnum)</l>
<l>    tuple_concat (PnumR, pnumr, PnumR)</l>
<l>    tuple_concat (PaddrR, paddrR, PaddrR)</l>
<c>    </c>
<l>    paddrR := paddrR + npreg</l>
<l>endfor</l>
<c></c>
<c>****** making Pnum2</c>
<l>tuple_length(Pnum, nPnum)</l>
<l>* lpnum2:= 30</l>
<c></c>
<l>for j:=0 to nPnum-1 by 1</l>
<l>    Pnum2[j]:=-1</l>
<l>endfor</l>
<l>pnump:=Pnum[0]</l>
<l>for j:=lpnum2 to nPnum-1 by 1</l>
<l>    pnumc:=Pnum[j]</l>
<l>    if(pnumc!=pnump)</l>
<l>        for jj:=1 to lpnum2 by 1</l>
<l>            Pnum2[j-jj]:=pnumc</l>
<l>            Pnum2[j+jj]:=pnump</l>
<l>        endfor</l>
<l>        Pnum2[j]:=pnump</l>
<l>    endif</l>
<l>    pnump:=pnumc</l>
<l>endfor</l>
<c>* ** test ***</c>
<l>* sj := 1100</l>
<l>* pnum := PnumR[sj-1]</l>
<l>* a := PaddrR[sj-1]</l>
<l>* pnum1 := Pnum[a]</l>
<c>* **************</c>
<l>get_grayval (WidthImageP, RowSkTh, ColSkTh, WG)</l>
<l>get_grayval (DirImageP, RowSkTh, ColSkTh, Dir)</l>
<l>Ang := Dir*1.0*3.1415926/256.0</l>
<l>K:=1.</l>
<l>Y1 := RowSkTh-sin(Ang)*(WG/K+wpl)</l>
<l>X1 := ColSkTh+cos(Ang)*(WG/K+wpl)</l>
<l>Y2 := RowSkTh+sin(Ang)*(WG/K+wpl)</l>
<l>X2 := ColSkTh-cos(Ang)*(WG/K+wpl)</l>
<l>YC := RowSkTh</l>
<l>XC := ColSkTh</l>
<c></c>
<l>* gen_region_points(P2, Y2, X2)</l>
<l>return ()</l>
</body>
<docu id="MSBuildFWM53">
<parameters>
<parameter id="DirImageP"/>
<parameter id="ImageIR"/>
<parameter id="PCinRnum"/>
<parameter id="PaddrC"/>
<parameter id="PaddrR"/>
<parameter id="PcontR"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumR"/>
<parameter id="PregC"/>
<parameter id="Puseint"/>
<parameter id="SkeletonsGThin"/>
<parameter id="WG"/>
<parameter id="WidthImageP"/>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XC"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YC"/>
<parameter id="lpnum2"/>
<parameter id="notusedint"/>
<parameter id="wpl"/>
</parameters>
</docu>
</procedure>
<procedure name="TeachingMain129">
<interface>
<io>
<par name="RegNoProc" base_type="iconic" dimension="0"/>
<par name="Gi" base_type="iconic" dimension="0"/>
<par name="Im" base_type="iconic" dimension="0"/>
<par name="RegionFlash" base_type="iconic" dimension="0"/>
<par name="RegionTrace" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionG" base_type="iconic" dimension="0"/>
<par name="RegionGS" base_type="iconic" dimension="0"/>
<par name="SkeletonG" base_type="iconic" dimension="0"/>
<par name="SkeletonGS" base_type="iconic" dimension="0"/>
<par name="WidthImageP" base_type="iconic" dimension="0"/>
<par name="DirImageP" base_type="iconic" dimension="0"/>
<par name="WidthImageS" base_type="iconic" dimension="0"/>
<par name="DirImageS" base_type="iconic" dimension="0"/>
<par name="SkeletonsG" base_type="iconic" dimension="0"/>
<par name="ImageIR" base_type="iconic" dimension="0"/>
<par name="RegionsPNi" base_type="iconic" dimension="0"/>
<par name="RegionsPNSi" base_type="iconic" dimension="0"/>
<par name="RegionsNFWM" base_type="iconic" dimension="0"/>
<par name="BoundariesNFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWM" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMcut" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMS" base_type="iconic" dimension="0"/>
<par name="SkeletonsLG" base_type="iconic" dimension="0"/>
<par name="SkeletonsFWMScut" base_type="iconic" dimension="0"/>
<par name="RegionsGND" base_type="iconic" dimension="0"/>
<par name="RegionsEMPTY" base_type="iconic" dimension="0"/>
<par name="ImDisplacement" base_type="iconic" dimension="0"/>
<par name="SkeletonGd" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsP" base_type="iconic" dimension="0"/>
<par name="EPNFWMremove" base_type="iconic" dimension="0"/>
<par name="SkeletonPartsPnoG" base_type="iconic" dimension="0"/>
<par name="ImageIR16" base_type="iconic" dimension="0"/>
<par name="ImageIRS" base_type="iconic" dimension="0"/>
<par name="RegionMS" base_type="iconic" dimension="0"/>
<par name="RegionsPNPi" base_type="iconic" dimension="0"/>
<par name="RegionsmainSNoCut" base_type="iconic" dimension="0"/>
<par name="SkelEP" base_type="iconic" dimension="0"/>
<par name="RegionCut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GNDamin" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="fwmhw" base_type="ctrl" dimension="0"/>
<par name="parop" base_type="ctrl" dimension="0"/>
<par name="WidthG" base_type="ctrl" dimension="0"/>
<par name="HeightG" base_type="ctrl" dimension="0"/>
<par name="jrad" base_type="ctrl" dimension="0"/>
<par name="gap" base_type="ctrl" dimension="0"/>
<par name="groundpn" base_type="ctrl" dimension="0"/>
<par name="groundgval" base_type="ctrl" dimension="0"/>
<par name="sm_factor" base_type="ctrl" dimension="0"/>
<par name="lookaround" base_type="ctrl" dimension="0"/>
<par name="wpl" base_type="ctrl" dimension="0"/>
<par name="smoothCADcontours" base_type="ctrl" dimension="0"/>
<par name="maxdirSP" base_type="ctrl" dimension="0"/>
<par name="wFWM" base_type="ctrl" dimension="0"/>
<par name="wside" base_type="ctrl" dimension="0"/>
<par name="wFWMS" base_type="ctrl" dimension="0"/>
<par name="wsideS" base_type="ctrl" dimension="0"/>
<par name="eradMSe" base_type="ctrl" dimension="0"/>
<par name="eradNFWMremove" base_type="ctrl" dimension="0"/>
<par name="elengthend" base_type="ctrl" dimension="0"/>
<par name="elengthnoend" base_type="ctrl" dimension="0"/>
<par name="jpadd" base_type="ctrl" dimension="0"/>
<par name="removeGNDfromFWM" base_type="ctrl" dimension="0"/>
<par name="cutendMSS" base_type="ctrl" dimension="0"/>
<par name="minWGS" base_type="ctrl" dimension="0"/>
<par name="minWG" base_type="ctrl" dimension="0"/>
<par name="useODB" base_type="ctrl" dimension="0"/>
<par name="autowidth" base_type="ctrl" dimension="0"/>
<par name="EPexp" base_type="ctrl" dimension="0"/>
<par name="elongLG" base_type="ctrl" dimension="0"/>
<par name="minPSklen" base_type="ctrl" dimension="0"/>
<par name="lpnum2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="nFWM" base_type="ctrl" dimension="0"/>
<par name="nFWMS" base_type="ctrl" dimension="0"/>
<par name="nNonWFM" base_type="ctrl" dimension="0"/>
<par name="WG" base_type="ctrl" dimension="0"/>
<par name="YC" base_type="ctrl" dimension="0"/>
<par name="XC" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Pnum" base_type="ctrl" dimension="0"/>
<par name="Pnum2" base_type="ctrl" dimension="0"/>
<par name="PnumR" base_type="ctrl" dimension="0"/>
<par name="PregC" base_type="ctrl" dimension="0"/>
<par name="PcontR" base_type="ctrl" dimension="0"/>
<par name="PaddrR" base_type="ctrl" dimension="0"/>
<par name="PaddrC" base_type="ctrl" dimension="0"/>
<par name="PCinRnum" base_type="ctrl" dimension="0"/>
<par name="PuseintP" base_type="ctrl" dimension="0"/>
<par name="WGS" base_type="ctrl" dimension="0"/>
<par name="YCS" base_type="ctrl" dimension="0"/>
<par name="XCS" base_type="ctrl" dimension="0"/>
<par name="Y1S" base_type="ctrl" dimension="0"/>
<par name="X1S" base_type="ctrl" dimension="0"/>
<par name="Y2S" base_type="ctrl" dimension="0"/>
<par name="X2S" base_type="ctrl" dimension="0"/>
<par name="PnumS" base_type="ctrl" dimension="0"/>
<par name="PnumS2" base_type="ctrl" dimension="0"/>
<par name="PnumRS" base_type="ctrl" dimension="0"/>
<par name="PregCS" base_type="ctrl" dimension="0"/>
<par name="PcontRS" base_type="ctrl" dimension="0"/>
<par name="PaddrRS" base_type="ctrl" dimension="0"/>
<par name="PaddrCS" base_type="ctrl" dimension="0"/>
<par name="PCinRnumS" base_type="ctrl" dimension="0"/>
<par name="PuseintS" base_type="ctrl" dimension="0"/>
<par name="SequenceIRB" base_type="ctrl" dimension="0"/>
<par name="SequenceIRBS" base_type="ctrl" dimension="0"/>
<par name="WGN" base_type="ctrl" dimension="0"/>
<par name="YCN" base_type="ctrl" dimension="0"/>
<par name="XCN" base_type="ctrl" dimension="0"/>
<par name="Y1N" base_type="ctrl" dimension="0"/>
<par name="X1N" base_type="ctrl" dimension="0"/>
<par name="Y2N" base_type="ctrl" dimension="0"/>
<par name="X2N" base_type="ctrl" dimension="0"/>
<par name="PnumN" base_type="ctrl" dimension="0"/>
<par name="PnumRN" base_type="ctrl" dimension="0"/>
<par name="PregCN" base_type="ctrl" dimension="0"/>
<par name="PcontRN" base_type="ctrl" dimension="0"/>
<par name="PaddrRN" base_type="ctrl" dimension="0"/>
<par name="PaddrCN" base_type="ctrl" dimension="0"/>
<par name="PCinRnumN" base_type="ctrl" dimension="0"/>
<par name="TotalPRC" base_type="ctrl" dimension="0"/>
<par name="CurrentOper" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* ** TeachingMain128</c>
<c>** added elongated SkeletonsLG</c>
<c>*** 240504 - problems with SgeletonsGS at ends</c>
<c>*** 240224 - Cut without overlap for both P and S</c>
<c>*** 231213 - new version with RegNoProc</c>
<c>***- new RegionsPNi built with forbid. reg. as SkeletonGS</c>
<c>*** 231011 - i6-bit IR, IRB</c>
<c>*** 231002 - new version with RegNoProc</c>
<c>*** 230912 - problem with SkeletonsGS</c>
<c>*** 230313 - swapping elongation (2) and PNi renumbering (1) of skeleton parts</c>
<c>*****</c>
<c>*** 220313 - fixed JP for SkeletomsFWM</c>
<c>*** 220317 Made SkeletonGd with removed endpoints areas</c>
<c>*** 220421 made circle regions to remove SP for significant dir. changes (overkills)</c>
<c>*** 220430 FWM for Space</c>
<c>*** 220603 wFWM, wFWMS ar parameters</c>
<c>*** 220606 FWM elongation added</c>
<c>*** 220607 NFWM endpoint don't care area added</c>
<c>*** 220610 NFWM added ExtendedSkeletonWFMP with jpadd (rad. add to jp area removal)</c>
<c>*** 220614 arbitrary number of FWM and FWMS widths (defined by tuples lengths)</c>
<c>**** and elength (elongation length). FWM elongation changed to 2 types (rect. and circ.)</c>
<c>*** 220615 removed FWM in RegionGMD areas (to avoid artifacts)</c>
<c>*** 220817  added PuseintP and PuseintS - intersection points which should be saved in FWM</c>
<c>*** 220828  TeachingMainL109 - fixed nEMPTY=0 case, were problems in FWMS</c>
<c>*** 220920 fixed edit CR for NFWM</c>
<c>*** 221209 if smoothCADcontours==0, then smoothCADcontours is measured by MaesureSmoothing() proc.</c>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<c></c>
<c>* *** adding overlap area to R, it should become cleared</c>
<l>TotalPRC:=5</l>
<l>CurrentOper:='Starting'</l>
<l>tuple_max(wFWM, maxwfwm)</l>
<l>dilation_circle(RegNoProc, RegNoProcd, maxwfwm)</l>
<c></c>
<l>* difference (DomainG, ROut, RC)</l>
<c>* ** TeachingMain7</c>
<l>* complement (ROut, RC)</l>
<l>* intersection (Gi, RC, G)</l>
<l>* intersection (ROut, DomainG, ROut)</l>
<l>* intersection (RC, DomainG, RC)</l>
<l>* stop ()</l>
<c></c>
<c>* *************</c>
<l>set_system('neighborhood', 8)</l>
<c></c>
<l>get_domain(Gi, DomainG)</l>
<c></c>
<l>difference(DomainG, RegNoProc, RegProc)</l>
<l>smallest_rectangle1(RegProc, Row11, Column11, Row21, Column21)</l>
<l>gen_rectangle1(Rectangle, Row11, Column11, Row21, Column21)</l>
<l>area_center(RegProc, Area3, RowDKu, ColumnDKu)</l>
<l>gen_rectangle1(RegionCut, RowDKu, Column11, RowDKu+1, Column21+1)</l>
<c></c>
<c></c>
<c></c>
<c>* CAD pattern and shape regions</c>
<l>threshold (Gi, RegionGi, 127, 255)</l>
<l>* closing_circle (RegionGii, RegionGi, 1)</l>
<l>* difference (RegionGii, RegMargin, RegionGi1)</l>
<l>difference (RegionGi, RegNoProc, RegionGi)</l>
<l>difference (RegionGi, RegNoProcd, RegionGid)</l>
<c></c>
<l>* read_image (Unit03, 'H:/Unit03.tiff')</l>
<l>* RegionGi := RegionGii</l>
<c></c>
<l>connection (RegionGi, RegionsGi)</l>
<l>* connection (RegionGid, RegionsGi)</l>
<c></c>
<l>* threshold(Gi, RegionGi, 128, 255)</l>
<l>* dilation_circle(RegionGi, RegionGid, 3.5)</l>
<l>difference (RegNoProc, RegionGid, RmnoG)</l>
<c></c>
<l>difference (DomainG, RegNoProc, RegNoProcC)</l>
<l>difference (DomainG, RegNoProcd, RegNoProcCd)</l>
<c>*** correcting RC right side (temp.)</c>
<c>* smallest_rectangle1(RC, Row1, Column1, Row2, Column2)ImIRBS:= ImageIRBS</c>
<l>* Column2:=Column2-5</l>
<l>* gen_rectangle1(RC, Row1, Column1, Row2, Column2)</l>
<c>*******</c>
<l>select_shape(RegionsGi, RegionsGnoholes, 'holes_num', 'and', 0, 0)</l>
<l>select_shape(RegionsGnoholes, SelectedRegions, 'compactness', 'and', 10, 99999)</l>
<c></c>
<l>if(smoothCADcontours==0)</l>
<l>    threshold(Im, RegionI, 128, 255)</l>
<l>    MaesureSmoothing (RegionsGi, RegionI, smoothCADcontours)</l>
<l>endif</l>
<c></c>
<c></c>
<c>*******</c>
<l>TotalPRC:=7</l>
<l>CurrentOper:='Smoothing regions'</l>
<l>* smoothCADcontours := 0</l>
<l>SmoothingRegion (RegionsGi, RegionsGsm, smoothCADcontours)</l>
<l>union1(RegionsGsm, RegionGsm)</l>
<l>difference (RegionGsm, RegNoProc, RegionG)</l>
<l>RegionGi:=RegionG</l>
<c>* **** nGND - number of GND-like (big size) regions to be removed from overflowing for Pattern</c>
<l>connection (RegionGi, RegionsGi)</l>
<l>select_shape (RegionsGi, RegionsGND, 'area', 'and', GNDamin, 99999999)</l>
<l>count_obj (RegionsGND, nGND)</l>
<c>**** to avoid problem in IRB</c>
<l>* nGND:=nGND+1</l>
<c></c>
<l>difference (RegionsGND, RegNoProc, RegionsGNDnR)</l>
<l>* read_image (Im2173, 'C:/TmpIm/Im2_173.tif')</l>
<l>* threshold(Im2173, Region, 90, 255)</l>
<c></c>
<c>* ***</c>
<c>* **** nEMPTY - number of empty (big size) regions to be removed from overflowing for Space</c>
<l>EMPTYamin := 900000</l>
<c>* 16.04.2024 </c>
<l>* difference (DomainG, RegionGsm, RegionGSi)</l>
<l>difference (DomainG, RegionG, RegionGSi)</l>
<l>connection (RegionGSi, RegionsGSi)</l>
<l>select_shape (RegionsGSi, RegionsEMPTY, 'area', 'and', EMPTYamin, 999999999)</l>
<l>count_obj (RegionsEMPTY, nEMPTY)</l>
<l>if(nEMPTY==0)</l>
<l>    nEMPTY:=1</l>
<l>endif</l>
<l>difference (RegionsEMPTY, RegNoProc, RegionsEMPTYnR)</l>
<c>* ***********************************************</c>
<l>* stop ()</l>
<c>*****220130****</c>
<l>erosion_circle(RegionG, RegionErosion, 14)</l>
<l>dilation_circle(RegionErosion, RegionDilation, 14+6)</l>
<l>intersection(RegionDilation, RegionG, RegionIntersection)</l>
<c>***************</c>
<c></c>
<l>* complement (RegionGi, RegionGComplement)</l>
<l>* intersection (RegionGComplement, DomainG, RegionGSi)</l>
<c>* **** finding skeletons *****</c>
<c></c>
<l>RegionGS := RegionGSi</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>* closing_circle(RegionGi, RegionGiic, 1)</l>
<l>skeleton (RegionGi, SkeletonGi)</l>
<c>***** cutting RecOvl</c>
<l>* intersection (SkeletonGi, RC, SkeletonG)</l>
<l>difference(DomainG, RegNoProc, RC)</l>
<l>intersection (SkeletonGi, RC, SkeletonG)</l>
<l>junctions_skeleton(SkeletonG,EndPointsG, JuncPointsG)</l>
<l>get_region_points(EndPointsG, RowsEP, ColumnsEP)</l>
<l>* rcep:=5</l>
<l>* tuple_length(RowsEP, nEP)</l>
<l>* tuple_gen_const(nEP, rcep, Rcep)</l>
<l>* gen_circle(CEP, RowsEP, ColumnsEP, Rcep)</l>
<c>**** SkeletonGd is for proper Open finding</c>
<l>gen_empty_obj(CEP)</l>
<l>difference(SkeletonG, CEP, SkeletonGd)</l>
<c>*******</c>
<l>difference (SkeletonG, RegNoProc, SkeletonG)</l>
<c></c>
<c>*******</c>
<c></c>
<c>* 16.04.2024</c>
<l>* intersection (RegionGSi, RC, RegionGSii)</l>
<l>* difference (RegionGSii, RegNoProc, RegionGSi)</l>
<c></c>
<c></c>
<l>num_iter := 999</l>
<l>connection (SkeletonG, SkeletonsG)</l>
<c></c>
<l>skeleton (RegionGSi, SkeletonGSi)</l>
<l>intersection (SkeletonGSi, RC, SkeletonGSii)</l>
<l>difference (SkeletonGSii, RegNoProc, SkeletonGS)</l>
<l>connection(SkeletonGS, SkeletonsGS)</l>
<c></c>
<l>* select_shape(ConnectedRegionsS, SkeletonsGS, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>*** cutting ends of MSS</c>
<c></c>
<c></c>
<c>*** Old LG</c>
<l>*  if(elongLG &gt;0)</l>
<l>*     junctions_skeleton(SkeletonGS, EndPointsGS, JuncPointsGS)</l>
<l>*     dilation_circle(EndPointsGS, RegionDilationGS, elongLG)</l>
<l>*     intersection(SkeletonGSi, RegionDilationGS, RegionIntersection1)</l>
<l>*     union2(SkeletonGS, RegionIntersection1, SkeletonLG)</l>
<l>*     connection(SkeletonLG, SkeletonsLG)</l>
<l>*  endif</l>
<c>*     union2</c>
<l>* elseif(cutendMSS &gt;0)    </l>
<l>    for j:=1 to cutendMSS by 1</l>
<l>        junctions_skeleton(SkeletonsGS,EndPointsMSS, JuncPointsMSS)</l>
<l>        area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>        tuple_length(Area1, nEndPointsMSS)</l>
<l>        if(Area1&gt;0)</l>
<l>            union1(EndPointsMSS, EndPointsMSSu)</l>
<l>            connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>            area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>            tuple_length(RowMSS, nMSS)</l>
<l>            tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>            gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>            union1(CMSSE, CMSSEu)</l>
<l>            difference(SkeletonsGS, CMSSEu, SkeletonsGS)</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>* endif</l>
<c></c>
<c></c>
<l>* junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 13.5)</l>
<l>* stop()</l>
<l>* ExtendedSkeletonWFMP5(RegionG, SkeletonsGS, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<c></c>
<c></c>
<l>union2(SkeletonGS, RegNoProc, RegForbid)</l>
<l>* RegForbid := SkeletonGS</l>
<c> </c>
<l>expand_region (SkeletonsG, RegForbid, RegionsPNii, num_iter, 'image')</l>
<l>dilation_circle(RegionsPNii,RegionsPNi, 1)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegForbid, RegionsPNPii, num_iter, 'image')</l>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 1)</l>
<c></c>
<l>* write_object (SkeletonGS, path+'SkeletonGS.hobj')</l>
<c>* ***** Building Width and Dir images *********</c>
<l>set_system ('current_runlength_number', 50000000)</l>
<l>* PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>* SpaceWidthDirImages (RegionGSi, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** RegionGiic - closed CAD region to remove small artifacts 220805</c>
<l>TotalPRC:=10</l>
<l>CurrentOper:='Building width and direction images'</l>
<l>PatternWidthDirImages (RegionGi, SkeletonG, WidthImageP, DirImageP, AngleImageP, WidthG, HeightG)</l>
<l>difference(DomainG, RegionGi, RegionGSii) </l>
<l>* SpaceWidthDirImages (RegionGSii, SkeletonGS, WidthImageS, DirImageS, WidthG, HeightG)</l>
<c>*** 24.04.02 RegionGSi -&gt; RegionGSii</c>
<l>SpaceWidthDirImages (RegionGSii, SkeletonGS, \
                     WidthImageS, DirImageS, \
                     WidthG, HeightG)</l>
<c></c>
<l>dev_disp_text('Width/Dir processing finished', 'window', 10, 10, 'black', [], [])</l>
<l>* stop ()</l>
<c></c>
<c>*******250308</c>
<c>******</c>
<c></c>
<l>junctions_skeleton(SkeletonsGS, SkelEPi, JuncPoints1)</l>
<l>union1(SkelEPi, SkelEPu)</l>
<l>get_region_points(SkelEPu, Rows, Columns)</l>
<l>get_grayval(WidthImageS, Rows, Columns, wEPs)</l>
<l>tuple_max(wEPs, wEP)</l>
<c></c>
<l>dilation_circle(SkelEPu, SkelEP, wEP/2+EPexp)</l>
<c>*********************************</c>
<c>*** Displacement Image</c>
<c>*** teaching part</c>
<l>* union1(RegionG, RegionG1)</l>
<l>distance_transform(RegionGi,DistGPi,'euclidean', 'true', WidthG, HeightG)</l>
<l>distance_transform(RegionGSi,DistGSi,'euclidean', 'true', WidthG, HeightG)</l>
<c></c>
<l>convert_image_type(DistGSi, DistGSii, 'byte')</l>
<l>convert_image_type(DistGPi, DistGP, 'byte')</l>
<l>scale_image(DistGSii, DistGS, 1, -1)</l>
<l>sub_image(DistGS, DistGP, ImDisplacementi, 1, 128)</l>
<l>dilation_circle (RegNoProc, Rd, 3.5)</l>
<l>paint_region(Rd, ImDisplacementi, ImDisplacement, 127, 'fill')</l>
<l>* stop()</l>
<c>* no-shift displ. image  -double jump near the boundary</c>
<l>* convert_image_type(DistGSi, DistGSii, 'int1')</l>
<l>* convert_image_type(DistGPi, DistGPii, 'int1')</l>
<l>* scale_image(DistGPii, DistGP, 1, -1)</l>
<l>* scale_image(DistGSii, DistGS, 1, -1)</l>
<l>* sub_image(DistGS, DistGP, ImDisplacement, 1, 0)</l>
<c>* *** histogram-based CAD width analysis****</c>
<c>* ** pattern **</c>
<l>TotalPRC:=20</l>
<l>CurrentOper:='Building Pattern Skeletons'</l>
<l>minlen := minPSklen</l>
<l>pruning(SkeletonG,SkeletonG, 10)</l>
<l>junctions_skeleton(SkeletonG, EndPointsG, JuncPointsG)</l>
<l>union1(JuncPointsG, JP)</l>
<l>get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>tuple_length(RowsJ, nJ)</l>
<l>if(nJ &gt; 0)</l>
<l>    get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>    gen_circle(CJ, RowsJ, ColumnsJ, RadJ/2+1)</l>
<l>    difference(SkeletonG, CJ, Skeletonii)</l>
<l>else</l>
<l>    Skeletonii:=SkeletonG</l>
<l>endif</l>
<c></c>
<l>get_region_points (Skeletonii, RowsGi, ColsGi)</l>
<l>get_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<l>tuple_length (WGi, nWGi)</l>
<l>tuple_median(WGi, medWGi)</l>
<l>tuple_deviation(WGi, devWGi)</l>
<c></c>
<c>****** correcting pattern width (image ang tuple) with minWGS</c>
<l>for j:=0 to nWGi-1 by 1</l>
<l>    if(WGi[j]&lt; minWG)</l>
<l>        WGi[j] := minWG</l>
<l>    endif</l>
<l>endfor</l>
<l>set_grayval (WidthImageP, RowsGi, ColsGi, WGi)</l>
<c>**************************************************</c>
<l>* tuple_min (WGi, minWGi)</l>
<l>* tuple_max (WGi, maxWGi)</l>
<l>* tuple_histo_range (WGi, 0, maxWGi, 1*(maxWGi+1), HistoGi, BinSize)</l>
<l>* PrcWGi := HistoGi*100./nWGi</l>
<l>* tuple_length(PrcWGi, nP)</l>
<c></c>
<l>* write_tuple(PrcWGi, 'PrcWGi')</l>
<l>* read_tuple('PrcWGitst', PrcWGi)</l>
<l>if(autowidth==1)</l>
<l>*     wside:=6</l>
<l>    FindWidth (WGi, wside, WidthP)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* stop()</l>
<l>* tuple_max(MaxInd, pmax)</l>
<l>* tuple_min(MaxInd, pmin)</l>
<l>* pmid:=(pmax+pmin)/2</l>
<l>* span:=pmax-pmin</l>
<l>* stop()</l>
<c></c>
<c>* *** space ***</c>
<l>get_region_points (SkeletonGS, RowsGSi, ColsGSi)</l>
<l>get_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<l>wsideS:=6</l>
<l>if(autowidth==1)</l>
<l>    FindWidth (WGSi, wsideS, WidthS)</l>
<l>endif</l>
<c></c>
<l>* tuple_length (WGSi, nWGSi)</l>
<l>* tuple_max (WGSi, maxWGSi)</l>
<c>****** correcting space width (image ang tuple) with minWGS</c>
<l>* for j:=0 to nWGSi-1 by 1</l>
<l>*     if(WGSi[j]&lt; minWGS)</l>
<l>*         WGSi[j] := minWGS</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* set_grayval (WidthImageS, RowsGSi, ColsGSi, WGSi)</l>
<c>**********************************************************************</c>
<l>* tuple_histo_range (WGSi, 0, maxWGSi, 1*(maxWGSi+1), HistoGSi, BinSize)</l>
<l>* PrcWGSi := HistoGSi*100/nWGSi</l>
<c></c>
<c></c>
<c>****** Auto setting of FWM/S widths using width histogram 16.04.2024 </c>
<l>* create_funct_1d_array(PrcWGSi, FPrcWGSi)</l>
<l>* local_min_max_funct_1d(FPrcWGSi, 'strict_min_max', 'true', MinPrcWGS, MaxPrcWGS)</l>
<l>* tuple_length(MinPrcWGS, nMinPrcWGS)</l>
<l>* tuple_length(MaxPrcWGS, nMaxPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MinPrcWGS, 'constant', YMinPrcWGS)</l>
<l>* get_y_value_funct_1d(FPrcWGSi, MaxPrcWGS, 'constant', YMaxPrcWGS)</l>
<c></c>
<c></c>
<c>**** Selection of FWM by histogram *********</c>
<l>* reduce_domain(WidthImageP, SkeletonG, ImageReduced)</l>
<l>* get_region_points(SkeletonG, RowsG, ColumnsG)</l>
<l>* get_grayval(WidthImageP,RowsG, ColumnsG, WdG)</l>
<l>* tuple_length(WdG, nWdG)</l>
<l>* tuple_histo_range(WdG,1, 255, 255, HistoWdG, BinSize1)</l>
<l>* PrcWdG:=HistoWdG*100./nWdG</l>
<c>*********************************************</c>
<l>dev_disp_text('Pat FWM finding started', 'window', 10, 10, 'black', [], [])</l>
<c>**********************</c>
<c>*** Selection FWM from ODB++ ***</c>
<c>*************</c>
<l>lTrmin:=50</l>
<l>nWr:=0</l>
<l>sgap:=0</l>
<l>if(useODB&gt;0 and useODB&lt;3)</l>
<l>    dev_disp_text('Finding wires from ODB++            ', 'window', 10, 10, 'black', [], [])</l>
<l>    FindWires3 (RegionG, SkeletonG, RegionFlash, RegionTrace, DirImageP, WidthImageP, RegionsPNPi, SkeletonsWire, Rnoint, lTrmin, nWr, wpl, sgap, nTr)</l>
<l>    dev_disp_text('Finding wires finished           ', 'window', 10, 10, 'black', [], [])</l>
<l>endif</l>
<c></c>
<c>*************</c>
<c>**** Selection of FWM amd FWMS by histogram *********</c>
<l>* prcmin:=5</l>
<l>* numP:=3</l>
<l>* numS:=1</l>
<l>* wmax:=45</l>
<l>* if(useODB==1)</l>
<l>*       WSelbyHist (PrcWGi, wmax, prcmin, numP, WminPa) </l>
<l>* endif</l>
<c></c>
<l>* numS:=1</l>
<l>* WSelbyHist (PrcWGSi, wmax, prcmin, numS, WminSa)</l>
<l>* stop()</l>
<c>*****************************************************</c>
<l>* stop ()</l>
<l>* Wmain := [6, 14, 28]</l>
<l>if(useODB==0)</l>
<l>      set_system('neighborhood', 8)</l>
<l>    if(autowidth==0)</l>
<l>        WminP := wFWM</l>
<l>    else</l>
<l>        WminP := WidthP</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_length(WminP, nWP)</l>
<c>    </c>
<c>    ***** temp. tuple based Pattern Skel. FWM</c>
<l>*     WminP := [16, 24, 68, 126]</l>
<l>*     tuple_length(WminP, nWP)</l>
<l>    RowsM:=[] </l>
<l>    ColsM:=[]</l>
<l>    RowsT:=[] </l>
<l>    ColsT:=[]</l>
<l>    for j := 0 to nWGi-1 by 1</l>
<c>        </c>
<l>        w := WGi[j]</l>
<l>        for k:=0 to nWP-1 by 1</l>
<l>            if ( w &gt;= (WminP[k]-wside) and w &lt;= (WminP[k]+wside)) </l>
<l>                tuple_concat(RowsT, RowsGi[j], RowsT) </l>
<l>                tuple_concat(ColsT, ColsGi[j], ColsT) </l>
<l>            endif</l>
<l>        endfor</l>
<l>        if(j%10000 == 0)</l>
<l>            tuple_concat(RowsM, RowsT, RowsM) </l>
<l>            tuple_concat(ColsM, ColsT, ColsM) </l>
<l>            RowsT:=[] </l>
<l>            ColsT:=[]</l>
<l>        endif</l>
<l>        if(j%100000==0)</l>
<l>            dev_disp_text(j+' from '+nWGi, 'window', 10, 145, 'black', [], [])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    tuple_concat(RowsM, RowsT, RowsM) </l>
<l>    tuple_concat(ColsM, ColsT, ColsM) </l>
<c>    </c>
<l>*     tuple_equal(RowsMo, RowsM, EqualR)</l>
<l>*     tuple_equal(ColsMo, ColsM, EqualC)</l>
<c>    </c>
<l>    gen_region_points (Rmain, RowsM, ColsM)</l>
<l>*     stop()</l>
<l>    connection(Rmain, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainNoCut, 'area', 'and', minlen, 9999999)  </l>
<c>    </c>
<l>elseif(useODB==1)</l>
<l>    RegionsmainNoCut:=SkeletonsWire</l>
<l>else </l>
<l>    RegionmainNoCut:=SkeletonGS</l>
<l>    connection(RegionmainNoCut, RegionsmainNoCut)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj(RegionsmainNoCut, nFWMP)</l>
<c></c>
<l>* junctions_skeleton(Regionsmain,EndPoints1, JuncPoints1)</l>
<l>* union1(EndPoints1, EndPoints1u)</l>
<l>* difference(Regionsmain, EndPoints1u, RegionDifference1)</l>
<l>* junctions_skeleton(RegionDifference1,EndPoints2, JuncPoints2)</l>
<l>* union1(EndPoints2, EndPoints2u)</l>
<l>* get_region_points(EndPoints2u, Rows2, Cols2)</l>
<c></c>
<c>** elongation lengths (elengthend, elengthnoend) </c>
<c>** are moved to Teaching parameters</c>
<c></c>
<l>get_image_size(WidthImageP,Width, Height)</l>
<l>get_image_size(DirImageP,Widthd, Heightd)</l>
<c></c>
<l>* write_image(DirImageP,'tiff', 0, path+'Test/DirImageP')</l>
<l>* write_image(WidthImageP,'tiff', 0, path+'Test/WidthImageP')</l>
<l>* write_object(RegionG, path+'Test/RegionG')</l>
<l>* write_object(Regionsmain, path+'Test/Regionsmain')</l>
<l>* write_object(SkeletonGi, path+'Test/SkeletonGi')</l>
<c></c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<l>* union1(RegionsmainNoCut, Regionmain)</l>
<c></c>
<l>*difference(SkeletonFWM, Cr, SkeletonFWM)</l>
<c>***</c>
<l>difference(RegionsmainNoCut, RegionCut, Regionmaini)</l>
<l>connection(Regionmaini, Regionsmain)</l>
<l>union1(Regionsmain, Regionmain)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c></c>
<c>******</c>
<l>* gen_contours_skeleton_xld (RegionsmainNoCut, ContoursG, 1, 'filter')</l>
<l>* count_obj( ContoursG, nC) </l>
<l>* nc:=1</l>
<l>* select_obj(ContoursG,ContourSelected, nc)</l>
<l>* select_obj(RegionsmainNoCut, ObjectSelected, nc)</l>
<l>* contour_point_num_xld (ContourSelected, np)</l>
<l>* if (np &lt; 21)</l>
<l>*     lookaround := 1</l>
<l>* else</l>
<l>*     lookaround := 11</l>
<l>* endif</l>
<c></c>
<l>* get_contour_angle_xld (ContourSelected, 'abs', 'regress', lookaround, AnglesG)</l>
<c></c>
<l>* AngleUnwrap (AnglesG, AnglesG)</l>
<l>* AnglesGrad:=(AnglesG-AnglesG[0])*180./3.1415926</l>
<c></c>
<l>* create_funct_1d_array(AnglesGrad, FAnglesGrad)</l>
<l>* smooth_funct_1d_mean(FAnglesGrad, 39, 1, FAnglesGradsm)</l>
<c></c>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNPnci, num_iter, 'image')</l>
<l>* expand_region (RegionsmainNoCut, RegForbid, RegionsPNP2, 50, 'image')</l>
<l>* tuple_length(AnglesGrad, nA)</l>
<l>* get_contour_xld(ContourSelected,RowC, ColC)</l>
<l>* jbeg:=0</l>
<l>* gen_empty_obj(AllRegs)</l>
<l>* Reg:=ObjectSelected</l>
<l>* ang:=0.</l>
<l>* js:=5</l>
<l>* elongthover:=20.5</l>
<l>* for j:=0 to nA-1 by 1</l>
<c>    </c>
<l>*     if((AnglesGrad[j]-ang) &gt; 290)</l>
<l>*         gen_circle(Circle, RowC[j], ColC[j], 2.5)</l>
<l>*          if(j &lt; nA-50)</l>
<l>*             get_grayval (WidthImageP, RowC[j], ColC[j], wg)</l>
<l>*             get_grayval (DirImageP, RowC[j], ColC[j], p)</l>
<l>*             pa:=p*3.14159/256</l>
<l>*             gen_rectangle2(Rectangle, RowC[j], ColC[j] ,pa, wg*4, 1)</l>
<l>*             intersection(Reg, Rectangle, RegionIntersection1)</l>
<l>*             area_center(RegionIntersection1, a, Row1, Column1)</l>
<l>*             if(a==0)</l>
<l>*                 continue</l>
<l>*             endif</l>
<l>*             difference(Reg, Circle, Reg)</l>
<l>*             connection(Reg, Regs)</l>
<l>*             jl:=j+js</l>
<l>*             get_region_index(Regs, RowC[jl], ColC[jl],Index)</l>
<l>*             get_region_index(Regs, RowC[j-js], ColC[j-js],IndexR)</l>
<l>*             select_obj(Regs, Reg, Index)</l>
<l>*             select_obj(Regs, Reg1, IndexR)</l>
<l>*             gen_region_points(PC, RowC[j], ColC[j])</l>
<l>*             expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>*             intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>*             union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>*             concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>*          endif</l>
<l>*         ang:=AnglesGrad[j]</l>
<l>*     endif</l>
<c>    </c>
<l>* endfor</l>
<l>* connection(Reg, Regs)</l>
<l>* select_obj(Regs, Reg1, 1)</l>
<l>* expand_region(PC, RegionGS, RegionExpanded, elongthover, 'image')</l>
<l>* intersection(SkeletonG, RegionExpanded, RegionIntersection)</l>
<l>* union2(Reg1, RegionIntersection, Reg1exp)</l>
<l>* concat_obj(AllRegs, Reg1exp, AllRegs)</l>
<l>* gen_image_const(Image, 'byte', Widthd, Heightd)</l>
<l>* write_image(Image, 'tiff', 0, 'Image')</l>
<l>* stop()</l>
<c>******</c>
<l>* select_obj(AllRegs, ObjectSelected1, 1)</l>
<l>* select_obj(AllRegs, ObjectSelected2, 2)</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* gen_empty_obj(AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected3, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected2, AllRegsR)</l>
<l>* concat_obj(AllRegsR, ObjectSelected1, AllRegsR)</l>
<l>* expand_region (AllRegs, SkeletonGS, RegionsPNPnci, 30, 'image')</l>
<l>* expand_region (AllRegsR, SkeletonGS, RegionsPNPnciR, 30, 'image')</l>
<l>* select_obj(AllRegs, ObjectSelected3, 3)</l>
<l>* expand_region (ObjectSelected3, SkeletonGS, RegionsPNPnci3, 30, 'image')</l>
<l>* concat_obj(RegionsPNPnci, RegionsPNPnci3, RegionsPNPnci)</l>
<c></c>
<l>* dev_display(Gi)</l>
<l>* dev_display(AllRegs)</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<c>***nA</c>
<l>* connection(Regionmain, Regionsmain)</l>
<l>expand_region (Regionsmain, RegForbid, RegionsPNPi, num_iter, 'image')</l>
<c>* RegionsPNPii,RegionsPNPi</c>
<l>* dilation_circle(RegionsPNPii,RegionsPNPi, 2)</l>
<c>***</c>
<l>* intersection(RegionsPNi, Regionmain, RegionsmainPNi)</l>
<l>* count_obj(RegionsmainPNPi, nRMPNI)</l>
<c></c>
<c></c>
<l>intersection(RegionsPNPi, Regionmain, RegionsmainPNPi)</l>
<l>count_obj(RegionsmainPNPi, nRMPNPI)</l>
<l>* elengthover:=0</l>
<l>* ExtendedSkeletonWFMP5(RegionG, Regionsmain, SkeletonGi, WidthImageP, DirImageP, \
SkeletonPartsPi, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>ExtendedSkeletonWFMP5(RegionG, RegionsmainNoCut, SkeletonG, WidthImageP, DirImageP, \
SkeletonPartsPinc, WidthImagePout, DirImagePout, \
                      elengthend, elengthnoend, jpadd)</l>
<l>* ExtendedSkeletonWFMP7 (RegionG, RegionsmainPNPi, RegionsmainNoCut, WidthImageP, DirImageP, RegionCut, \
                       SkeletonPartsPi, WidthImagePout, DirImagePout, ImageOverlap, RegsOverlap, \
                       elengthend, elengthnoend, jpadd, elengthover)</l>
<l>* scale_image_max(ImageOverlap,ImageScaleMax)</l>
<l>* ExtendedSkeletonWFMP5(RegionG, RegionsmainPNi, SkeletonGi, WidthImageP, DirImageP, SkeletonPartsPi, WidthImagePout, DirImagePout, elengthend, elengthnoend, jpadd)</l>
<c>**** removing R ******</c>
<l>difference (SkeletonPartsPinc, RegNoProc, SkeletonPartsPii)</l>
<l>if(removeGNDfromFWM==1)</l>
<c>   ********* remowing GND from FWM *****</c>
<l>   difference(SkeletonPartsPii, RegionsGND, SkeletonPartsPi) </l>
<l>else</l>
<l>    SkeletonPartsPi:=SkeletonPartsPii</l>
<l>endif</l>
<l>* union1(SkeletonPartsPi, SkeletonPartPi)</l>
<c>*** prun ****</c>
<l>* pruning(SkeletonPartPi, RegionPrune, 1)</l>
<c>*********</c>
<l>* connection(RegionPrune, SkeletonPartsPip)</l>
<l>* pruning(SkeletonPartsPi, SkeletonPartsP, 1)</l>
<l>SkeletonPartsP:=SkeletonPartsPi</l>
<l>dev_disp_text('Pat FWM finding finished              ', 'window', 10, 10, 'black', [], [])</l>
<l>* stop()</l>
<c></c>
<l>* intersection(RegionGu, Rectanglesu, Regs) </l>
<l>* union2(RegionExpandedi, Regs, RegionExpanded)</l>
<l>* count_seconds(t2)</l>
<l>* t:=t2-t1</l>
<l>* dev_display(Gi)</l>
<l>* dev_display(RegionExpanded)</l>
<l>* dev_disp_text('t='+ (t)$'5.5', 'window', 0, 0, 'black', [], [])</l>
<l>* stop()</l>
<l>* stop()</l>
<c></c>
<l>* difference (Regionsmain, RegNoProc, Regionsmainr)</l>
<l>* difference(Regionsmainr, RegionsGND, SkeletonPartsPnoG)</l>
<c>******</c>
<l>TotalPRC:=40</l>
<l>CurrentOper:='Building Space Skeletons'</l>
<l>count_obj(SkeletonPartsP, nSkP)</l>
<l>if(autowidth==1)</l>
<l>   WminS := WidthS</l>
<l>else</l>
<l>   WminS := wFWMS</l>
<l>endif</l>
<l>* WminS := wFWMS</l>
<l>tuple_length(WminS, nWS)</l>
<c>***** vector based Space Skel. FWMS</c>
<l>* wsides := 2</l>
<l>* RowsM := []</l>
<l>* ColsM := 0</l>
<l>* VectorRM := {1}</l>
<l>* VectorRM.clear()</l>
<l>* VectorCM := {1}</l>
<l>* VectorCM.clear()</l>
<l>* for j := 0 to nWGSi-1 by 1</l>
<l>*     w := WGSi[j]</l>
<l>*     for k:=0 to nWS-1 by 1</l>
<l>*         if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS)) </l>
<l>*             VectorRM.insert(j, RowsGSi[j])</l>
<l>*             VectorCM.insert(j, ColsGSi[j])</l>
<l>*         endif</l>
<l>*     endfor</l>
<l>* endfor</l>
<l>* convert_vector_to_tuple (VectorRM, RowsMS)</l>
<l>* convert_vector_to_tuple (VectorCM, ColsMS)</l>
<c>***** temp. tuple based Space Skel. FWMS</c>
<l>dev_disp_text('Space FWMS finding started                   ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('yellow')</l>
<l>RowsMS:=[] </l>
<l>ColsMS:=[]</l>
<l>RowsT:=[] </l>
<l>ColsT:=[]</l>
<l>tuple_length(WGSi, nWGSi)</l>
<c></c>
<l>for j := 0 to nWGSi-1 by 1</l>
<l>     w := WGSi[j]</l>
<l>*      if (RowsGSi[j]==894 and ColsGSi[j]==9086) </l>
<l>*          stop()</l>
<l>*      endif</l>
<l>    for k:=0 to nWS-1 by 1</l>
<l>        if ( w &gt;= (WminS[k]-wsideS) and w &lt;= (WminS[k]+wsideS) and ColsGSi[j]&lt;Width-10 and ColsGSi[j]&gt;10) </l>
<l>            tuple_concat(RowsT, RowsGSi[j], RowsT) </l>
<l>            tuple_concat(ColsT, ColsGSi[j], ColsT) </l>
<l>        endif</l>
<l>    endfor</l>
<l>    if(j%10000 == 0)</l>
<l>        tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>        tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>        RowsT:=[] </l>
<l>        ColsT:=[]</l>
<l>    endif</l>
<l>    if(j%100000==0)</l>
<l>        dev_disp_text(j+' from '+nWGSi, 'window', 10, 145, 'black', [], [])</l>
<l>    endif</l>
<l>endfor</l>
<l>tuple_concat(RowsMS, RowsT, RowsMS) </l>
<l>tuple_concat(ColsMS, ColsT, ColsMS) </l>
<l>* stop()</l>
<l>gen_region_points (RmainS, RowsMS, ColsMS)</l>
<c></c>
<c>***** removing space junctions *****</c>
<l>junctions_skeleton(RmainS,EndPointsS, JuncPointsS)</l>
<l>union1(JuncPointsS, JuncPointsSu)</l>
<l>get_region_points(JuncPointsSu, RowsJS, ColumnsJS)</l>
<l>tuple_length(RowsJS, nJS)</l>
<l>rJ:=4.5</l>
<l>tuple_gen_const(nJS, rJ, RJ)</l>
<l>if(nJS&gt;0)</l>
<l>    gen_circle(CirclesSJ, RowsJS, ColumnsJS, RJ)</l>
<l>    union1(CirclesSJ, CirclesSJu)</l>
<l>    difference(RmainS, CirclesSJu, RmainSnoJ)</l>
<c>    **********</c>
<l>    connection(RmainSnoJ, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, RegionsmainSs, 'area', 'and', minlen, 9999999)</l>
<l>    union1(RegionsmainSs, RegionsmainSu)</l>
<l>    difference(DomainG, RegionsmainSu, RegionsmainSuc)</l>
<l>    junctions_skeleton(RegionsmainSs,EndPointsMSS, JuncPointsMSS)</l>
<l>    union1(EndPointsMSS, EndPointsMSSu)</l>
<l>    connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>    RegionsmainSn:=RegionsmainSs</l>
<l>else</l>
<l>    RegionsmainSn:=RmainS</l>
<l>endif</l>
<c></c>
<l>connection(RmainS, ConnectedRegionsS)</l>
<l>select_shape(ConnectedRegionsS, RegionsmainSNoCut, 'area', 'and', minlen, 9999999)  </l>
<l>* junctions_skeleton(RegionsmainSNoCut, SkelEPi, JuncPoints1)</l>
<l>* union1(SkelEPi, SkelEPu)</l>
<l>* dilation_circle(SkelEPu, SkelEP, 9.5)</l>
<l>* area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>* tuple_length(RowMSS, nMSS)</l>
<l>* tuple_gen_const(nMSS, 1, RadendMSS)</l>
<c>**** New LG ******</c>
<l>    junctions_skeleton(RegionsmainSNoCut, EndPointsSN, JuncPointsSN)</l>
<l>    dilation_circle(EndPointsSN, RegionDilationSN, elongLG)</l>
<l>    intersection(SkeletonGSi, RegionDilationSN, RegionIntersection1)</l>
<l>    union2(RegionsmainSNoCut, RegionIntersection1, SkeletonLG)</l>
<l>    connection(SkeletonLG, SkeletonsLG)</l>
<c></c>
<c>*************</c>
<l>for j:=1 to cutendMSS by 1</l>
<l>    *j:=585</l>
<l>    junctions_skeleton(RegionsmainSNoCut,EndPointsMSS, JuncPointsMSS)</l>
<l>    area_center(EndPointsMSS, Area1, Row1, Column1)</l>
<l>    tuple_length(Area1, nEndPointsMSS)</l>
<l>    if(Area1&gt;0)</l>
<l>        union1(EndPointsMSS, EndPointsMSSu)</l>
<l>        connection(EndPointsMSSu, EndPointsMSSuc)</l>
<l>        area_center(EndPointsMSSuc, Area, RowMSS, ColMSS)</l>
<l>        tuple_length(RowMSS, nMSS)</l>
<l>        tuple_gen_const(nMSS, 1, RadendMSS)</l>
<l>        gen_circle(CMSSE, RowMSS, ColMSS, RadendMSS)</l>
<l>        union1(CMSSE, CMSSEu)</l>
<l>        difference(RegionsmainSNoCut, CMSSEu, RegionsmainSNoCut)</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>* RegionsmainS:=RegionsmainSn</l>
<l>union1(RegionsmainSNoCut, RegionmainSNoCut)</l>
<l>difference(RegionmainSNoCut, RegionCut, RegionmainS)</l>
<l>connection(RegionmainS, RegionsmainS)</l>
<l>union1(RegionsmainS, RegionmainS)</l>
<l>count_obj(RegionsmainS, nFWMPS)</l>
<l>SkeletonsFWMScut:=RegionsmainS</l>
<l>dev_disp_text('Space FWMS finding finished                         ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>SkeletonsFWMS:=RegionsmainSNoCut</l>
<l>count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>cut:=0</l>
<l>cyc:=255</l>
<l>for j:=1 to nFWMS by 1</l>
<l>    select_obj(SkeletonsFWMS, Sk, j)</l>
<l>    get_region_points(Sk, RowsSk, ColumnsSk)</l>
<l>    get_grayval(DirImageS, RowsSk, ColumnsSk, DSk)</l>
<c>    * unwrapping DSk</c>
<l>    Unwrap (DSk, cyc, DSku)</l>
<c>    *****</c>
<l>    tuple_min(DSku, dSkumin)</l>
<l>    tuple_max(DSku, dSkumax)</l>
<l>    dSkuspan:=dSkumax-dSkumin</l>
<c>    </c>
<l>    if(dSkuspan &gt; 250)</l>
<l>        cut:=1</l>
<l>    endif</l>
<l>endfor</l>
<l>if(cut==0)</l>
<l>    gen_empty_obj(RegionCut)</l>
<l>    SkeletonsFWMScut:=SkeletonsFWMS</l>
<l>endif</l>
<c></c>
<c>*****</c>
<l>* stop ()</l>
<c>* **********************</c>
<c>* ******** Preping IRB image  *******************</c>
<l>TotalPRC:=60</l>
<l>CurrentOper:='Preparing IRB'</l>
<c>* *** preparing for IRB (pattern)</c>
<c></c>
<l>* gen_image_const (ImageIRB, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIR16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbid)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNPi, nINB)</l>
<l>tuple_gen_sequence (2, nINB+1, 1, SequenceINBi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseq := nGND+1</l>
<l>* overf := 255-stseq</l>
<l>* SequenceIRB := SequenceINBi%overf+stseq</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c></c>
<l>*stseq := 5</l>
<l>*SequenceINB:=SequenceINBi+stseq</l>
<c>* ****</c>
<l>union1 (RegionsGND, RegionGND)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionGND, RegionGNDC)</l>
<l>* complement (RegionG, RegionGS)</l>
<l>difference (DomainG, RegionG, RegionGS)</l>
<c></c>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNi, ImageIR, ImageIR, SequenceIRB, 'fill')</l>
<l>paint_region (RegionsPNPi, ImageIR16, ImageIR16, SequenceINBi, 'fill')</l>
<l>* stop ()</l>
<c></c>
<c>***</c>
<c>***</c>
<c>***  removing false call</c>
<l>* gen_circle(Cr, 11895, 3182, 10)</l>
<l>* difference(SkeletonPartsP, Cr, SkeletonPartsP)</l>
<l>* count_seconds(t1)</l>
<c>**** building Non-FWM MSNs</c>
<l>dev_disp_text('Non-FWM building started                            ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>TotalPRC:=70</l>
<l>CurrentOper:='Building non-FWM sensors'</l>
<c></c>
<l>MSNBuildNonFWM1 (RegionG, SkeletonPartsP, WidthImageP, DirImageP, RegionGS, ImageIR, SkeletonFWM, RegionsNFWM, RegionsNFWMBcut, sm_factor, lookaround, wpl, 0, PnumN, PnumRN1, Y1N, X1N, Y2N, X2N, PaddrCN, PaddrRN, WN, WGN, PregCN, PCinRnumN, PcontRN)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'inner_radius', 'and', 10, 9999999)</l>
<l>select_shape(RegionsNFWM, RegionsNFWMs, 'area', 'and', 400, 9999999)</l>
<l>area_center(RegionsNFWMs, AreaNFWMs, Row, Column)</l>
<l>gen_region_points(Region1, Y1N, X1N)</l>
<l>gen_region_points(Region2, Y2N, X2N)</l>
<l>YCN:=(Y1N+Y2N)/2</l>
<l>XCN:=(X1N+X2N)/2</l>
<l>dev_disp_text('Non-FWM building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<l>* stop()</l>
<c>* ****************</c>
<c>***** rearranging Skeletons to PNi/PNSi</c>
<c>*** activate not to use MS elongation</c>
<l>* SkeletonPartsP:=Regionsmain</l>
<c>*****</c>
<c>*** removed 240118</c>
<l>* union1(SkeletonPartsP, SkeletonPartsPu)</l>
<l>* intersection(RegionsPNPi, SkeletonPartsPu, SkeletonPartsPr)</l>
<l>* count_obj(SkeletonPartsPr, nSkPr)</l>
<c></c>
<c></c>
<c></c>
<l>* gen_empty_obj(Empty)</l>
<l>* gen_empty_obj(Parts)</l>
<l>* count_obj(RegionsPNi, nPNi)</l>
<l>* for j:=1 to nPNi by 1</l>
<c>    </c>
<l>*     if(j==10 or j==20)</l>
<l>*         concat_obj(Parts, SkeletonPartsPu, Parts)</l>
<l>*     else</l>
<l>*         concat_obj(Parts, Empty, Parts)</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* count_obj(Parts, nParts)</l>
<l>* stop()</l>
<c>* *** preparing for IRBS (space)</c>
<c></c>
<l>gen_image_const (ImageIRBS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS, 'byte', WidthG, HeightG)</l>
<l>gen_image_const (ImageIRS16, 'uint2', WidthG, HeightG)</l>
<l>gen_empty_region (RegForbidS)</l>
<c></c>
<l>* pniovl := 4</l>
<c>* ** if RegForbid is from RegionIS, then need to recalculate for every image</c>
<c>* ** alternative - create RegForbid from eroded RegionGS</c>
<l>* erosion_circle (RegionGSi, RegionGSer, 4)</l>
<l>* RegForbid := RegionGSer</l>
<c></c>
<l>* add_image(ImageIR, ImageIRS, ImageIRSum, 0.5, 0)</l>
<l>* regiongrowing(ImageIRSum, Regions, 3, 3, 6, 100)</l>
<l>* stop ()</l>
<c></c>
<c></c>
<c>**** MS elongation</c>
<l>* jradMSe:=9</l>
<l>* eradMSe:=7</l>
<l>* pruning(Regionsmain, SkeletonsFWMi, 50)</l>
<c></c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(Regionsmain, EndPoints, JuncPoints)</l>
<l>* union1(JuncPoints, JP)</l>
<l>* get_region_points(JP, RowsJ, ColumnsJ)</l>
<l>* get_grayval(WidthImageP, RowsJ, ColumnsJ, RadJ)</l>
<l>* gen_circle(CJ, RowsJ, ColumnsJ, RadJ)</l>
<l>* difference(Regionsmain, CJ, SkeletonsFWMii)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* SkeletonsFWMii:=SkeletonPartsP</l>
<l>difference(SkeletonPartsP, RegNoProcd, SkeletonsFWMii) </l>
<l>* SkeletonsFWMii:=Regionsmain</l>
<l>union1(EndPoints, EP)</l>
<c></c>
<l>get_region_points(EP, RowsE, ColumnsE)</l>
<l>* test_subset_region(EndPoints, SkeletonsG, IsSubset)</l>
<l>* test_region_point(SkeletonG, RowsE, ColumnsE, IsInsideE)</l>
<l>tuple_length(RowsE, nE)</l>
<c>**** checking if EP is real EP (not working yet)</c>
<l>* RowsEv:=[]</l>
<l>* ColumnsEv:=[]</l>
<l>* nEv:=0</l>
<l>* for j:=0 to nE-1 by 1</l>
<l>*     test_region_point(SkeletonG, RowsE[j], ColumnsE[j], IsInsideE)</l>
<l>*     if(IsInsideE==0)</l>
<l>*         tuple_concat(RowsEv, RowsE[j], RowsEv)</l>
<l>*         tuple_concat(ColumnsEv, ColumnsE[j], ColumnsEv)</l>
<l>*         nEv:=nEv+1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<c>***** changed 220716 (elongation skeleton is used) ***</c>
<l>* tuple_gen_const(nE, eradMSe, Erad)</l>
<l>* gen_circle(CE, RowsE, ColumnsE, Erad)</l>
<l>* difference(SkeletonsFWMii, CE, SkeletonsFWMi)</l>
<c></c>
<l>select_shape(SkeletonsFWMii, SkeletonsFWMp, 'area', 'and', minlen, 999999)</l>
<l>count_obj(SkeletonsFWMp, nFWMs)</l>
<l>* difference(SkeletonG, SkeletonsFWMp, RegionDifference)</l>
<c></c>
<c>*** Non-FWM removal areas for endpoints</c>
<l>* eradNFWMremove:=15</l>
<l>tuple_gen_const(nE, eradNFWMremove, Erad2)</l>
<l>gen_circle(CE2, RowsE, ColumnsE, Erad2)</l>
<l>union1(CE2, EPNFWMremove)</l>
<c></c>
<l>* SkeletonsFWMcut := Regionsmain</l>
<l>intersection (Regionsmain, SkeletonFWM, SkeletonsFWMcut)</l>
<c>*** FWMS (for space)</c>
<c>*** removing areas around EP and JP for FWM Pat. Skels***** </c>
<l>junctions_skeleton(RegionsmainS, EndPointsS, JuncPointsS)</l>
<l>difference(RegionsmainS, RegNoProcd, SkeletonsFWMSii)</l>
<l>* SkeletonsFWMSii:=RegionsmainS</l>
<l>union1(EndPointsS, EPS)</l>
<l>get_region_points(EPS, RowsES, ColumnsES)</l>
<l>tuple_length(RowsES, nES)</l>
<l>* get_grayval(WidthImageP, RowsE, ColumnsE, RadE)</l>
<l>tuple_gen_const(nES, 7, EradS)</l>
<l>gen_circle(CES, RowsES, ColumnsES, EradS)</l>
<l>difference(SkeletonsFWMSii, CES, SkeletonsFWMSi)</l>
<c></c>
<l>* select_shape(SkeletonsFWMSi, SkeletonsFWMSp, 'area', 'and', minlen, 999999)</l>
<l>* SkeletonsFWMSp := RegionsmainS</l>
<l>* stop()</l>
<c></c>
<l>* union1(SkeletonsFWMSi, SkeletonFWMS)</l>
<l>* connection(SkeletonFWMS, SkeletonsFWMS)</l>
<l>* count_obj(SkeletonsFWMS, nFWMS)</l>
<c></c>
<l>RegForbidS := SkeletonGi</l>
<l>* expand_region (SkeletonsGS, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<l>expand_region (SkeletonsFWMScut, RegForbidS, RegionsPNSii, num_iter, 'image')</l>
<c></c>
<c></c>
<l>count_obj (RegionsPNSii, nINBS)</l>
<l>tuple_gen_sequence (2, nINBS+1, 1, SequenceINBSi)</l>
<c>* *** old GND</c>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<l>* SequenceIRB := SequenceINBi%250+3</l>
<l>* SequenceIRB[groundpn-1] := groundgval</l>
<c>* *** new GND</c>
<c>* ** start of the sequence</c>
<l>* stseqS := nEMPTY+1</l>
<l>* overfS := 255-stseqS</l>
<l>* SequenceIRBS := SequenceINBSi%overfS+stseqS</l>
<c></c>
<l>* SequenceINBS:=SequenceINBSi</l>
<l>* SequenceINBS:=SequenceINBSi+stseq</l>
<l>* SequenceIRBS[groundpn-1] := groundgval</l>
<c>* ****</c>
<l>union1 (RegionsEMPTY, RegionEMPTY)</l>
<c></c>
<l>* complement (RegionGND, RegionGNDC)</l>
<l>difference (DomainG, RegionEMPTY, RegionEMPTYC)</l>
<l>dilation_circle(RegionsPNSii,RegionsPNSi, 1) </l>
<l>* complement (RegionG, RegionGS)</l>
<l>* difference (DomainG, RegionG, RegionGS)</l>
<l>* expand_region (SkeletonsFWM, RegionGS, RegionExpanded, 'maximal', 'image')</l>
<c>* ** temporary image for pnum finding for FWM area MSs, used in MSBuildFWM - should exist in Teaching!!!</c>
<l>* paint_region (RegionsPNSi, ImageIRS, ImageIRS, SequenceIRBS, 'fill')</l>
<l>paint_region (RegionsPNSi, ImageIRS16, ImageIRS16, SequenceINBSi, 'fill')</l>
<c></c>
<l>* expand_region(SkeletonsFWMS, SkeletonG, RegionExpanded, 7, 'image')</l>
<l>* intersection(RegionsPNSi, SkeletonFWMS, SkeletonsFWMS)</l>
<l>* stop()</l>
<c>***** removing GND from SkeletonsFWM</c>
<l>* SkeletonsFWM:=SkeletonPartsPr</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c>***********************************************************</c>
<c>* *****   Building MS (measurement sensors)  **************</c>
<c>* *********************************************************</c>
<c>*** FWMS (for space)</c>
<l>* MSBuildFWM4 (SkeletonsFWMS, WidthImageS, DirImageS, ImageIRS, wpl, useint, PnumS, PnumRS, YS1, XS1, YS2, XS2, PaddrCS, PaddrRS, YSC, XSC, WGS, PregCS, PCinRnumS, PcontRS, Puseint)</l>
<l>* gen_region_points (PSC, YSC, XSC)</l>
<c>* ********************************************************</c>
<c>****** removing points between FWM skeleton line *********</c>
<c>**********************************************************</c>
<c>****** parameters for AnglesFWM:</c>
<c>* endpoint circle radius</c>
<l>* count_obj(SkelsEPUver, nSkelsEPUver)</l>
<l>* stop()</l>
<l>* complement(SkeletonFWM, SkeletonFWMC)</l>
<c></c>
<l>* closing_circle(SlelEPU, RegionClosing, 19.5)</l>
<l>* set_system('neighborhood', 8)</l>
<l>* expand_region(SkelEPU, SkeletonFWMC, SlelEPUexp, 5, 'image')</l>
<l>* connection(RegionClosing, CircsEPcl)</l>
<l>* set_system('neighborhood', 4)</l>
<l>* count_obj(CircsEPcl, nEPcl)</l>
<c>************************************************************</c>
<c>*** FWMP (for pattern)</c>
<l>* SkeletonsFWM:=Regionsmain</l>
<l>* SkeletonsFWM:=SkeletonPartsPi</l>
<c></c>
<l>* difference(SkeletonPartsPi, RegionCut, SkeletonFWMii)</l>
<l>* connection(SkeletonFWMii, SkeletonsFWMii)</l>
<l>* SkeletonsFWM:=SkeletonsFWMii</l>
<l>* SkeletonsFWM:=SkeletonsFWMp</l>
<l>* difference(SkeletonsFWM, RegNoProc, SkeletonsFWMrc)</l>
<c>******** test *****</c>
<l>* count_obj(RegionsGND, nGND)</l>
<l>* stseq:=nGND+1</l>
<l>* overf:=255-stseq</l>
<l>* i:=1744</l>
<l>* nIRB:=i%overf+stseq</l>
<c>***** checking ImageIR values vs jFWM</c>
<l>* count_obj(SkeletonsFWMrc, nFWM)</l>
<l>* for jFWM:=1 to nFWM by 1</l>
<l>*     select_obj(SkeletonsFWM, Sksel, jFWM)</l>
<l>*     get_region_points(Sksel, Rse, Cse)</l>
<l>*     tuple_length(Rse, nse)</l>
<l>*     if(nse&gt;0)</l>
<l>*         get_grayval(ImageIR, Rse[nse/2], Cse[nse/2], vIR)</l>
<l>*         nIRB:=jFWM%overf+stseq                                                                                                                                                                                                                                             </l>
<l>*         if(nIRB!=vIR)</l>
<l>*             stop()</l>
<l>*         endif</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* stop()</l>
<c>* ***********************</c>
<c></c>
<c>**** not used int points*</c>
<c></c>
<c></c>
<l>useint:=10</l>
<l>dev_disp_text('Building FWM...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('cyan')</l>
<l>SkeletonsFWM:=SkeletonPartsPinc</l>
<c></c>
<l>TotalPRC:=80</l>
<l>CurrentOper:='Building pattern sensors'</l>
<c></c>
<l>* lpnum2:=30</l>
<l>MSBuildFWM53 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, \
              wpl, useint, lpnum2,\
              Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>* MSBuildFWM6 (SkeletonsFWM, WidthImageP, DirImageP, ImageIR16, ImageOverlap, \
             wpl, useint, \
             Pnum, Pnum2, PnumR, Y1, X1, Y2, X2, PaddrC, PaddrR, YC, XC, WG, PregC, PCinRnum, PcontR, PuseintP)</l>
<c></c>
<l>dev_disp_text('FWM MS building finished          ', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>* *************************************</c>
<c></c>
<l>* gen_region_line(RegionLines, Y1, X1, Y2, X2)</l>
<l>gen_region_points (PC, YC, XC)</l>
<c>*** FWMS (for pattern)</c>
<c></c>
<l>TotalPRC:=90</l>
<l>CurrentOper:='Building space sensors'</l>
<c></c>
<l>dev_disp_text('Building FWMS...                                ', 'window', 10, 10, 'black', [], [])</l>
<l>dev_set_color('blue')</l>
<l>intersection(SkeletonsFWMS, RC, SkeletonsFWMSrc)</l>
<l>MSBuildFWM52 (SkeletonsFWMSrc, WidthImageS, DirImageS, ImageIRS16,\
             wpl, useint,\
             PnumS, PnumS2, PnumRS, Y1S, X1S, Y2S, X2S, PaddrCS, PaddrRS, YCS, XCS, WGS, PregCS, PCinRnumS, PcontRS, PuseintS)</l>
<c>* *************************************</c>
<l>gen_region_points (PCS, YCS, XCS)</l>
<l>dev_disp_text('FWMS MSS building finished', 'window', 10, 10, 'black', [], [])</l>
<c></c>
<c>*******************************************************</c>
<l>* ncut:=1000000</l>
<l>* tuple_length(X1, nMS)</l>
<l>* n:=nMS/ncut</l>
<l>* gen_empty_obj(RegionMSLines)</l>
<l>* for j:=0 to n-1 by 1</l>
<l>*     tuple_select_range(Y1, j*ncut, (j+1)*ncut-1, Y1c)</l>
<l>*     tuple_select_range(X1, j*ncut, (j+1)*ncut-1, X1c)</l>
<l>*     tuple_select_range(Y2, j*ncut, (j+1)*ncut-1, Y2c)</l>
<l>*     tuple_select_range(X2, j*ncut, (j+1)*ncut-1, X2c)</l>
<l>*     gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>*     union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<l>* endfor</l>
<l>* tuple_select_range(Y1, n*ncut, nMS-1, Y1c)</l>
<l>* tuple_select_range(X1, n*ncut, nMS-1, X1c)</l>
<l>* tuple_select_range(Y2, n*ncut, nMS-1, Y2c)</l>
<l>* tuple_select_range(X2, n*ncut, nMS-1, X2c)</l>
<l>* gen_region_line(RegionMSLinesc, Y1c, X1c, Y2c, X2c)</l>
<l>* union2(RegionMSLines, RegionMSLinesc, RegionMSLines)</l>
<c></c>
<c></c>
<l>* gen_region_line(RegionMSLines, Y1, X1, Y2, X2)</l>
<l>* union1(RegionMSLines,RegionMSi)</l>
<l>* closing_circle(RegionMSLines, RegionMS, 3.5)</l>
<c>*******************************************************</c>
<l>* stop()</l>
<l>RegionsPNi:=RegionsPNPi</l>
<l>TotalPRC:=100</l>
<c></c>
<l>if(autowidth==1)</l>
<l>    wFWM:=Width</l>
<l>    wFWMS:=WidthS</l>
<l>endif</l>
<c></c>
<l>CurrentOper:='End of Teaching'</l>
<l>return()</l>
<c></c>
</body>
<docu id="TeachingMain129">
<parameters>
<parameter id="BoundariesNFWM"/>
<parameter id="CurrentOper"/>
<parameter id="DirImageP"/>
<parameter id="DirImageS"/>
<parameter id="EPNFWMremove"/>
<parameter id="EPexp"/>
<parameter id="GNDamin"/>
<parameter id="Gi"/>
<parameter id="HeightG"/>
<parameter id="Im"/>
<parameter id="ImDisplacement"/>
<parameter id="ImageIR"/>
<parameter id="ImageIR16"/>
<parameter id="ImageIRS"/>
<parameter id="PCinRnum"/>
<parameter id="PCinRnumN"/>
<parameter id="PCinRnumS"/>
<parameter id="PaddrC"/>
<parameter id="PaddrCN"/>
<parameter id="PaddrCS"/>
<parameter id="PaddrR"/>
<parameter id="PaddrRN"/>
<parameter id="PaddrRS"/>
<parameter id="PcontR"/>
<parameter id="PcontRN"/>
<parameter id="PcontRS"/>
<parameter id="Pnum"/>
<parameter id="Pnum2"/>
<parameter id="PnumN"/>
<parameter id="PnumR"/>
<parameter id="PnumRN"/>
<parameter id="PnumRS"/>
<parameter id="PnumS"/>
<parameter id="PnumS2"/>
<parameter id="PregC"/>
<parameter id="PregCN"/>
<parameter id="PregCS"/>
<parameter id="PuseintP"/>
<parameter id="PuseintS"/>
<parameter id="RegNoProc"/>
<parameter id="RegionCut"/>
<parameter id="RegionFlash"/>
<parameter id="RegionG"/>
<parameter id="RegionGS"/>
<parameter id="RegionMS"/>
<parameter id="RegionTrace"/>
<parameter id="RegionsEMPTY"/>
<parameter id="RegionsGND"/>
<parameter id="RegionsNFWM"/>
<parameter id="RegionsPNPi"/>
<parameter id="RegionsPNSi"/>
<parameter id="RegionsPNi"/>
<parameter id="RegionsmainSNoCut"/>
<parameter id="SequenceIRB"/>
<parameter id="SequenceIRBS"/>
<parameter id="SkelEP"/>
<parameter id="SkeletonFWM"/>
<parameter id="SkeletonG"/>
<parameter id="SkeletonGS"/>
<parameter id="SkeletonGd"/>
<parameter id="SkeletonPartsP"/>
<parameter id="SkeletonPartsPnoG"/>
<parameter id="SkeletonsFWM"/>
<parameter id="SkeletonsFWMS"/>
<parameter id="SkeletonsFWMScut"/>
<parameter id="SkeletonsFWMcut"/>
<parameter id="SkeletonsG"/>
<parameter id="SkeletonsLG"/>
<parameter id="TotalPRC"/>
<parameter id="WG"/>
<parameter id="WGN"/>
<parameter id="WGS"/>
<parameter id="WidthG"/>
<parameter id="WidthImageP"/>
<parameter id="WidthImageS"/>
<parameter id="X1"/>
<parameter id="X1N"/>
<parameter id="X1S"/>
<parameter id="X2"/>
<parameter id="X2N"/>
<parameter id="X2S"/>
<parameter id="XC"/>
<parameter id="XCN"/>
<parameter id="XCS"/>
<parameter id="Y1"/>
<parameter id="Y1N"/>
<parameter id="Y1S"/>
<parameter id="Y2"/>
<parameter id="Y2N"/>
<parameter id="Y2S"/>
<parameter id="YC"/>
<parameter id="YCN"/>
<parameter id="YCS"/>
<parameter id="autowidth"/>
<parameter id="cutendMSS"/>
<parameter id="elengthend"/>
<parameter id="elengthnoend"/>
<parameter id="elongLG"/>
<parameter id="eradMSe"/>
<parameter id="eradNFWMremove"/>
<parameter id="fwmhw"/>
<parameter id="gap"/>
<parameter id="groundgval"/>
<parameter id="groundpn"/>
<parameter id="jpadd"/>
<parameter id="jrad"/>
<parameter id="lookaround"/>
<parameter id="lpnum2"/>
<parameter id="maxdirSP"/>
<parameter id="minPSklen"/>
<parameter id="minWG"/>
<parameter id="minWGS"/>
<parameter id="nFWM"/>
<parameter id="nFWMS"/>
<parameter id="nNonWFM"/>
<parameter id="parop"/>
<parameter id="path"/>
<parameter id="removeGNDfromFWM"/>
<parameter id="sm_factor"/>
<parameter id="smoothCADcontours"/>
<parameter id="useODB"/>
<parameter id="wFWM"/>
<parameter id="wFWMS"/>
<parameter id="wpl"/>
<parameter id="wside"/>
<parameter id="wsideS"/>
</parameters>
</docu>
</procedure>
</hdevelop>
